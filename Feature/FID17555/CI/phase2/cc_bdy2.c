/********************************************************************16**

        (c) COPYRIGHT 1989-1999 by Trillium Digital Systems, Inc.
                          All rights reserved.

     This software is confidential and proprietary to Trillium
     Digital Systems, Inc.  No part of this software may be reproduced,
     stored, transmitted, disclosed or used in any form or by any means
     other than as expressly provided by the written license agreement
     between Trillium and its licensee.

     Trillium warrants that for a period, as provided by the written
     license agreement between Trillium and its licensee, this
     software will perform substantially to Trillium specifications as
     published at the time of shipment and the media used for delivery
     of this software will be free from defects in materials and
     workmanship.

     TRILLIUM MAKES NO OTHER WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
     WITHOUT LIMITATION WARRANTIES OF MERCHANTABILITY OR FITNESS FOR
     A PARTICULAR PURPOSE WITH REGARD TO THIS SOFTWARE OR ANY RELATED
     MATERIALS.

     IN NO EVENT SHALL TRILLIUM BE LIABLE FOR ANY INDIRECT, SPECIAL,
     OR CONSEQUENTIAL DAMAGES IN CONNECTION WITH OR ARISING OUT OF
     THE USE OF, OR INABILITY TO USE, THIS SOFTWARE, WHETHER BASED
     ON BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE), PRODUCT
     LIABILITY, OR OTHERWISE, AND WHETHER OR NOT IT HAS BEEN ADVISED
     OF THE POSSIBILITY OF SUCH DAMAGE.

                       Restricted Rights Legend

     This software and all related materials licensed hereby are
     classified as "restricted computer software" as defined in clause
     52.227-19 of the Federal Acquisition Regulation ("FAR") and were
     developed entirely at private expense for nongovernmental purposes,
     are commercial in nature and have been regularly used for
     nongovernmental purposes, and, to the extent not published and
     copyrighted, are trade secrets and confidential and are provided
     with all rights reserved under the copyright laws of the United
     States.  The Government's rights to the software and related
     materials are limited and restricted as provided in clause
     52.227-19 of the FAR.

                    IMPORTANT LIMITATION(S) ON USE

     The use of this software is limited to the Use set
     forth in the written License Agreement between Trillium and
     its Licensee. Among other things, the Use of this software
     may be limited to a particular type of Designated Equipment.
     Before any installation, use or transfer of this software, please
     consult the written License Agreement or contact Trillium at
     the location set forth below in order to confirm that you are
     engaging in a permissible Use of the software.

                    Trillium Digital Systems, Inc.
                  12100 Wilshire Boulevard, suite 1800
                    Los Angeles, CA 90025-7118, USA

                        Tel: +1 (310) 442-9222
                        Fax: +1 (310) 442-1162

                   Email: tech_support@trillium.com
                     Web: http://www.trillium.com

*********************************************************************17*/

/********************************************************************20**

        Name:     Call Control - body 1

        Type:     C source file

        Desc:     C source code for Call Control Connection State Machine

        File:     cc_bdy2.c

        Sid:      cc_bdy2.c 1.5  -  12/21/99 07:10:27

        Prg:      rs

*********************************************************************21*/


/************************************************************************

     Note:

     This file has been extracted to support the following options:

     Option             Description
     ------    ------------------------------


************************************************************************/


/*
*/


/*
 *      This software may be combined with the following TRILLIUM
 *      software:
 *
 *      part no.                      description
 *      --------    ----------------------------------------------
 *
 */


  
/* header include files (.h) */
#include <unistd.h>
#include <sys/types.h> 
#include <sys/times.h> 
#ifndef LINUX
#include <time.h> 
#include <proc.h>
#else
#include <sys/time.h> 
#endif

#include "envopt.h"             /* environment options */  
#include "envdep.h"             /* environment dependent */
#include "envind.h"             /* environment independent */

#include "gen.h"                /* general */
#include "ssi.h"                /* system services interface */
#include "cm_ss7.h"             /* general SS7 layer */
#include "cm_atm.h"             /* general ATM layer */
#include "cm_hash.h"            /* hash list structure */
#include "cm_llist.h"           /* Common list defines */
#include "cm_cc.h"              /* Common Call Control Hash Defs */
#include "sit.h"                /* PSIF interface*/
#include "bicct.h"
#include "int.h"                /* PSIF interface*/
#include "cst.h"
#include "sipt.h"
#include "mgcpt.h"
#include "cct.h"                /* PSIF interface*/
#include "rtt.h"                /* router interface */
#include "rm.h"                /* Resource Manager interface */
#include "rmt.h"                /* Resource Manager interface */
#include "sft.h"                /* Switching Fabric Manager interface */
#include "lcc.h"                /* layer management */
#include "mf.h"                 /* Message Decoding / Encoding Hdr */
#include "cm5.h"                /* timers */
#include "msg_enum_1299.h"      /* Common message types (CC and FIC) */
#include "fct.h"                /* FIC datastructures */
#include "fst.h"                /* FIC_NUM_CP_EVNTS defintion */
#include "fctcommon.h"          /* Close Error Codes  */
#include "cc.h"                 /* Call Control Private header file */
#include "cc_err.h"             /* Call Control Error Codes */
#ifdef ZC
#include "cm_pftha.h"      /* common PSF */
#include "lzc.h"           /* ZC LM defines */
#include "zc.h"            /* ZC defines */
#include "zc_err.h"        /* ZC error defines */
#endif /* ZC */
#include "lin.h"
#include "cct.h"   
#include "lg3.h"   
#include "g3.h"   
#include "rm.h"   

#if 1 /* FGD*/
#include "tsc_tgp.h"
#endif /*FGD*/

#include "SoftSwitchDBApi.h"
#include "git_class.h"        /* for gitDebugPrint() */
#include "proc_info.h"
#include "telica_defs.h"
#include "telica_std.h"
#include "billing_cmds.h"
#include <stdlib.h>            /* Used for the atoi and free functions */
#include "cm_sdp.h"            /* SDP */
#include "TsmColDefs.h"
#include "tb.h"
#include "tb_cccfg.h"
#include "tb_cas.h"
#include "tb_mgc.h"
#include "tb_sdp.h"
#include "tb_sipt.h"

/* header/extern include files (.x) */

#include "gen.x"                /* general */
#include "ssi.x"                /* system services interface */
#include "cm_ss7.x"             /* general SS7 layer */
#include "cm_atm.x"             /* general ATM layer */
#include "cm_hash.x"            /* hash list structure */
#include "cm_lib.x"             /* common library */
#include "cm_llist.x"           /* Common list defines */
#include "cm_cc.x"              /* Common Call Control Typedefs */
#include "sit.x"                /* PSIF interface*/
#include "bicct.x"
#include "int.x"                /* PSIF interface*/
#ifdef CCXM
#include "xmt.x"                /* PSIF Interface */
#endif /* CCXM */
#include "mgct.h"
#include "cst.x"
#include "sipt.x"
#include "mgcpt.x"
#include "cc_nanp.h"   
#include "tfsu_memmap.h"
#include "cct.x"                /* PSIF Interface */
#include "rtt.x"                /* router interface */
#include "rmt.x"                /* Resource Manager interface */
#include "sft.x"                /* Switching Fabric Manager interface */
#include "lcc.x"                /* layer management */
#include "mf.x"                 /* Message Encoding/Decoding Hdr */
#include "cm5.x"                /* timers */
#include "fct.x"                /* FIC datastructures */
#include "cc_cache.x"                 /* Call Control Private header file */
#include "cc.x"                 /* Call Control Private header file */
#ifdef ZC
#include "cm_pftha.x"      /* common PSF */
#include "lzc.x"           /* ZC LM */
#include "zc.x"            /* ZC typedefs */
#endif /* ZC */
#include "cc_insubs.h"
#include "lg3.x"
#include "g3.x"
#include "telica_defs.h"
#include "telica_cic.h" /* telica_find_slot_from_cic() */
#include "lsf.x"
#include "sf.x"

#include "agc_EM_NE_enum.h"
#include "cm_pcrcdr.h"
#include "telica_errtreat.h"
#include "cc_treat.h"
#include "cc_overlap.h"
#include "cc_geo.x"
#include "cc_geo_cri.h"
#include "cc_geo_cri.x"
#include "si.h"
#include "OalGen.h"
#include "cc_li.h"
#include "cc_li.x"
#include "lrs.h"

#include "cc_asn.h"   /* FID16206.0 */
#include "cc_ccbs.x"  /* FID16970.0 */

/* local defines */

/* local typedefs */

/* local externs */
EXTERN S16 fcIsHomedNumber (CdPtyNmb *cdNmb);
EXTERN S16 ccSetDfltCsCgPtyNmb  ARGS((CgPtyNmb *cgPtyNmb));
EXTERN S16 ccBufE01SXX ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE11S82 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
/* Bug 44485 */
EXTERN  S16 ccCheckSamDigit(CcConCb    *con);
/*END of Bug 44485 */

/* Added for Bug 18422 */
EXTERN  S16 ccConE63S00 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN  S16 ccConE14S57 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE15S57 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE14S72 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN  S16 ccConE66SXX ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE48SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE50SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE51SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE03S61  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE52S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE03S_FICBUF
                         ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                                       PTR event2));
EXTERN S16 ccConE04SBUF
                         ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                                       PTR event2));
EXTERN S16 ccConE37S62  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE37S138  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE39S62  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2)); 
EXTERN S16 ccConE47S62  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE52S62  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE37S45  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE39S45  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S45  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE52S45  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE37S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE39S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE52S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE11S87 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE14S87 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE69SXX ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE69SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE62S51  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

/* CPDI prepaid */
//EXTERN  S16 ccConE37S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
//                                PTR event2));
EXTERN  S16 ccConE39S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE47SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE52S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE71S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE62S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE08S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE70S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
/* euysal - 03/16/2005 - Camel Support */
EXTERN  S16 ccConE71S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE37S11  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE39S11  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE52S11  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE70S11  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE71S11  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE08S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE11S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE37S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE39S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE47S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE52SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE62S52  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE62S53  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE03S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE04S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE14S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE11S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE11S98  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE11S100  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN  S16 ccConE31S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, 
                          PTR event2));
PUBLIC S16 ccConE11S97  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE14S97  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE31S97  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE62S82  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S98  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE08SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE31SYY  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE67SXX ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
PUBLIC  S16 ccConE67SFICRSP ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
PUBLIC  S16 ccConE67SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
PUBLIC  S16 ccConE67SMGI ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
PUBLIC  S16 ccConE71SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE39S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE40S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE41S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE42S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE43S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE44S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE45S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE46S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE50S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE51S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE52S79 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE31S32 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S40 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S46 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE72S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE37S09 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE37S10 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE72S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE72SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN  S16 ccConE72SXY  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE37SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE37SCQBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2)); /* FID 14457.0 */
#if 1 /* EARLY_ACM */
EXTERN S16 ccConE76SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE38SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE39SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE05SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE06SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE62SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccHandleE76Exp ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
#endif
EXTERN S16 ccConE14S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
/*euysal - 04/21/2005 - Support for O_Answer request */
EXTERN S16 ccConE37S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE39S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE40S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE71S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

EXTERN S16 ccConE39S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));

/* CRBT General */
/* Disconnect Call */
EXTERN S16 ccConE52S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_CONTINUE from FIC */
EXTERN S16 ccConE39S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE39S124 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* Analyze Route */
EXTERN S16 ccConE37S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccProcessAR  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE60S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccProcessSwapRequest  ARGS ((CcConCb *con1, CcConCb *con2));
EXTERN S16 ccProcessSwapType     ARGS ((CcConCb *con));
EXTERN S16 ccProcessMoveRequest  ARGS ((CcConCb *con1, CcConCb *con2));
EXTERN S16 ccProcessMoveSendRelease ARGS ((CcConCb *con1,CcConCb *con2));
EXTERN Bool ccFindSwitchingReqForAssocCalls  ARGS ((CcConCb *con));

/* Handle MgctTxnCfm for SwapCall */
EXTERN S16 ccConE11S121 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* Handle MgctTxnCfm for MoveCall */
PUBLIC S16 ccConE11S122 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_CAC */
EXTERN S16 ccConE77S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_SWAPCALL */
EXTERN S16 ccConE78S95  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE78S124 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_MOVECALL */
EXTERN S16 ccConE79S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE79S99  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE79S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_INT_SWAPCALL */
EXTERN S16 ccConE80SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE80SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_INT_MOVECALL */
EXTERN S16 ccConE81S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE81SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* CCE_PREANMTMREXP */
EXTERN S16 ccHandleE82Exp ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE82SBUF   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE84S37   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE11S134   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE36S134   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE85S32   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE85SBUF   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE86S32   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE11S135   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE36S135   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE62S32   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE03S13X   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN S16 ccConE03S56   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE68S139  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE10S139  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE92S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* forward references */
static void ccPermSignalHack(RmRsc *rsc);

PUBLIC  S16 ccIgnoreEvent ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                 PTR event2));
PUBLIC  S16 ccUnexpEvent ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE00S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S02  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S02  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE16S02  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S05  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S05  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE16S05  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE06S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE07S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE07S16  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE13S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE02S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE02SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                          PTR event2));
PRIVATE S16 ccConE03S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S65  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE07S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE13S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE13S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE02S09 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC S16 ccConE07S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S07  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE13S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE17S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE18S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE19S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S12  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S12  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE06S13  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S13  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S13  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S15  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S14  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S15  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S15  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S15  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S15  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S17  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S17  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE10S17  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S17  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE10S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S19  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S19  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S19  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S20  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S20  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S20  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S20  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE10S21  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S21  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE17S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE18S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE19S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S23  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S23  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE17S23  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE21S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S31  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
#if 0 /* GB - Turned off untill E21 is supported in otherthan 10 & 31 */
PRIVATE S16 ccConE21S02  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S05  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE21S22  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
#endif /* Turned off */
PRIVATE S16 ccConE22SOK  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S28  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S28  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S28  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S28  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE25S30  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE30SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S31  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S2X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S3X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S20  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S5X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31SFICRSP
                         ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                                         PTR event2));
PRIVATE S16 ccConE31S52  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31S6X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE31SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* new event added for Telica stats */
PRIVATE S16 ccConE32SOK  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE03S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S04  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S06  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S17  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S19  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S28  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S32  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S33  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S34  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S34  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S35  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S51  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S51  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S52  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S52  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S53  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S53  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S53  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE05S59  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE35S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE35S34  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE36S35  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE48S52  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE49S53  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE37S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE47S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE37S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE37S47  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE38S47  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE47S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S42  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE38S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE41S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE47S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S40  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE41S40  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE44S40  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE45S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE43S42  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE45S42  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE40S43  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE40S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE42S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE42S43  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE46S43  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE40S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE42S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE42S64  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE46S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE39S46  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE41S46  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE04S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S46  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S40  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S43  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE14S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE47S47  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE50SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S39  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE47S47  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConCleanUp ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE51SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE60S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE09S60  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE58S61  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE52S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE52S64  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE55S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE15S47  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S51  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE03S54  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S55  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S59  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S72  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S64  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S59  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S63  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S69  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S70  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S71  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S64  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S54  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S55  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S54  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S55  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S56  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S54  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S55  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE15S56  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN  S16 ccConE15S03  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S63  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S66  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S67  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S69  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S70  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S71  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE60S64  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S65  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S76  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE03S48  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S48  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE07S48  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S48  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S66  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE57S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* Added for CALEA */
PRIVATE S16 ccConE53SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE54SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE53S36  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S50  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S50  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S55  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S61  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S50  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE04S50  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE56S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC S16 ccConE04S56  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE67SFICRSP
                        ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                                        PTR event2));
/* The Functions are Defined in cc_bdy8.c */
PUBLIC  S16 ccConE03S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S73  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S74  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S75  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S78  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S81  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S83  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S7Y  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S7Z  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S74  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S77  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S78  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S80  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE13S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE31S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE31S7Y  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE64S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE67S7X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE67S7Y  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccExit2RegSm ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
/* TRFO */
PUBLIC  S16 ccConE04SCOB ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S109 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S106 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE04S1XX ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S110 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S108 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S107 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S118 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S113 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE33S113 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE33SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S111 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S111 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S112 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S116 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S116 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S114 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE33S114 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S115 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S119 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S120 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S117 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

PUBLIC  S16 ccConE03S105 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE04S105 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* TRFO */

/* FID-2112 SIP UPDATE + */
PUBLIC  S16 ccConE11SAckOrPrack  ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));

PUBLIC  S16 ccConE04SUpdSesAwtMg1 ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));
PUBLIC  S16 ccConE11SUpdSesAwtMg1 ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));
PUBLIC  S16 ccConE64SUpdSesAwtMg1 ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));

PUBLIC  S16 ccConE03SUpdSesAwtRsp ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));
PUBLIC  S16 ccConE11SUpdSesAwtMg2 ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));

PUBLIC  S16 ccConE83S09           ARGS ((CcConCb *con, PTR event,
                                        AinBCM_t *bcm, PTR event2));
/* FID-2112 SIP UPDATE - */
/* FID-2575: LMSD + */
PUBLIC  S16 ccConE11S136  ARGS ((CcConCb *con, PTR event,
                                 AinBCM_t *bcm, PTR event2));
/* FID-2575: LMSD - */
/* FID-14715: Support INAP Operations for FP/PP/VPN with OSP + */
PUBLIC  S16 ccConE11S137  ARGS ((CcConCb *con, PTR event,
                                 AinBCM_t *bcm, PTR event2));
PUBLIC  S16 ccConE40S11  ARGS ((CcConCb *con, PTR event,
                                 AinBCM_t *bcm, PTR event2));
/* FID-14715: Support INAP Operations for FP/PP/VPN with OSP - */
PUBLIC  S16 ccConE11S125 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S126 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S127 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S128 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE11S129 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE33S128 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

/* Bug:52472 */
PUBLIC  S16 ccConE33S81  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* Bug:86942 */
EXTERN  S16 ccConE14S68  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

/* + FID 15801.0 */
EXTERN S16 ccConE37S149 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE39S149 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE47S149 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE52S149 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
EXTERN S16 ccConE14S149 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                              PTR event2));
/* - FID 15801.0 */
/* BUG:90302 ++ */
PRIVATE S16 ccConE11S153  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE09S153  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
/* BUG:90302 -- */
PUBLIC S16 ccCheckUUSIParam(CcConCb *con);  
#ifdef CC_FID_2138_2167_2168_2169_2171
/* Req 7359 */
PUBLIC S16 ccCheckIncIsupCUG(CcConCb *con);
/* End of Req 7359 */
#else
/*Bug 42104 */
PUBLIC S16 ccCheckIsupToSipCUG(CcConCb *con);
/*end of Bug42104 */
#endif /*End of CC_FID_2138_2167_2168_2169_2171 */
/* Added for DTMF support */


/**************************************************************************** 
* TONE-TEST: This function will handle the release indication when the CC   *
* is in the CCS-LOCALLYANSWERED state.                                      *
****************************************************************************/
PRIVATE S16 ccConE04S32  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PRIVATE S16 ccConE04S33  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE11S33  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S33  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* Added for Voice Mail */
PRIVATE S16 ccConE09S84  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE01S85  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE03S85  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE14S85  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE58S85  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PRIVATE S16 ccConE65S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE01S18  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE47S38  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC S16 ccConE11S57  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE31S57  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE11S58  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE39S49  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccHandleContErr ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE14S58  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE31S58  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE03S91  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE04S91  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC S16 ccConE73S91  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE03S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE62S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03SMGIBUF
                         ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03SBUF  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S2X  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S90  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S90  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S35  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE62S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S51  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE24S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S24  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S24  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S24  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE23SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE23S25  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S25  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S25  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S26  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S26  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE00S27  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S27  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S27  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE26S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE26S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE26SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S29  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S29  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S16  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S16  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE62S30  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S30  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S30  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE11S92  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE14S92  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
PUBLIC  S16 ccConE61S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE60S41  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE23S01  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* Feature 1839 - compatibility */
PRIVATE S16 ccProcessCompat ARGS ((CcConCb *con));
PRIVATE S16 ccProcessCompatACK ARGS ((CcConCb *con, CcCnStEvnt *ccCnStEvnt));
/* end of compatibility */

/* Feature 1789 - German ISUP: Added for Toiw2 timer Support */
PUBLIC  S16 ccConE74S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

PUBLIC void   ccDisconnectCallInCC10    ARGS (( CcConCb *con,
                                                Bool     split, PTR event));
PUBLIC  S16 ccConE07SXXBuf ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE07SBUF   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE07S30    ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* Added For Awaiting Answer timer Support, RV Suresh 5.0 */

PUBLIC  S16 ccConE29SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
/* euysal - 03/17/2005 - CAMEL Support */
PUBLIC  S16 ccConE75SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
/* euysal - 03/17/2005 - CAMEL Support */
PUBLIC  S16 ccConE75SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

/* Added for Awaiting Requested Information */
PUBLIC  S16 ccConE02S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE14S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE23S96  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

                                
/* Added for Delayed Release Process */
PUBLIC  S16 ccConE04S97  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
                                
/* ACC Start */
PUBLIC S16 ccConE03S99  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
PUBLIC S16 ccConE39S99  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
PUBLIC S16 ccConE52S99  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
PUBLIC S16 ccConE71S99  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
    /* euysal - 07/06/2005 - ACC Support */
PUBLIC S16 ccConE71S44  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
/* ACC End */
/* Bug# 40847 */
PUBLIC S16 ccConE39S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                            PTR event2));
/* Bug 64647 */
PUBLIC  S16 ccConE62S58  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2)); 

/* ********* Start : Functions define in cc_svc.c ******************  */
PUBLIC  S16 ccConE12S08  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE15S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE12S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE45S88  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE39S88  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03S88  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04S88  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE11SA2  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03SA2  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04SA2  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE12SA2  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE11SA3  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE03SA3  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04SA3  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE03SA4  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE04SA4  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE12SA4  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE15SA4  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE20S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE20SBuf ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE20SErr ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));

PUBLIC  S16 ccConE12SErr ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
PUBLIC  S16 ccConE12SBuf ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
/* ********* End   : Functions define in cc_svc.c ******************  */

/* FID 14234.0 support RBWF for UK */
EXTERN S16 ccConE34S00   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE87S37   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE87S44   ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE87S124  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE39S140  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE87S140  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE88S140  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S140  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* End of FID 14234.0 */

/* + FID 15083.0 */
PUBLIC  S16 ccConE11S141 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN S16 ccConE12SLi   ARGS  ((CcConCb *con, PTR event, AinBCM_t *bcm,
                                PTR event2));
EXTERN S16 ccConE89S142  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* - FID 15083.0 */

/* + FID 15083.1 */
EXTERN  S16 ccConE93SMI  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN  S16 ccConE93SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));

EXTERN  S16 ccConE93SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* 1 FID 15083.1 */

/* + FID 14941.0 */
EXTERN  S16 ccConE03S143  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN  S16 ccConE11S144  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN  S16 ccConE03S145  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
EXTERN  S16 ccConE11S146  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,
                               PTR event2));
/* - FID 14941.0 */
/* FID 15045.1 + */
EXTERN S16 ccConE90S10  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE90SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE91S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE91S90  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE91SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE91SXX  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 15045.1 - */

/* FID15319.0 + */
EXTERN S16 ccConE01S148 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));                         
EXTERN S16 ccConE03S147 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));     
EXTERN S16 ccConE03S148 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));                         
EXTERN S16 ccConE04S147 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2)); 
EXTERN S16 ccConE11S148 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));                         
EXTERN S16 ccConE14S147 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE14S148 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));                         
EXTERN S16 ccConE23S147 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE62S148 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID15319.0 - */

/* FID 15310.1 + */
EXTERN S16 ccConE94S00 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE95S00 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 15310.1 - */

/* FID 14457.0 + */
EXTERN S16 ccConE96S37  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE37S89  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE96S86  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE96S123 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE03S150 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S150 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE14S150 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE97S150 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 14457.0 - */

/* BUG: 88025 + */
EXTERN S16 ccConE98S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE98SBUF ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* BUG: 88025 - */
/* FID 16206 +*/
PRIVATE S16 ccConE99S00  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
PRIVATE S16 ccConE100S151  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
PRIVATE S16 ccConE99S152  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
PRIVATE S16 ccConE101S151  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
PRIVATE S16 ccConE101S152  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
PRIVATE S16 ccConE99S151  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm,PTR event2));
/* FID 16206 -*/
/* FID 15068.0 + */
PRIVATE S16 ccConE03S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE11S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE01S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE04S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE07S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConEXXS154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE23S154  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 15068.0 - */

/* FID 16970.0 + */
PRIVATE S16 ccConE04S151 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE04S152 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE30S151 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE09S151 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
PRIVATE S16 ccConE13S151 ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 16970.0 - */

/* FID 17174 Annc Support via External MRF + */
EXTERN S16 ccConE01S155  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE03S155  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S155  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 17174 Annc Support via External MRF - */

/* FDI 17373.0 */
EXTERN S16 ccConE23S09  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));

/* FID 17555.0 + Kavon */
EXTERN S16 ccConE02S156  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE03S156  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE04S156  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
EXTERN S16 ccConE11S156  ARGS ((CcConCb *con, PTR event, AinBCM_t *bcm, PTR event2));
/* FID 17555.0 - */

/* bug:24575 wr*/
void updateBillingForExit(ProtType ogProtocolType, U8 icEventType, CcCallDtlInfo *cdi) ;

/* public variable declarations */

S16 ccFsmFrameCnt;

StateFn stateTable[CCMAXEVENTS][CCMAXSTATES] = 
{
  /* Connect indication - 00 */
  {
    ccConE00S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccConE00S27,             /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
      /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */  
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE Kavon */
  },
  /* Connct confirm  - 01*/
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccConE01S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE01S09,             /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED (Bug 51411)        */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccBufE01SXX,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccConE01S18,             /* 18-CCS_AWTRELCFM_OG                */          
    ccConE01S18,             /* 19-CCS_AWTRELCFM_BOTH              */          
    ccConE01S18,             /* 20-CCS_AWTSWTCFM_TOCLR             */ /* BUG:86320 */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccBufE01SXX,             /* 43-CCS_AWTRSPFORDPE28              */
    ccBufE01SXX,             /* 44-CCS_AWTRSPFORDPE9               */
    ccBufE01SXX,             /* 45-CCS_AWTRSPFORDPE33              */
    ccBufE01SXX,             /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConE01S50,             /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccConE01S55,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE01S55,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccBufE01SXX,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE01S61,             /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccBufE01SXX,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccBufE01SXX,             /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccBufE01SXX,             /* 73-CCS_AWT_QRYRSP                  */
    ccBufE01SXX,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccBufE01SXX,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccBufE01SXX,             /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccBufE01SXX,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccBufE01SXX,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccBufE01SXX,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccBufE01SXX,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccBufE01SXX,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE01S85,             /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccBufE01SXX,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
      /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccBufE01SXX,             /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE01S18,             /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccBufE01SXX,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */ /* bug82930 */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccBufE01SXX,             /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccBufE01SXX,             /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccBufE01SXX,             /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccBufE01SXX,             /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccBufE01SXX,             /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccBufE01SXX,             /* 136-CCS_AWT_MG_PRACKRSP            */
    ccBufE01SXX,             /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */  
    ccBufE01SXX,             /* 140-CCS_AWTRSPOAPM                 */
    ccBufE01SXX,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE01S148,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccBufE01SXX,             /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccBufE01SXX,             /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:91193*/
    ccConE01S154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE01S155,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent             /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Address Indication - 02 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccConE02S01,             /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE02SXX,             /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE02SXX,             /* 06-CCS_AWTOGRSC                    */   
    ccConE02SXX,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE02SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE02S09,             /* 09-CCS_AWTANS                      */  
    ccIgnoreEvent,            /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccIgnoreEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccIgnoreEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccIgnoreEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccConE02SBUF,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccConE02S01,             /* 25-CCS_AWTCOT                      */          
    ccConE02SBUF,            /* 26-CCS_AWTMGCTCFMCOTIC1            */                
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccConE02SXX,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE02SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE02SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE02SXX,            /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE02SXX,              /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,            /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE02SXX,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE02SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,             /* 93-CCS_AWTMINDIGITS                */ 
    ccUnexpEvent,             /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE02S96,             /* 96-CCS_AWTMOREINFO                     */
      /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE02SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,            /* 101-CCS_AWTDELAYEDRELL            */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */  
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE02SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE02SBUF,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccIgnoreEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccIgnoreEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccIgnoreEvent,           /* or buffer it?? 155-CCS_AWT_MRFRSP FID17174.0 */
    ccConE02S156,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Connection progress status indication - 03 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccConE03S01,             /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE03S_FICBUF,        /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE03S04,             /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE03S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE03S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE03S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE03S09,             /* 09-CCS_AWTANS                      */  
    ccConE03S10,             /* 10-CCS_ANSWERED                    */
    ccConE03S_FICBUF,        /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE03S08,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE03S15,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccConE03S17,             /* 17-CCS_AWTRELCFM_IC                */
    ccConE03S18,             /* 18-CCS_AWTRELCFM_OG                */
    ccConE03S19,             /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE03S2X,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccConE03S2X,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE03S28,             /* 28-CCS_AWTOGSWTCFM                 */
    ccConE03SMGIBUF,         /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE03SMGIBUF,         /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE03S32,             /* 32-CCS__LOCALLYANSWERED            */
    ccConE03S33,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE03S34,             /* 34-CCS_AWT_ADDR_CFM                */
    ccConE03S35,             /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE03S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE03S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE03S_FICBUF,        /* 38-CCS_AWTRSPFORDPE37              */
    ccConE03S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE03S_FICBUF,        /* 40-CCS_AWTRSPFORDPE30              */
    ccConE03S_FICBUF,        /* 41-CCS_AWTRSPFORDPE11              */
    ccConE03S_FICBUF,        /* 42-CCS_AWTRSPFORDPE27              */
    ccConE03S_FICBUF,        /* 43-CCS_AWTRSPFORDPE28              */
    ccConE03S_FICBUF,        /* 44-CCS_AWTRSPFORDPE9               */
    ccConE03S_FICBUF,        /* 45-CCS_AWTRSPFORDPE33              */
    ccConE03S_FICBUF,        /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE03S48,             /* 48-CCS_AWT_REATTEMPT               */
    ccConE03S_FICBUF,        /* 49-CCS_AWTRSPFORDPE22              */
    ccConE03S50,             /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE03S51,             /* 51-CCS_AWTBUSYREL_IC               */
    ccConE03S52,             /* 52-CCS_AWT_RESUME                  */
    ccConE03S53,             /* 53-CCS_AWT_TMDRELEXP               */
    ccConE03S54,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE03S55,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE03S56,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE03SMGIBUF,         /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE03SMGIBUF,         /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE03S59,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE03S61,             /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE03S_FICBUF,        /* 62-CCS_AWTRSPFORDPE19              */
    ccConE03SMGIBUF,         /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE03S64,             /* 64-CCS_AWTRSPFAILOUT               */
    ccConE03SMGIBUF,         /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE03SMGIBUF,         /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE03SMGIBUF,         /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE03SMGIBUF,         /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE03SMGIBUF,         /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE03SMGIBUF,         /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE03SMGIBUF,         /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccConE03S72,             /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE03S73,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE03S74,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE03S75,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE03SMGIBUF,         /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE03S7X,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE03S78,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE03S7X,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE03S81,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE03S82,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE03S83,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE03S85,             /* 85-CCS_AWTMWIUPDCFM                */
    ccConE03S_FICBUF,        /* 86-CCS_AWTRSPFORDPE17              */
    ccConE03SMGIBUF,         /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE03S88,             /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE03S89,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE03SMGIBUF,         /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE03S91,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE03SMGIBUF,         /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccConE03S9X,            /* 93-CCS_AWTMINDIGITS                */
    ccConE03S9X,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE03S_FICBUF,        /* 95-CCS_AWTRSPFORDPE08              */
    ccConE03S96,             /* 96-CCS_AWTMOREINFO                     */
      /* euysal - 06/01/2005 - ACC Support */
    ccConE03SMGIBUF,         /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE03SMGIBUF,         /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE03S99,             /* 99-CCS_AWTRSPFORDPE12             */
    ccConE03SMGIBUF,         /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE03S18,             /* 101-CCS_AWTDELAYEDREL               */
    ccConE03SA2,             /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccConE03SA3,             /* 103-CCS_AWT_MGIT_CREATE            */          
    ccConE03SA4,             /* 104-CCS_AWT_RLT                    */          
    ccConE03S105,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE03S106,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE03S107,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE03S108,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE03SBUF,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE03SBUF,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE03S111,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE03SBUF,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE03S113,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE03S114,            /* 114-CCS_COB_AWTXFERROUT            */
    ccConE03SBUF,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE03S116,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE03SBUF,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE03SBUF,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE03SBUF,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE03SBUF,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccIgnoreEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE03SBUF,            /* 123-CCS_AWTIDISCONNECT             */ /* bug86953 */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE03SBUF,            /* 125-CCS_CBI_AWTMGI1                */
    ccConE03S126,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccConE03S127,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE03S128,            /* 128-CCS_CBI_AWTOGXFER              */
    ccConE03SBUF,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE03SMGIBUF,         /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE03SMGIBUF,         /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE03SUpdSesAwtRsp,   /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE03SMGIBUF,         /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE03S13X,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE03S13X,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE03SMGIBUF,         /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE03SMGIBUF,         /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE03SBUF,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE03SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE03SBUF,            /* 142-CCS_AWT_MGID_RSP               */
    ccConE03S143,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccConE03S145,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE03S147,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE03S148,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE03S_FICBUF,        /* 149-CCS_AWTOREDIRECT_RSP              */
    ccConE03S150,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccConE03SBUF,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE03S154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE03S155,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccConE03S156,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Connection release indication - 04 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccConE04S01,             /* 01-CCS_AWTROUTERSC                 */
    ccConE04S02,             /* 02-CCS_AWTROUTEDGT                 */
    ccConE04SBUF,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE04S04,             /* 04-CCS_AWTRSCALOCCFM               */
    ccConE04S05,             /* 05-CCS_AWTENBLOCSND                */
    ccConE04S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE04S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE04S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE04S09,             /* 09-CCS_AWTANS                      */  
    ccConE04S10,             /* 10-CCS_ANSWERED                    */
    ccConE04SBUF,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccConE04S13,             /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE04S08,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE04S15,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE04S16,             /* 16-COT_OG_DONE                     */
    ccConE04S17,             /* 17-CCS_AWTRELCFM_IC                */
    ccConE04S18,             /* 18-CCS_AWTRELCFM_OG                */
    ccConE04S19,             /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE04S20,             /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccConE04S22,             /* 22-CCS_RETRIEVE                    */
    ccConE04S23,             /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE04SBUF,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccConE04S25,             /* 25-CCS_AWTCOT                      */
    ccConE04SBUF,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccConE04S27,             /* 27-COT_IC_DONE                     */          
    ccConE04S28,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE04SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE04S30,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE04S32,             /* 32-CCS__LOCALLYANSWERED            */
    ccConE04S33,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE04S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE04S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE04SBUF,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE04S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE04S40,             /* 40-CCS_AWTRSPFORDPE30              */
    ccConE04S63,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE04S63,             /* 42-CCS_AWTRSPFORDPE27              */
    ccConE04S43,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE04S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccConE04SBUF,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE04S46,             /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE04S48,             /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConE04S50,             /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE04S51,             /* 51-CCS_AWTBUSYREL_IC               */
    ccConE04S52,             /* 52-CCS_AWT_RESUME                  */
    ccConE04S53,             /* 53-CCS_AWT_TMDRELEXP               */
    ccConE04S54,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE04S55,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE04S56,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE04SBUF,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE04SBUF,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE04S59,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE04SBUF,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE04S63,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE04S64,             /* 64-CCS_AWTRSPFAILOUT               */
    ccConE04S65,             /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE04S63,             /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE04S63,             /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE04S69,             /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE04S70,             /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE04S71,             /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE04S7Y,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE04S7X,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE04S7Z,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE04SBUF,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE04S7X,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE04S7X,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE04S7X,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE04S7Y,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE04S82,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE04S7Z,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE04S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccConE04SBUF,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE04S88,             /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE04S89,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE04SBUF,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE04S91,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE04SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,             /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,             /* 94-CCS_AWTMAXDIGITS                */
    ccConE04SBUF,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE04S96,             /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE04SBUF,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE04SBUF,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE04SBUF,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE04SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE04S97,             /* 100-CCSAWTDELAYEDREL              */
    ccConE04SA2,             /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccConE04SA3,             /* 103-CCS_AWT_MGIT_CREATE            */          
    ccConE04SA4,             /* 104-CCS_AWT_RLT                    */          
    ccConE04S105,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE04S1XX,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE04S1XX,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE04S1XX,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE04SCOB,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE04SBUF,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE04SCOB,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE04SCOB,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE04S1XX,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE04S1XX,            /* 114-CCS_COB_AWTXFERROUT            */
    ccConE04SCOB,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE04SBUF,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE04SCOB,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE04SCOB,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE04SCOB,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE04SCOB,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccConE04SBUF,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccConE04SBUF,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE04S123,            /* 123-CCS_AWTIDISCONNECT             */
    ccConE04SBUF,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE04SCOB,            /* 125-CCS_CBI_AWTMGI1                */
    ccExit2RegSm,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccExit2RegSm,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccExit2RegSm,            /* 128-CCS_CBI_AWTOGXFER              */
    ccConE04SCOB,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE04SBUF,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE04SBUF,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE04SUpdSesAwtMg1,   /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE04SBUF,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE04SBUF,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE04SBUF,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE04SBUF,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE04SBUF,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE04SBUF,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE04SBUF,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE04S140,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE04SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE04SBUF,            /* 142-CCS_AWT_MGID_RSP               */
    ccExit2RegSm,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccConE04SCOB,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccExit2RegSm,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccConE04SCOB,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE04S147,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE04SBUF,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE04SBUF,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccConE04S150,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE04S151,            /* 151-CCS_AWTNCCFM  FID16970.0       */
    ccConE04S152,            /* 152-CCS_AWTNCIND  FID16970.0      */
    ccConE04SBUF,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE04S154,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE04S155,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccConE04S156,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Connection release confirmation - 05 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE05S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE05S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE05S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE05S09,             /* 09-CCS_AWTANS                      */  
    ccConE05S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE05S08,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccConE05S17,             /* 17-CCS_AWTRELCFM_IC                */          
    ccConE05S18,             /* 18-CCS_AWTRELCFM_OG                */          
    ccConE05S19,             /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE05S10,             /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccConE05S53,             /* 53-CCS_AWT_TMDRELEXP               */
   ccIgnoreEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL   */
   ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL    */
   ccIgnoreEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL     */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE05S59,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE05SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE04S97,             /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE05SBUF,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE05SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccConE05SBUF,            /* 152-CCS_AWTNCIND   FID16206.0      */ 
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 call E05S17??*/
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Resouce Confirm - 06 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE06S06,             /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccConE06S13,             /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE06SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDRELM             */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */    
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Reattempt indication - 07 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE07S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE07S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE07S09,             /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE07S16,             /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE07SXXBuf,          /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE07S30,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE07S48,             /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE07SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE07SXXBuf,          /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE07SXXBuf,          /* 140-CCS_AWTRSPOAPM                 */
    ccConE07SXXBuf,          /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE07S154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Time Out Timer Expired - 08 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccConE08SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccConE08S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccConE08S38,             /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,             /* 44-CCS_AWTRSPFORDPE9          */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE08SXX,             /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE08SXX,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */    
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Resource Allocation Confirmation - 09 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccConE09S01,             /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE09S04,             /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccConE09S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE09S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE09S09,             /* 09-CCS_AWTANS                      */
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccConE09S12,             /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE09S15,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccConE09S20,             /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccConE09S22,             /* 22-CCS_RETRIEVE                    */          
    ccConE09S23,             /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccConE09S28,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE09S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccConE09S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccConE09S60,             /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccConE09S84,             /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccIgnoreEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccIgnoreEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE09S151,            /* 151-CCS_AWTNCCFM  FID16970.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccConE09S153,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Resource Deallocation Confirmation - 10 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */   
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */ 
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccIgnoreEvent,           /* 09-CCS_AWTANS                      */  
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccConE10S17,             /* 17-CCS_AWTRELCFM_IC                */          
    ccConE10S18,             /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccConE10S21,             /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */          
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */          
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */          
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccIgnoreEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccIgnoreEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE10S18,             /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccIgnoreEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE10S139,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccIgnoreEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccIgnoreEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccIgnoreEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccConE10S17,             /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccIgnoreEvent,           /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_MGCTTXNCFM - MGCT Txn Confirmation - 11 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccConE11S07,             /* 07-CCS_AWTANSSWT                   */
    ccConE11S08,             /* 08-CCS_AWTSWTCFM                   */
    ccIgnoreEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccConE11S14,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE11S20,             /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE11S24,             /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccConE11S26,             /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE11S28,             /* 28-CCS_AWTOGSWTCFM                 */
    ccConE11S29,             /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE11S33,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccConE11S38,             /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConE11S50,             /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccConE11S54,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE11S55,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE11S56,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE11S57,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE11S58,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE11S63,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccConE11S65,             /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE11S66,             /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE11S67,             /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE11SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE11S69,             /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE11S70,             /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE11S71,             /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE11S74,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE11S76,             /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE11S77,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE11S78,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE11S80,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE11S82,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE11S87,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE11S90,             /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE11S92,             /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE11S97,             /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE11S98,             /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE11S100,             /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */
    ccConE11SA2,             /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccConE11SA3,             /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE11S109,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE11S110,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE11S111,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE11S112,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccConE11S115,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE11S116,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE11S117,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE11S118,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE11S119,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE11S120,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccConE11S121,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccConE11S122,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE11S125,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccConE11S129,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE11SAckOrPrack,     /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE11SUpdSesAwtMg1,   /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE11SUpdSesAwtMg2,   /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE11S134,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE11S135,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE11S136,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE11S137,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE11S141,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccConE11S144,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccConE11S146,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccIgnoreEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccConE11S148,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccConE11S153,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE11S154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccConE11S156,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_SVC_IND - 12 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE12SLi,             /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE12SLi,             /* 06-CCS_AWTOGRSC                    */   
    ccConE12S08,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE12S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE12SErr,            /* 09-CCS_AWTANS                      */  
    ccConE12S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE12S08,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccConE12SErr,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccConE12SErr,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccConE12SErr,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE12SErr,            /* 37-CCS_AWTRSPFORDPE3               */
    ccConE12SErr,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE12SErr,            /* 39-CCS_AWTRSPFORDPE20              */
    ccConE12SErr,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE12SErr,            /* 41-CCS_AWTRSPFORDPE11              */
    ccConE12SErr,            /* 42-CCS_AWTRSPFORDPE27              */
    ccConE12SErr,            /* 43-CCS_AWTRSPFORDPE28              */
    ccConE12SErr,            /* 44-CCS_AWTRSPFORDPE9               */
    ccConE12SErr,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE12SErr,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE12SErr,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccConE12SErr,            /* 52-CCS_AWT_RESUME                  */
    ccConE12SErr,            /* 53-CCS_AWT_TMDRELEXP               */
    ccConE12SErr,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE12SErr,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE12SErr,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE12SErr,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE12SErr,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE12SErr,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE12SErr,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE12SErr,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE12SErr,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE12SErr,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE12SErr,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE12SErr,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE12SErr,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE12SErr,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE12SErr,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE12SErr,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE12SErr,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE12S08,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE12SErr,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE12SErr,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE12SErr,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */          
    ccConE12SA2,             /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccConE12SErr,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccConE12SA4,             /* 104-CCS_AWT_RLT                    */          
    ccConE12SErr,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE12SErr,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE12SErr,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE12SErr,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE12SErr,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE12SErr,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE12SErr,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE12SErr,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE12SErr,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE12SErr,            /* 114-CCS_COB_AWTXFERROUT            */
    ccConE12SErr,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE12SErr,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE12SErr,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE12SErr,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE12SErr,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE12SErr,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE12SBuf,            /* 125-CCS_CBI_AWTMGI1                */
    ccConE12SBuf,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccConE12SBuf,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE12SBuf,            /* 128-CCS_CBI_AWTOGXFER              */
    ccConE12SBuf,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE12SErr,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE12SLi,             /* 140-CCS_AWTRSPOAPM                 */
    ccConE12SLi,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE12SLi,             /* 142-CCS_AWT_MGID_RSP               */
    ccConE12SErr,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccConE12SErr,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccConE12SErr,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccConE12SErr,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Status Indication - Initiate Release - 13 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE13S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE13S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE13S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE13S09,             /* 09-CCS_AWTANS                      */  
    ccConE13S09,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE13S08,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE13S7X,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE13S7X,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE13S7X,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE13S7X,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE13S7X,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE13S7X,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE13S7X,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE13S7X,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE13S151,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccConE13S151,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* SETUP Timer Expired - 14 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccConE14S01,             /* 01-CCS_AWTROUTERSC                 */
    ccConE14S02,             /* 02-CCS_AWTROUTEDGT                 */
    ccConE14S30,             /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE14S04,             /* 04-CCS_AWTRSCALOCCFM               */
    ccConE14S05,             /* 05-CCS_AWTENBLOCSND                */
    ccConE14S06,             /* 06-CCS_AWTOGRSC                    */   
    ccConE14S07,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE14S08,             /* 08-CCS_AWTSWTCFM                   */
    ccConE14S09,             /* 09-CCS_AWTANS                      */  
    ccConE14S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE14S15,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE14S16,             /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccConE14S18,             /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccConE14S24,             /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccConE14S25,             /* 25-CCS_AWTCOT                      */          
    ccConE14S26,             /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccConE14S27,             /* 27-COT_IC_DONE                     */          
    ccConE14S28,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE14S29,             /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE14S30,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE14S33,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE14S34,             /* 34-CCS_AWT_ADDR_CFM                */
    ccConE14S35,             /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE14S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE14S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE14S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE14S39,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE14S48,             /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE14S51,             /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccConE14S66,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE14S66,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE14S66,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE14S57,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE14S58,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE14S66,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE14S34,             /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE14S66,             /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE14S68,             /* 68-CCS_CANNOTPROCESSEVENTS         */ /* bug86942 */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccConE14S72,             /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE14S85,             /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE14S87,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE14S89,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE14S90,             /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE14S92,             /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
/* euysal - 02/22/2006 - BUG:44781 */    
    ccConE14S92,             /* 95-CCS_AWTRSPFORDPE08              */
    ccConE14S96,             /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE14S97,             /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE14S98,             /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE14S18,             /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE14S37,             /* 140-CCS_AWTRSPOAPM                 */
    ccConE14S39,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE14S39,             /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE14S147,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE14S148,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE14S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccConE14S87,             /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:91193*/
    ccConE14S39,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE14S39,             /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* RELEASE Timer Expired -15 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE15S03,             /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccConE15S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccConE15S12,             /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccConE15S13,             /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE15S15,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccConE15S17,             /* 17-CCS_AWTRELCFM_IC                */          
    ccConE15S18,             /* 18-CCS_AWTRELCFM_OG                */          
    ccConE15S19,             /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE15S20,             /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccConE15S21,             /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccConE15S31,             /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE15S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE15S51,             /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccConE15S54,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE15S55,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE15S56,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE15S18,             /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccConE15SA4,             /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE15S03,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE15S03,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* ??? 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  }, 
  /* INTERDGT Timer Expired -16 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccConE16S02,             /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccConE16S05,             /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Layer Management Initiated Release - 17 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */   
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */ 
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccIgnoreEvent,           /* 09-CCS_AWTANS                      */  
    ccConE17S10,             /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */          
    ccConE17S22,             /* 22-CCS_RETRIEVE                    */          
    ccConE17S23,             /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */          
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */          
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */          
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccIgnoreEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccIgnoreEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccIgnoreEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccIgnoreEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccIgnoreEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccIgnoreEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccIgnoreEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccIgnoreEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccIgnoreEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccIgnoreEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccIgnoreEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccIgnoreEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccIgnoreEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccIgnoreEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Connection Hold Indication - 18 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccConE18S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccConE18S22,             /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Connection Retrieve Indication - 19 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccConE19S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccConE19S22,             /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_PCC_MSG - 20 */
  {
    ccConE20SErr,            /* 00-CCS_IDLE                        */
    ccConE20SErr,            /* 01-CCS_AWTROUTERSC                 */
    ccConE20SErr,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE20SErr,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE20SErr,            /* 04-CCS_AWTRSCALOCCFM               */
    ccConE20SErr,            /* 05-CCS_AWTENBLOCSND                */
    ccConE20SErr,            /* 06-CCS_AWTOGRSC                    */   
    ccConE20SBuf,            /* 07-CCS_AWTANSSWT                   */ 
    ccConE20SBuf,            /* 08-CCS_AWTSWTCFM                   */
    ccConE20SErr,            /* 09-CCS_AWTANS                      */  
    ccConE20S10,             /* 10-CCS_ANSWERED                    */
    ccConE20SErr,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccConE20SErr,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccConE20SErr,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE20SBuf,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE20SErr,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE20SErr,            /* 16-COT_OG_DONE                     */
    ccConE20SErr,            /* 17-CCS_AWTRELCFM_IC                */          
    ccConE20SErr,            /* 18-CCS_AWTRELCFM_OG                */          
    ccConE20SErr,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccConE20SErr,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccConE20SErr,            /* 21-CCS_AWTDEALOCCFM                */          
    ccConE20SErr,            /* 22-CCS_RETRIEVE                    */          
    ccConE20SErr,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccConE20SErr,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccConE20SErr,            /* 25-CCS_AWTCOT                      */          
    ccConE20SErr,            /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccConE20SErr,            /* 27-COT_IC_DONE                     */          
    ccConE20SErr,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE20SErr,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE20SErr,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccConE20SErr,            /* 31-CCS_AWTDELFROMACT               */
    ccConE20SErr,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE20SErr,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE20SErr,            /* 34-CCS_AWT_ADDR_CFM                */
    ccConE20SErr,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE20SErr,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE20SErr,            /* 37-CCS_AWTRSPFORDPE3               */
    ccConE20SErr,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE20SErr,            /* 39-CCS_AWTRSPFORDPE20              */
    ccConE20SErr,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE20SErr,            /* 41-CCS_AWTRSPFORDPE11              */
    ccConE20SErr,            /* 42-CCS_AWTRSPFORDPE27              */
    ccConE20SErr,            /* 43-CCS_AWTRSPFORDPE28              */
    ccConE20SErr,            /* 44-CCS_AWTRSPFORDPE9               */
    ccConE20SErr,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE20SErr,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE20SErr,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE20SErr,            /* 48-CCS_AWT_REATTEMPT               */
    ccConE20SErr,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConE20SErr,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE20SErr,            /* 51-CCS_AWTBUSYREL_IC               */
    ccConE20SErr,            /* 52-CCS_AWT_RESUME                  */
    ccConE20SErr,            /* 53-CCS_AWT_TMDRELEXP               */
    ccConE20SErr,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE20SErr,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE20SErr,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE20SErr,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE20SErr,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE20SErr,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccConE20SErr,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE20SErr,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE20SErr,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE20SErr,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE20SErr,            /* 64-CCS_AWTRSPFAILOUT               */
    ccConE20SErr,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE20SErr,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE20SErr,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE20SErr,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE20SErr,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE20SErr,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE20SErr,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccConE20SErr,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE20SErr,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE20SErr,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE20SErr,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE20SErr,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE20SErr,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE20SErr,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE20SErr,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE20SErr,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE20SErr,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE20SErr,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE20SErr,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccConE20SErr,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE20SErr,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE20SErr,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE20SErr,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE20SErr,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE20SErr,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE20SErr,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE20SErr,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE20SErr,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccConE20SErr,            /* 93-CCS_AWTMINDIGITS                */
    ccConE20SErr,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE20SErr,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE20SErr,            /* 96-CCS_AWTMOREINFO                     */
    ccConE20SErr,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE20SErr,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE20SErr,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE20SErr,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE20SErr,            /* 101-CCS_AWTDELAYEDREL               */          
    ccConE20SErr,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccConE20SErr,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccConE20SErr,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE20SErr,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Resource Deallocation Indication - 21 */
  /* GB - At present E21 is used only for "post-failover RM-GCC Audit"s.
   * Hence, all E21 handling is Ignored (for Good!) and only E21S10
   * and E21S31 are handled. Thse E21SXX will be used once PAP and OAP
   * are supported for RM-GCC */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */   
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */ 
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccIgnoreEvent,           /* 09-CCS_AWTANS                      */  
    ccConE21S10,             /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */          
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */          
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE67SMGI,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccConE21S31,             /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Call Detail Timer Expired - 22 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */   
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */ 
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccConE22SOK,             /* 09-CCS_AWTANS                      */  
    ccConE22SOK,             /* 10-CCS_ANSWERED                    */
    ccConE22SOK,             /* 11-CCS_AWTRSPTIMEOUT               */  
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE22SOK,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */          
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */          
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */          
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */          
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccConE22SOK,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccConE22SOK,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE22SOK,             /* 42-CCS_AWTRSPFORDPE27              */
    ccConE22SOK,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE22SOK,             /* 44-CCS_AWTRSPFORDPE9               */
    ccConE22SOK,             /* 45-CCS_AWTRSPFORDPE33              */
    ccConE22SOK,             /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccConE22SOK,             /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE22SOK,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE22SOK,             /* 62-CCS_AWTRSPFORDPE19              */
    ccConE22SOK,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccConE22SOK,             /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE22SOK,             /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE22SOK,             /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE22SOK,             /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE22SOK,             /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE22SOK,             /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE22SOK,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE22SOK,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE22SOK,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE22SOK,             /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE22SOK,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE22SOK,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE22SOK,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE22SOK,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
/* euysal - 09/12/2005 - BUG: 40634 We should handle call detail timer in this state */
#if 1
    ccConE22SOK,             /* 82-CCS_AWTANNCMPLT_CTR             */
#else
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
#endif    
    ccConE22SOK,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE22SOK,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE22SOK,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE22SOK,             /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE22SOK,             /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE22SOK,             /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE22SOK,             /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE22SOK,             /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE22SOK,             /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE22SOK,             /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE22SOK,             /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE22SOK,             /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE22SOK,             /* 114-CCS_COB_AWTXFERROUT            */
    ccConE22SOK,             /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE22SOK,             /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE22SOK,             /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE22SOK,             /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE22SOK,             /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE22SOK,             /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccIgnoreEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE22SOK,             /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccIgnoreEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE22SOK,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE22SOK,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Continuity report - 23 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccConE23S01,             /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE23S09,             /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccConE23S154,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE23S09,             /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE23SBUF,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccConE23S25,             /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE23S154,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent ,          /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE23S09,             /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE23S09,             /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE23S09,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE23S96,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE23S147,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE23S154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Continuity check - 24 */
  {
    ccConE24S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */              
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Stop Continuity - 25 */ 
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE25S30,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Loop back acknowledge - 26 */
  {
    ccConE26S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE26S09,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE26SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccConE26SBUF,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE26SBUF,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_TMINDIGITEXPIRY - 27 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccConE27S24,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccConE27S25,            /* 25-CCS_AWTCOT                      */          
    ccConE27S26,            /* 26-CCS_AWTMGCTCFMCOTIC1            */                
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccConE27S93,             /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE27S96,             /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP           */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_TMAXDIGITEXPIRY - 28 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccConE28S24,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccConE28S24,            /* 25-CCS_AWTCOT                      */          
    ccConE28S24,            /* 26-CCS_AWTMGCTCFMCOTIC1            */               
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccConE28S94,             /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccConE28S96,             /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP           */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_TAWAITANSEXPIRY - 29 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccConE29SXX,             /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE29SXX,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE29SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE29SXX,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Buffer timer expiry  - 30 */
  {
    ccConE30SXX,             /* 00-CCS_IDLE                        */
    ccConE30SXX,             /* 01-CCS_AWTROUTERSC                 */
    ccConE30SXX,             /* 02-CCS_AWTROUTEDGT                 */
    ccConE30SXX,             /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE30SXX,             /* 04-CCS_AWTRSCALOCCFM               */
    ccConE30SXX,             /* 05-CCS_AWTENBLOCSND                */
    ccConE30SXX,             /* 06-CCS_AWTOGRSC                    */   
    ccConE30SXX,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE30SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE30SXX,             /* 09-CCS_AWTANS                      */  
    ccConE30SXX,             /* 10-CCS_ANSWERED                    */
    ccConE30SXX,             /* 11-CCS_AWTRSPTIMEOUT               */  
    ccConE30SXX,             /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccConE30SXX,             /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccConE30SXX,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE30SXX,             /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE30SXX,             /* 16-COT_OG_DONE                     */
    ccConE30SXX,             /* 17-CCS_AWTRELCFM_IC                */
    ccConE30SXX,             /* 18-CCS_AWTRELCFM_OG                */
    ccConE30SXX,             /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE30SXX,             /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccConE30SXX,             /* 21-CCS_AWTDEALOCCFM                */
    ccConE30SXX,             /* 22-CCS_RETRIEVE                    */
    ccConE30SXX,             /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE30SXX,             /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccConE30SXX,             /* 25-CCS_AWTCOT                      */
    ccConE30SXX,             /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccConE30SXX,             /* 27-COT_IC_DONE                     */          
    ccConE30SXX,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccConE30SXX,             /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE30SXX,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE30SXX,             /* 32-CCS__LOCALLYANSWERED            */
    ccConE30SXX,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE30SXX,             /* 34-CCS_AWT_ADDR_CFM                */
    ccConE30SXX,             /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE30SXX,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE30SXX,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE30SXX,             /* 38-CCS_AWTRSPFORDPE37              */
    ccConE30SXX,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE30SXX,             /* 40-CCS_AWTRSPFORDPE30              */
    ccConE30SXX,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE30SXX,             /* 42-CCS_AWTRSPFORDPE27              */
    ccConE30SXX,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE30SXX,             /* 44-CCS_AWTRSPFORDPE9               */
    ccConE30SXX,             /* 45-CCS_AWTRSPFORDPE33              */
    ccConE30SXX,             /* 46-CCS_AWTRSPFORDPE32              */
    ccConE30SXX,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE30SXX,             /* 48-CCS_AWT_REATTEMPT               */
    ccConE30SXX,             /* 49-CCS_AWTRSPFORDPE22              */
    ccConE30SXX,             /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE30SXX,             /* 51-CCS_AWTBUSYREL_IC               */
    ccConE30SXX,             /* 52-CCS_AWT_RESUME                  */
    ccConE30SXX,             /* 53-CCS_AWT_TMDRELEXP               */
    ccConE30SXX,             /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE30SXX,             /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE30SXX,             /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE30SXX,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE30SXX,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE30SXX,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccConE30SXX,             /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE30SXX,             /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE30SXX,             /* 62-CCS_AWTRSPFORDPE19              */
    ccConE30SXX,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE30SXX,             /* 64-CCS_AWTRSPFAILOUT               */
    ccConE30SXX,             /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE30SXX,             /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE30SXX,             /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE30SXX,             /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE30SXX,             /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE30SXX,             /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE30SXX,             /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccConE30SXX,             /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE30SXX,             /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE30SXX,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE30SXX,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccConE30SXX,             /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE30SXX,             /* 85-CCS_AWTMWIUPDCFM                */
    ccConE30SXX,             /* 86-CCS_AWTRSPFORDPE17              */
    ccConE30SXX,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE30SXX,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE30SXX,             /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE30SXX,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE30SXX,             /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE30SXX,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE30SXX,             /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE30SXX,             /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE30SXX,             /* 99-CCS_AWTRSPFORDPE12             */
    ccConE30SXX,             /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE30SXX,             /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE30SXX,             /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccExit2RegSm,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccExit2RegSm,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccExit2RegSm,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccExit2RegSm,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccExit2RegSm,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccExit2RegSm,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccExit2RegSm,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccExit2RegSm,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccExit2RegSm,            /* 114-CCS_COB_AWTXFERROUT            */
    ccExit2RegSm,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccExit2RegSm,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccExit2RegSm,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccExit2RegSm,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccExit2RegSm,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccExit2RegSm,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccConE30SXX,             /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccConE30SXX,             /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE30SXX,             /* 123-CCS_AWTIDISCONNECT             */
    ccConE30SXX,             /* 124-CCS_AWTRSPFORDPE7              */
    ccExit2RegSm,            /* 125-CCS_CBI_AWTMGI1                */
    ccExit2RegSm,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccExit2RegSm,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccExit2RegSm,            /* 128-CCS_CBI_AWTOGXFER              */
    ccExit2RegSm,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE30SXX,             /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE30SXX,             /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE30SXX,             /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE30SXX,             /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE30SXX,             /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE30SXX,             /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE30SXX,             /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE30SXX,             /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE30SXX,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE30SXX,             /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccIgnoreEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccConE30SXX,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE30SXX,             /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE30SXX,             /* 147-CCS_BICC_AWTICBEARER           */
    ccConE30SXX,             /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE30SXX,             /* 149-CCS_AWTOREDIRECT_RSP              */
    ccConE30SXX,             /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE30S151,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccConE30S151,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE30SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE30SXX,             /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_MGCTSVCCHGIND -31 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE31SYY,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccConE31S04,             /* 04-CCS_AWTRSCALOCCFM               */
    ccConE31S2X,             /* 05-CCS_AWTENBLOCSND                */
    ccConE31S3X,             /* 06-CCS_AWTOGRSC                    */   
    ccConE31S3X,             /* 07-CCS_AWTANSSWT                   */ 
    ccConE31S3X,             /* 08-CCS_AWTSWTCFM                   */
    ccConE31S09,             /* 09-CCS_AWTANS                      */  
    ccConE31S10,             /* 10-CCS_ANSWERED                    */
    ccConE31SYY,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccConE31SYY,           /* 12-CCS_AWTRSCCFM_TOCLR         */   
    ccConE31SYY,           /* 13-CCS_AWTOGRSC_TOCLR          */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE31SYY,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */          
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */          
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */          
    ccConE31S20,             /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */          
    ccConE31S5X,             /* 22-CCS_RETRIEVE                    */          
    ccConE31SYY,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccConE31S2X,             /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccConE31S6X,             /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE31SBUF,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE31SFICRSP,         /* 36-CCS_AWTRSPFORDPE1               */
    ccConE31SFICRSP,         /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccConE31SFICRSP,         /* 40-CCS_AWTRSPFORDPE30              */
    ccConE31S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE31SFICRSP,         /* 42-CCS_AWTRSPFORDPE27              */
    ccConE31SFICRSP,         /* 43-CCS_AWTRSPFORDPE28              */
    ccConE31SFICRSP,         /* 44-CCS_AWTRSPFORDPE9               */
    ccConE31SFICRSP,         /* 45-CCS_AWTRSPFORDPE33              */
    ccConE31SFICRSP,         /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccConE31SFICRSP,         /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE31S09,             /* 51-CCS_AWTBUSYREL_IC               */
    ccConE31S52,             /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE31S57,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE31S58,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE31SBUF,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE31SBUF,            /* 64-CCS_AWTRSPFAILOUT               */
    ccConE31SBUF,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE31SBUF,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE31SBUF,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE31SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE31SBUF,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE31SBUF,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE31SBUF,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE31S7Y,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE31SBUF,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE31S7Y,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE31S7Y,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE31S7Y,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE31S7X,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE31S82,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE31S7X,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE31SFICRSP,         /* 86-CCS_AWTRSPFORDPE17         */
    ccConE31SBUF,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE31SFICRSP,         /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE31S97,             /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE31SYY,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE31SFICRSP,         /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Stats Call Detail Timer Expired - 32 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccConE32SOK,             /* 09-CCS_AWTANS                      */
    ccConE32SOK,             /* 10-CCS_ANSWERED                    */
    ccConE32SOK,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccConE32SOK,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE32SOK,             /* 42-CCS_AWTRSPFORDPE27              */
    ccConE32SOK,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE32SOK,             /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccConE32SOK,             /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccConE32SOK,             /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE32SOK,             /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE32SOK,             /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE32SOK,             /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE32SOK,             /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE32SOK,             /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE32SOK,             /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE32SOK,             /* 82-CCS_AWTANNCMPLT_CTR             */ /*Bug 86305*/
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE32SOK,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE32SOK,             /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE32SOK,             /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE32SOK,             /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE32SOK,             /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE32SOK,             /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE32SOK,             /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE32SOK,             /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE32SOK,             /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE32SOK,             /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE32SOK,             /* 114-CCS_COB_AWTXFERROUT            */
    ccConE32SOK,             /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE32SOK,             /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE32SOK,             /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE32SOK,             /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE32SOK,             /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE32SOK,             /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccIgnoreEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE32SOK,             /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccIgnoreEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE32SOK,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE32SOK,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccConE32SOK,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccIgnoreEvent,           /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_TMR_REINVITE - 33 */ /* Re-invite timer expiry */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE33S81,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE33SBUF,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE33S113,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE33S114,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE33S128,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE32SOK,             /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_VIRTUALCALLSETUP - 34 */
  {
    ccConE34S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Address Confirmation - 35 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE35S09,             /* 09-CCS_AWTANS                      */  
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE35S34,             /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Mid call Confirmation - 36 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */ 
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */   
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */ 
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */  
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */  
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */   
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */   
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */          
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */          
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */          
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */          
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */          
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */          
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */          
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */          
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */          
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */             
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */          
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */          
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */          
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */          
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccConE36S35,             /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */          

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE36S134,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE36S135,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Analyze Route - 37 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE37S62,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE37SBUF,            /* 06-CCS_AWTOGRSC                    */
    ccConE37SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE37SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE37S09,             /* 09-CCS_AWTANS                      */
    ccConE37S10,             /* 10-CCS_ANSWERED                    */
    ccConE37S11,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE37SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE37SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE37SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE37S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE37S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE37S38,             /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccConE37S45,             /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE37S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConCleanUp,            /* 48-CCS_AWT_REATTEMPT               */
    ccConCleanUp,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE37SBUF,            /* 55-CCS_AWTSWTCFM_SENDONEREL F17174.0 support HQC */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE37SCQBUF,          /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE37SCQBUF,          /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE37S62,             /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE40S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE37S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE37S89,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE37SCQBUF,          /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE37SCQBUF,          /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE37SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE37S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE37SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE37S123,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE37S138,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE37SCQBUF,          /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE37S37,             /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE37S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE37SBUF,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Authorize Terminate - 38 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE38S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConCleanUp,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE39S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE38SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE39S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Continue - 39 */
  {
    ccHandleContErr,         /* 00-CCS_IDLE                    */
    ccHandleContErr,         /* 01-CCS_AWTROUTERSC             */
    ccHandleContErr,         /* 02-CCS_AWTROUTEDGT             */
    ccConE39S03,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccHandleContErr,         /* 04-CCS_AWTRSCALOCCFM           */
    ccHandleContErr,         /* 05-CCS_AWTENBLOCSND            */
    ccHandleContErr,         /* 06-CCS_AWTOGRSC                */
    ccConE39SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE39SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE39S09,             /* 09-CCS_AWTANS                      */
    ccConE39S09,             /* 10-CCS_ANSWERED                    */
    ccConE39S11,             /* 11-CCS_AWTRSPTIMEOUT               */
   ccHandleContErr,         /* 12-CCS_AWTRSCCFM_TOCLR         */
   ccHandleContErr,         /* 13-CCS_AWTOGRSC_TOCLR          */
   ccHandleContErr,         /* 14-CCS_AWT_MGI_XFERQRYHOLD     */
   ccHandleContErr,         /* 15-CCS_AWTRSCALLOCCFM_GLARE    */
   ccHandleContErr,         /* 16-CCS_AWT_OFFHOOK_COMPLETE           */
   ccHandleContErr,         /* 17-CCS_AWTRELCFM_IC            */
   ccHandleContErr,         /* 18-CCS_AWTRELCFM_OG            */
   ccHandleContErr,         /* 19-CCS_AWTRELCFM_BOTH          */
   ccHandleContErr,         /* 20-CCS_AWTSWTCFM_TOCLR         */
   ccHandleContErr,         /* 21-CCS_AWTDEALOCCFM            */
   ccHandleContErr,         /* 22-CCS_RETRIEVE                */
   ccHandleContErr,         /* 23-CCS_AWTALOCCFM_TOCLR        */
   ccHandleContErr,         /* 24-CCS_AWTROUTESWT             */
   ccHandleContErr,         /* 25-CCS_AWTCOT                  */
   ccHandleContErr,         /* 26-CCS_CONT_FAIL               */
   ccHandleContErr,         /* 27-CCS_AWTCONTRES              */
   ccHandleContErr,         /* 28-CCS_AWTOGSWTCFM             */
   ccHandleContErr,         /* 29-CCS_AWT_CCRTIMEOUT          */
   ccHandleContErr,         /* 30-CCS_AWTCONTRESCCR           */
   ccHandleContErr,         /* 31-CCS_AWTDELFROMACT           */
   ccHandleContErr,         /* 32-CCS__LOCALLYANSWERED        */
   ccHandleContErr,         /* 33-CCS_AWTSWTCFMFORSVC         */
    ccHandleContErr,         /* 34-CCS_AWT_ADDR_CFM            */
    ccHandleContErr,         /* 35-CCS_AWT_MID_CALL_CFM        */
    ccConE39S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE39S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE39S38,             /* 38-CCS_AWTRSPFORDPE37              */
    ccConE39S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE39S40,             /* 40-CCS_AWTRSPFORDPE30              */
    ccConE39S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE39S42,             /* 42-CCS_AWTRSPFORDPE27              */
   ccHandleContErr,         /* 43-CCS_AWTRSPFORDPE28          */
    ccConE39S44,         /* 44-CCS_AWTRSPFORDPE9           */
    ccConE39S45,             /* 45-CCS_AWTRSPFORDPE33              */
    ccConE39S46,             /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConCleanUp,            /* 48-CCS_AWT_REATTEMPT               */
   ccConE39S49,             /* 49-CCS_AWTRSPFORDPE22         */
   ccHandleContErr,         /* 50-CCS_AWTCALEALEGSWTCFM         */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccHandleContErr,         /* 53-CCS_AWT_TMDRELEXP               */
    ccHandleContErr,         /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccHandleContErr,         /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccHandleContErr,         /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE39SBUF,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE39SBUF,         /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccHandleContErr,         /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccHandleContErr,         /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccHandleContErr,         /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE39S62,             /* 62-CCS_AWTRSPFORDPE19              */
    ccHandleContErr,         /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccHandleContErr,         /* 64-CCS_AWTRSPFAILOUT               */
    ccHandleContErr,         /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccHandleContErr,         /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccHandleContErr,         /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccHandleContErr,         /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccHandleContErr,         /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccHandleContErr,         /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccHandleContErr,         /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccHandleContErr,         /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccHandleContErr,          /* 76-CCS_AWTSWTCFMFORCC6CC11    */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE39S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccHandleContErr,          /* 82-CCS_AWTANNCMPLT_CTR    */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccHandleContErr,         /* 84-CCS_AWTRSCALLOCCFM_MWI    */
    ccHandleContErr,         /* 85-CCS_AWTMWIUPDCFM          */
    ccConE39S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccHandleContErr,         /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE39S88,             /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE39SBUF,         /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE39SBUF,         /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccHandleContErr,         /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccHandleContErr,         /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccHandleContErr,         /* 93-CCS_AWTMINDIGITS                */
    ccHandleContErr,         /* 94-CCS_AWTMAXDIGITS                */

    ccConE39S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccHandleContErr,         /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccHandleContErr,         /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccHandleContErr,         /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE39S99,             /* 99-CCS_AWTRSPFORDPE12             */
    ccConE39SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccHandleContErr,         /* 101-CCS_AWTDELAYEDREL              */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE39S123,            /* 123-CCS_AWTIDISCONNECT             */
    ccConE39S124,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE39SBUF,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE39S03,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE39S140,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE39S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccConE39S37,             /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Disconnect Leg - 40 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE40S11,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccConE40S11,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE40S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccConE40S43,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE40S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE40S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE40S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE40S11,             /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
 },
  /* Forward Call - 41 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE41S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE41S40,             /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE41S46,             /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConCleanUp,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE41S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Merge Call - 42 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE42S44,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE42S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccConE42S43,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE42S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE42S64,             /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE42S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Move Leg - 43 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccConE43S42,             /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE43S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY 2       */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Offer Call - 44 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccConE44S40,             /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE44S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Originate Call - 45 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE45S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE45S42,             /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE45S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE45S88,             /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Reconnect - 46 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccConE46S43,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE46S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE46S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Send_To_Resource - 47 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE47SXX,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE47SBUF,            /* 06-CCS_AWTOGRSC                    */
    ccConE47SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE47SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE47S09,             /* 09-CCS_AWTANS                      */
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccConE47SXX,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE47SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE47SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE47SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE47S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE47S37,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE47S38,             /* 38-CCS_AWTRSPFORDPE37              */
    ccConE47S39,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE47S40,             /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccConE47S45,             /* 45-CCS_AWTRSPFORDPE33              */
    ccConE47S46,             /* 46-CCS_AWTRSPFORDPE32              */
    ccConE47S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE47S62,             /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE47S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE47SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE47SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL             */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE47SXX,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE47S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* SUSPEND Tmr Expiry    - 48 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccConE48S52,             /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE48SBUF,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* TimedRel Tmr Expiry  - 49 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccConE49S53,             /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* T_NO_ANSWER Tmr Expiry -  50 */ 
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccConE50SBUF,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE50SBUF,            /* 06-CCS_AWTOGRSC                    */
    ccConE50SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE50SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE50SXX,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE50SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE50SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE50SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE50SBUF,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37               */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE50SBUF,            /* 41-CCS_AWTRSPFORDPE11              */
    ccConE50SBUF,            /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccConE50SBUF,            /* 44-CCS_AWTRSPFORDPE9               */
    ccConE50SBUF,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccConE50SBUF,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE50SBUF,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE50SBUF,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE50SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE50SBUF,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE50S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE50SBUF,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE50SBUF,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE50SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccIgnoreEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE50SBUF,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* 0_NO_ANSWER Tmr Expiry -  51 */ 
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE51SBUF,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccConE51SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE51SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE51SXX,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccConE51SBUF,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE51SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE51SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE51SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccConE51SBUF,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccConE51SBUF,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE51SBUF,            /* 41-CCS_AWTRSPFORDPE11              */
    ccConE51SBUF,            /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccConE51SBUF,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE51SBUF,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE51SBUF,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE51SBUF,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE51SBUF,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE51SBUF,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE51SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE51SBUF,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE51S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE51SBUF,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE51SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE51SBUF,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE51SBUF,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE51SBUF,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Disconnect             -  52 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE52S03,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE52SXX,             /* 09-CCS_AWTANS                      */
    ccConE52SXX,            /* 10-CCS_ANSWERED                */
    ccConE52S11,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE52S37,             /* 37-CCS_AWTRSPFORDPE3               */
   ccConE52SXX,            /* 38-CCS_AWTRSPFORDPE37           */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccConE52S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccConE52S45,             /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE52SXX,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE52S62,             /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE52S64,             /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE52S79,             /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE52S86,             /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE52SXX,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE52S99,             /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE52S123,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE52S03,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE52S149,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE52SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Originate CALEA Call    -  53 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE53S36,             /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE53SXX,             /* 39-CCS_AWTRSPFORDPE20              */
    ccConE53SXX,             /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccConE53SXX,             /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccConE53SXX,             /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Data Request   -  54 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccConE54SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE54SXX,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE54SXX,            /* 41-CCS_AWTRSPFORDPE11               */
    ccConE54SXX,             /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,             /* 44-CCS_AWTRSPFORDPE9          */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE54SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_RECONNECTEXP - 55 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE55S09,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CALEALEGEXP - 56 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccConE56S10,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CREATECALL - 57 */
  {
    ccConE57S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */  
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_NOTIFYTIMEREXP - 58 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE58S61,             /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE58S85,             /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_EVENTUSEDFORBUFF - 59 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccIgnoreEvent,           /* 09-CCS_AWTANS                      */
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccIgnoreEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccIgnoreEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccIgnoreEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccIgnoreEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccIgnoreEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccIgnoreEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccIgnoreEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccIgnoreEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccIgnoreEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccIgnoreEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccIgnoreEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccIgnoreEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */

    ccIgnoreEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccIgnoreEvent,           /* 103-CCS_AWT_MGIT_CREATE            */          
    ccIgnoreEvent,           /* 104-CCS_AWT_RLT                    */          
    ccIgnoreEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccIgnoreEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccIgnoreEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccIgnoreEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccIgnoreEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccIgnoreEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccIgnoreEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccIgnoreEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccIgnoreEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccIgnoreEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccIgnoreEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccIgnoreEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccIgnoreEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccIgnoreEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccIgnoreEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccIgnoreEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccIgnoreEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccIgnoreEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccIgnoreEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccIgnoreEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccIgnoreEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccIgnoreEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccIgnoreEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccIgnoreEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccIgnoreEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccIgnoreEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccIgnoreEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccIgnoreEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccIgnoreEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccIgnoreEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccIgnoreEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccIgnoreEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccIgnoreEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccIgnoreEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccIgnoreEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccIgnoreEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccIgnoreEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccIgnoreEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccIgnoreEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccIgnoreEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccIgnoreEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccIgnoreEvent,           /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Ignore Event from FIC  60 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE60S41,             /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccConE60S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE60S64,             /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccExit2RegSm,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccExit2RegSm,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccExit2RegSm,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccExit2RegSm,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccExit2RegSm,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccExit2RegSm,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE60S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL                */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Circuit reservation Ack from ISUP 61 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE61S09,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_MGCTNOTIFY - 62 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE62S09,             /* 09-CCS_AWTANS                      */
    ccConE62S10,             /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE62SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE62S30,             /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccConE62S32,             /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE62S51,             /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccConE62S53,             /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE62S58,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE62SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccExit2RegSm,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE62SBUF,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccExit2RegSm,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE62S82,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE62S89,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccIgnoreEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE62SBUF,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE62SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL            */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccConE62SBUF,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE62S148,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_STA_CRM - 63 */
  {
    ccConE63S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_NEGOTIATION_TMR - 64 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE64S7X,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE64S7X,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE64S7X,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccConE64S7X,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE64S7X,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE64S7X,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE64S7X,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE64S7X,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE64S7X,             /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE64S7X,             /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE64S7X,             /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE64S7X,             /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE64S7X,             /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE64S7X,             /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE64S7X,             /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE64S7X,             /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE64S7X,             /* 114-CCS_COB_AWTXFERROUT            */
    ccConE64S7X,             /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE64S7X,             /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE64S7X,             /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE64S7X,             /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE64S7X,             /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE64S7X,             /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE64S7X,             /* 125-CCS_CBI_AWTMGI1                */
    ccConE64S7X,             /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccConE64S7X,             /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE64S7X,             /* 128-CCS_CBI_AWTOGXFER              */
    ccConE64S7X,             /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE64SUpdSesAwtMg1,   /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE64SUpdSesAwtMg1,   /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE64SUpdSesAwtMg1,   /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccConE64S7X,             /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccConE64S7X,             /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccConE64S7X,             /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccConE64S7X,             /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_FCTMWIREQ - 65 */
  {
    ccConE65S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */ 
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CLOSEFROMFIC - 66 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE66SXX,             /* 06-CCS_AWTOGRSC                    */
    ccConE66SXX,             /* 07-CCS_AWTANSSWT                   */
    ccConE66SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE66SXX,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccConE66SXX,             /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE66SXX,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE66SXX,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE66SXX,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccConE66SXX,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE66SXX,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE66SXX,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE66SXX,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE66SXX,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE66SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_KILLCALL     - 67 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccConE67SMGI,            /* 07-CCS_AWTANSSWT                   */
    ccConE67SMGI,            /* 08-CCS_AWTSWTCFM                   */
    ccConE67SXX,             /* 09-CCS_AWTANS                      */
    ccConE67SXX,             /* 10-CCS_ANSWERED                    */
    ccConE67SFICRSP,         /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccConE67SMGI,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-CCS_AWTSWTCFM_REATTEMPT     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE67SMGI,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE67SXX,             /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccConE67SXX,             /* 25-CCS_AWTCOT                      */
    ccConE67SXX,             /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccConE67SXX,             /* 27-COT_IC_DONE                     */
    ccConE67SMGI,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE67SMGI,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE67SXX,             /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE67SXX,             /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE67SFICRSP,         /* 36-CCS_AWTRSPFORDPE1               */
    ccConE67SFICRSP,         /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE67SFICRSP,         /* 39-CCS_AWTRSPFORDPE20              */
    ccConE67SFICRSP,         /* 40-CCS_AWTRSPFORDPE30              */
    ccConE67SFICRSP,         /* 41-CCS_AWTRSPFORDPE11              */
    ccConE67SFICRSP,         /* 42-CCS_AWTRSPFORDPE27              */
    ccConE67SFICRSP,         /* 43-CCS_AWTRSPFORDPE28              */
    ccConE67SFICRSP,         /* 44-CCS_AWTRSPFORDPE9               */
    ccConE67SFICRSP,         /* 45-CCS_AWTRSPFORDPE33              */
    ccConE67SFICRSP,         /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccConE67SFICRSP,         /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE67SXX,             /* 51-CCS_AWTBUSYREL_IC               */
    ccConE67SXX,             /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccConE67SMGI,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE67SMGI,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE67SMGI,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE67SXX,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE67SXX,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE67SFICRSP,         /* 62-CCS_AWTRSPFORDPE19              */
    ccConE67SMGI,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccConE67SMGI,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE67SMGI,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE67SMGI,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE67SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE67SMGI,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE67SMGI,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE67SMGI,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE67S7Y,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE67SMGI,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccConE67S7Y,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE67S7Y,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE67S7Y,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE67S7X,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE67SMGI,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE67S7X,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE67SFICRSP,         /* 86-CCS_AWTRSPFORDPE17              */
    ccConE67SMGI,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE67SXX,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE67SMGI,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE67SXX,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE67SMGI,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccConE67SXX,             /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccConE67SMGI,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE67SMGI,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE67SXX,             /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE67SMGI,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE67SMGI,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE67SMGI,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE67SMGI,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE67SMGI,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE67SMGI,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE67SMGI,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE67SMGI,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE67SMGI,            /* 114-CCS_COB_AWTXFERROUT            */
    ccConE67SMGI,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE67SMGI,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE67SMGI,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE67SMGI,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE67SMGI,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE67SMGI,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccConE67S7Y,             /* 125-CCS_CBI_AWTMGI1                */
    ccConE67S7Y,             /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccConE67S7Y,             /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE67S7Y,             /* 128-CCS_CBI_AWTOGXFER              */
    ccConE67S7Y,             /* 129-CCS_CBI_AWTSUB                 */
    ccConE67SMGI,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE67SMGI,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE67SMGI,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE67SMGI,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE67SMGI,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE67SMGI,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE67SMGI,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE67SMGI,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE67SMGI,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE67SMGI,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE67SMGI,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccConE67SXX,             /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE67SXX,             /* 147-CCS_BICC_AWTICBEARER           */
    ccConE67SXX,             /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE67SFICRSP,         /* 149-CCS_AWTOREDIRECT_RSP              */
    ccConE67SMGI,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE67SMGI,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CONGOVRLD_CFM - 68 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE68S139,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_FRAUDCALLTMREXP - 69 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE69SXX,             /* 06-CCS_AWTOGRSC                    */
    ccConE69SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE69SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE69SXX,             /* 09-CCS_AWTANS                      */
    ccConE69SXX,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccConE69SXX,             /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccConE69SXX,             /* 32-CCS__LOCALLYANSWERED            */
    ccConE69SBUF,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccConE69SXX,             /* 41-CCS_AWTRSPFORDPE11              */
    ccConE69SXX,             /* 42-CCS_AWTRSPFORDPE27              */
    ccConE69SXX,             /* 43-CCS_AWTRSPFORDPE28              */
    ccConE69SXX,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccConE69SXX,             /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE69SXX,             /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccConE69SBUF,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccConE69SBUF,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE69SBUF,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE69SBUF,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE69SBUF,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE69SBUF,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE69SBUF,            /* 73-CCS_AWT_QRYRSP                  */
    ccConE69SBUF,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE69SBUF,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE69SBUF,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccConE69SBUF,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE69SBUF,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE69SBUF,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE69SBUF,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE69SBUF,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccConE69SBUF,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE69SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccConE69SBUF,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_ACKNOWLEDGE - 70 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03--CCS_AWTRSPODISCONNECT          */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccConE70S10,             /* 10-CCS_ANSWERED                    */
    ccConE70S11,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CONNECT_TO_RESOURCE - 71 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE71S03,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    /* euysal - 05/25/2005 - ACC Support */
    ccConE71S10,             /* 10-CCS_ANSWERED                    */
    ccConE71S11,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    /* euysal - 07/06/2005 - ACC Support */
    ccConE71S44,             /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccIgnoreEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccConE71S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE71S99,             /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccConE71SBUF,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE71S03,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE71SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_FIC_ERROR - 72 */
  {
    ccIgnoreEvent,           /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03--CCS_AWTRSPODISCONNECT          */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccConE72S09,             /* 06-CCS_AWTOGRSC                    */
    ccConE72SXX,             /* 07-CCS_AWTANSSWT                   */
    ccConE72SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE72S09,             /* 09-CCS_AWTANS                      */
    ccConE72S10,             /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */
    ccConE72SXX,             /* 28-CCS_AWTOGSWTCFM                 */
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccConE72SXX,             /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE72SXY,             /* 36-CCS_AWTRSPFORDPE1               */
    ccConE72SXY,             /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccConE72SXY,             /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccIgnoreEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccIgnoreEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE72SXX,             /* 73-CCS_AWT_QRYRSP                  */
    ccConE72SXX,             /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE72SXX,             /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccIgnoreEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccConE72SXX,             /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE72SXX,             /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE72SXX,             /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE72SXX,             /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE72SXX,             /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccIgnoreEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccIgnoreEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccIgnoreEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */

    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccConE72SXX,             /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL               */

    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE72SXX,             /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_PAUSETMREXPIRY - 73 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */

    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE73S91,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* Feature 1789 - German ISUP:                                   *
   * CCE_TOIW2TMREXPIRY - Toiw2 timer expire - 74                  */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE74S09,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* euysal - 03/17/2005 - CAMEL Support */
  /* CCE_RELEASECALL - 75 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE75SXX,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccConE75SXX,             /* 04-CCS_AWTRSCALOCCFM               */
    ccConE75SXX,             /* 05-CCS_AWTENBLOCSND                */
    ccConE75SXX,             /* 06-CCS_AWTOGRSC                    */
    ccConE75SXX,             /* 07-CCS_AWTANSSWT                   */
    ccConE75SXX,             /* 08-CCS_AWTSWTCFM                   */
    ccConE75SXX,             /* 09-CCS_AWTANS                      */
    ccConE75SXX,             /* 10-CCS_ANSWERED                    */
    ccConE75SXX,             /* 11-CCS_AWTRSPTIMEOUT               */
    ccConE75SXX,             /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccConE75SXX,             /* 13-CCS_AWTOGRSC_TOCLR              */
    ccConE75SXX,             /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccConE75SXX,             /* 17-CCS_AWTRELCFM_IC                */
    ccConE75SXX,             /* 18-CCS_AWTRELCFM_OG                */
    ccConE75SXX,             /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE75SXX,             /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccConE75SXX,             /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccConE75SXX,             /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE75SXX,             /* 37-CCS_AWTRSPFORDPE3               */
    ccConE75SXX,             /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccConE75SXX,             /* 44-CCS_AWTRSPFORDPE9               */
    ccConE75SXX,             /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccConE75SXX,             /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE75SXX,             /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE75SXX,             /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE75SXX,             /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE75SXX,             /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE75SXX,             /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccConE75SXX,             /* 86-CCS_AWTRSPFORDPE17              */
    ccConE75SXX,             /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE75SXX,             /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE75SXX,             /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE75SXX,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE75SXX,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
        /* euysal - 06/01/2005 - ACC Support */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccConE75SXX,             /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE75SXX,             /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE75SXX,             /* 123-CCS_AWTIDISCONNECT             */
    ccConE75SXX,             /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE75SXX,             /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE75SXX,             /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE75SXX,             /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE75SXX,             /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConE75SXX,             /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_EARLYACMTMREXP - 76 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccHandleE76Exp,          /* 03-CCS_AWTRSPODISCONNECT           */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccHandleE76Exp,          /* 06-CCS_AWTOGRSC                    */
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccHandleE76Exp,          /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */ /* Bug:62821 */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE76SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE76SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccHandleE76Exp,          /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccHandleE76Exp,          /* 37-CCS_AWTRSPFORDPE3               */
    ccHandleE76Exp,          /* 38-CCS_AWTRSPFORDPE37              */
    ccHandleE76Exp,          /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccHandleE76Exp,          /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccHandleE76Exp,          /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccHandleE76Exp,          /* 86-CCS_AWTRSPFORDPE17              */
    ccConE76SBUF,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,             /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE76SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccHandleE76Exp,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccHandleE76Exp,          /* 96-CCS_AWTMOREINFO                */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE76SBUF,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE76SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE76SBUF,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccHandleE76Exp,          /* 149-CCS_AWTOREDIRECT_RSP              */
    ccHandleE76Exp,          /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_CAC - 77 */
  {
    ccConE77S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_SWAPCALL - 78 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccConE78S95,             /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccConE78S124,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_MOVECALL - 79 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE79S03,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccConE79S99,             /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE79S123,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_INT_SWAPCALL - 80 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccConE80SXX,             /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccConE80SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE80SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE80SXX,             /* 09-CCS_AWTANS                      */
    ccConE80SXX,             /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE80SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE80SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE80SXX,             /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE80SBUF,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE80SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12              */
    ccConE80SBUF,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE80SBUF,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE80SBUF,            /* 133-CCS_UPDSES_AWTMG_2     U3      */ /* bug86988 */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE80SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_INT_MOVECALL - 81 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccConE81SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE81SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccConE81S09,             /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccConE81SBUF,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE81SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE81SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccConE81SBUF,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccConE81SBUF,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE81SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE81SBUF,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE81SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_PREANMTMREXP - 82 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccConE82SBUF,            /* 06-CCS_AWTOGRSC                    */
    ccConE82SBUF,            /* 07-CCS_AWTANSSWT                   */
    ccConE82SBUF,            /* 08-CCS_AWTSWTCFM                   */
    ccHandleE82Exp,          /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,            /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccConE82SBUF,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE82SBUF,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,            /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE82SBUF,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,            /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccConE82SBUF,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_CPG_RETRYTMREXP - 83 */
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccConE83S09,             /* 09-CCS_AWTANS                      */
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS__LOCALLYANSWERED            */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccIgnoreEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccIgnoreEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccIgnoreEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccIgnoreEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccIgnoreEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccIgnoreEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccIgnoreEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccIgnoreEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccIgnoreEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccIgnoreEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccIgnoreEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccIgnoreEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccIgnoreEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccIgnoreEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccIgnoreEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccIgnoreEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccIgnoreEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccIgnoreEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccIgnoreEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccIgnoreEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccIgnoreEvent,           /* 103-CCS_AWT_MGIT_CREATE            */          
    ccIgnoreEvent,           /* 104-CCS_AWT_RLT                    */          
    ccIgnoreEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccIgnoreEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccIgnoreEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccIgnoreEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccIgnoreEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccIgnoreEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccIgnoreEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccIgnoreEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccIgnoreEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccIgnoreEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccIgnoreEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccIgnoreEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccIgnoreEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccIgnoreEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccIgnoreEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccIgnoreEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccIgnoreEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccIgnoreEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccIgnoreEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccIgnoreEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccIgnoreEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccIgnoreEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccIgnoreEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccIgnoreEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccIgnoreEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccIgnoreEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccIgnoreEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccIgnoreEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccIgnoreEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* Test Line - 84 */
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccConE84S37,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccConE38S47,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_TSTLNDSCNTMREXP - 85 */
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE85S32,            /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE85SBUF,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_TSTLNCDTMREXP - 86 */
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccConE86S32,            /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */          
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */          
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */          
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_SENDAPM - 87 */
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccConE87S140,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,          /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccConE87S37,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccConE87S44,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */    
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccConE87S124,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */    
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE87S140,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  }, 
  
  /* CCE_SENDACM - 88 */ 
  {
    ccIgnoreEvent,          /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccConE88S140,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },

  /* CCE_MGID_RSP - 89 */ 
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE89S142,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_SENDMSG - 90 */ 
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccConE90S10,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccConE90SBUF,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE90SBUF,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE90SBUF,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE90SBUF,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccConE90SBUF,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccConE90SBUF,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CANCEL - 91 */ 
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,          /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,          /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccConE91SXX,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,          /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,          /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE91SBUF,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE91SBUF,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE91S89,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE91S90,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE91SBUF,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE91SBUF,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_TOIW3TMREXP - 92 */
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccConE92S09,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CAC_CFM                */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_LIMANINV - 93 */
  {
    ccUnexpEvent,          /* 00-CCS_IDLE                        */
    ccConE93SXX,           /* 01-CCS_AWTROUTERSC                 */
    ccConE93SXX,           /* 02-CCS_AWTROUTEDGT                 */
    ccConE93SXX,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccConE93SXX,           /* 04-CCS_AWTRSCALOCCFM               */
    ccConE93SXX,           /* 05-CCS_AWTENBLOCSND                */
    ccConE93SXX,           /* 06-CCS_AWTOGRSC                    */
    ccConE93SXX,           /* 07-CCS_AWTANSSWT                   */
    ccConE93SXX,           /* 08-CCS_AWTSWTCFM                   */
    ccConE93SMI,           /* 09-CCS_AWTANS                      */
    ccConE93SMI,           /* 10-CCS_ANSWERED                    */
    ccConE93SXX,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccConE93SXX,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccConE93SXX,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccConE93SXX,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccConE93SXX,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccConE93SXX,           /* 16-COT_OG_DONE                     */
    ccConE93SXX,           /* 17-CCS_AWTRELCFM_IC                */
    ccConE93SXX,           /* 18-CCS_AWTRELCFM_OG                */
    ccConE93SXX,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccConE93SXX,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccConE93SXX,           /* 21-CCS_AWTDEALOCCFM                */
    ccConE93SXX,           /* 22-CCS_RETRIEVE                    */
    ccConE93SXX,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccConE93SXX,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccConE93SXX,           /* 25-CCS_AWTCOT                      */
    ccConE93SXX,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccConE93SXX,           /* 27-COT_IC_DONE                     */
    ccConE93SXX,           /* 28-CCS_AWTOGSWTCFM                 */
    ccConE93SXX,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccConE93SXX,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccConE93SXX,           /* 31-CCS_AWTDELFROMACT               */
    ccConE93SXX,           /* 32-CCS_LOCALLYANSWERED             */
    ccConE93SXX,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccConE93SXX,           /* 34-CCS_AWT_ADDR_CFM                */
    ccConE93SXX,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccConE93SXX,           /* 36-CCS_AWTRSPFORDPE1               */
    ccConE93SXX,           /* 37-CCS_AWTRSPFORDPE3               */
    ccConE93SXX,           /* 38-CCS_AWTRSPFORDPE37              */
    ccConE93SXX,           /* 39-CCS_AWTRSPFORDPE20              */
    ccConE93SXX,           /* 40-CCS_AWTRSPFORDPE30              */
    ccConE93SXX,           /* 41-CCS_AWTRSPFORDPE11              */
    ccConE93SXX,           /* 42-CCS_AWTRSPFORDPE27              */
    ccConE93SXX,           /* 43-CCS_AWTRSPFORDPE28              */
    ccConE93SXX,           /* 44-CCS_AWTRSPFORDPE9               */
    ccConE93SXX,           /* 45-CCS_AWTRSPFORDPE33              */
    ccConE93SXX,           /* 46-CCS_AWTRSPFORDPE32              */
    ccConE93SXX,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccConE93SXX,           /* 48-CCS_AWT_REATTEMPT               */
    ccConE93SXX,           /* 49-CCS_AWTRSPFORDPE22              */
    ccConE93SXX,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccConE93SXX,           /* 51-CCS_AWTBUSYREL_IC               */
    ccConE93SXX,           /* 52-CCS_AWT_RESUME                  */
    ccConE93SXX,           /* 53-CCS_AWT_TMDRELEXP               */
    ccConE93SXX,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccConE93SXX,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccConE93SXX,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccConE93SXX,          /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccConE93SXX,          /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccConE93SXX,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccConE93SXX,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccConE93SXX,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccConE93SXX,           /* 62-CCS_AWTRSPFORDPE19              */
    ccConE93SXX,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccConE93SXX,           /* 64-CCS_AWTRSPFAILOUT               */
    ccConE93SXX,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccConE93SXX,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccConE93SXX,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccConE93SXX,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccConE93SXX,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccConE93SXX,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccConE93SXX,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccConE93SXX,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccConE93SXX,           /* 73-CCS_AWT_QRYRSP                  */
    ccConE93SXX,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccConE93SXX,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccConE93SXX,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccConE93SXX,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccConE93SXX,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccConE93SXX,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccConE93SXX,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccConE93SXX,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccConE93SXX,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccConE93SXX,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccConE93SXX,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccConE93SXX,           /* 85-CCS_AWTMWIUPDCFM                */
    ccConE93SXX,           /* 86-CCS_AWTRSPFORDPE17              */
    ccConE93SXX,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccConE93SXX,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccConE93SXX,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccConE93SXX,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccConE93SXX,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccConE93SXX,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccConE93SXX,           /* 93-CCS_AWTMINDIGITS                */
    ccConE93SXX,           /* 94-CCS_AWTMAXDIGITS                */
    ccConE93SXX,           /* 95-CCS_AWTRSPFORDPE08              */
    ccConE93SXX,           /* 96-CCS_AWTMOREINFO                 */
    ccConE93SXX,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccConE93SXX,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccConE93SXX,           /* 99-CCS_AWTRSPFORDPE12              */
    ccConE93SXX,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccConE93SXX,           /* 101-CCS_AWTDELAYEDREL              */
    ccConE93SXX,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccConE93SXX,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccConE93SXX,           /* 104-CCS_AWT_RLT                    */
    ccConE93SXX,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccConE93SXX,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccConE93SXX,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccConE93SXX,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccConE93SXX,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccConE93SXX,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccConE93SXX,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccConE93SXX,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccConE93SXX,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccConE93SXX,           /* 114-CCS_COB_AWTXFERROUT            */
    ccConE93SXX,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccConE93SXX,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccConE93SXX,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccConE93SXX,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccConE93SXX,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccConE93SXX,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccConE93SXX,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccConE93SXX,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE93SXX,           /* 123-CCS_AWTIDISCONNECT             */
    ccConE93SXX,           /* 124-CCS_AWTRSPFORDPE7              */
    ccConE93SXX,           /* 125-CCS_CBI_AWTMGI1                */
    ccConE93SXX,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccConE93SXX,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccConE93SXX,           /* 128-CCS_CBI_AWTOGXFER              */
    ccConE93SXX,           /* 129-CCS_CBI_AWTSUB                 */
    ccConE93SXX,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccConE93SXX,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccConE93SXX,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccConE93SXX,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccConE93SXX,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccConE93SXX,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccConE93SXX,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccConE93SXX,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccConE93SXX,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccConE93SXX,           /* 139-CCS_AWT_CAC_CFM                */
    ccConE93SXX,           /* 140-CCS_AWTRSPOAPM                 */
    ccConE93SXX,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccConE93SXX,           /* 142-CCS_AWT_MGID_RSP               */
    ccConE93SXX,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccConE93SXX,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccConE93SXX,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccConE93SXX,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccConE93SXX,           /* 147-CCS_BICC_AWTICBEARER           */
    ccConE93SXX,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccConE93SXX,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,          /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,          /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,          /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,          /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_ICA - 94 */
  {
    ccConE94S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CAC_CFM                */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,           /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_IACA - 95 */
  {
    ccConE95S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CAC_CFM                */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,           /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_CALLQUEUED - 96 */ 
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,          /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,          /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccConE96S37,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccConE96S86,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccConE96S123,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,           /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,           /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_HPCMGRETRYTMREXP - 97 FID 14457.0 */ 
  {
    ccUnexpEvent,           /* 00-CCS_IDLE                        */
    ccUnexpEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,           /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,           /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,           /* 09-CCS_AWTANS                      */
    ccUnexpEvent,           /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,           /* 16-COT_OG_DONE                     */
    ccUnexpEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,           /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,           /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,           /* 27-COT_IC_DONE                     */
    ccUnexpEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccUnexpEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccUnexpEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,           /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccUnexpEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccUnexpEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccUnexpEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccUnexpEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccUnexpEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccUnexpEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,           /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccUnexpEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccUnexpEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,           /* 149-CCS_AWTOREDIRECT_RSP           */
    ccConE97S150,           /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,           /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,           /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,           /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* CCE_HPCDELAYREQ - 98 FID 14457.0, BUG: 88025 */ 
  {
    ccUnexpEvent,            /* 00-CCS_IDLE                        */
    ccIgnoreEvent,           /* 01-CCS_AWTROUTERSC                 */
    ccIgnoreEvent,           /* 02-CCS_AWTROUTEDGT                 */
    ccIgnoreEvent,           /* 03-CCS_AWTRSPODISCONNECT           */
    ccIgnoreEvent,           /* 04-CCS_AWTRSCALOCCFM               */
    ccIgnoreEvent,           /* 05-CCS_AWTENBLOCSND                */
    ccIgnoreEvent,           /* 06-CCS_AWTOGRSC                    */
    ccIgnoreEvent,           /* 07-CCS_AWTANSSWT                   */
    ccIgnoreEvent,           /* 08-CCS_AWTSWTCFM                   */
    ccConE98S09,             /* 09-CCS_AWTANS                      */
    ccIgnoreEvent,           /* 10-CCS_ANSWERED                    */
    ccIgnoreEvent,           /* 11-CCS_AWTRSPTIMEOUT               */
    ccIgnoreEvent,           /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccIgnoreEvent,           /* 13-CCS_AWTOGRSC_TOCLR              */
    ccIgnoreEvent,           /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccIgnoreEvent,           /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccIgnoreEvent,           /* 16-COT_OG_DONE                     */
    ccIgnoreEvent,           /* 17-CCS_AWTRELCFM_IC                */
    ccIgnoreEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccIgnoreEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccIgnoreEvent,           /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccIgnoreEvent,           /* 21-CCS_AWTDEALOCCFM                */
    ccIgnoreEvent,           /* 22-CCS_RETRIEVE                    */
    ccIgnoreEvent,           /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccIgnoreEvent,           /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccIgnoreEvent,           /* 25-CCS_AWTCOT                      */
    ccIgnoreEvent,           /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccIgnoreEvent,           /* 27-COT_IC_DONE                     */
    ccIgnoreEvent,           /* 28-CCS_AWTOGSWTCFM                 */
    ccIgnoreEvent,           /* 29-CCS_AWTMGCTCFMCOTOG0            */    
    ccIgnoreEvent,           /* 30-CCS_AWTMGCTNOTIFY1              */
    ccIgnoreEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccIgnoreEvent,           /* 32-CCS_LOCALLYANSWERED             */
    ccIgnoreEvent,           /* 33-CCS_AWTSWTCFMFORSVC             */
    ccIgnoreEvent,           /* 34-CCS_AWT_ADDR_CFM                */
    ccIgnoreEvent,           /* 35-CCS_AWT_MID_CALL_CFM            */
    ccIgnoreEvent,           /* 36-CCS_AWTRSPFORDPE1               */
    ccIgnoreEvent,           /* 37-CCS_AWTRSPFORDPE3               */
    ccIgnoreEvent,           /* 38-CCS_AWTRSPFORDPE37              */
    ccIgnoreEvent,           /* 39-CCS_AWTRSPFORDPE20              */
    ccIgnoreEvent,           /* 40-CCS_AWTRSPFORDPE30              */
    ccIgnoreEvent,           /* 41-CCS_AWTRSPFORDPE11              */
    ccIgnoreEvent,           /* 42-CCS_AWTRSPFORDPE27              */
    ccIgnoreEvent,           /* 43-CCS_AWTRSPFORDPE28              */
    ccIgnoreEvent,           /* 44-CCS_AWTRSPFORDPE9               */
    ccIgnoreEvent,           /* 45-CCS_AWTRSPFORDPE33              */
    ccIgnoreEvent,           /* 46-CCS_AWTRSPFORDPE32              */
    ccIgnoreEvent,           /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccIgnoreEvent,           /* 48-CCS_AWT_REATTEMPT               */
    ccIgnoreEvent,           /* 49-CCS_AWTRSPFORDPE22              */
    ccIgnoreEvent,           /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccIgnoreEvent,           /* 51-CCS_AWTBUSYREL_IC               */
    ccIgnoreEvent,           /* 52-CCS_AWT_RESUME                  */
    ccIgnoreEvent,           /* 53-CCS_AWT_TMDRELEXP               */
    ccIgnoreEvent,           /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccIgnoreEvent,           /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccIgnoreEvent,           /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccIgnoreEvent,           /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccIgnoreEvent,           /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccIgnoreEvent,           /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccIgnoreEvent,           /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccIgnoreEvent,           /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccIgnoreEvent,           /* 62-CCS_AWTRSPFORDPE19              */
    ccIgnoreEvent,           /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccIgnoreEvent,           /* 64-CCS_AWTRSPFAILOUT               */
    ccIgnoreEvent,           /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccIgnoreEvent,           /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccIgnoreEvent,           /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccIgnoreEvent,           /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccIgnoreEvent,           /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccIgnoreEvent,           /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccIgnoreEvent,           /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccIgnoreEvent,           /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccIgnoreEvent,           /* 73-CCS_AWT_QRYRSP                  */
    ccIgnoreEvent,           /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccIgnoreEvent,           /* 75-CCS_AWT_XFRRSP_FROM_2           */    
    ccIgnoreEvent,           /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccIgnoreEvent,           /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccIgnoreEvent,           /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccIgnoreEvent,           /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccIgnoreEvent,           /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccIgnoreEvent,           /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccIgnoreEvent,           /* 82-CCS_AWTANNCMPLT_CTR             */
    ccIgnoreEvent,           /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccIgnoreEvent,           /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccIgnoreEvent,           /* 85-CCS_AWTMWIUPDCFM                */
    ccIgnoreEvent,           /* 86-CCS_AWTRSPFORDPE17              */
    ccIgnoreEvent,           /* 87-CCS_AWTSWTCFMFORDP              */
    ccIgnoreEvent,           /* 88-CCS_AWTFICRSP_2_XFER            */
    ccIgnoreEvent,           /* 89-CCS_AWTMGCTNOTIFY0              */
    ccIgnoreEvent,           /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccIgnoreEvent,           /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccIgnoreEvent,           /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccIgnoreEvent,           /* 93-CCS_AWTMINDIGITS                */
    ccIgnoreEvent,           /* 94-CCS_AWTMAXDIGITS                */
    ccIgnoreEvent,           /* 95-CCS_AWTRSPFORDPE08              */
    ccIgnoreEvent,           /* 96-CCS_AWTMOREINFO                 */
    ccIgnoreEvent,           /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR    */
    ccIgnoreEvent,           /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR    */
    ccIgnoreEvent,           /* 99-CCS_AWTRSPFORDPE12              */
    ccIgnoreEvent,           /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccIgnoreEvent,           /* 101-CCS_AWTDELAYEDREL              */
    ccIgnoreEvent,           /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccIgnoreEvent,           /* 103-CCS_AWT_MGIT_CREATE            */
    ccIgnoreEvent,           /* 104-CCS_AWT_RLT                    */
    ccIgnoreEvent,           /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccIgnoreEvent,           /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccIgnoreEvent,           /* 107-CCS_COB_AWTXFERRSPIN           */
    ccIgnoreEvent,           /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccIgnoreEvent,           /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccIgnoreEvent,           /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccIgnoreEvent,           /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccIgnoreEvent,           /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccIgnoreEvent,           /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccIgnoreEvent,           /* 114-CCS_COB_AWTXFERROUT            */
    ccIgnoreEvent,           /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccIgnoreEvent,           /* 116-CCS_COB_AWTMGCTTOREL           */
    ccIgnoreEvent,           /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccIgnoreEvent,           /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccIgnoreEvent,           /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccIgnoreEvent,           /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccIgnoreEvent,           /* 121-CCS_AWTTMGCTFORSWAPCALL        */    
    ccIgnoreEvent,           /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccIgnoreEvent,           /* 123-CCS_AWTIDISCONNECT             */
    ccIgnoreEvent,           /* 124-CCS_AWTRSPFORDPE7              */
    ccIgnoreEvent,           /* 125-CCS_CBI_AWTMGI1                */
    ccIgnoreEvent,           /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccIgnoreEvent,           /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccIgnoreEvent,           /* 128-CCS_CBI_AWTOGXFER              */
    ccIgnoreEvent,           /* 129-CCS_CBI_AWTSUB                 */
    ccIgnoreEvent,           /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccIgnoreEvent,           /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccIgnoreEvent,           /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccIgnoreEvent,           /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccIgnoreEvent,           /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccIgnoreEvent,           /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccIgnoreEvent,           /* 136-CCS_AWT_MG_PRACKRSP            */
    ccIgnoreEvent,           /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccIgnoreEvent,           /* 138-CCS_AWT_RSP_FOR_SO             */
    ccIgnoreEvent,           /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccIgnoreEvent,           /* 140-CCS_AWTRSPOAPM                 */
    ccIgnoreEvent,           /* 141-CCS_AWTCFM_FOR_LI              */
    ccIgnoreEvent,           /* 142-CCS_AWT_MGID_RSP               */
    ccIgnoreEvent,           /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */  
    ccIgnoreEvent,           /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccIgnoreEvent,           /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccIgnoreEvent,           /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccIgnoreEvent,           /* 147-CCS_BICC_AWTICBEARER           */
    ccIgnoreEvent,           /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccIgnoreEvent,           /* 149-CCS_AWTOREDIRECT_RSP           */
    ccIgnoreEvent,           /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccUnexpEvent,            /* 151-CCS_AWTNCCFM  FID16206.0       */
    ccUnexpEvent,            /* 152-CCS_AWTNCIND   FID16206.0      */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccConEXXS154,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
  /* FID16206 None Call indication - 99 */
  {
    ccConE99S00,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,            /* 18-CCS_AWTRELCFM_OG                */ 
    ccUnexpEvent,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,             /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE99S151,            /* 151-CCS_AWTNCCFM  FID16206.0     */
    ccConE99S152,            /* 152-CCS_AWTNCIND   FID16206.0     */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
 /* FID16206 None call confirm  - 100 */
  {
    ccUnexpEvent,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccConE05S17,            /* 17-CCS_AWTRELCFM_IC                */
    ccConE05S18,            /* 18-CCS_AWTRELCFM_OG                */
    ccConE05S19,            /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,             /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE100S151,           /* 151-CCS_AWTMSGCFM   FID16206.0     */
    ccUnexpEvent,            /* 152-CCS_AWTMSGIND   FID16206.0     */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD   BUG:90302     */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
 /* FID16206 CCE_CFXCONTROLTMREX - 101 */
  {
    ccUnexpEvent,             /* 00-CCS_IDLE                        */
    ccUnexpEvent,            /* 01-CCS_AWTROUTERSC                 */
    ccUnexpEvent,            /* 02-CCS_AWTROUTEDGT                 */
    ccUnexpEvent,            /* 03-CCS_AWTRSPODISCONNECT           */
    ccUnexpEvent,            /* 04-CCS_AWTRSCALOCCFM               */
    ccUnexpEvent,            /* 05-CCS_AWTENBLOCSND                */
    ccUnexpEvent,            /* 06-CCS_AWTOGRSC                    */
    ccUnexpEvent,            /* 07-CCS_AWTANSSWT                   */
    ccUnexpEvent,            /* 08-CCS_AWTSWTCFM                   */
    ccUnexpEvent,            /* 09-CCS_AWTANS                      */
    ccUnexpEvent,            /* 10-CCS_ANSWERED                    */
    ccUnexpEvent,            /* 11-CCS_AWTRSPTIMEOUT               */
    ccUnexpEvent,            /* 12-CCS_AWTRSCCFM_TOCLR             */
    ccUnexpEvent,            /* 13-CCS_AWTOGRSC_TOCLR              */
    ccUnexpEvent,            /* 14-CCS_AWT_MGI_XFERQRYHOLD         */
    ccUnexpEvent,            /* 15-CCS_AWTRSCALLOCCFM_GLARE        */
    ccUnexpEvent,            /* 16-COT_OG_DONE                     */
    ccUnexpEvent,            /* 17-CCS_AWTRELCFM_IC                */
    ccUnexpEvent,           /* 18-CCS_AWTRELCFM_OG                */
    ccUnexpEvent,           /* 19-CCS_AWTRELCFM_BOTH              */
    ccUnexpEvent,            /* 20-CCS_AWTSWTCFM_TOCLR             */
    ccUnexpEvent,            /* 21-CCS_AWTDEALOCCFM                */
    ccUnexpEvent,            /* 22-CCS_RETRIEVE                    */
    ccUnexpEvent,            /* 23-CCS_AWTALOCCFM_TOCLR            */
    ccUnexpEvent,            /* 24-CCS_AWTMGCTCFMCOTIC0            */
    ccUnexpEvent,            /* 25-CCS_AWTCOT                      */
    ccUnexpEvent,            /* 26-CCS_AWTMGCTCFMCOTIC1            */
    ccUnexpEvent,             /* 27-COT_IC_DONE                     */
    ccUnexpEvent,            /* 28-CCS_AWTOGSWTCFM                 */
    ccUnexpEvent,            /* 29-CCS_AWTMGCTCFMCOTOG0            */
    ccUnexpEvent,            /* 30-CCS_AWTMGCTNOTIFY1              */
    ccUnexpEvent,           /* 31-CCS_AWTDELFROMACT               */
    ccUnexpEvent,            /* 32-CCS__LOCALLYANSWERED            */
    ccUnexpEvent,            /* 33-CCS_AWTSWTCFMFORSVC             */
    ccUnexpEvent,            /* 34-CCS_AWT_ADDR_CFM                */
    ccUnexpEvent,            /* 35-CCS_AWT_MID_CALL_CFM            */
    ccUnexpEvent,            /* 36-CCS_AWTRSPFORDPE1               */
    ccUnexpEvent,            /* 37-CCS_AWTRSPFORDPE3               */
    ccUnexpEvent,            /* 38-CCS_AWTRSPFORDPE37              */
    ccUnexpEvent,            /* 39-CCS_AWTRSPFORDPE20              */
    ccUnexpEvent,            /* 40-CCS_AWTRSPFORDPE30              */
    ccUnexpEvent,            /* 41-CCS_AWTRSPFORDPE11              */
    ccUnexpEvent,            /* 42-CCS_AWTRSPFORDPE27              */
    ccUnexpEvent,            /* 43-CCS_AWTRSPFORDPE28              */
    ccUnexpEvent,            /* 44-CCS_AWTRSPFORDPE9               */
    ccUnexpEvent,            /* 45-CCS_AWTRSPFORDPE33              */
    ccUnexpEvent,            /* 46-CCS_AWTRSPFORDPE32              */
    ccUnexpEvent,            /* 47-CCS_AWTRSPFORDPEXY_TOCLR        */
    ccUnexpEvent,            /* 48-CCS_AWT_REATTEMPT               */
    ccUnexpEvent,            /* 49-CCS_AWTRSPFORDPE22              */
    ccUnexpEvent,            /* 50-CCS_AWTCALEALEGSWTCFM           */
    ccUnexpEvent,            /* 51-CCS_AWTBUSYREL_IC               */
    ccUnexpEvent,            /* 52-CCS_AWT_RESUME                  */
    ccUnexpEvent,            /* 53-CCS_AWT_TMDRELEXP               */
    ccUnexpEvent,            /* 54-CCS_AWTSWTCFM_SENDBOTHREL       */
    ccUnexpEvent,            /* 55-CCS_AWTSWTCFM_SENDONEREL        */
    ccUnexpEvent,            /* 56-CCS_AWTSWTCFM_SENDNOREL         */
    ccUnexpEvent,            /* 57-CCS_AWTMGCTCFMFORMODIFY0        */
    ccUnexpEvent,            /* 58-CCS_AWTMGCTCFMFORMODIFY1        */
    ccUnexpEvent,            /* 59-CCS_AWTRELCFM_KEEP_CON          */
    ccUnexpEvent,            /* 60-CCS_AWTRSCCFMNOTIFY             */
    ccUnexpEvent,            /* 61-CCS_NOTIFYRSPFORMSUB            */
    ccUnexpEvent,            /* 62-CCS_AWTRSPFORDPE19              */
    ccUnexpEvent,            /* 63-CCS_AWTSWTCFMFORCC6CC10         */
    ccUnexpEvent,            /* 64-CCS_AWTRSPFAILOUT               */
    ccUnexpEvent,            /* 65-CCS_AWTSWTCFMFORHOLD            */
    ccUnexpEvent,            /* 66-CCS_AWTSWTCFMCONFTONE           */
    ccUnexpEvent,            /* 67-CCS_AWTSWTCFMFORSPLIT3WC        */
    ccUnexpEvent,            /* 68-CCS_CANNOTPROCESSEVENTS         */
    ccUnexpEvent,            /* 69-CCS_AWTSWTCFMFORMERGEINCC4      */
    ccUnexpEvent,            /* 70-CCS_AWTSWTCFM_MERGEINCC6IC      */
    ccUnexpEvent,            /* 71-CCS_AWTSWTCFM_MERGEINCC6OG      */
    ccUnexpEvent,            /* 72-CCS_AWT_PERMSIG_TREATMENT_CFM   */
    ccUnexpEvent,            /* 73-CCS_AWT_QRYRSP                  */
    ccUnexpEvent,            /* 74-CCS_AWT_XFRRSP_FROM_1           */
    ccUnexpEvent,            /* 75-CCS_AWT_XFRRSP_FROM_2           */
    ccUnexpEvent,            /* 76-CCS_AWTSWTCFMFORCC6CC11         */
    ccUnexpEvent,            /* 77-CCS_AWT_MGI_SUBCFM_TO_QRY       */
    ccUnexpEvent,            /* 78-CCS_AWT_RSP_TO_CLR_BEARER       */
    ccUnexpEvent,            /* 79-CCS_AWT_FIC_RSP_TO_KILL         */
    ccUnexpEvent,            /* 80-CCS_AWT_QRYRSP_ONSWITCH         */
    ccUnexpEvent,            /* 81-CCS_AWT_XFRRSP_1_ONSWITCH       */
    ccUnexpEvent,            /* 82-CCS_AWTANNCMPLT_CTR             */
    ccUnexpEvent,            /* 83-CCS_AWT_XFRRSP_2_ONSWITCH       */
    ccUnexpEvent,            /* 84-CCS_AWTRSCALLOCCFM_MWI          */
    ccUnexpEvent,            /* 85-CCS_AWTMWIUPDCFM                */
    ccUnexpEvent,            /* 86-CCS_AWTRSPFORDPE17              */
    ccUnexpEvent,            /* 87-CCS_AWTSWTCFMFORDP              */
    ccUnexpEvent,            /* 88-CCS_AWTFICRSP_2_XFER            */
    ccUnexpEvent,            /* 89-CCS_AWTMGCTNOTIFY0              */
    ccUnexpEvent,            /* 90-CCS_AWTMGCTCFMFORMODIFY2        */
    ccUnexpEvent,            /* 91-CCS_AWTPAUSETIMEREXPIRY         */
    ccUnexpEvent,            /* 92-CCS_AWTMGCTCFMCOTOG1            */
    ccUnexpEvent,            /* 93-CCS_AWTMINDIGITS                */
    ccUnexpEvent,            /* 94-CCS_AWTMAXDIGITS                */
    ccUnexpEvent,            /* 95-CCS_AWTRSPFORDPE08              */
    ccUnexpEvent,            /* 96-CCS_AWTMOREINFO                     */
    ccUnexpEvent,            /* 97-CCS_AWTMGCTCFMFORMODIFY1_CTR   */
    ccUnexpEvent,            /* 98-CCS_AWTMGCTCFMFORMODIFY2_CTR   */
    ccUnexpEvent,            /* 99-CCS_AWTRSPFORDPE12             */
    ccUnexpEvent,            /* 100-CCS_AWTMGCTCFMFOREARLYACM      */
    ccUnexpEvent,           /* 101-CCS_AWTDELAYEDREL               */
    ccUnexpEvent,            /* 102-CCS_AWT_MGIT_SUBSCRIBE         */
    ccUnexpEvent,            /* 103-CCS_AWT_MGIT_CREATE            */
    ccUnexpEvent,            /* 104-CCS_AWT_RLT                    */
    ccUnexpEvent,            /* 105-CCS_AWT_OFFNET_XFERRSP         */
    ccUnexpEvent,            /* 106-CCS_COB_AWTXFERRSPBOTH         */
    ccUnexpEvent,            /* 107-CCS_COB_AWTXFERRSPIN           */
    ccUnexpEvent,            /* 108-CCS_COB_AWTXFERRSPOUT          */
    ccUnexpEvent,            /* 109-CCS_COB_AWTMGCTADDICANDOUT     */
    ccUnexpEvent,            /* 110-CCS_COB_AWTMGCTSUBALL          */
    ccUnexpEvent,            /* 111-CCS_COB_AWTMGCTICSUBADD_AWTXFERRSPOUT */
    ccUnexpEvent,            /* 112-CCS_COB_AWTMGCTICSUBADD        */
    ccUnexpEvent,            /* 113-CCS_COB_AWTXFERRSPINANDXFEROUT */
    ccUnexpEvent,            /* 114-CCS_COB_AWTXFERROUT            */
    ccUnexpEvent,            /* 115-CCS_COB_AWTMGCTOUTSUBADD_AWTXFERRSPIN */
    ccUnexpEvent,            /* 116-CCS_COB_AWTMGCTTOREL           */
    ccUnexpEvent,            /* 117-CCS_COB_AWTMGCTOUTSUBADD       */
    ccUnexpEvent,            /* 118-CCS_COB_AWTMGCTMODICANDOUT     */
    ccUnexpEvent,            /* 119-CCS_COB_AWTXFERRSPINANDOUTADD  */
    ccUnexpEvent,            /* 120-CCS_COB_AWTMGCTOUTADD          */
    ccUnexpEvent,            /* 121-CCS_AWTTMGCTFORSWAPCALL        */
    ccUnexpEvent,            /* 122-CCS_AWTTMGCTFORMOVECALL        */
    ccUnexpEvent,            /* 123-CCS_AWTIDISCONNECT             */
    ccUnexpEvent,            /* 124-CCS_AWTRSPFORDPE7              */
    ccUnexpEvent,            /* 125-CCS_CBI_AWTMGI1                */
    ccUnexpEvent,            /* 126-CCS_CBI_AWTOGQRYRSP            */
    ccUnexpEvent,            /* 127-CCS_CBI_AWTICXFERRSP1          */
    ccUnexpEvent,            /* 128-CCS_CBI_AWTOGXFER              */
    ccUnexpEvent,            /* 129-CCS_CBI_AWTSUB                 */
    ccUnexpEvent,            /* 130-CCS_AWTMGCTCFM_ACK     U0      */
    ccUnexpEvent,            /* 131-CCS_UPDSES_AWTMG_1     U1      */
    ccUnexpEvent,            /* 132-CCS_UPDSES_AWTRSP      U2      */
    ccUnexpEvent,            /* 133-CCS_UPDSES_AWTMG_2     U3      */
    ccUnexpEvent,            /* 134-CCS_AWT_MGCTCFM_LLTR           */
    ccUnexpEvent,            /* 135-CCS_AWT_MGCTCFM_TSTLNTONE      */
    ccUnexpEvent,            /* 136-CCS_AWT_MG_PRACKRSP            */
    ccUnexpEvent,            /* 137-CCS_AWT_MGI_CFM_FOR_DL2        */
    ccUnexpEvent,            /* 138-CCS_AWT_RSP_FOR_SO             */
    ccUnexpEvent,            /* 139-CCS_AWT_CONGOVRLD_CFM          */
    ccUnexpEvent,            /* 140-CCS_AWTRSPOAPM                 */
    ccUnexpEvent,            /* 141-CCS_AWTCFM_FOR_LI              */
    ccUnexpEvent,            /* 142-CCS_AWT_MGID_RSP               */
    ccUnexpEvent,            /* 143-CCS_CMAB_AWT_IC_QRY_RESP       */
    ccUnexpEvent,            /* 144-CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP */
    ccUnexpEvent,            /* 145-CCS_CMAB_AWT_OG_XFER_RESP      */
    ccUnexpEvent,            /* 146-CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP */
    ccUnexpEvent,            /* 147-CCS_BICC_AWTICBEARER           */
    ccUnexpEvent,            /* 148-CCS_BICC_AWT_MGCT_CFMNOT       */
    ccUnexpEvent,            /* 149-CCS_AWTOREDIRECT_RSP              */
    ccUnexpEvent,            /* 150-CCS_AWTHPCMGRETRYTIMEREXPRIY   */
    ccConE101S151,           /* 151-CCS_AWTNCCFM   FID16206.0     */
    ccConE101S152,            /* 152-CCS_AWTNCIND   FID16206.0     */
    ccUnexpEvent,            /* 153-CCS_AWTSWTCFMFORSUBADD BUG:90302 */
    ccUnexpEvent,            /* 154-CCS_AWT_PRECONDITION FID15068.0*/
    ccUnexpEvent,            /* 155-CCS_AWT_MRFRSP FID17174.0 */
    ccUnexpEvent,            /* 156-CCS_AWTSWTCFM_FOR_DIALINGTONE */
  },
};


/*
 *
 *       Fun:   ccCallStateMachine
 *
 *       Desc:  Call Control State Machine Driver
 *
 *       Ret:   ROK      - ok
 *
 *       Notes: None
 *
 *       File:  cc_bdy2.c
 *
*/
PUBLIC S16 ccCallStateMachine
(
 CcConCb   *con,             /* Connection Control Block */
 U8         evntType,        /* Event Type */
 PTR        event,           /* Event */
 SuId       sapId,           /* SapId of lower sap of GCC */
 UConnId    spConnId,        /* Connection handle of service provider */
 AinBCM_t  *bcm,             /* BCM */
 PTR        event2           /* Event */
)
{
  U8 oldstate;
#if defined(CC_FSM_PROFILE)
  Ticks startTicksCpu;
  struct timeval startTicksClk;
#endif /* CC_FSM_PROFILE */
  CcConCb   *tmpCon;
  S16 ret;

  TRC3(ccCallStateMachine)


    if(evntType > CCMAXEVENTS)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
        CCLOGERROR(ERRCLS_DEBUG, ECC331, (ErrVal) 0,
                   "ccCallStateMachine() Failed, Invalid connection event");
#endif
        RETVALUE(RFAILED);
      }

  if(con == NULLP)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC332, (ErrVal) 0,
                 "ccCallStateMachine() Failed, Invalid connection ");
#endif
      RETVALUE(RFAILED);
    }

  oldstate = con->state;

  if(oldstate > CCMAXSTATES)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC333, (ErrVal) 0,
                 "ccCallStateMachine() Failed, Invalid connection state");
#endif
      RETVALUE(RFAILED);
    }

  if( stateTable[evntType][oldstate] == NULLP )
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC334, (ErrVal) 0,
                 "ccCallStateMachine(): no state/event transistion defined");
#endif
      RETVALUE(RFAILED);
    }

    /* FID 17167.0 enable sigdbg for tightly coupled FIC/RM */
    if(con->logMask)
    {
        if(ccFsmFrameCnt == 0)
        {
          FIC_LOGGING_ON(con->logMask);       
          RM_LOGGING_ON(con->logMask);
        }
    }

  CC_DP(DBGMASK_CC, (con), "CCFSM: EXT:E%02dS%02d, dir:%d, icSp:0x%08X, "
        "icSu:0x%08X, ogSp:0x%08X, ogSu:0x%08X, icEvntType:%02d\n",
        evntType, oldstate, con->direction,
        (unsigned int)con->icSpConnId, (unsigned int)con->icSuConnId,
        (unsigned int)con->ogSpConnId, (unsigned int)con->ogSuConnId,
        con->icEvntType);

  /* TELICA-jwh-10/05/2001:  Add GCC fsm profiling */
#ifdef CC_FSM_PROFILE
  con->evntType = evntType;
#endif /* CC_FSM_PROFILE */

  CC_TRACE_EVENT (con, evntType);
  
#ifdef CC_BUFFER_EVENT
  con->bufferBlock.evntFromQ  = FALSE;
  if (ccFsmFrameCnt == 0) 
  {
    con->bufferBlock.evntQueued = FALSE;
  }
#endif /* CC_BUFFER_EVENT */

  CC_PROFILE_EVT_START(&startTicksCpu, &startTicksClk);

  ccFsmFrameCnt++;
  (*stateTable[evntType][oldstate])(con, event, bcm, event2);
  ccFsmFrameCnt--;

  CC_PROFILE_EVT_END(startTicksCpu, startTicksClk, evntType, oldstate);

#ifdef CC_BUFFER_EVENT
  if (ccFsmFrameCnt == 0)
  {
     ret = cmHashListFind (&ccFreedConTbl, (U8 *)&con, 
                         (U16)sizeof(U8 *), (U16)0, (PTR *) &tmpCon);
     if (ret != ROK)
     {
        if((con->bufferBlock.evntQueued == FALSE) &&
           (con->bufferBlock.qPresent == TRUE))
        {
          ccProcessBufferedEvent (con);
        }
     }

     /* MCAO 09/04/03 Bug 24505 reset evntQueued when exits */
     con->bufferBlock.evntQueued =FALSE;
    
     if (ccFreedConTbl.nmbEnt)
     {
        while ((ret = cmHashListGetNext(&ccFreedConTbl, NULLP, (PTR*)&tmpCon)) == ROK)
        {
           cmHashListDelete(&ccFreedConTbl, (PTR)tmpCon);
           TELICA_FREE_CONNECTION (tmpCon);
        }
     }
  }
#endif /* CC_BUFFER_EVENT */
    
   /* FID 17167.0 disable sigdbg after state function call return */ 
   if (ccFsmFrameCnt == 0)
   {
       FIC_LOGGING_OFF();       
       RM_LOGGING_OFF();
   }

  RETVALUE(ROK);
} /* end of ccCallStateMachine */


/*
 *     Chapter 1:  Connection State Machine functions 
 */


/*
*
*      Fun:   ccUnexpEvent
*
*      Desc:  Handle unexpected Event in any state              
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PUBLIC  S16 ccUnexpEvent
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  ABORT_DEBUG;
  CCDBGP(DBGMASK_CC, (ccInit.prntBuf, " Received Unexpected Event \n"));
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccIgnoreEvent
 *
 *      Desc:  Handle Events which could be ignored
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PUBLIC  S16 ccIgnoreEvent
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDBGP(DBGMASK_CC, (ccInit.prntBuf, " ccIgnoreEvent called \n"));
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE00S00
*
*      Desc:  Connection state function
*             event - Connection Indication
*             state - IDLE
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE00S00
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  S16 sdpRet = RFAILED; /* Bug#38891 */
  const char *fn = __FUNCTION__ ;
  CcConEvnt        *conEvnt = (CcConEvnt*)event;
  CasCctEvent_t    *conIndEvnt = &conEvnt->m.casCctEvnt;
  SiCgPtyCat       *siCpc = NULL;
  TknStrM          *sipCpcStr = NULL;
  SipAcceptContactHdr *sipAcceptContactHdr = NULL;
  U8               cdLen = 0;
  SiCdPtyNum       *cdPtyNum = NULLP;

  noOfCalls++;
  if (ccInit.acnt == TRUE)
  {
#if 1 /* change from local time to UTC in billing */
    SwTimevalGet (&con->callDtlInfo.cm.timevalStart,
		  SW_TIMEVAL_IcConIndRcvd, NULL);
#else
    (Void) SGetDateTime(&con->callDtlInfo.cm.tmIcConIndRcvd);
#endif
    con->callDtlInfo.cm.tckIcConIndRcvd.pres = PRSNT_NODEF;
    (Void) SGetSysTime(&con->callDtlInfo.cm.tckIcConIndRcvd.val);
  }


  cmMemset ((U8 *)&con->carrierSelection, 0, sizeof(TknU8));

  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
  ccCp.sts.totalCalls++;

  if (ccIsSTDigitPresInEvent(con, event, CCE_CONIND))
    con->STDigitRecd = TRUE;

  /* Feature 2290 - KPN ALS70 POTs (CAS) support */
  if((con->icProtType == CC_CS_LN) &&
        (conIndEvnt != NULLP) &&
        (conIndEvnt->als70KPNinfo.pres == PRSNT_NODEF))
  {
      /* populate the ic portion of the ALS70 KPN info */
      con->als70KPNinfo |= (conIndEvnt->als70KPNinfo.val & ALS70_IC_MASK);
  }
  /* BUG84531 init con->icCauseIwType */
  if ((con->icIntfcCb != NULL) && (con->icIntfcCb->ccTgCb) && 
        (con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr))
  {
    con->icCauseIwType = con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr->causeIwProc;
  }
  else
  {
    con->icCauseIwType = LCC_SIP_IW_PROC_RFC3398;
  }
  
  /* NOTE: For CAS we do the copying of CdPrtyNmb into CollectAddrInfo only
   * after receiving addrCfm in ccConE35S34() */
  if ((con->icProtType != CC_CS_LN) &&
      (con->icProtType != CC_CS_TG) &&
      (con->icProtType != CC_MGCP_LN) &&
      (con->icProtType != CC_MGCP_TG) &&
      (con->icProtType != CC_GR303)) 
  {
    /* Populating the Called Party Address in the collected Address field */
    if (ccCopyCdPty2ClAddr(con) !=ROK)
    {
      CCDP(AIN_DBG_LEVEL_0," Populating the Called Party Address failed\n");
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      ccCp.sts.fRoutUnavail++;
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL, NULL);
      RETVALUE(RFAILED);
    }
  }

  /* FID 15174.0 */ /*FID 16696.0 ignore minDigits setting if overlapToEnbloc = TRUE*/
  if((!ccGenPrfl.overlapToEnbloc) && 
     (con->icIntfcCb) &&
     (con->icIntfcCb->overlapCfg.minDigits >0) &&
     (CC_IS_SIP_ICOVERLAP(con) || CC_IS_SIPT_ICOVERLAP(con)))
  {
    if(icProtType == CC_SIP)
    {
      cdPtyNum = &(con->ccEvntHold->m.ccConEvnt.m.sipConEvnt.cdPtyNum);
    }
    else if (icProtType == CC_SIPT)
    {
      cdPtyNum = &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum);
    }
    cdLen = CC_FIND_NMB_DIGITS(cdPtyNum);
    if(cdLen < con->icIntfcCb->overlapCfg.minDigits)
    {
      CCDP(AIN_DBG_LEVEL_0,"cdLen=%d, minDigits=%d, release SIP/SIPT with cause 28\n",
           cdLen, con->icIntfcCb->overlapCfg.minDigits);
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCADDRINCOMP, NULL);
      RETVALUE(ROK);
    }
  }
  
  /* Place SIP CPC tag check here */
 
  /* Initialize the icBcm field in the CcConCb */
  ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->icBcm.cc),
                 (Size) sizeof(AinCallConfig_t));
  if (ret != ROK)
  {
    ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
               LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
    RETVALUE(RFAILED);
  }
  cmMemset((U8 *) (con->icBcm.cc), 0, sizeof(AinCallConfig_t));

  /* Allocate transId  */
  con->icBcm.svcHeader.transId = ccGetNewtransId();
  CCDP(AIN_DBG_LEVEL_0," TransId= %ld\n", con->icBcm.svcHeader.transId);

  ret = ccFillBCMInfo(con, &(con->icBcm), con->icBcm.svcHeader.transId,
                      CiOriginatingSetup, PicONull, BtOBcm,
                      DP_ORIGINATION_ATTEMPT);
  con->icBcm.cc->legId01 = & (con->icBcm);

  /* Insert in icBCM Hash table */
  ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(con->icBcm),
                         (U8 *)&(con->icBcm.svcHeader.transId),
                         (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCDP(AIN_DBG_LEVEL_3," ccicBCMInsTbl Insertion failed\n");
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULL);
    RETVALUE(RFAILED);
  }

  if (icProtType == CC_SIP)
  {
    /* Copy the caller ID for billing */
    ccExtractSipCallId(con, &con->ccEvntHold->m.ccConEvnt.m.sipConEvnt);
    /* FID 15445.3 populate sipRoamingFlag from SipConEvnt*/
    con->callDtlInfo.cm.sipRoamingFlag = 
        con->ccEvntHold->m.ccConEvnt.m.sipConEvnt.sipRoamingFlag;
    CCDP(AIN_DBG_LEVEL_0, "%s(): sipRoamingFlag:%d\n", __FUNCTION__,
        con->callDtlInfo.cm.sipRoamingFlag);
  }
  else if (icProtType == CC_SIPT)
  {
    ccExtractSiptCallId(con, &con->ccEvntHold->m.ccConEvnt.m.siConEvnt);
    /* FID 15445.3 populate sipRoamingFlag from SiConEvnt*/
    con->callDtlInfo.cm.sipRoamingFlag = 
        con->ccEvntHold->m.ccConEvnt.m.siConEvnt.optElmnt.sipt.sipRoamingFlag;
    CCDP(AIN_DBG_LEVEL_0, "%s(): sipRoamingFlag:%d\n", __FUNCTION__,
        con->callDtlInfo.cm.sipRoamingFlag);
  }
      /* bug:46451 - see what's in icRsc */
  if (icProtType == CC_SIP || icProtType == CC_SIPT)
  {
      CCDP(AIN_DBG_LEVEL_0, "%s - icRsc-intfcType:SIP, icProtType:%d, "
           "sipDesc.tgId:0x%x, sipDesc.ipAddr:%s\n", fn, icProtType,
           (int)con->icRsc.intfc.t.sipDesc.tgrpId,
           ip_ntoa(&con->icRsc.intfc.t.sipDesc.ipAddr));
  }

  /* FID 15319.0 */
  if (icProtType == CC_EXT_BICC)
  {
      ccCp.sts.totalInExtBicc++;

      BiccApmUserInfo apmUserInfo;
      BiccApmEncData *appInfo = &apmUserInfo.data;
      SiAccTrnspt   *accTrnspt   = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.accTrnspt;
      SiUsrTSrvInfo *usrTSrvInfo = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.usrTSrvInfo;
      SiAppTrans * appTrans = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.appTransParam;
      U8 cause = CCTMPFAIL;

      if (accTrnspt->eh.pres)
      { 
         /* Translate the ccEvntHold.SiConEvnt.SiAccTrnspt and save it
          * in ccEvntHold.SiConEvnt.SiUsrTSrvInfo. 
          */
          U8 i = 0;
          ret = ccDecATP (accTrnspt, (ElmtHdr *)usrTSrvInfo, &meHlComp, &i, TRUE);
      }

      /* Allocate incoming extBicc block */
      ret = ccAllocExtBiccCb(&con->icExtBiccCb);
      if (ret == ROK) 
      {
          ret = ccDecodeAndCheckAppInfo(&apmUserInfo, appTrans, &cause);
          if (ret == ROK)
          {
              U8 idx = 0;
              U8 cdcIdx;                                  
              U8 *tgtCdcIdx = con->icExtBiccCb->tgtCdcIdx;
              U8 tgtCdcTypeFlag;
              U8 tgtCdcTypeFlag1 = 0;
              U8 tgtCdcTypeFlag2 = 0;
              U8 sdpPrflId = con->icIntfcCb->sdpPrflId;
              CcSdpCb *sdpCb = NULLP;

              if((appInfo->actInd.pres == NOTPRSNT) ||
                (appInfo->actInd.val != AI_CONFWD)) 
              {
                  CCDP(AIN_DBG_LEVEL_0, "%s, Action Indicator not valid\n", __FUNCTION__);
                  cause = CCPROTERR;
                  ret = RFAILED;
              }
              if(appInfo->bCntrlTun.pres == NOTPRSNT)
              {
                  CCDP(AIN_DBG_LEVEL_0, "%s, Bearer Control Tunneling not present\n", __FUNCTION__);
                  cause = CCPROTERR;
                  ret = RFAILED;
              }

              /* tgtCdcTypeFlag1: from PRFL-SDP configuration */
              if(CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb))
              {
                  CC_SET_CT_FLAG(tgtCdcTypeFlag1, CC_G711_64_M_FLAG);
              }
              else
              {
                  cmHashListFind(&ccSdpTbl, (U8 *)&sdpPrflId, (U16)sizeof(U8), (U16)0, (PTR *)&sdpCb);
                  if(sdpCb != NULLP)
                  {
                      for(cdcIdx=0; cdcIdx<sdpCb->sdpAtt.NumCodec; cdcIdx++)
                      {
                          switch(sdpCb->sdpAtt.CodecTypes[cdcIdx])
                          {
                              case SDP_CODEC_PCMA:
                                  CC_SET_CT_FLAG(tgtCdcTypeFlag1, CC_G711_64_A_FLAG);
                                  break;
                              case SDP_CODEC_AMR:
                                  CC_SET_CT_FLAG(tgtCdcTypeFlag1, CC_UMTS_AMR2_FLAG);
                                  break;
                              default:
                                  break;
                          }
                      }
                  }
                  else
                  {
                      CCDP(AIN_DBG_LEVEL_0, "%s, sdpCb does not exists\n", __FUNCTION__);
                      cause = CCRESCUNAVAIL;
                      ret = RFAILED;
                  }
              }

              if((appInfo->cdcLst.pres != NOTPRSNT) && (appInfo->cdcLst.numCdcs))
              {
                  /* tgtCdcTypeFlag2: from ATP parameter in IAM message */
                  for(cdcIdx=0; cdcIdx<appInfo->cdcLst.numCdcs; cdcIdx++)
                  {
                      if(CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb))
                      {
                          if(appInfo->cdcLst.cdc[cdcIdx].orgId == OI_ITU_T &&
                             appInfo->cdcLst.cdc[cdcIdx].cdcInfo.cdcType == CT_G711_64K_M)
                          {
                              CC_SET_CT_FLAG(tgtCdcTypeFlag2, CC_G711_64_M_FLAG);
                              tgtCdcIdx[idx++] = cdcIdx;
                              break;
                          }
                      }
                      else
                      {
                          if(appInfo->cdcLst.cdc[cdcIdx].orgId == OI_ITU_T &&
                             appInfo->cdcLst.cdc[cdcIdx].cdcInfo.cdcType == CT_G711_64K_A)     
                          {
                              CC_SET_CT_FLAG(tgtCdcTypeFlag2, CC_G711_64_A_FLAG);
                              tgtCdcIdx[idx++] = cdcIdx;
                          }
                          else if(appInfo->cdcLst.cdc[cdcIdx].orgId == OI_ETSI &&
                                  appInfo->cdcLst.cdc[cdcIdx].cdcInfo.cdcType == CTE_UMTS_AMR2)
                          {
                              CC_SET_CT_FLAG(tgtCdcTypeFlag2, CC_UMTS_AMR2_FLAG);
                              tgtCdcIdx[idx++] = cdcIdx;
                          }
                      }
                  }

                  /* by default use PCMA if no target codec configured in PRFL-SDP */
                  if(tgtCdcTypeFlag1 == 0)
                  {
                      CC_SET_CT_FLAG(tgtCdcTypeFlag1, CC_G711_64_A_FLAG);
                  }

                  /* build tgtCdcTypeFlag and save it */
                  tgtCdcTypeFlag = tgtCdcTypeFlag1 & tgtCdcTypeFlag2;
                  con->icExtBiccCb->tgtCdcTypeFlag = tgtCdcTypeFlag;
                  if(tgtCdcTypeFlag == 0)
                  {
                      CCDP(AIN_DBG_LEVEL_0, "%s, no codec supported in codec list\n", __FUNCTION__);
                      cause = CCRESCUNAVAIL;
                      ret = RFAILED;
                  }
                  /* fax call only supports PCMA */
                  else if (usrTSrvInfo->highLyr.pres == PRSNT_NODEF &&
                           usrTSrvInfo->highLyr.val == HLCI_FAXG4)
                  {
                      if (CC_IS_CT_FLAG_SET(tgtCdcTypeFlag, CC_G711_64_A_FLAG) != 0)
                      {
                          CC_CLR_CT_FLAG(tgtCdcTypeFlag, CC_UMTS_AMR2_FLAG);
                      }
                      else
                      {
                          CCDP(AIN_DBG_LEVEL_0, "%s, no PCMA in codec list for fax call\n", __FUNCTION__);
                          cause = CCRESCUNAVAIL;
                          ret = RFAILED;
                      }
                  }
              }
              else
              {
                  if(tgtCdcTypeFlag1 == 0)
                  {
                      CC_SET_CT_FLAG(con->icExtBiccCb->tgtCdcTypeFlag, CC_G711_64_A_FLAG);
                      appInfo->cdcLst.cdc[0].orgId = OI_ITU_T;
                      appInfo->cdcLst.cdc[0].cdcInfo.cdcType = CT_G711_64K_A;
                      tgtCdcIdx[0] = 0;
                  }
                  else
                  {
                      CCDP(AIN_DBG_LEVEL_0, "%s, no codec list\n", __FUNCTION__);
                      cause = CCRESCUNAVAIL;
                      ret = RFAILED;
                  }
              }
          }
      }

      if ( ret != ROK )
      {
          CCLOGERR("%s, Failed to setup incoming ExtBICC call cause=%d\n", __FUNCTION__,cause);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, cause, NULL);
          RETVALUE(RFAILED);
      }        

      /* Save the BiccApmUserInfo */
      cmMemcpy((U8*)&con->icExtBiccCb->apmUsrInfoHdr, (U8*)&apmUserInfo.hdr, sizeof(BiccApmEncHdr));

      ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->icExtBiccCb->apmUsrInfoData),
                    (Size) sizeof(BiccApmEncData));
      if (ret != ROK)
      {                                                                                        
         ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                    LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
         RETVALUE(RFAILED);
      }
      cmMemcpy((U8*)con->icExtBiccCb->apmUsrInfoData, (U8*)appInfo, sizeof(BiccApmEncData));

      /* codec filling will be done later function before sending apm */

      if((apmUserInfo.data.bCntrlTun.pres  != NOTPRSNT) && 
         (apmUserInfo.data.bCntrlInfo.pres != NOTPRSNT) && 
         (strlen(apmUserInfo.data.bCntrlInfo.data)) )
      {
          /* IPBCP exists, setup up fast forward flavor */
          CC_SET_EXTBICC_FLAVOR(con, CC_INCOMING, CC_BICC_FLAVOR_FAST_FWD);
      }
      else
      {
          /* delay forward */
          CC_SET_EXTBICC_FLAVOR(con, CC_INCOMING, CC_BICC_FLAVOR_DELAYED_FWD);
      }

      if ( con->icIntfcCb && con->icIntfcCb->ccTgCb->tgAtt.ConnNotifyReq )
      {
          /* setup the reqNotify flag from tkgrp for later usage */
          CC_SET_EXTBICC_NOTIFY(con, CC_INCOMING, TRUE);
      }

      CC_SET_EXTBICC_BEARERSTATE(con, CC_INCOMING, CC_BICC_STATE_RCVD_CONFWD);
  } /* End of FID 15319.0 */

  /* FID 14890*/
  if (icProtType == CC_SIP)
  {
      sipCpcStr = &(((CcConEvnt *)event)->m.sipConEvnt.sipCpcStr);
      sipAcceptContactHdr = &(((CcConEvnt *)event)->m.sipConEvnt.sipAcceptContactHdr);
      siCpc= &(((CcConEvnt *)event)->m.sipConEvnt.cgPtyCat);
      CCDP(AIN_DBG_LEVEL_2, "sipCpcStr->(pres:%d,len:%d,val:%s), "
           "sipAcceptContactHdr->eh.pres=%d, acceptLangStr->(pres:%d,len:%d,val:%s)\n", 
           sipCpcStr->pres, sipCpcStr->len, sipCpcStr->val,
           sipAcceptContactHdr->eh.pres,
           sipAcceptContactHdr->acceptLangStr.pres,
           sipAcceptContactHdr->acceptLangStr.len,
           sipAcceptContactHdr->acceptLangStr.val);
      if (sipCpcStr->pres == PRSNT_NODEF)
      {
          ccMapSIP2SICpc(sipCpcStr, sipAcceptContactHdr, siCpc, con);
          cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.sipConEvnt.cgPtyCat), 
                   (U8*) siCpc, sizeof(SiCgPtyCat));
      }
      /*bug 90587*/
      con->sameDigits = ccIsFromValsametoPAI(&(((CcConEvnt *)event)->m.sipConEvnt));
  }
  else if ((icProtType == CC_SI) || (icProtType == CC_EXT_BICC)) /* FID 15319.0 */
  {
      siCpc= &(((CcConEvnt *)event)->m.siConEvnt.cgPtyCat);
      sipCpcStr = &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.isup.sipCpcStr);
      sipAcceptContactHdr = &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.isup.sipAcceptContactHdr);
      ccMapSI2SIPCpc(siCpc, sipCpcStr, sipAcceptContactHdr);
      cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.optElmnt.isup.sipCpcStr),
               (U8*) sipCpcStr, sizeof(TknStrM));
      cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.optElmnt.isup.sipAcceptContactHdr), (U8*) sipAcceptContactHdr, sizeof(SipAcceptContactHdr));
  }
  else if (icProtType == CC_SIPT)
  {
      siCpc= &(((CcConEvnt *)event)->m.siConEvnt.cgPtyCat);
      sipCpcStr = &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sipCpcStr);
      sipAcceptContactHdr = &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sipAcceptContactHdr);
      
      CCDP(AIN_DBG_LEVEL_2, "siCpc->eh.pres=%d,val=%d\n", siCpc->eh.pres, 
           siCpc->cgPtyCat.val);
      CCDP(AIN_DBG_LEVEL_2, "sipCpcStr->(pres:%d,len:%d,val:%s), "
           "sipAcceptContactHdr->eh.pres=%d, acceptLangStr->(pres:%d,len:%d,val:%s)\n", 
           sipCpcStr->pres, sipCpcStr->len, sipCpcStr->val,
           sipAcceptContactHdr->eh.pres,
           sipAcceptContactHdr->acceptLangStr.pres,
           sipAcceptContactHdr->acceptLangStr.len,
           sipAcceptContactHdr->acceptLangStr.val);

      if ((siCpc->eh.pres == PRSNT_NODEF) &&
          (sipCpcStr->pres != PRSNT_NODEF))
      {
          ccMapSI2SIPCpc(siCpc, sipCpcStr, sipAcceptContactHdr);
          cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.optElmnt.sipt.sipCpcStr), (U8*) sipCpcStr, sizeof(TknStrM));
          cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.optElmnt.sipt.sipAcceptContactHdr), (U8*) sipAcceptContactHdr, sizeof(SipAcceptContactHdr));
      }
      else if ((sipCpcStr->pres == PRSNT_NODEF) &&
               (siCpc->eh.pres != PRSNT_NODEF))
      {
          ccMapSIP2SICpc(sipCpcStr, sipAcceptContactHdr, siCpc, con);
          cmMemcpy((U8*) &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cgPtyCat), 
                   (U8*) siCpc, sizeof(SiCgPtyCat));
      }
  }

 /* FID 14732 */
 ccExtractSipwMBufFromConIndAndConCfm(con, CCE_CONIND, (PTR) event);
 /* FID 14732 */

 /* FID 14419.0 */
 ccExtractSpecialCallFromConInd(con, icProtType, (CcConEvnt *) event);

 /* FID 14457.0 + */
 if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
 {
   ccUpdGetsSts(con->icProtType, CC_INCOMING);
 } /* FID 14457.0 - */

  /*FID 15317.0 P-Early-Media Support */
  /*FID 15317.2 */
   if ((icProtType == CC_SIP) &&
      (((CcConEvnt *)event)->m.sipConEvnt.pEarlyMedia.cnt))
  {
   	if ((((CcConEvnt *)event)->m.sipConEvnt.pEarlyMedia.params[0])==SIP_PEM_SUPPORTED)
   	{
      		CCT_SET_SIP_PEM_MASK(con->icSipMethodSupMask);
      		CCDP(AIN_DBG_LEVEL_2, "%s, Rx pEarlyMedia=%d\n",
          	                   __FUNCTION__, (((CcConEvnt *)event)->m.sipConEvnt.pEarlyMedia.params[0]));
   	}
  }

  /*end FID 15317.0 P-Early-Media Support */
 
  switch (icProtType)
  {
      case CC_BICC:
          sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                             &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.bicc.sdp));
          ccRegisterIngressInterCcsCall(con);
          if (CC_INGRESS_INTER_CCS_CALL(con))
          {
#if 0 /* 47058: remove this */
            ccCp.sts.totalCalls--;
#endif
#if 0
            if (ccUnPkBillingInfoForInterCcsCall(con, ccCp.genCfg.ownCcsId, event) 
                != ROK)
#else
            if (ccUnPkFwdCallSetupInfoForInterCcsCall(con, ccCp.genCfg.ownCcsId, event) 
                != ROK)
#endif
            {
              CCLOGERR("Error: ccUnPkFwdCallSetupInfoForInterCcsCall failed\n");
              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                           con->icProtType, CCTMPFAIL, NULL);
              RETVALUE(RFAILED);
            }
            if (con->icIntfcCb) 
            con->icIntfcCb->sts.numIcCallAttempt++;

            /* FID 17167.0 trigger TL1 event for call trace */
            cmSendProcId4CallTraceEvent(&con->callTrcId);

            /* FID 16942.0 validate mode-change-period after icIntfcCb is available */
            /* FID 17066.0 call ccProcessSRTP here too */
            if((ccValidateAMRAttr(con, con->icIpParam.rmtDesc) == RFAILED) ||
               (ccProcessSRTP(&con->icBcm, con->icIpParam.rmtDesc) != ROK))
            {
              CCLOGERR("%s:SDP Error: Remote SDP can't meet period setting/or SRTP setting\n", __FUNCTION__);
              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                           con->icProtType, CCTMPFAIL, NULL);
              RETVALUE(RFAILED);
            }

            /* FID 14419.0 release inter-ccs BICC calls under CC_CONGESTION here */
            if (CC_CONGESTION)
            {
              /* FID 14457.2 */
              Bool relPrioCall = FALSE;
              Bool relNrmCall = FALSE;

              if (CC_CONGESTION_LEVEL4)
              {
                if (con->specialCall)
                {
                  if (ccCp.getsEnabled && IS_THIS_CALL_GETS(con))
                  {
                    ccCp.getsSts.nsepLimitExceeded++;
                    ccCp.sts.totalGetsRejOvldRx++;
                  }
                  else
                    ccCp.sts.totalPrioRejOvldRx++;

                  ccCongCb.ccDqExtCngCb.prioCallsDroppedSoFar++; /* FID 14457.2 */
                  relPrioCall = TRUE;

                }
                else
                {
                  ccCp.sts.totalNormRejOvldRx++;

                  ccCongCb.ccDqExtCngCb.nrmCallsDroppedSoFar++; /* FID 14457.2 */
                  relNrmCall = TRUE;
                }

                ccCongCb.ccDqExtCngCb.currBlockCnt++;
                ccCongCb.ccDqExtCngCb.currAttemptCnt++;
              }
              else
              {
                /* We come here for Congestion Level1 thru' Level3  */
                if (!(con->specialCall))
                {
                   if ((!ccCongCb.ccDqExtCngCb.currBlockCnt && !ccCongCb.ccDqExtCngCb.currAttemptCnt) ||
                       (((ccCongCb.ccDqExtCngCb.currBlockCnt * 100)/ccCongCb.ccDqExtCngCb.currAttemptCnt) <=
                          ccDmndQCong_V2.callReleasePct[GET_GCC_ACTN_CONG_LEVEL]))
                   {
                     /* Release Normal Calls */
                     ccCp.sts.totalNormRejOvldRx++;
                     ccCongCb.ccDqExtCngCb.nrmCallsDroppedSoFar++; /* FID 14457.2 */

                     ccCongCb.ccDqExtCngCb.currBlockCnt++;
                     relNrmCall = TRUE;
                   }
                   ccCongCb.ccDqExtCngCb.currAttemptCnt++;
                }
              }

              if (relPrioCall || relNrmCall)
              {
                 ccStopConTmr(con, TMR_SETUP);
                 ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
                 CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
                 ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCSWTCHCONG, NULL);

                 /* + FID 14457.2 */
                 if (relPrioCall && !(ccCongCb.ccDqExtCngCb.prioCallsDroppedSoFar%100))
                 {
                   DP("%s():  In GCC CongLevel %d, released %ld PRIORITY calls so far\n",
                      __FUNCTION__, GET_GCC_ACTN_CONG_LEVEL, 
                      ccCongCb.ccDqExtCngCb.prioCallsDroppedSoFar);
                 }
                 else if (relNrmCall && !(ccCongCb.ccDqExtCngCb.nrmCallsDroppedSoFar%1000))
                 {
                   DP("%s():  In GCC CongLevel %d, released %ld NORMAL calls so far\n",
                      __FUNCTION__, GET_GCC_ACTN_CONG_LEVEL, 
                      ccCongCb.ccDqExtCngCb.nrmCallsDroppedSoFar);
                 }
                 /* - FID 14457.2 */

                 RETVALUE(RFAILED);
              }
            } /* CC_CONGESTION */
          }

          /*
           * Bug 55261 copy the typeOfXchg from incoming CCS to outgoing CCS
           */
          if(con->direction == INCTOOUT)
          {
              con->typeOfXchg = ((CcConEvnt *)event)->m.siConEvnt.optElmnt.bicc.typeOfXchg.val;
          } /* End of bug 55261 */

          /* BUG: 71409: Removed code to default con->icSipMethodSupMask */
          break;
      case CC_SIPT:
          sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                           &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sdp));
          /* FID-2112 */
          ccExtractSipMethodSupport(con, INCTOOUT,
             ((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.headerSupportMask);
          /*ESC21662*/
          if (((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.charging.icidValue.pres == PRSNT_NODEF)
          {
              CCDP(AIN_DBG_LEVEL_1, "ccExtractPChargingVectorFromConEvent: %s\n",
                        ((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.charging.icidValue.icidValue);

              cmMemcpy((U8 *)&con->callDtlInfo.cm.chargingIcidValue,
                 (U8*)&((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.charging.icidValue,
                 sizeof(SipIcidValue));
           }
          /*ESC21662*/
          break; 
      case CC_SIP:
          sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                                     &(((CcConEvnt *)event)->m.sipConEvnt.sdp));
          /* Extract p-charging-vector */
          ccExtractPChargingVectorFromConEvent(con, 
                                &con->ccEvntHold->m.ccConEvnt.m.sipConEvnt);
          /* FID 14382.4 */
          ccExtractSipAccessNetInfo(con, &con->ccEvntHold->m.ccConEvnt.m.sipConEvnt);
          /* FID-2112 */
          ccExtractSipMethodSupport(con, INCTOOUT,
                    ((CcConEvnt *)event)->m.sipConEvnt.headerSupportMask);

          break;
      default:
           sdpRet = ROK;
           break;
  }

      /* Bug 38891+*/
      if (sdpRet != ROK)
      {
        CCLOGERR("Error: SDP parsing failed - %d\n", sdpRet);
        /* It's Ideal to call ccProcessFailCond(). Since the Ingress Resource
           is not allocated we can't call that function. If that becomes a 
           requiement to process failure condition, we need to move
           this ccExtractProtSdp to E09S01 and process failure condition.
           For now let's release the call with relCause */
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                           con->icProtType, CCBCAPNOTIMP, NULL);
        RETVALUE(ROK);
      }
      /* Bug 38891-*/

      /* Bug# 51782 , Bug# 64990 - Changes to process IAM echo bit on Egress CCS */
      if (((icProtType == CC_SI) || (icProtType == CC_SIPT) || 
           (icProtType == CC_BICC)) && (con->ccEvntHold != NULLP))
      {                
        /* Set the global flag for interworkingInd field of FwdCallInd*/
        CC_SET_IAM_ECHO_IND(con);
      }

  if ((icProtType == CC_SI) || (icProtType == CC_BICC))
  {
          /* Bug 32680 - This is based on International Requirments, if the call is a CUG call
           * then Release the call with Release Cause = "92 Non_exisitent CUG"
           *
           * Therefore check if the siCugEvent is present in the ConEvnt. If so, 
           * Release the call
           * 
           * Changes made for International, RV Suresh. 5.0 
           */
      if ((con->ccEvntHold != NULLP) && (ccIsCUGCallForTelstra(con, event)))
      {
          CCDP(AIN_DBG_LEVEL_0," CUG Call Not Supported \n");
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCUGNOTEXIST, NULL);
          RETVALUE(RFAILED);
      }
  }

  ccGeoExtractProtCri(con, (CcAllSdus *)event, CCE_CONIND);
  /* BUG: 91793 + */
  if ((icProtType == CC_BICC) && 
      (con->criInfo) && (con->criInfo->ic) && (con->criInfo->ic->l3Cri.count))
  {
     /* L3 CRI Received over BICC from SIP/SIPT */
     CC_SET_CALL_FLAG2(con, CC_FLAG_L3CRI_RECV_BICC);
  }
  /* BUG: 91793 - */

  ccExtractCallReferenceForIAM (con, event);
  /* FID 17328.0 */
  if ((con->icProtType == CC_INETSI) && 
	  (con->icIntfcCb) && (con->icIntfcCb->cfIwProc == CFX_TS183036))
  {
     ccExtractCallFowardInfoFromDivertingLeg2(con, event);
  }
  ccExtractInfoFromConEvent(con, event);

  /* FID-2112 + */
  if (((icProtType == CC_SIP) ||
       (icProtType == CC_SIPT) ||
       (icProtType == CC_BICC)) &&
     !(con->icIpParam.rmtDesc))
  {
    /* FID-2575: LMSD + */
    /* For now, set the method == CC_OFFANS_TYPE_REL18X_INVITENOSDP.
     * If we send 18X as reliable before 200 OK, we will change it later.
     */
    CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_OFFERPENDING, CC_OFFANS_STATE_NO_OP,
                           CC_OFFANS_SUBSTATE_AWAITRMTANS_INVITENOSDP,
                           CC_OFFANS_TYPE_200OKINVITE);
    CC_SET_CALL_FLAG(con->flag, CC_FLAG_IP_CALL_NO_INITIAL_SDP); /*BUG:86958*/
  }
  else if (con->icIpParam.rmtDesc)
  {
    CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_RCVDOFFER, CC_OFFANS_STATE_NO_OP,
                           CC_OFFANS_SUBSTATE_NULL,
                           CC_OFFANS_TYPE_INVITE);
    /* FID-2575: LMSD - */
  }
  /* FID-2112 - */
  
  /* FID-14700.0 -- */
   if( ccPopulateCcCpuId(con)== FALSE )   
   {   
      CCDP(AIN_DBG_LEVEL_2, "FID 14700.0: populate CM-CPU IDs failed\n");   
   }   
   else   
   {   
      CCDP(AIN_DBG_LEVEL_2, "FID 14700.0: Ingress:(pres-%d, CM-%d-CPU-%d),Egress:(pres-%d, CM-%d-CPU-%d)\n",   
                           con->callDtlInfo.cm.ingressProcessorId.pres,   
                           con->callDtlInfo.cm.ingressProcessorId.iomId,    
                           con->callDtlInfo.cm.ingressProcessorId.cpuId,   
                           con->callDtlInfo.cm.egressProcessorId.pres,   
                           con->callDtlInfo.cm.egressProcessorId.iomId,   
                           con->callDtlInfo.cm.egressProcessorId.cpuId);   
    }   
  /* FID-14700.0 ++ */
#if 0
  /* Check if CgPN is present and take the appropriate action */
  switch (ccGetConIndCgPNAction(con))
  {
    case RFAILED:
      CCDP(AIN_DBG_LEVEL_0," Calling Number Not Present For G500 call\n");
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
               con->icProtType,CCCALLRJT, NULL);
      RETVALUE(RFAILED);
      
    case ROKDNA:
      /* request infoReq and goes to the AWAITING INFO state */
      ccSendInfoRequest(con);
      CC_STATE_CHANGE(con, CCS_AWTINFO);
      RETVALUE(ROK);
      
    default:
      /* ROK - proceed normally with the call */
      break;
  }
#endif


  if ((CC_GET_PROTOCOL(con->icProtType) == CC_SIP)||
      (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT))
  {
    /* Note: we are not covering BICC here */
    /* This is intentional, reason: */
    /* For SIP -> XXX inter-CCS Call */
    /* If the BGW is not inserted at the ingress CCS, but in the egress CCS */
    /* Then the MG media CAC would be done at egress CCS */
    /* 14732.0 would pass the ingress realm (as a result of realm-mapaddr) */ 
    /* from ingress CCS to egress CCS through BICC */
    /* That's why we do not handle SDP in BICC here */

    ccFindMgMapAddr (con->icIpParam.rmtDesc, con);
  }

  if ((!con->callDtlInfo.cm.ingressRealmId) && 
      (!CC_INGRESS_INTER_CCS_CALL(con)) &&         /* not to do this on Egress CCS */
      (con->icIntfcCb != NULLP) &&
      (con->icIntfcCb->ccTgCb != NULLP) &&
      (con->icIntfcCb->ccTgCb->tgAtt.realmId))
  {
    con->callDtlInfo.cm.ingressRealmId = con->icIntfcCb->ccTgCb->tgAtt.realmId;
  }

  /* Bug# 84799 - Populate icBcm ipVersion for handling any error or treatment scenaros */
  if ((CC_GET_PROTOCOL(con->icProtType) == CC_SIP)||
      (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)||
      (CC_INGRESS_INTER_CCS_CALL(con) && (CC_GET_PROTOCOL(con->icProtType) == CC_BICC)))
  {
    CCDP(AIN_DBG_LEVEL_2,"icProtType %d\n", (CC_GET_PROTOCOL(con->icProtType)));
    ccFillicBcmIpVersion(&con->icBcm);

    /* FID15068.0 Identify it's pre-condition call and initialize it */
    if (ccPrecndConfigOff(con->icIntfcCb, con->icProtType))
    {
       /* continue the call without pre-condition */
      CCDP(AIN_DBG_LEVEL_2,"%s sipPreconds OFF \n", __FUNCTION__);
    }
    else if(ccPrecndConfigOn(con->icIntfcCb, con->icProtType))
    { 
      S16  retPrecnd = ROK;
      Sdp *rmtSdp = NULLP;
      CC_LOCATE_RMT_SDP(con, rmtSdp);

      CCDP(AIN_DBG_LEVEL_2,"icSipMethodSupMask 0x%lx \n", con->icSipMethodSupMask);

      /* BICC's icSipMethodSupMask will need from ingress-ccs ???? */
      if ((CCT_IS_PRECOND_SUPPORTED(con->icSipMethodSupMask)) && (CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask)) &&
          (CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask)) &&
          (sdpRet == ROK))
      {

        if (ccIsSdpPrecndPres(rmtSdp))
        {
          /* Allocate precndCb and initialize it */
          ccAllocateIcPrecndCb(con);
          ccExtractPrecnd(con->icPrecndCb, rmtSdp, TRUE);
         
          if (CC_GET_PROTOCOL(con->icProtType) != CC_BICC)
          {
            retPrecnd = ccValidaPrecndForInvite(con, con->icPrecndCb);
            if (retPrecnd != ROK)
            {
              /* release the call as its precnd attributes not meet requirement */
              CCLOGERR("Release call due to SDP precondition attr validation failure icSu=%ld\n", con->icSuConnId);
              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                             con->icProtType, CCPRECONDFAIL, NULL);

              RETVALUE(ROK);
            }

          retPrecnd = ccValidatePrecnd(con, con->icPrecndCb, rmtSdp);
          if (retPrecnd != ROK)
          {
            /* release the call as its precnd attributes not meet requirement */
            CCLOGERR("Release call due to SDP precondition attr validation failure icSu=%ld\n", con->icSuConnId);
            ccStopConTmr(con, TMR_SETUP);
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                           con->icProtType, CCPRECONDFAIL, NULL);

            RETVALUE(ROK);
          }
          }

          /* Mark it is pre-condition call */
          CC_SET_CALL_FLAG2(con, CC_FLAG_PRECONDITION);

        }
        else if ((CCT_IS_PRECOND_REQUIRED(con->icSipMethodSupMask)) && (rmtSdp) && (rmtSdp->eh.pres == PRSNT_NODEF))
        {
          /* release the call as its precnd attributes not meet requirement */
          CCLOGERR("Release call due to SDP precondition not present but require precondition icSu=%ld\n", con->icSuConnId);
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, CCPRECONDFAIL, NULL);
          RETVALUE(ROK);
        }
        else if ((!rmtSdp) || (rmtSdp->eh.pres != PRSNT_NODEF))
        {
          ccAllocateIcPrecndCb(con);
          /* Mark it is pre-condition call for Initial INVITE without SDP case*/
          CC_SET_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
          CCDP(AIN_DBG_LEVEL_2,"Initial INVITE does not carry SDP, set precondition icSipMethodSupMask 0x%lx flag2 0x%lx\n", 
               con->icSipMethodSupMask, con->flag2);
        }
      }
      else if (CCT_IS_PRECOND_REQUIRED(con->icSipMethodSupMask) &&
               (!(CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask)) ||
                !(CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask))))
      {
          /* release the call as its precnd attributes not meet requirement */
          CCLOGERR("Release call due to SDP precondition not present but require precondition icSu=%ld\n", con->icSuConnId);
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCPRECONDFAIL, NULL);
          RETVALUE(ROK);
      }
      else if (CCT_IS_PRECOND_SUPPORTED(con->icSipMethodSupMask))
      {
#if 0
        /* with precondition header but no precondition attr */
        if ((rmtSdp) && (rmtSdp->eh.pres == PRSNT_NODEF) && !ccIsSdpPrecndPres(rmtSdp))
        {
          /* release the call as its precnd attributes not meet requirement */
          CCLOGERR("Release call due to SDP precondition attr validation failure icSu=%ld\n", con->icSuConnId);
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCPRECONDFAIL, NULL);
          RETVALUE(ROK);
        }
#endif
      }
      else if (!CCT_IS_PRECOND_SUPPORTED(con->icSipMethodSupMask))
      {
        /* no precondition header but with it in SDP attr */
        if ((ccIsSdpPrecndPres(rmtSdp)) &&
            (!CC_INGRESS_INTER_CCS_CALL(con)))
        {
          /* release the call as its precnd attributes not meet requirement */
          CCLOGERR("Release call due to SDP precondition attr validation failure icSu=%ld\n", con->icSuConnId);
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCPRECONDFAIL, NULL);
          RETVALUE(ROK);
        }
      }
    }
  }

  CCFILLCONTTYPE(con);

  /* Request for alocation/verification of the incoming resource */
  CC_STATE_CHANGE(con, CCS_AWTROUTERSC);
  if ((!CC_IS_PROT_TYPE_G500V0(con->icProtType) && (con->routeInfo->cgCtgy == CC_CAT_TEST)) ||
      (CC_IS_PROT_TYPE_G500V0(con->icProtType) && (con->routeInfo->cgCtgy == CC_CAT_TESTCALL)))
  {
    ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING,
                       RMT_ALOC_TEST_CALL);
  }
  else if (CC_IS_ICA_CALL(con) && (CC_INGRESS_INTER_CCS_CALL(con)))
  {
    /* FID15310.1 ICA calls */

    SvcHeader_t header;
    InfoCollected_t infoCollected;
    int index = 0;
    
    /* Send Info Collected message to FIC and continue normal call processing */
    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

    /* Cleaning up the NEL ??????*/
    for (index = 0; index < EReqMax; index++)
    {
        con->icBcm.nel[index] = NEL_UNARMED;
    }

    /* Fill in parameters in the Service Header Structure */
    ccFillSvcHeader(&header, &(con->icBcm), MSG_Info_Collected);
    CCDP(AIN_DBG_LEVEL_1," Filled SvcHeader\n");

    /* Fill in parameters in the Info Collected Structure */
    ccFillInfoColltdParam(&infoCollected, &(con->icBcm));
    CCDP(AIN_DBG_LEVEL_1," Filled InfoCollected\n");

    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);

    CCDP(AIN_DBG_LEVEL_1,"%s: Sending InfoCollected\n",__FUNCTION__);
    CcUiFctInfoCollected(&infoCollected, &header);

    RETVALUE(ROK);
  }
  else
  {
    ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING, RMT_DONTCARE);
  }
      /* The call to ccChkCallTrc for non-cas calls used to be here. (bug:40864)
         Now its gone into e09s01, because sometimes, the rscAlloc can fail. */
  RETVALUE(ROK);
} /* end ccConE00S00 */

/*
*
*      Fun:   ccConE65S00
*
*      Desc:  Handle FCT MWI Request
*             event - FCT MWI Requests
*             state - IDLE
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE65S00
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTRSCALLOCCFM_MWI);
  ccAllocateResource(con, NULL, CC_INCOMING, RMT_DONTCARE);
  RETVALUE(ROK);
} /* ccConE65S00 */


/*
 *
 *      Fun:   ccConE04S01
 *
 *      Desc:  Connection state function
 *             event - Cct Release Indication 
 *             state - AWTROUTERSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S01
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret   = RFAILED;

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  else if (ret == ROKDRSIG)
  {
    /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect 
             notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n"); 
  }
  else
     /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
     CCDP(AIN_DBG_LEVEL_0, "O_Disconnect event is not Armed\n");

    /* Wait for resource confirmation to clear the call */
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC340, (ErrVal) ret,
                 "ccConE04S01() Failed, ccStoreEvnt failed");
#endif
    con->direction = INCTOOUT;
    con->icEvnt = (CcAllSdus *) event;
    CC_STATE_CHANGE(con, CCS_IDLE);
    if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      RETVALUE(RFAILED);
  }

  con->relPend = INRELRSPANDNOREL;
  CC_STATE_CHANGE(con, CCS_AWTRSCCFM_TOCLR);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S01
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation confirm    
 *             state - AWTROUTERSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S01
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  OriginationAttempt_t   originationAttempt;
  SvcHeader_t            header;
  CcAddrReqEvnt          ccAddrReqEvnt;
  VmsMwiCfm_t            vmsMwiCfm;
  MgctSignalsDescriptor  signalDesc;
  MgctSignalsDescriptor *ptr_signalDesc    = NULLP;
  RmAlocCfmEvnt         *rscEvnt             = NULLP;
  CcConCb               *oldCon              = NULLP;
  CcTgCb                *tgCb                = NULL;
  S16                    ret                 = RFAILED;
  ProtType               icProtType          = CC_GET_PROTOCOL(con->icProtType);
  U8                     index               = 0;
  U8                     val                 = 0;
  Bool                   allowedReattempt    = FALSE;
  const char             *fn                = __FUNCTION__ ;

  rscEvnt = (RmAlocCfmEvnt *) event;

  CCDP(AIN_DBG_LEVEL_0, "ccConE09S01 Result = %d\n", rscEvnt->rscSta1);
  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
    con->icRscVal = TRUE;
    if (con->icRsc.rscPres != NOTPRSNT)
    {
      if ((rscEvnt->rsc1->intfc.intfType == CC_SI_INTFC) || 
#if 0
          (rscEvnt->rsc1->intfc.intfType == CC_BICC_INTFC))
#else
          (rscEvnt->rsc1->intfc.intfType == CC_EXT_BICC_INTFC))
#endif
      {
        /* Get the trunk group, phyDs0 that was filled while validating */
        con->icRsc.intfc.t.tgrpDesc.tgrpId =
             rscEvnt->rsc1->intfc.t.tgrpDesc.tgrpId;
        con->icRsc.t.nbRsc.phyDs0 = rscEvnt->rsc1->t.nbRsc.phyDs0;
        CCDP(AIN_DBG_LEVEL_2, "Calling with resource1 = %d\n",
             rscEvnt->rsc1->intfc.t.tgrpDesc.tgrpId );
      }
      else if (rscEvnt->rsc1->intfc.intfType == CC_IN_INTFC)
      {
        /* Get the phyDs0 that was filled while validating */
        con->icRsc.t.dss1Rsc.phyDs0 = rscEvnt->rsc1->t.dss1Rsc.phyDs0;
      }
      /* BUG90207 */
      else if (rscEvnt->rsc1->intfc.intfType == CC_CS_TG)
      {
        if (con->icRsc.t.csRsc.memberId == 0)
        {
          con->icRsc.t.csRsc.memberId = rscEvnt->rsc1->t.csRsc.memberId;
        }
        if (con->icRsc.t.csRsc.ds0Rsc.term == 0)
        {
          con->icRsc.t.csRsc.ds0Rsc = rscEvnt->rsc1->t.csRsc.ds0Rsc;
        } 
        CCDP(AIN_DBG_LEVEL_2, "resource1 CS_TG memberId = %d term = 0x%llx\n",
             con->icRsc.t.csRsc.memberId,
             con->icRsc.t.csRsc.ds0Rsc.term);
      }
    }

    /* Store trunk group attributes in con */
    if((icProtType == CC_SI) || (icProtType == CC_EXT_BICC) || /* FID 15319.0 */
       (icProtType == CC_CS_TG))
    {
      if (con->icIntfcCb)
         tgCb = con->icIntfcCb->ccTgCb;
      if(tgCb)
      {
        con->icTgAtt = 0;
        CCDP(AIN_DBG_LEVEL_0, "ccConE09S01:OWN:%d,FEC:%d,COS:%d,tgDIR:%d\n",
             tgCb->tgAtt.ownClass, tgCb->tgAtt.Class, tgCb->tgAtt.ClassOfSvc,
             tgCb->tgAtt.Direction);
        ccFillTgAttr(con, tgCb->tgAtt.ownClass, tgCb->tgAtt.Class,
                     tgCb->tgAtt.ClassOfSvc, tgCb->tgAtt.Direction, 0);
      }
      else
        CCDP(AIN_DBG_LEVEL_2, "ccConE09S01: tgCb is NULL: "
             " failed for icProtType%d\n", icProtType);
    }
    /* bug:46451 - what's in icRsc? */
    if (icProtType == CC_SIP || icProtType == CC_SIPT)
    {
        CCDP(AIN_DBG_LEVEL_0, "%s - icRsc-intfcType:SIP, icProtType:%d, "
             "sipDesc.tgId:0x%x, sipDesc.ipAddr:%s\n", fn, icProtType,
             (int)con->icRsc.intfc.t.sipDesc.tgrpId,
             ip_ntoa(&con->icRsc.intfc.t.sipDesc.ipAddr));
    }
    if (con->icRsc.rscPres == NOTPRSNT)
    {
        cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));   
    }
    else if (ccIsDifferentRscAllocated(con->icProtType, &con->icRsc, 
                                       rscEvnt->rsc1))
    {
      cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));   
    }
    else 
    {
      if (!ccIsRscReqd(con))
      {
          rscEvnt->rsc1->rscPres = NOTPRSNT;
      }
    }
    /* bug:46451 - what's in icRsc? */
    if (icProtType == CC_SIP || icProtType == CC_SIPT)
    {
        CCDP(AIN_DBG_LEVEL_0, "%s - icRsc-intfcType:SIP, icProtType:%d, "
             "sipDesc.tgId:0x%x, sipDesc.ipAddr:%s\n", fn, icProtType,
             (int)con->icRsc.intfc.t.sipDesc.tgrpId,
             ip_ntoa(&con->icRsc.intfc.t.sipDesc.ipAddr));
    }

    if (rscEvnt->tfcDesc != NULLP) 
    {
      if (rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.pres == PRSNT_NODEF)
      {
        con->echoCntrl.icResEchoCntrlDevInd = 
             rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.val;
      }
    }
                                            
    /* Copy Additional Resource Information */
    if (rscEvnt->addnlRscInfo != NULLP)
    {
      cmMemcpy((U8 *) &con->icAddnlRscInfo, (U8 *)rscEvnt->addnlRscInfo, 
               sizeof(RmAddnlRscInfo));   
    }
    else
      con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

    /* Copy the mBuf received from RM */
    if (con->icRscMBuf)
      SPutMsg(con->icRscMBuf);
      con->icRscMBuf = rscEvnt->mBuf;
    rscEvnt->mBuf = NULLP;

    /* Copy the modified traffic descriptor */
    if(rscEvnt->tfcDesc)
      cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc,
               sizeof(RmTfcDesc));

    /* bug:42561 - Now that we have something in con->icRsc from a successful rscAlloc,
       begin the callcapture business.
       bug:40864 only for non-cas, call here - for cas, in e35s34(addrCfm) */
    if ((con->icProtType != CC_CS_LN) &&
        (con->icProtType != CC_CS_TG) &&
        (con->icProtType != CC_MGCP_LN) &&
        (con->icProtType != CC_MGCP_TG) &&
        (con->icProtType != CC_GR303))
    {
        ccChkCallTrc(con, CALLINC, 0);
    }

    if (con->icProtType == CC_GR303)
    {
        if( CcLiCctRscRsp(&con->icSapCb->pst, con->icSapCb->spId, con->icSpConnId,
                          con->icSuConnId, &con->icRsc, con->STDigitRecd) != ROK)
        {
          /* BUG 43995 */
          RETVALUE(ROK);
        }
    }

    if ((con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303) ||
        (con->icProtType == CC_MGCP_LN))
    {
      if(CC_IS_WAITMORE_INFO(con->waitForMoreInfo))
      {
          CCDP(AIN_DBG_LEVEL_1, "ccConE09S01: con->waitForMoreInfo=0x%2x\n", con->waitForMoreInfo);
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_AWTMOREINFO);
          RETVALUE(ROK);
      }
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&originationAttempt, 0, sizeof(OriginationAttempt_t));

      ccUpdateBcm(con, PicONull, CiOriginatingSetup, BtOBcm);
      for (index = 0; index < EReqMax; index++)
      {
        con->icBcm.nel[index] = NEL_UNARMED;
      }
      ccFillSvcHeader(&header, &(con->icBcm), MSG_Origination_Attempt);
      ccFillOrigAttemptParam(&originationAttempt, &(con->icBcm), FALSE);

      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE1);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                         CCS_CANNOTPROCESSEVENTS);

      CCDP(AIN_DBG_LEVEL_0," Send OrigAtt, TransID = 0x%lx, icSu = 0x%lx\n",
           header.spTransId, con->icSuConnId);
      CcUiFctOriginationAttempt(&originationAttempt, &header);
      RETVALUE(ROK);
    }
    else
    {
      if ((icProtType == CC_SI) || (icProtType == CC_BICC))
      {
#if 0 /* Pushed to UnpackFwdCallSetup..() */
        if ((icProtType == CC_BICC) && (CC_INGRESS_INTER_CCS_CALL(con)))
        {
          if (con->icIngressCcsRscIntfcPres)
          { 
            ret = ccGetIntfcSap(&con->icIntfcCb, &(con->icIngressCcsRscIntfc));
            if (ret != ROK)
              CCLOGERR("Error: ccGetIntfcSap failed for internal BICC call\n"); 
          }
        }
#endif
        switch(con->cotBlock.contType)
        {
          case CC_IAM_INITIATED:
            CC_FIND_CONTCHKIND_VAL(con, val);
            if (val == CONTCHK_NOTREQ)
            {
              CCLOGERR("Error: Invalid combination icSu = 0x%lx, val = %d,"
                       " contType = %d\n", con->icSuConnId, val,
                       con->cotBlock.contType);
              ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
              RETVALUE(ROK);
            }
            else if (val == CONTCHK_PREV)
            {
              if(CC_IS_WAITMORE_INFO(con->waitForMoreInfo))
              {
                  CCDP(AIN_DBG_LEVEL_0, "ccConE09S01: con->waitForMoreInfo=0x%02x\n",
                       con->waitForMoreInfo);
                  con->lastState = con->state;
                  CC_STATE_CHANGE(con, CCS_AWTMOREINFO);
                  RETVALUE(ROK);
              }
              CC_STATE_CHANGE(con, CCS_AWTCOT);
              RETVALUE(ROK);
            }
            else
            {
              CCDP(AIN_DBG_LEVEL_0, "Proceed with COT request icSu =0x%lx\n",
                   con->icSuConnId);
              CCFILLCOTSTAT(con, CC_IC_COT_ATTEMPT, CC_ACTION_INCREMENT);
	      
	      /* bug: 47086 */
              if((val == CONTCHK_REQ) && (CC_IS_WAITMORE_INFO(con->waitForMoreInfo)) )
              {
                  CCDP(AIN_DBG_LEVEL_0, "ccConE09S01: con->waitForMoreInfo=0x%02x\n",
                       con->waitForMoreInfo);

		  /* BUG: 49715 */
		  con->waitForMoreInfo &= 0xFE;
		  /* End of 49715 */
              }               
              /* end of 47086 */
            }
          case CC_CRM_INITIATED:
          case CC_CCR_INITIATED:

            if (con->cotBlock.contType == CC_CCR_INITIATED)
                CCFILLCOTSTAT(con, CC_IC_COT_ATTEMPT, CC_ACTION_INCREMENT);

            /* FID 14457.2 - Megaa congestion handling */
            if (CC_MEGAA_CONGESTED)
            {
              if (ccProcessNCAForMegaaCong((S16)con->specialCall) == RELEASE_CALL)
              {
                CCLOGERR("Release call due to Megaa congestion icSu=%ld\n", con->icSuConnId);
                ccHandleCleanUpConCb(con, TRUE, CCSWTCHCONG);
                RETVALUE(RFAILED);
              }
            }

            /*FID 2005*/
            if(CC_MG_CONGESTION)
            {
              if(ccReleaseCallDueToMgCongestion(con) == TRUE)
              {
                CCLOGERR("Release call due to MG congestion icSu=%ld\n", con->icSuConnId);
                ccHandleCleanUpConCb(con, TRUE, CCSWTCHCONG);
                RETVALUE(RFAILED);
              }
            }
            /* FID 7804 */
            if (ccProcessOverLoadControl(con, FALSE) == ROK)
            {
                CCDP(AIN_DBG_LEVEL_0, "Overload Processing icSu:0x%lx\n",
                     con->icSuConnId);
                RETVALUE(ROK);
            }

            cmMemset((U8*) &signalDesc, 0, sizeof(MgctSignalsDescriptor));
            con->icBcm.bcmType = BtOBcm;
            /*COT case: needs to assign the mgSpId for icBmc */
            con->icBcm.mgSpId  = ((CcGenSap *)(*ccSfSapLstPtr))->spId;
            
            if (con->cotBlock.contType == CC_CRM_INITIATED)
            {
              CCDP(AIN_DBG_LEVEL_0, "Send ISUP CRA 0x%lx\n", con->icSuConnId);
              ccSendStaReq(con, CCE_STA_CIRRSRVACK, 0, CC_INCOMING);
            }
            mgctSignalDesc(&con->ctl, PRSNT_NODEF, MGCT_SIG_ID_CT_RSP,
                           MGCT_PACKAGE_ID_CT, SIG_SIGNAL_TYPE_ON_OFF,
                           0, NULLP, NULLP, MGCT_KEEP_ACTIVE_MAX, &signalDesc);
            if (signalDesc.pres == PRSNT_NODEF)
              ptr_signalDesc = &signalDesc;
            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                         &(con->icBcm),
                                         NULLP, NULLP, ptr_signalDesc, NULLP, NULLP,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, con);
            ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                               CCS_CANNOTPROCESSEVENTS);
            CC_STATE_CHANGE(con, CCS_AWTMGCTCFMCOTIC0);
            con->mgBlock->con = con;
            ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
            if (ret != ROK)
            {
              CCLOGERR("ERROR: ccSendMgiQueue FAILED : icSu 0x%lx\n",
                       con->icSuConnId);
              cleanUpMgQ(con);
              ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
              RETVALUE(ROK);
            }
            break;
          case CC_CCR_INITIATED_OG:
            CCFILLCOTSTAT(con, CC_OG_COT_ATTEMPT, CC_ACTION_INCREMENT);
            ccProcessOgCotInitByCCR(con);
            break;
          default:
            CCDP(AIN_DBG_LEVEL_0, "No COT: Go ahead with normal call"
                 " processing icSu = 0x%lx, contType = %d\n",
                 con->icSuConnId, con->cotBlock.contType);

            /* Bug: 45275 */
            if (con->cotBlock.contType == CC_CRM_NOCONT)
            {
              CCDP(AIN_DBG_LEVEL_0, "Send ISUP CRA 0x%lx\n", con->icSuConnId);
              ccSendStaReq(con, CCE_STA_CIRRSRVACK, 0, CC_INCOMING);
              CC_STATE_CHANGE(con, COT_IC_DONE);
              RETVALUE(ROK);
            }

#if 0
            /* Internatinal Development: ISUP Overlap Support */
	        /* Check First if incoming call is using overlap operation before */
	        /*   going to FIC; Not supported for ANSI */
	        if (ccCheckIfOverlap(con) == RIGNORE)   /* Note: May Change CC State */
	        {
              ccSendOrSkipInfoCollected(con);
            }
#endif
            /* If there need waitting for more info from ISUP, change the state to S96 */
            if(CC_IS_WAITMORE_INFO(con->waitForMoreInfo))
            {
                CCDP(AIN_DBG_LEVEL_1, "ccConE09S01: con->waitForMoreInfo=0x%02x\n",
                     con->waitForMoreInfo);
                con->lastState = con->state;
                CC_STATE_CHANGE(con, CCS_AWTMOREINFO);
                RETVALUE(ROK);
            }
            else
            {
                ccSendOrSkipInfoCollected(con);
            }
            break;
        }
        RETVALUE(ROK);
      }
      else if (con->icProtType == CC_CS_TG )
      {
        CC_STATE_CHANGE(con, CCS_AWT_ADDR_CFM);
        ccSetDefaultAddrReq(con->icProtType, &ccAddrReqEvnt);




        ccUpdateAddrReq(con, &ccAddrReqEvnt);
        if (ccIsIPSubscriber(&(con->icBcm)))
          ccUpdateAddrReqForDMAPofIPSubscriber(con, &ccAddrReqEvnt);
        ccFillTgAttrForAddrReq(con, &ccAddrReqEvnt); 
        CcLiCctAddrReq(&con->icSapCb->pst, con->icSapCb->spId,
                       con->icSpConnId, con->icSuConnId, con->icProtType,
                       &ccAddrReqEvnt);
        RETVALUE(ROK);
      }
      else if(ccIsPlayAnnouncePresentInConEvnt(con, icProtType)) /*FID:372*/
      {
        if(ROK != ccHandleSendToRscFromIngress(con, icProtType))
        {
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          /* CCUNALLOC will force SIPW to send 404 response code
           * to Ingress SIP network */
          ccSendRelease(con, con->icSapCb, con->icSpConnId,
                con->icSuConnId, con->icProtType, CCUNALLOC, NULL);
        }
        RETVALUE(ROK);
      }
      else
      {
#if 0
       /* International Development: ISDN Overlap Support *
	    * Check First if incoming call is using overlap operation before
        * going to FIC; Not supported for ANSI
	    */
	    if (ccCheckIfOverlap(con) == RIGNORE)   /* Note: May Change CC State */
	    {
          ccSendOrSkipInfoCollected(con);
        }
#endif
        /* If there need waitting for COT/INF/SAM from ISUP
	 * or INFO from ISDN, change the state to S96 
	 */
        if(CC_IS_WAITMORE_INFO(con->waitForMoreInfo))
        {
            CCDP(AIN_DBG_LEVEL_1, "ccConE09S01: con->waitForMoreInfo=0x%02x\n",
                 con->waitForMoreInfo);

            con->lastState = con->state;

            if((con->icProtType == CC_INETSI) && 
               (CC_IS_IN_PLAYDIALTONE(con->waitForMoreInfo)))
            {
                /* FID17555.0 Play dialing tone Kavon */
                con->icBcm.mgSpId = ((CcGenSap *)(*ccSfSapLstPtr))->spId;
                ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SEND_ONLY, MGCT_PACKAGE_ID_CG, 
                                             MGCT_SIG_ID_CG_DT, MGCT_CMD_ADD,
                                             &(con->icBcm), 
                                             NULLP, NULLP, NULLP, NULLP, NULLP, 
                                             0, MGCT_CONTEXT_CHOOSE, con);
                CC_STATE_CHANGE(con, CCS_AWTSWTCFM_FOR_DIALINGTONE);
                con->mgBlock->con = con;
                ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
                if (ret != ROK)
                {
                    CCLOGERR("ERROR: ccSendMgiQueue failed\n");
                    cleanUpMgQ(con);
                    ccCleanUpMGCtx(con);
                    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
                    RETVALUE(ROK);
                }
            }
            else
            {
                CC_STATE_CHANGE(con, CCS_AWTMOREINFO);

                /* FID: 2111 --- ISDN overlap reeiving */
                if (ccIsRscRspReqd(con))
                {
                    CcLiCctRscRsp(&con->icSapCb->pst, con->icSapCb->spId,
                                    con->icSpConnId, con->icSuConnId, &con->icRsc,
                                    con->STDigitRecd);
                }
            }

            RETVALUE(ROK);
        }
        else
        {
            if((icProtType != CC_SIP) && (icProtType != CC_SIPT) && (icProtType != CC_EXT_BICC))
            {
	             con->STDigitRecd = TRUE;
            }
            ccSendOrSkipInfoCollected(con);
        }
        RETVALUE(ROK);
      }
    }
  }
   /* Bug 26807: Check for RMT Resource Busy condition for all the Trunk
    * Interface. Waiting for Termination Attempt needs to be handled
    *
    *  RV Suresh, 01/19/2004
    */
  else if((rscEvnt->rscSta1 == RMT_RES_INTERNAL_BUSY) &&
          ((rscEvnt->rsc1->intfc.intfType == CC_BICC_INTFC) ||
           (rscEvnt->rsc1->intfc.intfType == CC_EXT_BICC_INTFC) ||
            (rscEvnt->rsc1->intfc.intfType == CC_CS_TG_INTFC)||
            (rscEvnt->rsc1->intfc.intfType == CC_SI_INTFC)))
  {
    CcConCb *oldCon = NULLP;
    /* This can be hit  in case of : 
     * 1) Race condition b/w ConReq and ConInd at CCT level (internal glare)
     * 2) early MGIT TxnReq for BICC trunks.
     */
    /* Pull the conBlock of the call waiting for ANSWER. */
    ret = cmHashListFind(&ccSuOgInstTbl,
                         (U8 *)&(rscEvnt->addnlRscInfo->busySuConnId),
                         (U16)sizeof(UConnId), 0, (PTR *)&oldCon);

    if ((ret == ROK) && (oldCon))
    {
      /* Bug 26807: Check for RMT Resource Busy condition for all the Trunk
       * Interface. Waiting for Termination Attempt needs to be handled
       * 
       * If the Internal resource is busy and old_con state is Waiting for Termination
       * attempt, then this is a glare condition. Then do the following:
       * 1. copy the old_con id in con.
       * 2. Send RMT_MOD for old_con.
       * 3. CH_OWN the old_con's resources to con.
       *
       *  RV Suresh, 01/19/2004
       */
      switch(rscEvnt->rsc1->intfc.intfType)
      {
        case CC_CS_TG_INTFC:
          if ((oldCon->state == CCS_AWTANS) ||
              (oldCon->state == CCS_AWTRSPFORDPE20))
            allowedReattempt = TRUE;
          break;

        case CC_BICC_INTFC:
        case CC_EXT_BICC_INTFC:
          if ((oldCon->state == CCS_AWTOGSWTCFM) ||
               (oldCon->state == CCS_AWTRSPFORDPE20))
            allowedReattempt = TRUE;
           break;
        case CC_SI_INTFC:
          if ((oldCon->state == CCS_AWTMGCTCFMCOTOG0) ||
              (oldCon->state == CCS_AWTMGCTNOTIFY1)   ||
              (oldCon->state == CCS_AWTMGCTCFMCOTOG1) ||
              (oldCon->state == COT_OG_DONE)          ||
              (oldCon->state == CCS_AWTRSPFORDPE20)   ||
              ((oldCon->state == CCS_AWTSWTCFMFORDP)&&
               (oldCon->relPend == CONTINUEWITHREATTEMPT)) /* Bug92094 */
             )
            allowedReattempt = TRUE;
          break;
        default:
           if (oldCon->state == CCS_AWTRSPFORDPE20)
             allowedReattempt = TRUE;
           break;
      }
    }
    if ((ret != ROK) || (!allowedReattempt))
    {
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      ccCp.sts.fResUnavail++;
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      CCLOGERR("Releasing the call : trunk is not good for incoming call\n");

      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
      RETVALUE(ROK);
    }

    if(rscEvnt->rsc1->intfc.intfType == CC_CS_TG_INTFC)
    {
      /* CAS-SP will send a reAttempt Indication for oldCon. So, wait
       * untill we recive Re-attemp indication from ISUP/CAS/etc... */

      /* change the state of the oldCon to CCS_AWT_REATTEMPT */ 
      CC_STATE_CHANGE(oldCon, CCS_AWT_REATTEMPT);
      /* Keep the SuConnId of this call in oldCall */
      oldCon->icSuConnIdOfIntGlare = con->icSuConnId;
      /* Do not change the state of the new call. Keep it in the same state.*/
      CC_STATE_CHANGE(con, CCS_AWTROUTERSC);
    }
    else if ((rscEvnt->rsc1->intfc.intfType == CC_SI_INTFC)        &&
             ((oldCon->state == CCS_AWTMGCTCFMCOTOG0)              ||
              (oldCon->state == CCS_AWTMGCTNOTIFY1)                ||
              (oldCon->state == CCS_AWTMGCTCFMCOTOG1)              ||
              (oldCon->state == COT_OG_DONE)                       ||
              ((oldCon->state == CCS_AWTSWTCFMFORDP)&&
               (oldCon->relPend == CONTINUEWITHREATTEMPT)) /* Bug92379 */
             ))
    {
      CCDP(AIN_DBG_LEVEL_0, "Rsc will be grabbed when OgCOT is cleared:0x%lx\n",
           oldCon->icSuConnIdOfIntGlare);
      oldCon->icSuConnIdOfIntGlare = con->icSuConnId;
    }
    else /* either BICC or old_con is waiting for Termination attempt from FIC */
    {
      CcGenSap *rmCb;

      /* This can happen if
       * + Terminating Side is BICC and
       * + GCC is waiting for MgctTxnCfm(addReq) from MGIT for a call
       *   who's (oldCon) outGoing BICC-Circuit (oldCon->ogRsc) is same as 
       *   this call's (con) incoming BICC-Circuit (con->icRsc).
       * + This window is wide open because, MGIT is loosly-coupled
       *   with GCC and GCC already seized the CKT before MgitTxnReq(addReq).
       */

       /* This can also happen if, old_con is either on ISUP or BICC and is waiting 
        * for TERMINATION ATTEMPT for FIC. In this case GCC will be in state 39 
        * (AWTRSPFORDPE20) and is waiting for Authorize_terminate_attempt(38) from FIC
        *
        * If the Internal resource is busy and old_con state is Waiting for Termination
        * attempt, then this is a glare condition. Then do the following:
        * 1. copy the old_con id in con.
        * 2. Send RMT_MOD for old_con.
        * 3. CH_OWN the old_con's resources to con.
        *
        *
        * BUG 26807: RV Suresh : 01/19/2004
        */

      /* PLAN: 
       * + RMT_MOD on oldCall.
       * + CH_OWN on newCall.
       */
      
      oldCon->ogRscVal = FALSE;
      if((oldCon->ogSapCb) && (oldCon->ogSapCb->nmbActvConn > 0))
        oldCon->ogSapCb->nmbActvConn--;
      else
        CCLOGERR("ERROR %s:oldCon->ogSapCb->nmbActvConn=%d\n", __FUNCTION__,
                 (oldCon->ogSapCb)?oldCon->ogSapCb->nmbActvConn:0);
      if((oldCon->ogIntfcCb) && (oldCon->ogIntfcCb->nmbActvConn > 0))
         oldCon->ogIntfcCb->nmbActvConn--;
      else
        CCLOGERR("ERROR %s:oldCon->ogIntfcCb->nmbActvConn=%d\n", __FUNCTION__,
                 (oldCon->ogIntfcCb)?oldCon->ogIntfcCb->nmbActvConn:0);
      oldCon->ogRscSta = RMT_RES_INVALID;
      rmCb = oldCon->rmSapCb;

        /* Send RmtAlocReq .. and make sure RmtAlocCfm is handled in the following
         * states in GCC:
         *
         * Termination Attempt ( State 39 ) in case of ISUP/BICC/CAS calls
         * MgitTxnCfm state in State 28 - AWTOGSWTCFM 
         * AWT_REATTEMPT in case of CAS calls
         *
         * BUG 26807 : RV Suresh 
         */ 
      CcLiRmtAlocReq (&rmCb->pst, rmCb->spId, oldCon->ogSuConnId,
                      oldCon->ogProtType, RMT_MOD, &(oldCon->ogRsc),
                      &oldCon->tfcDsc, FALSE, NULLP, &oldCon->icAddnlRscInfo,
                       NULLP);
      /* Old call freed the ckt */

      /* New call : grab the ckt  */
      ccAllocateResource(con, (CcConEvnt *)(con->ccEvntHold),
                         CC_INCOMING, RMT_ALOC);
      RETVALUE(ROK);
    }
  }
  else if((rscEvnt->rscSta1 == RMT_RES_INTERNAL_BUSY) &&
          ((rscEvnt->rsc1->intfc.intfType == CC_CS_LN_INTFC) ||
           (rscEvnt->rsc1->intfc.intfType == CC_MGCP_LN_INTFC) ||
           (rscEvnt->rsc1->intfc.intfType == CC_G3_INTFC)))
  {
    /* somebody else has resource. If 'other' call is in AWTMWIUPDCFM
     * then release it, take the resource, and then continue.  */

    ret = cmHashListFind(&ccSuInstTbl,
                         (U8 *)&(rscEvnt->addnlRscInfo->busySuConnId),
                         (U16)sizeof(UConnId), 0, (PTR *)&oldCon);
    if ((ret == ROK) &&
        ((oldCon->state == CCS_AWTMWIUPDCFM) ||
         (oldCon->state == CCS_AWTRSCALLOCCFM_MWI)))
    {
      /* steal the resource from oldCon */
      /* the call to ccAllocateResource will run us back thru the state machine
       * with con and then return here to continue running.  Once we get back
       * here don't do anything with the resource or with con... just use
       * oldcon */
       ccAllocateResource(con, (CcConEvnt *)con->ccEvntHold, CC_INCOMING,
                          RMT_ALOC_CHOWN);

       /* send failure report message to FCT */
       ccFillSvcHeader(&header, &(oldCon->icBcm), MSG_Close); 
       header.lastTransactionFlag = TRUE;
       vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
       vmsMwiCfm.srvcId        = oldCon->icBcm.svcHeader.srvcId;
       CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);

       /* We stole the resource from oldCon, so just release oldCon */
       ccRelCon(oldCon);
       RETVALUE(ROK);
    }
    /* bug : 17870 */
    /* This is a case of Internal Glare on subscriber lines */
    /* We will neglect this call, and let the call (in states like 28 & 39)
     * the line is busy terminate successfully */

    /* CctConInd is being ignored */
    CCLOGERR("Ignoring attempt to call : Call is bound to terminate on this"
             "subscriber line : icSp:%lx\n", con->icSpConnId);

    CC_STATE_CHANGE(con, CCS_IDLE);
    ccRelCon(con);
  }
  else if ((rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE) ||
           (rscEvnt->rscSta1 == RMT_RES_ALOC_BY_PEER) ||
           (rscEvnt->rscSta1 == RMT_RES_ALOC_BUSY))
  {
    con->icRscVal = FALSE;
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccCp.sts.fResUnavail++;
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                  con->icProtType, CCTMPFAIL,NULL);
  }
  else
  {
    U8 cause = CCTMPFAIL;
    /* unknown case?? Release the call */
    CCLOGERR("Unknown resoure status %d - from RM. Releasing the call\n",
             rscEvnt->rscSta1);
    con->icRscVal = FALSE;
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccCp.sts.fResUnavail++;
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

#if 1 /* Bugzilla 14719:taraveti */
    switch(rscEvnt->rscSta1)
    {
      case RMT_RES_INVALID:
        cause = CCINVCALLREF;
        break;
      case RMT_RES_OUTOFRSC:
        cause = CCRESCUNAVAIL;
        break;
    }
#endif
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, cause,NULL);
  }
  RETVALUE(ROK);
} /* end ccConE09S01 */


/*
 *
 *      Fun:   ccConE14S01
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTROUTERSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S01
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    /* RM is tightly coupled to GCC so this should never happened, 
     * except in the case when the S01 is overloaded and this con is the 
     * waitingCon (search for this keyword). */

    ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
               LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                  con->icProtType, CCTMPFAIL,NULL);
    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S02
 *
 *      Desc:  Connection state function
 *             event - Release Indication 
 *             state - AWTROUTEDGT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S02
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret            = RFAILED; /* return value */

  TRC3(ccConE04S02)

  ccStopConTmr(con, TMR_INTERDGT);
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* Release switching connection if one exists!!. However, Mgi context is
   * not expected in this state !*/
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
    if (con->direction == INCTOOUT)
      con->relPend = INRELRSPANDOUTREL;
    else
      con->relPend = OUTRELRSPANDINREL;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_3, "No Switching Ctx found state/evnt==%d/%d\n",
            con->state, 4);
  }

  /* If MGI context is not available ( which is most likely in this case)
   * Go ahead and release the resource */
  con->icEvnt = (CcAllSdus *) event;
  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
#ifdef GUARD_TIMER
   ret = ccGuardOrDeallocResource(con, CC_INCOMING);
#else
  ret = ccDeallocateResource(con, CC_INCOMING);
#endif
  if (ret == RFAILED)
  {
      CC_STATE_CHANGE(con, CCS_IDLE);
      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *) event;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      ccRelCon(con);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S02
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTROUTEDGT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S02
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  TRC3(ccConE14S02)
   
    /* Stop timer, Send release to incoming side, Generate Alarm? */
    ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
               LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  ccStopConTmr(con, TMR_INTERDGT);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL,NULL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE16S02
 *
 *      Desc:  Connection state function
 *             event - INTERDIGT Timer Expired
 *             state - AWTROUTEDGT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE16S02
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  TRC3(ccConE16S02)
   
    /* Stop timer, Send release to incoming side, Generate Alarm? */
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCINVNMBFRM,NULL);
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE09S04
*
*      Desc:  Connection state function
*             event - Resource Allocation Confirmation
*             state - AWTRSCALOCFM
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE09S04
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  S16 compatRet = RFAILED;
  RmAlocCfmEvnt *rscEvnt;
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);
   CcCause         cause;
#if 1 /*FGD*/
  CcTgCb *tgCb = NULL;
#endif /*FGD*/
  const char   *fn = __FUNCTION__ ;

  /* First check and store the allocated resources */
  rscEvnt = (RmAlocCfmEvnt *) event;
  /* Check if RscCfmEvnt is from 2WayPriAlocReq or not -gb */
  /* Check pointers in RscCfmEvnt */
  if(((rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC) || 
      (rscEvnt->rscSta1 == RMT_RES_ALOC_BUSY))
       &&(rscEvnt->ogPrtclType != NULLP))
  {
    /* store outgoing sap */
    if ((ret = ccGetPsSap(&con->ogSapCb, 
                          &rscEvnt->rsc1->intfc))!= ROK)
    {
      CCLOGERR("ccAllocateResourceArray() Failed, ccGetPsSap failed");
      ccCp.sts.fRoutUnavail++;

      ccPlayToneOrRelease(con, CCTMPFAIL);
      RETVALUE(RFAILED);
    }
    if (con->ogSapCb)
      con->ogSapCb->nmbActvConn++;

    if(!CC_EGRESS_INTER_CCS_CALL(con))
    {
      ret = ccGetIntfcSap(&con->ogIntfcCb, &(rscEvnt->rsc1->intfc));
      if(ret != ROK) 
      {
          ccCp.sts.fRoutUnavail++;
          ccPlayToneOrRelease(con, CCTMPFAIL);
          RETVALUE(RFAILED);
      }
      con->ogProtType = con->ogIntfcCb->protType;

      /* Bug 43055, drop the RelEvntHold in case if it exists */
      ccRestoreEvntHold(con);
      if (con->ccRelEvntHold != NULLP)
      {
          SPutSBuf(ccInit.region, ccInit.pool, con->ccRelEvntHold,
                  (Size)(sizeof(CcAllSdus)));
          con->ccRelEvntHold = NULLP;
      }

      if (con->ogIntfcCb)
        con->ogIntfcCb->nmbActvConn++;
    }
  } /* RMT_RES_ALOC_SUCC - gb */
  else
    con->ogIntfcCb = NULLP;

  con->ogRscSta = RMT_RES_INVALID;

  /* Bug 88302 */
  if((icProtType == CC_BICC) &&
     (con->ccEvntHold != NULLP) &&
     (con->ogIntfcCb) && (con->ogIntfcCb->ccTgCb) &&
     (con->ogIntfcCb->ccTgCb->tgAtt.stDigitOut) &&
      CC_IS_OGOVERLAP_ENABLED(con) &&
      CC_IS_ICOVERLAP_ENABLED(con))
  {
      if(CC_STDIGIT_PRESENT(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum))
      {
          con->STDigitRecd = TRUE;
          ccRemoveSTCalledParty(&(con->ccEvntHold->m.ccConEvnt.m.siConEvnt));
      }
  }

  /* FID 14677.0 ITU99 Propagation Delay handling 
   */ 
  ccFillConPropDelayVal(con,rscEvnt);

  if (rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.pres == PRSNT_NODEF)
  {
    con->echoCntrl.ogResEchoCntrlDevInd =
         rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.val;
  }
  else
    con->echoCntrl.ogResEchoCntrlDevInd = RM_ECHOCNTRL_NOK;

  if ((!con->ogRscVal) && (rscEvnt->rscSta1 != RMT_RES_INVALID))
  {
    con->ogRscSta = rscEvnt->rscSta1;
    if (rscEvnt->rsc1 != NULLP)
    {
        /* bug:46451 - see what's in both ogRsc's before the cmMemcpy */
        if (ogProtType == CC_SIP || ogProtType == CC_SIPT)
        {
            CCDP(AIN_DBG_LEVEL_0, "%s - ogRsc-intfcType:SIP, ogProtType:%d, "
                 "sipDesc.tgId:0x%x, sipDesc.ipAddr:%s, just-aloc'd:tgId:0x%x, "
                 "sipDesc-ipAddr:%s\n", fn, ogProtType,
                 (int)con->ogRsc.intfc.t.sipDesc.tgrpId,
                 ip_ntoa(&con->ogRsc.intfc.t.sipDesc.ipAddr),
                 (int)rscEvnt->rsc1->intfc.t.sipDesc.tgrpId,
                 ip_ntoa(&rscEvnt->rsc1->intfc.t.sipDesc.ipAddr));
        } /* end bug:46451 */
        cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
    }
    if (!CC_EGRESS_INTER_CCS_CALL(con))
    {
      /* Bug 25626:taraveti always update the ogProtType from the RscAlocCfm */
      ret = ccGetIntfcSap(&con->ogIntfcCb, &(rscEvnt->rsc1->intfc));
      if(ret != ROK)
      {
        ccCp.sts.fRoutUnavail++;
        ccPlayToneOrRelease(con, CCTMPFAIL);
        RETVALUE(RFAILED);
      }
      con->ogProtType = con->ogIntfcCb->protType;

      /* Bug 43055, drop the RelEvntHold in case if it exists */
      ccRestoreEvntHold(con);
      if (con->ccRelEvntHold != NULLP)
      {
        SPutSBuf(ccInit.region, ccInit.pool, con->ccRelEvntHold,
                  (Size)(sizeof(CcAllSdus)));
        con->ccRelEvntHold = NULLP;
      }
    }

    /* Copy Additional Resource Information */
    if (rscEvnt->addnlRscInfo != NULLP)
    {
      cmMemcpy((U8 *) &con->icAddnlRscInfo, (U8 *)rscEvnt->addnlRscInfo,
               sizeof(RmAddnlRscInfo));
    }
    else
      con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

    /* Copy the mBuf received from RM */
    if (con->icRscMBuf)
      SPutMsg(con->icRscMBuf);
    con->icRscMBuf = rscEvnt->mBuf;
    rscEvnt->mBuf = NULLP;

    /* Copy the modified traffic descriptor */
    cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc,
               sizeof(RmTfcDesc));
    /* FID 15068 */
    CCDP(AIN_DBG_LEVEL_0, "%s - contChkInd.pres %d val %d\n", __FUNCTION__,
         con->tfcDsc.nbTfcDesc.contChkInd.pres,
         con->tfcDsc.nbTfcDesc.contChkInd.val);
  }

#if 1 /* Bug# 50730 - Required for ReRoute scenarios */
  con->mapInfo.mapTblEntry = NULL; 
#endif
  /* RV Suresh 5.0, Changes made for GCC-BICC interworking 
   * Check the Egress protocol type...
   *    If the Egress is internal BICC then convert the incoming protocol type to
   *    BICC protocol type
   *
   * Changes made for Variant passing, refer to Section-4 of 79-3331 (International GCC Design)
   *
   */

  if (CC_EGRESS_INTER_CCS_CALL(con))
  {
       con->ogProtType = ccConvertProtTypeToBiccProtType(con);
  }
   /* now update the ogProtType to reflect the new con->ogProtType */
   ogProtType = CC_GET_PROTOCOL(con->ogProtType);

   /* BUG:84670&& CAC media update issue */
   if ((CC_IS_ICA_CALL(con) ||(CC_INGRESS_INTER_CCS_CALL(con) && (con->icIntfcCb->protType == CC_ICA))) &&
       (con->rmSapCb == NULLP))
   {
     if (((ret = ccGetRmSap(&con->rmSapCb, &con->ogRsc.intfc, 0)) == ROK) &&
         (con->rmSapCb->state == CC_BND))
     {
       con->icIntfcCb->destRMSAPId = con->rmSapCb->suId;
       CCDP(AIN_DBG_LEVEL_1, "%s: ICA call rmSapCb set\n", __FUNCTION__);
     }
     else
       CCLOGERR("%s::ICA call get rmSapCb failed\n", __FUNCTION__);
   }
  /* FID 14989.0 UK ISUP Enhancement, SIP to ISUP inter-working. */
  /*Bug87719 +*/
  if ((icProtType == CC_SIP) && (con->ogIntfcCb != NULLP) &&
      ((CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_SI) ||
       (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_EXT_BICC)))
  {
      /* Check if SIP INVITE without SDP */
      if ((con->ccEvntHold != NULLP) && (con->ccEvntHold->m.ccConEvnt.m.sipConEvnt.sdp.pres != PRSNT_NODEF))
      {
          CcSipPrflCb  *sipPrflPtr = NULL;

          /* Get SIP proflie */
          if ((con->icIntfcCb != NULL) && (con->icIntfcCb->ccTgCb))
          {
              sipPrflPtr = con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr;
          }

          /* Check inviteSdp option in SIP profile */
          if ((sipPrflPtr != NULL) && (sipPrflPtr->inviteSdp == TRUE))
          {
              CCLOGERR("Error: No SDP present in SIP INVITE, reject the call. inviteSdp=%d\n", sipPrflPtr->inviteSdp);

              if(rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
              {
                 con->ogRscVal = TRUE;
                 ccDeallocateResource(con, CC_OUTGOING);
              }
              ccHandleCleanUpConCb(con, TRUE, CCBCAPNOTIMP);
              RETVALUE(ROK);
          }
      }
   }
  /*Bug87719 -*/
  /* The first resource was successfully allocated now check for outgoing */
  switch (con->ogRscSta)
  {
    case RMT_RES_ALOC_SUCC:
      con->ogRscVal   = TRUE;
      con->isItAssg   = TRUE;
      ccRegisterCurrentInterface(con, &(rscEvnt->rsc1->intfc));

#if 1 /*FGD*/
      /* Store trunk group attributes in con */
      if((ogProtType == CC_SI) || (ogProtType == CC_CS_TG) ||
            (ogProtType == CC_EXT_BICC))
      {
        tgCb = con->ogIntfcCb->ccTgCb;
        if(tgCb)
        {
          con->ogTgAtt = 0;
          CCDP(AIN_DBG_LEVEL_2, "ccConE09S04:OWN:%d,FEC:%d,COS:%d,tgDIR:%d\n", 
               tgCb->tgAtt.ownClass, tgCb->tgAtt.Class, tgCb->tgAtt.ClassOfSvc,
               tgCb->tgAtt.Direction) ;
#if 1  /* bug: 19674 */
          ccFillTgAttr(con, tgCb->tgAtt.ownClass, tgCb->tgAtt.Class,
                       tgCb->tgAtt.ClassOfSvc, tgCb->tgAtt.Direction, 1);
#endif /* bug: 19674 */
        }
        else
          CCDP(AIN_DBG_LEVEL_2, "ccConE09S04: ogIntfcCb->ccTgCb is NULL"
               " ogProtType=%d\n", ogProtType);
      }
#endif /*FGD*/
      /* bug:46451 - update ogRsc from tgAtt */
      if (ogProtType == CC_SIP || ogProtType == CC_SIPT)
      {
          /* the og-tg should have been config'd with the ipAddr */
          tgCb = con->ogIntfcCb->ccTgCb;
          if (tgCb)
          {
              con->ogRsc.intfc.t.sipDesc.ipAddr = tgCb->tgAtt.SipIpAddress ;
              CCDP(AIN_DBG_LEVEL_0, "%s - ogProtType:%d, tgCb - tgId:0x%x, "
                   "sipIpAddr:%s, ogRsc - sipDesc.tgId:0x%x, sipDesc.ipAddr:%s\n",
                   fn, ogProtType, tgCb->tgn, ip_ntoa(&tgCb->tgAtt.SipIpAddress),
                   (int)con->ogRsc.intfc.t.sipDesc.tgrpId,
                   ip_ntoa(&con->ogRsc.intfc.t.sipDesc.ipAddr)) ;
          }
      } /* end bug:46451 */

      if (ccIsEnblocSndOk(con->routeInfo) || (con->STDigitRecd))
      {
        /* Added for Bug# 10613 */
        if (NMBRCATEGORY_IVR(con))
        {
          /* For IVR , do not send Termination Attempt to FIC,
           *  directly go for Cut Thru' for SS7 or ConReq for ISDN I/C */ 
          CCDP(AIN_DBG_LEVEL_2,"For IVR skip TerminationAttempt\n");
          if (ccProcessIVROgRscCfm(con) != ROK)
          {
            if ((icProtType == CC_CS_TG) || (icProtType == CC_CS_LN) ||
                (icProtType == CC_GR303))
            {
              ccPlayTone(con, MGCT_PACKAGE_ID_CG, MGCT_SIG_ID_CG_BT);
              RETVALUE(ROK);
            }
            else
            {
              if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
                  (con->icBcm.SndNotInd != SND_NOTIF_MAX))
              {
                CCDP(AIN_DBG_LEVEL_0, "Sending TermNot in ccConE09S04\n");
                ret = ccSendTerminationNot(&con->icBcm);
                if (ret != ROK)
                {
                  CCDP(AIN_DBG_LEVEL_0,
                       "Failed to send TermNotif after NEL event\n");
                }
              }

              /* OgRsc Allocation fails for IVR, then just release the call
               * with IVR cause value*/
              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, con->ivrSndcauseVal, NULLP);
              RETVALUE(ROK);
            } 
          }
          RETVALUE(ROK); 
        }
        /* END : addition for Bug# 10613 */

        /* Feature 1839 - compatibility */
        if( CC_IS_COMPAT_SUPPORTED(con->icIntfcCb, con->icProtType) &&
           con->compatSt == COMPAT_NOT_START)
        {
           compatRet = ccProcessCompat(con);
           /* if failed, continue normal process */
        }
        /* end of compatibility */

        /* jiany BUG 61082 check whether COMPAT ACK received from ISUP */
        if (((compatRet == ROK) && (con->compatSt == COMPAT_ACK_RECVED))
                || (compatRet != ROK))
        {
            /* stop compatibility timer */
            ccStopConTmr(con, CC_TMR_AWAIT_COMPAT_ACK);
            ccSendOrSkipTerminationAttempt(con);
        }
      }
      else
      {
        /* wait for more digits */
        ccStartConTmr(TMR_INTERDGT, con, (PTR)con->icSapCb);
        CC_STATE_CHANGE(con, CCS_AWTENBLOCSND);
      }
      break;
    case RMT_RES_ALOC_FAILURE_DISABLED_DPC:
      ccCp.sts.fRoutUnavailForDisabledDpc++;
      if (con->ogRscSta == RMT_RES_ALOC_FAILURE_DISABLED_DPC)
        con->ogRscSta = RMT_RES_ALOC_FAILURE;

    case RMT_RES_ALOC_BUSY:
      /* If the terminator has Call Waiting, we need to store the suConnId */
      con->busySuConnId = con->icAddnlRscInfo.busySuConnId;

    case RMT_RES_ALOC_FAILURE:
      if (ccIsEnblocSndOk(con->routeInfo) || (con->STDigitRecd))
      {
        if (ccCheckForInterfaces(con) == ROK)
        {
          con->routeEvnt->currentInterface ++;
          if (ccCheckForInterfaces(con) == ROK)
          { /* BUG 64103 */
            /* There is at least 1 more interface to try */
            /* So re-route the call*/
            ccDeallocateResource(con, CC_OUTGOING);
            ccCloseTBcmTransaction(con);
            con->ogRscVal = FALSE;
            initOgBcm(&con->ogBcm);
            ccRouteCall(con, FALSE);
            RETVALUE(ROK);
          }
          else
          /* Unable to re-route, let's leave with nothing changed*/
          con->routeEvnt->currentInterface --;
        }
        /* Added for Bug# 10613 */
        if (NMBRCATEGORY_IVR(con))
        {
          /* For IVR , do not send Termination Attempt to FIC,
           *  directly go for Cut Thru' for SS7 or ConReq for ISDN I/C */ 
          CCDP(AIN_DBG_LEVEL_2,"For IVR skip TerminationAttempt\n");
          if (ccProcessIVROgRscCfm(con) != ROK)
          {
            if ((icProtType == CC_CS_TG) || (icProtType == CC_CS_LN) ||
                (icProtType == CC_GR303))
            {
              ccPlayTone(con, MGCT_PACKAGE_ID_CG, MGCT_SIG_ID_CG_BT);
              RETVALUE(ROK);
            }
            else
            {
              if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
                  (con->icBcm.SndNotInd != SND_NOTIF_MAX))
              {
                CCDP(AIN_DBG_LEVEL_0, "Sending TermNot in ccConE09S04\n");
                ret = ccSendTerminationNot(&con->icBcm);
                if (ret != ROK)
                {
                  CCDP(AIN_DBG_LEVEL_0, "Failed to send TermNotif after NEL"
                       " event\n");
                }
              }
              /* OgRsc Allocation fails for IVR, then just release the call
               * with IVR cause value*/
              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, con->ivrSndcauseVal, NULLP);
              RETVALUE(ROK);
            }
          }
          RETVALUE(ROK); 
        }

        /* Cannot use ccIsLegSubscriber as ogBcm is not initialized */
        if (!((ogProtType == CC_CS_LN) || (ogProtType == CC_GR303) ||
              (ogProtType == CC_MGCP_LN)))
        {
          CCDP(AIN_DBG_LEVEL_0, "Need to detect NetworkBusy Event: %ld\n",
               con->icSuConnId);
          con->tempHolderForReleaseCause = CCNOCIRCUIT;

          /* Bug 91984: set location to 0x7 when the ingress is ISUPIG according to Q.850 */
          if (CC_IS_IC_ORI_SUPPORTED(con))
          {  
            CC_CAUSE_INIT(&cause, PRSNT_NODEF, CCNOCIRCUIT, PRSNT_NODEF,  
                          ILOC_INTNET, PRSNT_NODEF, CSTD_CCITT);  
          }  
          else  
          {   
            CC_CAUSE_INIT(&cause, PRSNT_NODEF, CCNOCIRCUIT, PRSNT_NODEF,
                          ILOC_PUBNETLU, PRSNT_NODEF, CSTD_CCITT);
          }

          ccFillBusyCauseFromRelCause(con, &cause);

          ret = ccProcessNetworkBusy(&(con->icBcm), FC_NB_LOCAL_RELEASE);
          if (ret == ROK)
          {
            CCDP(AIN_DBG_LEVEL_0, "Network Busy Detected: %ld\n",
                 con->icSuConnId);
            RETVALUE(ROK);
          }
          else
          {
            CCDP(AIN_DBG_LEVEL_0, "Network Busy Not Armed: %ld\n",
                 con->icSuConnId);
            /* Drop down for default treatment */
          }
        }
        /* Party on hold specific check, this is a hack */
        /* Else if it is a subscriber */
        else
        {
          if (con->icBcm.cc)
          {
            RmPhyDs0  *legId1rsc   = NULLP;

            if ((con->icBcm.cc->ccId >= CiThreePartySetup) &&
                (con->icBcm.cc->ccId <= CiRemoteTransferSetup))
            {
              if (con->icBcm.cc->legId1)
              {
                if (con->icBcm.cc->legId1->bcmType == BtOBcm)
                {
                  /* Bug 48131 */
                  if (ogProtType != CC_GR303)
                  {
                      legId1rsc = &(con->icBcm.cc->legId1->con->icRsc.t.csRsc.ds0Rsc);
                  }
                  else
                  {
                      legId1rsc = &(con->icBcm.cc->legId1->con->icRsc.t.gr3Rsc.ds0Rsc);
                  }
                }
                else /* It should be BtTBcm */
                {
                  if (ogProtType != CC_GR303)
                  {
                      legId1rsc = &(con->icBcm.cc->legId1->con->ogRsc.t.csRsc.ds0Rsc);
                  }
                  else
                  {
                      legId1rsc = &(con->icBcm.cc->legId1->con->ogRsc.t.gr3Rsc.ds0Rsc);
                  }
                }

                if (ogProtType != CC_GR303)
                {
                      ret = cmMemcmp((U8 *) legId1rsc, 
                                     (U8 *) &(con->ogRsc.t.csRsc.ds0Rsc), 
                                     sizeof(RmPhyDs0));
                }
                else
                {
                      ret = cmMemcmp((U8 *) legId1rsc, 
                                     (U8 *) &(con->ogRsc.t.gr3Rsc.ds0Rsc), 
                                     sizeof(RmPhyDs0));
                }

                if (ret == 0)
                {
                  /* Do not allow this call */
                  ccProcessFailCnd(con, FC_INTERNAL, TRUE);
                  RETVALUE(ROK);
                }
                else
                {
                  CCLOGERR("ret = %d, %ld\n", ret, con->icSuConnId);
                }
              }
            }
          }
        }
#if 1 /*FGD*/
        if(((ogProtType == CC_CS_TG) || (ogProtType == CC_SI)) && 
            (icProtType == CC_CS_TG))
        {
          short  own, fec;
          U8     cos;
          /*
           * If we are AT and we fail to seize the egress trunk to IXC/INC,
           * send a steady offhook to EO and play announcement to the ingress
           * trunk */
          MAP_TGP_COS(cos, con->icTgAtt);
          MAP_TGP_FEC(fec, con->icTgAtt);
          MAP_TGP_OWN(own, con->icTgAtt);

          CCDP(AIN_DBG_LEVEL_2, "ccConE09S04:OWN:%d,FEC:%d,COS:%d\n", own,
               fec, cos);

          if((cos == CoS_FGD) && (own == TGP_OWN_CLASS_AT))
          {
            ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);
          }
        }
#endif /*FGD*/

        /* Feature 1839 - compatibility */
        if( CC_IS_COMPAT_SUPPORTED(con->icIntfcCb, con->icProtType) &&
           con->compatSt == COMPAT_NOT_START)
        {
           compatRet = ccProcessCompat(con);
           /* if failed, continue normal process */
        }
        /* end of compatibility */

        /* jiany BUG 61082 check whether COMPAT ACK received from ISUP */
        if (((compatRet == ROK) && (con->compatSt == COMPAT_ACK_RECVED))
                || (compatRet != ROK))
        {
            /* stop compatibility timer */
            ccStopConTmr(con, CC_TMR_AWAIT_COMPAT_ACK);
            ccSendOrSkipTerminationAttempt(con);
        }
      }
      else
      {
        /* wait for more digits */
        ccStartConTmr(TMR_INTERDGT, con, (PTR)con->icSapCb);
        CC_STATE_CHANGE(con, CCS_AWTENBLOCSND);
      }
      break; /* rmt_res_aloc_failure */
    case RMT_RES_INVALID:
    default:
      CCLOGERR("Resource Alloc failure: %d\n",con->ogRscSta);
      /* Bug# 10613: For outgoing IVR just send the REL with 
       * ivrSndCauseValue */ 
      if (NMBRCATEGORY_IVR(con))
      {
        if ((icProtType == CC_CS_TG) || (icProtType == CC_CS_LN) ||
            (icProtType == CC_GR303))
        {
          ccPlayTone(con, MGCT_PACKAGE_ID_CG, MGCT_SIG_ID_CG_BT);
          RETVALUE(ROK);
        }
        else
        {
          if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
              (con->icBcm.SndNotInd != SND_NOTIF_MAX))
          {
            CCDP(AIN_DBG_LEVEL_0, "Sending TermNot in ccConE09S04\n");
            ret = ccSendTerminationNot(&con->icBcm);
            if (ret != ROK)
            {
              CCDP(AIN_DBG_LEVEL_0, "Failed to send TermNotif\n");
            }
          }

          /* OgRsc Allocation fails for IVR, then just release the call
           * with IVR cause value*/
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, con->ivrSndcauseVal, NULLP);
          RETVALUE(ROK);
        }
      }
      else
      {
        if (ogProtType == CC_IN)
        {
          ccProcessFailCnd(con, FC_USRBUSY, TRUE);
        }
        else
        {
          ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);
        }
      }
      break;
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S04
 *
 *      Desc:  Connection state function
 *             event - Cct Release Indication 
 *             state - AWTRSCALOCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S04
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret    = RFAILED;

  TRC3(ccConE04S04)

  /* Feature 1839 - compatibility */
  if( CC_IS_COMPAT_SUPPORTED(con->icIntfcCb, con->icProtType) &&
      con->compatSt == COMPAT_SENDTO_ISUP)
  {
      ccStopConTmr(con, CC_TMR_AWAITANS);
      ccStopConTmr(con, TMR_SETUP);
      /* stop compatibility timer */
      ccStopConTmr(con, CC_TMR_AWAIT_COMPAT_ACK);
  }
  /* end of compatibility */

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {   
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }   
  else if (ret == RFAILED)
  {   
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }   
  else if (ret == ROKDRSIG)
  {
    /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect 
             notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n"); 
       /* Feature 1839 - compatibility: clear resource */
       if (CC_IS_COMPAT_SUPPORTED(con->icIntfcCb, con->icProtType) &&
           (con->compatSt == COMPAT_SENDTO_ISUP) && con->icProtType != CC_LOCAL_SWT_PROT)
       {
          ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
          if (ret != ROK)
          {
             CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
          }
          /* For compatibility, OG resource is allocated successfully at this point */
          ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
          ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

          ccSendReleaseRsp(con); /* Bug 64453 */
 
          ccDeallocateResource(con, CC_INCOMING);
          con->icRscVal = FALSE;

          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM); /* Bug 64453 */
 
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
 
          RETVALUE(ROK);
       }
       /* end of compatibility */
  }
  else
    /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
    CCDP(AIN_DBG_LEVEL_0, "O_Disconnect event is not Armed\n");

  /* Store the release event */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC340, (ErrVal) ret,
                 "ccConE04S04() Failed, ccStoreEvnt failed");
#endif
      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *) event;
      CC_STATE_CHANGE(con, CCS_IDLE);
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      RETVALUE(RFAILED);
    }
  /* Wait for  resource confirmation to clear the call */
  CC_STATE_CHANGE(con, CCS_AWTRSCCFM_TOCLR);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S04
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTRSCALOCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S04
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  TRC3(ccConE14S04)

    /* Send release to incoming side, Generate Alarm?              */
    /* Set icRscVal and ogRscVal to true so a deallocation request */
    /* will be sent to RM after getting a release confirm          */
    con->icRscVal = TRUE;
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  ccPlayToneOrRelease(con, CCTMPFAIL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S05
 *
 *      Desc:  Connection state function
 *             event - Release Indication 
 *             state - AWTENBLOCSND
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S05
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret;                 /* return value */

  TRC3(ccConE04S05)

  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* Release switching connection if one exists!!. However, Mgi context is
   * not expected in this state !*/
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccUpdateMgQForSubRsc((PTR) NULLP,
                         con->mgBlock->mgCtx->suCtxId, con);
    if (con->direction == INCTOOUT)
    {
      ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
      con->relPend = INRELRSPANDOUTREL;
    }
    else
      con->relPend = OUTRELRSPANDINREL;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_3, "No Switching Ctx found state/evnt==%d/%d\n",
         con->state, 4);
  }

  /* If MGI context is not available ( which is most likely in this case)
   * Go ahead and release the resource */

  ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
  con->direction = INCTOOUT;
  con->icEvnt = (CcAllSdus *) event;
  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  if(con->ogRscVal)
    ccDeallocateResource(con, CC_OUTGOING);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
#ifdef GUARD_TIMER
   ret = ccGuardOrDeallocResource(con, CC_INCOMING);
#else
  ret = ccDeallocateResource(con, CC_INCOMING);
#endif
  if (ret == RFAILED)
    {
      CC_STATE_CHANGE(con, CCS_IDLE);
      ccRelCon(con);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S05
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTENBLOCSND
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S05
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  TRC3(ccConE14S05)

    /* Send release to incoming side, Generate Alarm?   */
    ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
               LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  if (con->ogRscVal)
  {
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
  }
  ccPlayToneOrRelease(con, CCNORTTODEST);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE16S05
 *
 *      Desc:  Connection state function
 *             event - INTERDGT Timer Expiry
 *             state - AWTENBLOCSND
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE16S05
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  CcConEvnt ogEvnt;
  Addrs digits;
  ShrtAddrs digits32; /* FID: 2111  expand the buffer for ccAddCalledDigits */
  Buffer   *uBuf;
  U8	    i;

  TRC3(ccConE16S05)

  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

    /* If interdigit timer expires then send the   */
    /* connection request with the digits received */
    /* so far + the ST Digit                       */

  digits.length = 1;
  digits.strg[0] = ST_DIGIT;
  con->STDigitRecd = TRUE;
  ccAddRouteDigits(con->routeInfo, &digits);

  /* FID: 2111 expand the buffer for ccAddCalledDigits */
  digits32.length = digits.length;

  for(i=0; i< digits.length; i++)
  {
      digits32.strg[i] = digits.strg[i];
  }
  ccAddCalledDigits(con, (CcConEvnt *)con->ccEvntHold, &digits32);

  /* Send Call Proceeding if necessary */
  if (ccIsCallProcReqd(con->icProtType))
    ccSendCallProcReq (con);

  /* check if Switching can be performed now */
  if ((!ccIsSwtchingReqOk(con, con->ogProtType, con->icProtType)) ||
      (!con->ogRscVal))
    {
      /* map connect event and send outgoing con request */
      /* wait for resource confirm from OG imterface */
      CC_STATE_CHANGE(con, CCS_AWTOGRSC);
      con->icEvnt = con->ccEvntHold;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      con->direction = INCTOOUT;
      ret = ccMapEvent(con, CCE_CONIND, 0);
      if (ret != ROK)
        {
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          ccDropUBuf(&con->uBuf);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                        con->icProtType, CCPROTERR,NULL);
          RETVALUE(ROK);
        }
      con->dgtsInCdNum = con->routeInfo->nmbDigits;
      uBuf = con->uBuf;
      con->uBuf = NULLP;

      if (ccInit.acnt == TRUE)
        {
          con->callDtlInfo.cm.tckOgConReqSent.pres = PRSNT_NODEF;
          (Void) SGetSysTime(&con->callDtlInfo.cm.tckOgConReqSent.val);
        }

      cmHashListInsert(&con->ogSapCb->ogConsInstTbl, (PTR)con, 
                       (U8 *)&con->ogSuConnId, (U16)sizeof(UConnId));

      /* 57460 */
      ccUpdInterCcsTermPbxSubId(con);

      /* Bug#15674, rkhan */
      ccUpdSts(con->icSapCb,con->ogSapCb);
  
      /* FID 14457.0 + */
      if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
      {
        ccUpdGetsSts(con->ogProtType, CC_OUTGOING);
      } /* FID 14457.0 - */

#ifdef SAVE_PRFLID
      ccSaveProfileId(con); 
#endif
      ccProcessOCallSent(&con->icBcm);

      /* PreAnswer Timer is only started for CRBT Call */
      ccStartConTmr(CC_TMR_PREANM, con, (PTR)&ccCp.genCfg);

      CcLiCctConReq (&con->ogSapCb->pst, con->ogSapCb->spId, 
                     con->ogSuConnId, &con->ogRsc, con->ogProtType,
                     &ogEvnt, uBuf, con);
    }
  else
    {
      /* map connect event, send outgoing con request */
      /* and  send switching con request */
      CC_STATE_CHANGE(con, CCS_AWTANSSWT);
      con->icEvnt = con->ccEvntHold;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      con->direction = INCTOOUT;
      ret = ccMapEvent(con, CCE_CONIND, 0);
      if (ret != ROK)
        {
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          ccDropUBuf(&con->uBuf);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                        con->icProtType, CCPROTERR,NULL);
          RETVALUE(ROK);
        }
      con->dgtsInCdNum = con->routeInfo->nmbDigits;
      uBuf = con->uBuf;
      con->uBuf = NULLP;

      if (ccInit.acnt == TRUE)
        {
          con->callDtlInfo.cm.tckOgConReqSent.pres = PRSNT_NODEF;
          (Void) SGetSysTime(&con->callDtlInfo.cm.tckOgConReqSent.val);
        }

      cmHashListInsert(&con->ogSapCb->ogConsInstTbl, (PTR)con, 
                       (U8 *)&con->ogSuConnId, (U16)sizeof(UConnId));

      /* 57460 */
      ccUpdInterCcsTermPbxSubId(con);

      /* Bug#15674, rkhan */
      ccUpdSts(con->icSapCb,con->ogSapCb);

      /* FID 14457.0 + */
      if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
      {
        ccUpdGetsSts(con->ogProtType, CC_OUTGOING);
      } /* FID 14457.0 - */

#ifdef SAVE_PRFLID
      ccSaveProfileId(con); 
#endif
      ccProcessOCallSent(&con->icBcm);

      /* PreAnswer Timer is only started for CRBT Call */
      ccStartConTmr(CC_TMR_PREANM, con, (PTR)&ccCp.genCfg);

      CcLiCctConReq (&con->ogSapCb->pst, con->ogSapCb->spId, 
                     con->ogSuConnId, &con->ogRsc, con->ogProtType,
                     &ogEvnt, uBuf, con);
    }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE06S06
 *
 *      Desc:  Connection state function
 *             event - Resource Confirm 
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE06S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcCnStEvnt    ogEvnt;
  S16 ret;

  TRC3(ccConE06S06)
  CCDP(AIN_DBG_LEVEL_1, "ccConE06S06\n");

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));
  if (con->ogRscVal)
  {
    if (ccIsDifferentRscAllocated(con->ogProtType, &con->ogRsc, (RmRsc *)event))
    {
      if ((CC_GET_PROTOCOL(con->ogProtType) == CC_IN)&&
          (con->ogBcm.mgCtx))/* 90302 */
      {
          CCDP(AIN_DBG_LEVEL_1, "new ISDN ogRsc received,SUB the old ogRsc first!\n");
          ccUpdateMgQForSubRsc(&(con->ogBcm), con->ogBcm.mgCtx->suCtxId, con);
          con->relPend = OUTRSCSUBANDCLR;

          con->mgBlock->con = con;
          
          ret = ccSendMgiQueue(con->ogBcm.mgCtx->suCtxId, con->mgBlock);
          if (ret != ROK)
          {
              CCLOGERR( "Error: ccSendMgiQueue failed\n");
              cleanUpMgQ(con);
              ccCleanUpMGCtx(con);
              ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
              RETVALUE(RFAILED);
          }
          /* In case the re-route case, tmpRmRsc already has vale, clean first */
          if (con->tmpRmRsc)
          {
             CCDP(AIN_DBG_LEVEL_2,"release tmpRmRsc buffer\n");
             SPutSBuf(ccInit.region, ccInit.pool, con->tmpRmRsc, (Size)sizeof(RmRsc));
             con->tmpRmRsc = NULLP;
          }
          ret = SGetSBuf(ccInit.region, ccInit.pool,(Data **)&con->tmpRmRsc, (Size) sizeof(RmRsc));
          if (ret != ROK)
          {
             CCLOGERR( "SGetSBuf Failed for tmpRmRsc\n");
             ccRelCon(con);
             RETVALUE(RFAILED);
          }
          cmMemset((U8 *) (con->tmpRmRsc), 0, sizeof(RmRsc));
          cmMemcpy((U8 *)con->tmpRmRsc, (U8 *)event, sizeof(RmRsc));
          
          CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSUBADD);
          CCDP(AIN_DBG_LEVEL_1, "SUB send!\n");
          RETVALUE(ROK);
      }

      /* Send an Deallocation request to Resource Manager for the old rsc */
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;

      /* Send an allocation request to Resource Manager for the new rsc*/
      CC_STATE_CHANGE(con, CCS_AWTANS);

      /* TELICA-jwh-01/05/2001:  Don't reallocate original resource. */
#if 1 /* Start of code change */
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)event, sizeof(RmRsc));
#endif  /* End of code change */

      if ((ret = ccGetIntfcSap (&con->ogIntfcCb,
                                &(con->ogRsc.intfc))) != ROK)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
          CCLOGERROR(ERRCLS_DEBUG, ECC338, (ErrVal) ret,
                     "ccConE06S06() Failed, ccGetIntfcSap failed");
#endif
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
      } 
      if (con->ogIntfcCb)
         con->ogIntfcCb->nmbActvConn++; /* bug:18416 */

      ccAllocateResource(con, (CcConEvnt *)NULLP, CC_OUTGOING, RMT_RESERVE);
    }
    else
    {
      /* Outgoing resource has been confirmed by succeeding node   */
      CC_STATE_CHANGE(con, CCS_AWTANS);
    }

  }
  else
  {
    U8 alocType;

    /* outgoing resource allocated by the succeeding switch */
    /* request resource manager for verification            */

    cmMemcpy((U8 *) &con->ogRsc, (U8 *)event, sizeof(RmRsc));
    CC_STATE_CHANGE(con, CCS_AWTANS);
    alocType = ccGetOgRscAlocType(con->ogProtType);
    ccAllocateResource(con, (CcConEvnt *)NULLP, CC_OUTGOING, alocType);
  }

#if 0 /* Bug 59332 */
  /* Check if additional digits were received after ConReq */

  if (ccIsAddDigitsRecd(con->routeInfo, con->dgtsInCdNum))
  {
    CCLOGERR("** This functionality can't be supported so dlting***\n");
  }
#endif

  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE11S153
 *
 *      Desc:  Connection state function
 *             event - MG Confirm 
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S153
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  MgctTxnCfm    *txnCfm         = NULLP;
  S16            ret            = RFAILED;

  TRC3(ccConE11S153)
  CCDP(AIN_DBG_LEVEL_1, "ccConE11S153\n");
  
  txnCfm   = (MgctTxnCfm*) event;
  
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
 
  CCDP(AIN_DBG_LEVEL_1,"ogProtType %d, relPend is %d, ccn%d\n",
        CC_GET_PROTOCOL(con->ogProtType),con->relPend, con->ccmCb.ccn);
  
  ret = ccHandleMgResponse(con, txnCfm);
  
  if (ret != ROK)
  {
    CCLOGERR("%s: ccHandleMgResponse : failed\n", __FUNCTION__);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK); 
  }
  
  
  if(con->relPend == OUTRSCSUBANDCLR)
  {
    /* Send an Deallocation request to Resource Manager for the old rsc */
    ccDeallocateResource(con, CC_OUTGOING);
    con->relPend = OUTRSCADDANDALOC;
    cmMemcpy((U8 *) &con->ogRsc, (U8 *)con->tmpRmRsc, sizeof(RmRsc));
    if (con->tmpRmRsc)
    {
       CCDP(AIN_DBG_LEVEL_2,"release tmpRmRsc buffer\n");
       SPutSBuf(ccInit.region, ccInit.pool, con->tmpRmRsc, (Size)sizeof(RmRsc));
       con->tmpRmRsc = NULLP;
    }

    if ((ret = ccGetIntfcSap (&con->ogIntfcCb,
                    &(con->ogRsc.intfc))) != ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
        CCLOGERROR(ERRCLS_DEBUG, ECC338, (ErrVal) ret,
                "ccConE11S153() Failed, ccGetIntfcSap failed");
#endif
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
    } 
    if (con->ogIntfcCb)
        con->ogIntfcCb->nmbActvConn++; /* bug:18416 */
    /*Stay in S153 and wait for the Allocation Confirm */
    ccAllocateResource(con, (CcConEvnt *)NULLP, CC_OUTGOING, RMT_RESERVE);
    CCDP(AIN_DBG_LEVEL_1,"old ogRsc SUB and new will be allocate!\n");
    RETVALUE(ROK);
  }

  if(con->relPend == OUTRSCADDANDALOC)
  {
    CC_STATE_CHANGE(con, CCS_AWTANS);
    CCDP(AIN_DBG_LEVEL_1,"New Rsc ADDed,keep in S09 to wait for Cnst!\n");
  }
  
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S06
 *
 *      Desc:  Connection state function
 *             event - Release Indication 
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret  = RFAILED;
  CcRelEvnt ogEvnt;
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);

  CcCause   cause;
  TknU16    sipCause;
  TknU16    sipStatus;
  /* BUG: 88130 + */ 
  U8  networkBusyRelType = FC_NB_REMOTE_RELEASE;
  /* BUG: 88130 - */ 
  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */
  
  /* Stop the CC_TMR_PREANM timer if it is started */
  ccStopConTmr(con, CC_TMR_PREANM);

  /* Get protocol release cause */
  ccGetRelCause (con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType),
                 (CcRelEvnt *)event, &cause, &sipCause, &sipStatus);
  if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
  {
      con->tempHolderForReleaseCause = cause.causeVal.val;
      con->ainInfo.diconnectCause    = cause.causeVal.val;
  }

  if ((con->direction == INCTOOUT) ||
      ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup)))

  {

    /* Case where caller abandoned before the Call was established */
    /* GR 1298 never talks about this case */
    ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER, CSTD_CCITT,
                                CCCALRABANDON);

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
    ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
#ifdef CC_CALEA
  if (icProtType != CC_LOCAL_SWT_PROT)
  {
    /* Make sure ur in Tapped Con */
    ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
    if (ret != ROK)
    {
      CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
    }
  }
#endif
    /* Stop the O & T_NO_ANSWER timer if it is started */
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
#if 1 /* EARLY_ACM */
    ccStopConTmr(con, CC_TMR_EARLYACM);
#endif

    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    /* verify if the Release request to be held till a resource */
    /* confirm is received for the call from the outgoing side  */
    /* (the release request is held if o/g side is BISUP) */
    if (ccIsReleaseReqdToBeHeld(con->ogProtType))
    {
      CC_STATE_CHANGE(con, CCS_AWTOGRSC_TOCLR);
      /* Store the release event for future mapping */
      if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC342, (ErrVal) ret,
                 "ccConE04S06() Failed, ccStoreEvnt failed");
#endif
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
      ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);

      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
#if 1 /* EARLY_ACM */
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP,
                           con->mgBlock->mgCtx->suCtxId, con);

        con->relPend = INRELRSPANDOUTREL;

        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);

        /* Bug 83259: Store the incoming Release event,it will be used in ccConE11S55 */
        if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {
          CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
        }

        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "Error: ccSendMgiQueue failed\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
        }
        else
          RETVALUE(ROK);
      }
#endif

      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

#ifdef GUARD_TIMER
      ret = ccGuardOrDeallocResource(con, CC_INCOMING);
#else
      ccDeallocateResource(con, CC_INCOMING);
#endif
      con->icRscVal = FALSE;

      ret = ccMapEvent(con, CCE_RELIND, 0);
      if (ret != ROK)
      {
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCPROTERR,NULL);
      }
      else
        ccSendReleaseReq(con);

    }
  }
  else if (con->direction == OUTTOINC)
  {
    if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup))
    {
      ret = ccProcessDisconnectEvent(con, event);

      if (con->surrogate != NULLP)
        ccProcessDisconnectNotfnForSurrogateLegs(con, event);

      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
        RETVALUE(ROK);
      }
      CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
    }
    /* We are in this function if outgoing is ISDN */

    /*CASE where the og ISDN release the call due to UserBusy */
    /* As per R5-[637] of GR 1298 */
    if ((cause.causeVal.val == CCNOCIRCUIT) || (cause.causeVal.val == CCUSRBSY))
      ccUpdateBusyCauseForTermNot (con, con->ogProtType, cause.location.val, 
                                   cause.location.val, cause.causeVal.val);
    if (CC_IS_REMOTE_REL(con->mntRelProc) && ccIsRelCauseRaProtRel(con, cause, sipCause, sipStatus))
    {
        /* FID 14716.0 */
        CC_SET_CALL_FLAG(con->flag, CC_FLAG_GROVRFLW_SKIP);

#if 1 /* BUG:71993. Do not use same BGN when doing ROUTE_ADVANCE due to
         NETWRK_BSY condition. Skip over to find index of new BGN*/
        RmInterface currIntfc;
        RmInterface prevIntfc;

        currIntfc = 
              con->routeEvnt->ogInterface[con->routeEvnt->currentInterface];

        prevIntfc =
              con->routeEvnt->ogInterface[con->routeEvnt->currentInterface - 1];

        /* Skip indexes till new TGN is found */
        while ((ROK == ccCheckForInterfaces(con)) &&
               (CC_ROUTE_ADVANCE_NOT_MULTIRR(con) && 
                (CC_IS_SAME_INTFC(prevIntfc, currIntfc) || 
                 ccCheckDupIsdnPseudoTgnForCurIntfc(con)))) /*FID 16796.0*/
        {
              currIntfc = 
                con->routeEvnt->ogInterface[++con->routeEvnt->currentInterface];
              CCDP(AIN_DBG_LEVEL_0, " Skipping to %ld. prevbgn %d-%d\n",
                  con->routeEvnt->currentInterface, prevIntfc.intfType,
                  prevIntfc.t.tgrpDesc.tgrpId);
        }
#endif /* BUG:71993. End 1*/

      con->tempHolderForReleaseCause = cause.causeVal.val;
      ret = ccCheckForInterfaces(con);
      if ((ret == ROK) && (CC_ROUTE_ADVANCE(con)))
      {
        CCDP(AIN_DBG_LEVEL_0, "Proceeding with ReRoute: icSu: %ld\n",
                              con->icSuConnId);
        ccReRouteCall(con, CC_MG_NULL);
        RETVALUE(ROK);
      }
      else
      {
        /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
        if (CC_IS_SIP_CONTACTURI_AVAIL(con))
        {
          CC_ADVANCE_CONTACT_URI_LIST(con, ret);

          if (ret == ROK)
          {
             CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                 "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                 con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
            RETVALUE(ROK);
          }
        }
        else if (CC_IS_SIP3XXCALL(con))
        {
          /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
             is needed for reroute due to default failCndId processing */
          ccRestoreEvntHold(con);
          ccRestoreOrigParamFor3xxCall(con);
        }
    
        CC_FREE_SIP3XX_BLOCK(con);
        /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */

        /* Bug 88130 + */
        if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_HPCQ_AR) && (!con->interCcsLocalBusy))
        {
          if ((con->icBcm.nel[EReqNetworkBusy] == NEL_REQUEST) &&
              (con->icBcm.svcHeader.transId)) 
          {
            con->icBcm.nel[EReqNetworkBusy] = NEL_UNARMED;
          }
        }
            
        if (con->interCcsLocalBusy)
        {
           /* Default is FC_NB_REMOTE_RELEASE */
           networkBusyRelType = FC_NB_LOCAL_RELEASE;
        }
        /* Bug 88130 - */

        CCDP(AIN_DBG_LEVEL_0, "Check For NetworkBusy Event: %ld\n",
                              con->icSuConnId);
        ccFillBusyCauseFromRelCause(con, &cause);
        ret = ccProcessNetworkBusy(&(con->icBcm), networkBusyRelType);
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Network Busy Detected: %ld\n",
                                con->icSuConnId);
          if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                  (U8 *)event, sizeof(CcRelEvnt))) != ROK)
          {
            CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
          }
          RETVALUE(ROK);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "Network Busy Not Armed: %ld\n",
                                con->icSuConnId);
          /* Drop down for default treatment */
        }
      }
    }
    if ((!CC_CAUSE_IS_VAL(&cause, CCCALLCLR, CSTD_CCITT)) &&
        (!CC_CAUSE_IS_VAL(&cause, CCNORMUNSPEC, CSTD_CCITT)) &&
        (con->icBcm.pic != PicOActive))
    {
      con->tempHolderForReleaseCause = cause.causeVal.val;
      ret = ccProcessOCalledPartyBusy(&(con->icBcm));
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "Detected OCdPrtyBusy:%ld\n", con->icSuConnId);
        RETVALUE(ROK);
      }
    }

    if (ret != ROKIGNORE) /* If OCalledParty is was reported then go ahead
                           * and release call */
    {
      /* Bug 37463 -- Check for ODisconnect*/
      ret = ccProcessDisconnectEvent(con, event);
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
        RETVALUE(ROK);
      }
      else if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
      }
      /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
      CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
    }

    UPDATE_OPIC(con, PicSelectRoute);
    /* Stop the O & T_NO_ANSWER timer if it is started */
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
#if 1 /* EARLY_ACM */
    ccStopConTmr(con, CC_TMR_EARLYACM);
#endif


    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    /* Send Resource Dealocation for initiating side */
    /* Send Release response and map the release    */

    /* Do not Relase incoming ISDN rsc on the rcving disconnect 
     * from remote side */

    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

    con->icEvnt = (CcAllSdus *) event;
    con->ogEvnt = (CcAllSdus *) &ogEvnt;
    if (con->direction == OUTTOINC)
    {
        con->failCndVal = ccMapProtRel2FailCnd (con, &cause, &sipCause, &sipStatus);
    }

#if 1 /* EARLY_ACM */
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      ccUpdateMgQForSubRsc((PTR) NULLP,
                           con->mgBlock->mgCtx->suCtxId, con);

      if ((con->direction == OUTTOINC) && ((con->reconnectBcm == OBCM)||(con->reconnectBcm == TBCM)) )
      {
         con->relPend = OUTRELRSPANDINREL;
      }
      else if ((con->direction == OUTTOINC) &&
          ((ccIsLEGSubscriber(&(con->icBcm))) || ((icProtType == CC_CS_TG) &&
          ((CC_CAUSE_IS_VAL(&cause, CCNORMUNSPEC, CSTD_CCITT) == FALSE) &&
          (CC_CAUSE_IS_VAL(&cause, CCCALLCLR, CSTD_CCITT) == FALSE)))))
      {
        con->relPend = OUTRELRSPANDINTONE;
      }
      else if (con->direction == OUTTOINC)
      {
        con->relPend = OUTRELRSPANDINREL;
      }
      else
      {
        con->relPend = INRELRSPANDOUTREL;
      }

      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);

      /* Bug 83259: Store the incoming Release event,it will be used in ccConE11S55 */
      if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
      {
        CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
      }

      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR( "Error: ccSendMgiQueue failed\n");
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        RETVALUE(ROK);
    }
#endif

    if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
    ccDeallocateResource(con, CC_OUTGOING);
#endif

    con->ogRscVal = FALSE;

    /* If required play busy/reorder tone on usrBusy relCause */
    /* Extract the release cause  from ISDN side */
    if ((ccIsLEGSubscriber(&(con->icBcm))) || ((icProtType == CC_CS_TG) &&
        (CCNORMUNSPEC != cause.causeVal.val) && (CCCALLCLR != cause.causeVal.val)))
    {
      /* Bug 25360  */ 
      if (cause.causeVal.val == CCDESTOUTORD)
      {
	cause.causeVal.val = CCUSRBSY;  
	/* user busy  - we want reorder tone to be played, when
	   audible ringing has not been applied yet */
      }
      /* Bug 25360 */

      ccStopConTmr (con, TMR_RELEASE);
      ccStartConTmr (TMR_SETUP, con, (PTR)&ccCp.genCfg);
      ret = ccProcessFailCnd (con, con->failCndVal, FALSE);
      if (ret == ROK)
          RETVALUE (ROK);

    }

    ret = ccMapEvent (con, CCE_RELIND, 0);
    if (ret != ROK)
    {
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCPROTERR,NULL);
    }
    else
      ccSendReleaseReq(con);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S06
 *
 *      Desc:  Connection state function
 *             event - Release Confirmation 
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                 ret;
  CcRelEvnt           ogEvnt;
  ProtType            icProtType      = CC_GET_PROTOCOL(con->icProtType);

  TRC3(ccConE05S06)
  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
    ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
#ifdef CC_CALEA
  if (icProtType != CC_LOCAL_SWT_PROT)
  {
    /* Make sure ur in Tapped Con */
    ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
    if (ret != ROK)
    {
      CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
    }
  }
#endif
  ret = RFAILED;

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELCFM, (PTR) event);
  /* FID 14732 */                 


      if (con->direction == INCTOOUT)
        {
          /* verify if the Release request to be held till a resource */
          /* confirm is received for the call from the outgoing side  */
          /* (the release request is held if o/g side is BISUP) */
          if (ccIsReleaseReqdToBeHeld(con->ogProtType))
            {
              /* Store the release event for future mapping */
              if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
                {
#if (ERRCLASS & ERRCLS_DEBUG)
                  CCLOGERROR(ERRCLS_DEBUG, ECC344, (ErrVal) ret,
                             "ccConE04S06() Failed, ccStoreEvnt failed");
#endif
                  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                                con->icProtType, CCTMPFAIL,NULL);
                  RETVALUE(RFAILED);
                }
              CC_STATE_CHANGE(con, CCS_AWTOGRSC_TOCLR);
            }
          else
            {
              /* Send Resource Dealocation for initiating side */
              /* Map the release    */
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
              con->icEvnt = (CcAllSdus *) event;
              con->ogEvnt = (CcAllSdus *) &ogEvnt;

              ccDeallocateResource(con, CC_INCOMING);
              con->icRscVal = FALSE;      
              ret = ccMapEvent(con, CCE_RELCFM, 0);
              if (ret != ROK)
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                              con->ogProtType, CCPROTERR,NULL);
              else
                ccSendReleaseReq(con);
            }
        }
      else if (con->direction == OUTTOINC)
        {
          /* Send Resource Dealocation for initiating side */
          /* Map the release    */
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          con->icEvnt = (CcAllSdus *) event;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;

          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;      

          ret = ccMapEvent(con, CCE_RELCFM, 0);
          if (ret != ROK)
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                          con->icProtType, CCPROTERR,NULL);
          else
            ccSendReleaseReq(con);
        }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE07S06
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - Reattempt
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE07S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcGenSap *rmCb;

  /* If static binding then release the connection */
      /* Reroute */
      rmCb = con->rmSapCb;

      /* Send a resource allocation request to RM to allocate another */
      /* resource at the same interface and retry the call */
      con->ogRscVal = FALSE;
      CC_STATE_CHANGE(con, CCS_AWTRSCALOCCFM);
      CcLiRmtAlocReq (&rmCb->pst, rmCb->spId, con->icSuConnId, 
                      con->ogProtType, RMT_MOD, &(con->ogRsc),
                      &con->tfcDsc, FALSE, NULLP, &con->icAddnlRscInfo, NULLP);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE13S06
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - InitRel
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE13S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  U8 relCause = CCCALLCLR;


  TRC3(ccConE13S06)

  /* The INITREL indication only comes from outgoing interface */

  /* Start of Bug#16346 : gb - Play tone after ISDN/SS7 finsh the RelCfm */
  if((con->direction == OUTTOINC) && (ogProtType == CC_IN))
  {
    CcStaEvnt *ccStaEvnt = (CcStaEvnt*)(event);

    if(ccStaEvnt == NULLP)
     relCause = CCSWTCHCONG;
    else
      relCause = ccStaEvnt->ccRelCalEvnt.ccCause.causeVal.val;
  }
  else
    relCause = CCSWTCHCONG;

  if((relCause != CCCALLCLR) &&
     (icProtType == CC_GR303 || icProtType == CC_CS_LN || icProtType == CC_CS_TG))
  {
     /* gb - Pending - Needs some design changes */
  }

  /* Initiate release in both directions */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
  ccProcRelCall(con, (CcStaEvnt *)event);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S06
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE14S06: %ld\n", con->icSuConnId);

  /* Initiate release in both directions */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  CCLOGERR("Setup timer expired: %ld, %d\n", con->icSuConnId, con->state);
   ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE01S07
 *
 *      Desc:  Connection state function
 *             event - Connect Confirm 
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE01S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* bug:20391, 20077 - gb - We should buffer if we have buffered some
   * previosuly */

  /* We can't process this untill MGI-txn-Cfm is rcvd */
  /* Acting on This Answer message will alter the sequence of messages
   * already buffered (example : S03S07) */

  ccBufferEventToQueue(con, bcm, event, CCE_CONCFM, sizeof(CcConEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE02S01
 *
 *      Desc:  Connection state function
 *             event -
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/

#ifdef ANSI
PRIVATE S16 ccConE02S01
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
 )
#else
PRIVATE S16 ccConE02S01(con, event, bcm, event2)
CcConCb *con;                    /* connection */
PTR     event;                   /* event */
AinBCM_t *bcm;                    /* bcm */
PTR     event2;                   /* event */
#endif
{
  S16 ret = RFAILED;

  TRC3(ccConE02S01)

    CC_DISCARD_SAM(con); /* FID 15174.0 */

    /* map connection status event */
    con->icEvnt = (CcAllSdus *)event;
    ret  = ccAddSubsqCalledDigits(con);
    if((con->ccEvntHold) &&
       ((CC_GET_PROTOCOL(con->icProtType) == CC_SI) ||
        (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC)) &&
       CC_STDIGIT_PRESENT(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum))
    {
        con->STDigitRecd = TRUE;
    }
    /* Append subsequent digits to what was already recvd */
    RETVALUE(ret);
}
/*
 *
 *      Fun:   ccConE02SBUF
 *
 *      Desc:  Connection state function
 *             event - CCE_ADDRIND
 *             state - all state
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
#ifdef ANSI
PRIVATE S16 ccConE02SBUF
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
 )
#else
PRIVATE S16 ccConE02SBUF(con, event, bcm, event2)
CcConCb *con;                    /* connection */
PTR     event;                   /* event */
AinBCM_t *bcm;                    /* bcm */
PTR     event2;                   /* event */
#endif
{
    CCDP(AIN_DBG_LEVEL_1, "ccConE02SBUF:icSu 0x%lx ogSu 0x%lx con->waitForMoreInfo 0x%2x\n",
       con->icSuConnId, con->ogSuConnId, con->waitForMoreInfo);
    CC_DISCARD_SAM(con); /* FID 15174.0 */
    ccBufferEventToQueue(con, bcm, event, CCE_ADDRIND, sizeof(CcConEvnt),
                       con->icSuConnId, NULLP, 0);

    /* mark the buffer bit for SAM event */
    CC_MARK_SAMBUFFERED(con);

    RETVALUE(ROK);
} /* End of ccConE02SBUF */



/*
 *
 *      Fun:   ccConE03S06
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - AWTOGRSC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret  = RFAILED;
  Bool           isUpdateRcvd   = FALSE;
  Bool           isPrackRcvd    = FALSE;
  Bool           isUpdateRspRcvd    = FALSE;
  Bool           isPrackRspRcvd  = FALSE;


  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    else if (ret == ROKDRSIG)
    {
      /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
      CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (con->icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif 
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    /* Stop the O and T_NO_ANSWER timer if it is started */
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
    ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, CCCALLCLR, NULL);
    RETVALUE(ROK);
  }
  else
  {

    /* FID15068.0 */
    isUpdateRcvd = ccIsUpdateRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->icEvntType, con->direction);
    isPrackRcvd = ccIsPrackRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->icEvntType, con->direction);
    isUpdateRspRcvd = ccIsUpdateRspRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->icEvntType, con->direction);
    isPrackRspRcvd = ccIsPrackRspRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->icEvntType, con->direction);

    if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) && 
        (isUpdateRcvd || isPrackRcvd || isUpdateRspRcvd || isPrackRspRcvd))
    {
        ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                           NULLP, 0);
        CCDP(AIN_DBG_LEVEL_2, "%s Precondition buffer E03 icEvntType %d\n", __FUNCTION__, con->icEvntType);
        RETVALUE(ROK);
    }

     CCLOGERR( "ccConE03S06: unexpected CnStInd in state 6 from %d/%d(%d)"
                "with event type==%d\n", con->icProtType, con->ogProtType,
                con->direction, con->icEvntType);
     RETVALUE(ROK);
  }

  RETVALUE(ROK);
}



/*
 *
 *      Fun:   ccConE03S07
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcCnStEvnt ogEvnt;
  ProtType   ogProtType = CC_GET_PROTOCOL(con->ogProtType);

  /* if SDM sent in the forward direction to SIPT after IAM and before ACM then buffer it */
  if ((con->icEvntType == CC_ET_SDM) && (con->direction == INCTOOUT) && 
          (ogProtType == CC_SIPT) && !(con->isACMSent))
  {
     CCDP(AIN_DBG_LEVEL_2, "ccConE03S07 - Buffering SDM in Queue\n");
     ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);

     RETVALUE(ROK);
  }
  /* End of FID 14677.0 ITU99 */

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                           NULLP, 0);
      RETVALUE(ROK);
  }

/* Removed as part of Bug# 10613, Not required as no CnStInd msgs will be
 * sent to Ingress, they will be prepared and sent when ConCfm is received */ 
   if (NMBRCATEGORY_IVR(con))
   {
      RETVALUE(ROK);
      /* No need to store or send the connection progress message to Ingress */ 
   }

  /* map connection status event */
  con->icEvnt = (CcAllSdus *)event;
  con->ogEvnt = (CcAllSdus *)&ogEvnt;

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    con->relPend = BOTHREL;
    /* wait for MGI rsp to do any call clearing */
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }

  CCDP(AIN_DBG_LEVEL_2, "Buffering EVENT until MGI-txn-Cfm is rcvd:%ld, %ld\n",
       con->icSuConnId, con->ogSuConnId);
  ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE04S65
 *
 *      Desc:  Connection state function
 *             event - Release Indication.
 *             state - CCS_AWTSWTCFMFORHOLD
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S65
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S65:%ld,%ld\n", con->icSuConnId, con->ogSuConnId);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE04S07
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16    ret = RFAILED;
    CcCause cause;
    ProtType        icProtType     = CC_GET_PROTOCOL(con->icProtType);
    ProtType        ogProtType     = CC_GET_PROTOCOL(con->ogProtType);
    TknU16          sipCause;
    TknU16          sipStatus;

    CCDP(AIN_DBG_LEVEL_1, "ccConE04S07\n");

    /* Get protocol release cause */
    ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType), (CcRelEvnt *)event, &cause,
                   &sipCause, &sipStatus);
    if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
    {
        con->tempHolderForReleaseCause = cause.causeVal.val;
        con->ainInfo.diconnectCause    = cause.causeVal.val;
    }



    /* As per R5-[637] of GR 1298 */
    if ((ogProtType == CC_SI) && (con->direction == OUTTOINC))
    {
        /* Interswitch call */
        if (CC_CAUSE_IS_VAL(&cause, CCNOCIRCUIT, CSTD_CCITT) || 
            CC_CAUSE_IS_VAL(&cause, CCUSRBSY, CSTD_CCITT))
        {
            ccUpdateBusyCauseForTermNot(con, con->ogProtType, cause.location.val,
                                        cause.cdeStand.val, cause.causeVal.val);
        }
        else
        {
            /* This is not per standard */
            ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                        CCCALRABANDON);
        }
    }
    else if ((ogProtType == CC_IN) && (con->direction == OUTTOINC))
    {
        if (CC_CAUSE_IS_VAL(&cause, CCNOCIRCUIT, CSTD_CCITT) || 
            CC_CAUSE_IS_VAL(&cause, CCUSRBSY, CSTD_CCITT))
        {
            ccUpdateBusyCauseForTermNot(con, con->ogProtType, cause.location.val,
                                        cause.cdeStand.val, cause.causeVal.val);
        }
        else
        {
            /* This is not per standard */
            ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                        CCCALRABANDON);
        }
    }
    else
    {
        /* It can be release from the incoming side */
        /* Case where caller abandoned before the Call was established */
        /* GR 1298 never talks about this case */
        if (con->direction == INCTOOUT)
        {
            ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER, CSTD_CCITT,
                                        CCCALRABANDON);
            ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
        }
        else
        {
            ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                        CCCALRABANDON);
        }
    }

    /* FID 14732 */
    ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
    /* FID 14732 */

    /* Clean the answer fraud Call */
    ccCleanAnsFraudCall(con);

#if 1 /* EARLY_ACM */
    ccStopConTmr(con, CC_TMR_EARLYACM);
#endif
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
    {
        CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
    }
  
    if(con->direction == INCTOOUT)
    {
        con->relPend = INRELRSPANDOUTREL;
        /* wait for MGI rsp to do any call clearing */
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
        RETVALUE(ROK);
    }
    else /* OUTTOINC */
    {
       if ((con->direction == OUTTOINC) &&
          ((ccIsLEGSubscriber(&(con->icBcm))) ||
           (CC_IS_CAUSEMAP_SUPPORTED (ogProtType)) ||
           ((icProtType == CC_CS_TG) &&
          ((CC_CAUSE_IS_VAL(&cause, CCNORMUNSPEC, CSTD_CCITT) == FALSE) &&
          (CC_CAUSE_IS_VAL(&cause, CCCALLCLR, CSTD_CCITT) == FALSE)))))
        {
            con->relPend = OUTRELRSPANDINTONE;
        }
        else if (con->direction == OUTTOINC)
        {
            con->relPend = OUTRELRSPANDINREL;
        }
        else
        {
            con->relPend = INRELRSPANDOUTREL;
        }

        /* wait for MGI rsp to do any call clearing */
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
        RETVALUE(ROK);
    }
}


/*
 *
 *      Fun:   ccConE05S07
 *
 *      Desc:  Connection state function
 *             event - Release Confirmation
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;

  /* Store the release event for future mapping */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELCFM, (PTR) event);
  /* FID 14732 */                 

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC347, (ErrVal) ret,
                 "ccConE05S07() Failed, ccStoreEvnt failed");
#endif
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                    con->ogProtType, CCTMPFAIL,NULL);
      RETVALUE(RFAILED);
    }

  /* this would be a release intitiated due to release confirm */
  /* so no release response is required to be sent */
  con->noRspReqd = TRUE;

 if(con->direction == INCTOOUT)
  {
    con->relPend = INRELRSPANDOUTREL;
    /* wait for MGI rsp to do any call clearing */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }
  else /* OUTTOINC */
  {
    con->relPend = OUTRELRSPANDINREL;
    /* wait for MGI rsp to do any call clearing */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE07S07
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - Reattempt
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE07S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* wait for Switching connect confirm first */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  con->reatRelProc = TRUE;
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE09S09
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirm 
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt;
  CCDP(AIN_DBG_LEVEL_1, "ccConE09S09\n");

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  rscEvnt = (RmAlocCfmEvnt *)event;
  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
     if (!con->icRscVal)
     {
        con->icRscVal = TRUE;
        cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
     }
     else if (!con->ogRscVal)
     {
    con->ogRscVal = TRUE;
    cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
     }
     else
     {
       CCLOGERR("Both icRscVal and ogRscVal is FALSE");
       RETVALUE(RFAILED);
     }

    /* Copy Additional Resource Information */
    if (rscEvnt->addnlRscInfo != NULLP)
    {
      cmMemcpy((U8 *) &con->icAddnlRscInfo, (U8 *)rscEvnt->addnlRscInfo,
               sizeof(RmAddnlRscInfo));
    }
    else
      con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

    /* Copy the mBuf received from RM */
    if (con->icRscMBuf)
      SPutMsg(con->icRscMBuf);
    con->icRscMBuf = rscEvnt->mBuf;
    rscEvnt->mBuf = NULLP;


    /* Copy the modified traffic descriptor */
    cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc, sizeof(RmTfcDesc));
    /* Stay in the Same State (AWT_ANS) */
  }
  else if (rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE)
  {
    CCLOGERR("Resource Allocation failed:icSu:%ld, status:%d\n",
              con->icSuConnId, rscEvnt->rscSta1);
    /* Bukucu - Bug-28058 */
    con->ogRsc.rscPres = FALSE;
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
  }

  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE09S07
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirm 
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt;
    rscEvnt = (RmAlocCfmEvnt *)event;

  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
    {
      /* Outgoing resource has been verified by the RM */
      /* go ahead with the  switching of the resources */
      con->ogRscVal = TRUE;
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));


      /* Copy Additional Resource Information */
      if (rscEvnt->addnlRscInfo != NULLP)
        {
          cmMemcpy((U8 *) &con->icAddnlRscInfo, 
                   (U8 *)rscEvnt->addnlRscInfo, 
                   sizeof(RmAddnlRscInfo));   
        }
      else
        con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

      /* Copy the mBuf received from RM */
      if (con->icRscMBuf)
        SPutMsg(con->icRscMBuf);
      con->icRscMBuf = rscEvnt->mBuf;
      rscEvnt->mBuf = NULLP;


      /* Copy the modified traffic descriptor */
      cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc, 
               sizeof(RmTfcDesc));

    }
  else if (rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE)
    {
      /* The outgoing resource verification failed */
      /* Initiate release on both interfaces       */
      ccCp.sts.fResUnavail++;
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(ROK);
    }
         
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE11S07
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm 
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                  ret     = RFAILED;
  MgctTxnCfm           *txnCfm = NULLP;
  CcCnStEvnt           ogEvnt;
#ifdef CC_CALEA
  MgctEcho             ingressEcho;
  MgctEcho             egressEcho;
  MgctEcho             *pIngrEcho  = NULLP;
  MgctEcho             *pEgrEcho   = NULLP;
  MgctCallProgItemId  mgSignal   = MGCT_ITEM_ID_CG_MAX;
#endif
  CcFailCondId         failCnd = FC_NOT_APPLICABLE;
  ProtType             ogProtType = 0;
  MgctMediaDesc        mediaDesc, *pMediaDesc = NULLP;
  Bool                 precnd = FALSE;

  /* FID 14840 AoC */
  ProtType               icProtType     = 0;
  /* End of FID 14840 AoC */
  TknU8                   DSVal;

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S07\n");

  DSVal.pres = NOTPRSNT;
  DSVal.val = 0;

  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt)); 
  ogProtType = CC_GET_PROTOCOL(con->ogProtType);

  icProtType = CC_GET_PROTOCOL(con->icProtType); /* FID 14840 AoC */

  cmMemset((U8*)&mediaDesc, 0, sizeof(MgctMediaDesc));
  pMediaDesc = &mediaDesc;

  /* Bug: 35674, uBuf is stored in tmpUbuf before going to S07 in S09
   * Restore it from tmpUBuf before proceeding with anything
   */
  CC_RESTORE_UBUF(con);
  txnCfm   = (MgctTxnCfm*) event;
  ret = ccHandleMgResponse(con, txnCfm);
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0, "Success Received from MGI Layer\n");

    /* FID 15261.0 & FID 15083.0 + */
    if (CC_IS_CALL_MULTI_MG(con))
    {
      if (con->ccmCb.ccn == CCN_1)
      {
        if (con->ccmCb.state == CC_EGRESS_MG)
        {
          con->ccmCb.state = CC_INGRESS_MG;
          /* bug 74612 restore the held direction */
          con->direction =CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          return(ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold));
        }
      }
      else
      {
        if (con->ccmCb.state == CC_EGRESS_MG)
        {
          if (con->ccmCb.ccn == CCN_5)
          {
            con->ccmCb.state = CC_Y_MG;
            con->direction =CC_GET_EVNTHOLD_DIR(con->directionHeld);
            con->icEvntType = con->evntTypeHeld;
            return(ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold));
          }
          else
          {
            con->ccmCb.state = CC_INGRESS_MG;
            con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
            con->icEvntType = con->evntTypeHeld;
            return(ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold));
          }
        }
        else if (con->ccmCb.state == CC_Y_MG)
        {
          con->ccmCb.state = CC_INGRESS_MG;
          con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          return(ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold));
        }
      }
    }
    /* FID 15261.0 & FID 15083.0 - */

    /* FID17160.0 Need to do the ADD for ConCurBcm */
    if (CC_IS_STEROMONO_CALL(con))
    {
       if (con->ccmCb.state == CC_EGRESS_MG)
       {
          con->ccmCb.state = CC_INGRESS_MG;
          con->direction =CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          return(ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold));
       }
    }

    if (CC_IS_MRF(con->mrfFlag, MRF_183_ANNC)) 
    {
      CCDP(AIN_DBG_LEVEL_1, "MRF call with flag %d\n", con->mrfFlag);
      CC_SET_MRF(con->mrfFlag, MRF_PLAYING_ANNC);

      /*set the OG OFFANS state after send PRACK */
      if (CC_OFFANS_OGRMTOFFER_PENDING(con))
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                         CC_OFFANS_STATE_RCVDOFFER,
                                         CC_OFFANS_GET_SUBSTATE(con),
                                         CC_OFFANS_METHOD_USED(con));
      }
      else if(CC_OFFANS_OGRMTANS_PENDING(con))
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                      CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));
      }

      /* free the locDesc if OG offer/answer completed */
      if (!CC_OFFANS_OGOFFANS_PENDING(con))
      {
        if (con->ogIpParam.locDesc)
          cmFreeSdp(ccInit.region, ccInit.pool, &con->ogIpParam.locDesc);
      }

      /* Send PRACK to MRF if incoming do NOT support 100rel */
      if((icProtType == CC_SI)||
          (((icProtType == CC_SIP)||(icProtType == CC_SIPT)) &&
             (!CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask) || CC_OFFANS_OGOFFANS_STATE_NULL(con)))) 
      {
        ccSendPrack(&con->ogBcm);
      } 

      if (((con->remoteSdpSentOnIcBCM&&con->renegSdpAfterAns) ||con->isAnsIndSent) &&
          (CC_OFFANS_ICOFFANS_STATE_NULL(con))
         )
      {
        CCDP(AIN_DBG_LEVEL_1,"will send update %lx\n",con->icSipMethodSupMask);
        if(CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask)) 
        {
          ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, 0x00,
                           ccLcfUpdateCbFunc, (PTR)con, CCS_AWT_MRFRSP);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_1,"Update not supported!\n");
          CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
        }
        /* MRF with MG: If incoming don't support update, don't send any message to IC */
      }
      else
      {
          ret = ccSendBackwardMessageForAnnoucement(con, con->ainInfo.Resourcetype.val, FALSE, TRUE);
          if (ret != ROK)
          {
            CCLOGERR("%s: Error, ccSendBackwardMessageForAnnoucement failed icSu=0x%lx\n",
                __FUNCTION__,con->icSuConnId);
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            RETVALUE(ret);
          }
 
          CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
      }


      /* set the incoming OFFANS state before send message to incoming */
      if (CC_OFFANS_ICOFFER_PENDING(con))
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                         CC_OFFANS_STATE_NO_OP,
                                         CC_OFFANS_SUBSTATE_AWAITRMTANS_INVITENOSDP,
                                         CC_OFFANS_TYPE_REL18X_INVITENOSDP);
      }
      else if(CC_OFFANS_ICANS_PENDING(con))
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));
      }
      RETVALUE(ROK);
    }   
    CC_STATE_CHANGE(con, CCS_AWTANS);
    ccProcessCcChangeforX2SIG(con); /* FID 15083.0 */

    /* FID15068.0 */
    if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
        (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP)) &&
        ((icProtType == CC_SIP || icProtType == CC_SIPT) && 
         (ogProtType == CC_SIP || ogProtType == CC_SIPT)) &&
         (CC_IS_CONTEXT_PRESENT(con)) &&
         (con->icPrecndCb) &&
         (!con->icPrecndCb->mask))
      /* set the ingress precond cb */
    {
        if ((con->ogPrecndCb) && (con->icPrecndCb))
        {
          U8 i=0;
          U8 locSend = PRECND_STRENGTH_OPTIONAL;
          U8 locRecv = PRECND_STRENGTH_OPTIONAL;
          U8 rmtSend = PRECND_STRENGTH_OPTIONAL;
          U8 rmtRecv = PRECND_STRENGTH_OPTIONAL;

          for (i=0; i<SDP_MAX_MEDIA; i++)
          {
            if (!((0x01 << i) & (con->ogPrecndCb->mask)))
              continue;

            con->icPrecndCb->mask  = con->ogPrecndCb->mask;

            SET_PRECND_TYPE(con->icPrecndCb->precnds[i].curConfStat, PRECND_QOS);
            SET_PRECND_STATUS_TYPE(con->icPrecndCb->precnds[i].curConfStat, PRECND_STATUS_LOCRMT);

            CCDP(AIN_DBG_LEVEL_1, "%s:i %d mask %d type %d status-type %d\n", __FUNCTION__, i,
                 con->ogPrecndCb->mask,
                 GET_PRECND_TYPE(con->icPrecndCb->precnds[i].curConfStat),
                 GET_PRECND_STATUS_TYPE(con->icPrecndCb->precnds[i].curConfStat));

            locSend = GET_PRECND_DESIRE_REMOTE_SEND_STRENGTH(con->ogPrecndCb->precnds[i].desireStat);
            locRecv = GET_PRECND_DESIRE_REMOTE_RECV_STRENGTH(con->ogPrecndCb->precnds[i].desireStat);
            rmtSend = GET_PRECND_DESIRE_LOCAL_SEND_STRENGTH(con->ogPrecndCb->precnds[i].desireStat);
            rmtRecv = GET_PRECND_DESIRE_LOCAL_RECV_STRENGTH(con->ogPrecndCb->precnds[i].desireStat);

            ccUpdatePrecndStaTbl(con, &(con->icPrecndCb->precnds[i]), PRECND_DIR_RECV, PRECND_DIR_NONE,
                      locSend, locRecv, rmtSend, rmtRecv);

            CCDP(AIN_DBG_LEVEL_1, "%s:i %d  icPrecndCb currConf 0x%x dirStatus 0x%x ogPrecndCb currConf 0x%x dirStatus 0x%x\n", __FUNCTION__, i,
                    con->icPrecndCb->precnds[i].curConfStat, con->icPrecndCb->precnds[i].desireStat,
                    con->ogPrecndCb->precnds[i].curConfStat, con->ogPrecndCb->precnds[i].desireStat);
          }
        }
    }


#ifdef CC_CALEA
    /* Case where CaleaRel was received when Tapped state m/c was 
     * in AWTANSSWT */
    if ((con->mgiPendRelReq) || (con->mgiPendAddReq))
    {
       con->lastState = con->state;
       if (con->mgiPendRelReq) 
       {
          ccProcessPendingCaleaMgiRelReq(con);
          con->mgiPendRelReq = 0; /* bug#24653, rkhan */
       }
       if (con->mgiPendAddReq)
       {
          ccProcessPendingCaleaMgiAddReq(con);
          con->mgiPendAddReq = 0; /* bug#24653, rkhan */
       }
       if ((con->mgiPendRelRsp != 0) || (con->mgiPendAddRsp != 0))
       {
          ret = ccSendCaleaMgiReq(con);
          if (ret == ROK)
             RETVALUE(ROK);
          else
          {
             CCDP(AIN_DBG_LEVEL_3,
            "ccSendCaleaMgiReq Failed, Continue with the Tapped call flow\n");
          }
       } 
    }
#endif
  }
#ifdef CC_CALEA
  else if (ret == ROUTRES)
  {
     /* This is the case where the LEA's addition failed, hence retry for the 
        subjects ONLY*/ 
     /*  generate an Alrm for the CALEA addition failure */
     ccGenAlarm(LCM_CATEGORY_SWITCHING, LCM_EVENT_SWITCHING_FAIL,
             LCM_CAUSE_CALEA_LEG_SWT_FAILED, (U8 *) &con->icSuConnId);
     ccUpdateCloseCauseForCaleas(con, CscSwitchFailure);
     CCDP(AIN_DBG_LEVEL_0,"Release the Calea Legs as the MGI request failed \n");
     ccReleaseCaleaLegs(con);
     CCDP(AIN_DBG_LEVEL_0,"Sending MGI Request for Subjects only \n"); 
      
     if (con->icProtType != CC_LOCAL_SWT_PROT)
     {
       if (((ogProtType == CC_CS_LN) || (ogProtType == CC_GR303)) ||
           (ogProtType == CC_IN))
       {
         ccUpdateMgEchoParam(con, &ingressEcho, &egressEcho);
         if (ingressEcho.pres == PRSNT_NODEF)
         {
           /* Ingress Echo cancellation required */
           CCDP(AIN_DBG_LEVEL_0,"Enable outgoing half echo Device\n");
           pIngrEcho = &ingressEcho;
         }
         else
         {
           /* Ingress Echo cancellation not required */
           CCDP(AIN_DBG_LEVEL_0,"Disable outgoing half echo Device\n");
           pIngrEcho = NULLP;
         }
         if ( (((ogProtType == CC_CS_LN)||(ogProtType == CC_GR303)) && 
              ccIsCsPBXDIDCall(con)) || ((ogProtType == CC_IN) &&
              (con->icEvntType == CCIN_ET_PROGRESS)) )
           /* RingBack by the PBX on Egress */
           mgSignal = MGCT_ITEM_ID_CG_MAX;
         else
         {
           mgSignal = MGCT_SIG_ID_CG_RT;
           con->mgPlayingTone = TRUE;
           con->mgToneType    = MGCT_SIG_ID_CG_RT;
         }

         if(pIngrEcho)
         {
           mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                         pIngrEcho->pres, pIngrEcho->echoTail,
                         pIngrEcho->echoCntrlNLP, pIngrEcho->echoCntrlType,
                         NULLP, 0, FALSE, DSVal, 0, NULLP, NULLP, pMediaDesc);
         }

         ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_CG,
                                      mgSignal, MGCT_CMD_ADD, &(con->icBcm),
                                      NULLP, NULLP, NULLP, NULLP, pMediaDesc,
                                      (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                      MGCT_CONTEXT_CHOOSE, con);
         if (egressEcho.pres == PRSNT_NODEF)
         {
           /* Egress Echo cancellation required */
           CCDP(AIN_DBG_LEVEL_0,"Enable incoming half echo Device\n");
           pEgrEcho = &egressEcho;
         }
         else
         {
           /* No Egress Echo cancellation */
           CCDP(AIN_DBG_LEVEL_0,"Disable incoming half echo Device\n");
           pEgrEcho = NULLP;
         }

         if(pEgrEcho)
         {
           mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                         pEgrEcho->pres, pEgrEcho->echoTail,
                         pEgrEcho->echoCntrlNLP, pEgrEcho->echoCntrlType,
                         0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
         }
         ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                      MGCT_ITEM_ID_CG_MAX,
                                      MGCT_CMD_ADD, &(con->ogBcm),
                                      NULLP, NULLP, NULLP, NULLP, pMediaDesc,
                                      (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                      MGCT_CONTEXT_CHOOSE, con);
         /* Send the Mg Queue. */
         CC_STATE_CHANGE(con, CCS_AWTANSSWT);
         con->mgBlock->con = con;
         ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
         if (ret != ROK)
         {
           CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                    con->icSuConnId);
           cleanUpMgQ(con);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
         }
         RETVALUE(ROK);
       }
       else if ((ogProtType == CC_SI) || (ogProtType == CC_BICC) ||
                (ogProtType == CC_CS_TG) || (ogProtType == CC_SIPT))
       {
         /* When the outgoing is trunk */
         /* Send a Mgi Connect Request */
         /* Process Echo Stuff. */
         ccUpdateMgEchoParam(con, &ingressEcho, &egressEcho);
         /* Queue the MG Request */
         /* Bug# 10273 */
         if (ingressEcho.pres == PRSNT_NODEF)
         {
           /* Ingress Echo cancellation required */
           CCDP(AIN_DBG_LEVEL_0, "Enable Outgoing Half Echo Cntrl Device\n");
           pIngrEcho = &ingressEcho;
         }
         else
         {
           /* Ingress Echo cancellation not required */
           CCDP(AIN_DBG_LEVEL_0, "Disable Outgoing Half Echo Cntrl Device\n");
           pIngrEcho = NULLP;
         }

         if(pIngrEcho)
         {
           mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                         pIngrEcho->pres, pIngrEcho->echoTail,
                         pIngrEcho->echoCntrlNLP, pIngrEcho->echoCntrlType,
                         0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
         }

         ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                      MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                      &(con->icBcm), NULLP, NULLP,
                                      NULLP, NULLP, pMediaDesc,
                                      (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                      MGCT_CONTEXT_CHOOSE, con);

         if (egressEcho.pres == PRSNT_NODEF)
         {
           CCDP(AIN_DBG_LEVEL_0, "Enable Incoming Half Echo Cntrl Device\n");
           pEgrEcho = &egressEcho;
         }
         else
         {
           /* No Egress Echo cancellation */
           CCDP(AIN_DBG_LEVEL_0, "Disable Incoming Half Echo Cntrl Device\n");
           pEgrEcho = NULLP;
         }

         if(pEgrEcho)
         {
           mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                         pEgrEcho->pres, pEgrEcho->echoTail,
                         pEgrEcho->echoCntrlNLP, pEgrEcho->echoCntrlType,
                         0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
         }

         ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                      MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                      &(con->ogBcm), NULLP, NULLP,
                                      NULLP, NULLP, pMediaDesc,
                                      (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                      MGCT_CONTEXT_CHOOSE, con);
  
         /* Send the Mg Queue. */
         CC_STATE_CHANGE(con, CCS_AWTANSSWT);
         con->mgBlock->con = con;
         ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
         if (ret != ROK)
         {
           CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                    con->icSuConnId);
           cleanUpMgQ(con);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
         }
         RETVALUE(ROK);
       }
       else
       {
         CCLOGERR("INVALID outgoing protocol in ccConE11S07 \n");
         cleanUpMgQ(con);
         ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
         RETVALUE(RFAILED);
       }
     }
     else
     {
        CCLOGERR("At this point con->icProtType cannot be CC_LOCAL_SWT_PROT\n"); 
        cleanUpMgQ(con);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
     }
  }
#endif
  else
  {
    CCLOGERR( "ERROR: Response Handling FAILED:%d\n", ret);
    /* BUG: 34559 */
    con->tempHolderForReleaseCause = CCRESTDIG;
    failCnd = ccGetMegacoFailCnd(con);

    if(failCnd != FC_NOT_APPLICABLE)
    {
      con->failCndVal = failCnd;

      if (CC_IS_CONTEXT_PRESENT(con))
      {
	ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
          con->mgBlock->con = con;
          con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
          RETVALUE(ROK);
        }
      }
      ccFreeTheRscFromCon(con, OUTTOINC);
      ccProcessFailCnd(con, con->failCndVal, TRUE);
      RETVALUE(ROK);
    }
    cleanUpMgQ(con); /* Bug: 43151 */
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  precnd = (!CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION)  &&
              ((con->icPrecndCb) && (con->ogPrecndCb) &&
              ((CC_GET_PROTOCOL(con->icProtType)== CC_SIP || CC_GET_PROTOCOL(con->icProtType)==CC_SIPT) &&
              (CC_GET_PROTOCOL(con->ogProtType)== CC_SIP || CC_GET_PROTOCOL(con->ogProtType)==CC_SIPT))));

  if ((CC_IS_CALL_TAPPED(con)) && (CC_IS_X3_ALLOWED(con)) &&
      (CC_IS_ANY_LI_TARGET_STEREO(con)) &&
      (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) || precnd) &&
      (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP))  &&
      (!CC_IS_LI_TERMS_ADDED_FOR_X3(con)))
  {
       ccProcessAddLi(con, (GccCallBakFunc)ccAlertingCallsCallBack,
                        (PTR) con, con->state);
       ret = ROK;
  }
  else
  {
    ret = ccAlertingCallsCallBack(con);
  }
  RETVALUE(ret);
}


/*
 *
 *      Fun:   ccConE13S07
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - InitRel
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE13S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;

  TRC3(ccConE13S07)

  /* The INITREL indication only comes from outgoing interface */
  /* Initiate release in both directions */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  con->relPend = BOTHREL;

  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcStaEvnt))) != ROK)
  {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC339, (ErrVal) ret,
                 "ccConE13S07() Failed, ccStoreEvnt failed");
#endif
      RETVALUE(RFAILED);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S07
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S07
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  TRC3(ccConE14S07)

  /* Initiate release in both directions */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
               LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  
  con->relPend = BOTHREL;
  /* wait for MGI rsp to do any call clearing */
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S08
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcCnStEvnt ogEvnt;

  TRC3(ccConE03S08)

    /* map connection status event */
    con->icEvnt = (CcAllSdus *)event;
  con->ogEvnt = (CcAllSdus *)&ogEvnt;

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    CCDP(AIN_DBG_LEVEL_0, "Flash ignored while waiting for Rsp from MGI\n");
    RETVALUE(ROK);
  }

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if (con->mgPlayingTone)
    {
      con->relPend = ICRELONLY;
      con->mgPlayingTone = FALSE;
    }
    else
      con->relPend = BOTHREL;
    
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    /* bug:23597 */
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    /* wait for MGI rsp to do any call clearing */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }

  CCDP(AIN_DBG_LEVEL_0,"Buffering EVNT until MGI-txn-Cfm is rcvd:0x%lx,0x%lx\n",
     con->icSuConnId, con->ogSuConnId);
  ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S08
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16   ret = RFAILED;

  U8            location = 0;
  U8            cdeStand = 0;
  CcAllSdus     *icEvnt = NULLP;
  U8            relCause = 0;
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);


  TRC3(ccConE04S08)

  /* esc 52387 */
  if ((con->icBcm.cc) && (con->icBcm.cc->ccId >= CiThreePartySetup))
  {
    CCDP(AIN_DBG_LEVEL_0, "Buffer Event CCE_RELIND \n");
    ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
    RETVALUE(ROK);
  }

  /* As per R5-[637] of GR 1298 */
  if ((ogProtType == CC_SI) && (con->direction == OUTTOINC))
  {
     /* Interswitch call */
     icEvnt = (CcAllSdus *) event;
     relCause = icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.causeVal.val;
     location = icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.location.val;
     cdeStand = icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.cdeStand.val;
     if ((relCause == CCNOCIRCUIT) || (relCause == CCUSRBSY))
        ccUpdateBusyCauseForTermNot(con, con->ogProtType, location,
                                    cdeStand, relCause);
     else
       /* This is not per standard */
       ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     relCause = 0;
  }
  else if ((ogProtType == CC_IN) && (con->direction == OUTTOINC))
  {
     icEvnt = (CcAllSdus *) event;
     relCause = icEvnt->m.ccRelEvnt.m.inDiscEvnt.causeDgn[0].causeVal.val;
     location = icEvnt->m.ccRelEvnt.m.inDiscEvnt.causeDgn[0].location.val;
     cdeStand = icEvnt->m.ccRelEvnt.m.inDiscEvnt.causeDgn[0].codeStand3.val;
     if ((relCause == CCNOCIRCUIT) || (relCause == CCUSRBSY))
       ccUpdateBusyCauseForTermNot(con, con->ogProtType, location, cdeStand,
                                    relCause);
     else
       /* This is not per standard */
       ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     relCause = 0;
  }
  else
  {
     /* It can be release from the incoming side */
     /* Case where caller abandoned before the Call was established */
     /* GR 1298 never talks about this case */
     if (con->direction == INCTOOUT)
     {
        ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER, CSTD_CCITT,
                                    CCCALRABANDON);
        ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
     }
     else
        ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                    CCCALRABANDON);
  }

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
  }
  
  /* Clean the answer fraud Call */
  ccCleanAnsFraudCall(con);

  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  if(con->direction == INCTOOUT)
  {
    /* Bug: 40768 */
    /*
     * Do we have an outgoing side? If so,
     * set relPend to INRELRSPANDOUTREL. Otherwise,
     * set relPend to INRELRSPANDNOREL so we don't
     * try to send an outgoing Release (since there
     * isn't an outgoing side).
     */

    if (con->ogRscVal)
        con->relPend = INRELRSPANDOUTREL;
    else
        con->relPend = INRELRSPANDNOREL;

    /* End of Bug: 40768 */
	
    /* wait for MGI rsp to do any call clearing */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }
  else /* OUTTOINC */
  {
    con->relPend = OUTRELRSPANDINREL;
    /* wait for MGI rsp to do any call clearing */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S08
 *
 *      Desc:  Connection state function
 *             event - Release Confirmation
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                   ret    = RFAILED;
  S16                   tmpret = RFAILED;
  MgctPackageId         pkgId  = MGCT_PACKAGE_ID_MAX;
  MgctCallProgItemId    signal = MGCT_ITEM_ID_CG_MAX;
  MgctMode              mode   = MGCT_MODE_MAX;

  TRC3(ccConE05S08)

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  else if (ret == ROKDRSIG)
  {
     /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
              notification is sent  and continue with release*/
     CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
  }
  else
     /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
     CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELCFM, (PTR) event);
  /* FID 14732 */                 

  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
  }

  /* check for a special case: Waiting for MGI response to play a tone on
   * incoming CAS line/trunk and we got RelCfm from ISDN. This can happen only
   * if the relcause is either USRBUSY or NOCKTAVAIL */

  tmpret = ccCheckMgContext(&(con->icBcm), &pkgId, &signal, &mode);
  if((con->direction == OUTTOINC) && (con->mgPlayingTone == TRUE))
  {
    CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);
    /* Dealloc the resource and go to AWTBUSYREL_IC */
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
    RETVALUE(ROK);
  }

  if(con->direction == INCTOOUT)
  {
    /* since we got RelCfm instead if RelInd, free the resource */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    ccDeallocateResource(con, CC_INCOMING);
    con->icRscVal = FALSE;
    con->relPend = OGRELONLY;
    /* wait for MGI rsp to do any call clearing */
    RETVALUE(ROK);
  }
  else /* OUTTOINC */
  {
    /* since we got RelCfm instead if RelInd, free the resource */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
    con->relPend = ICRELONLY;
    /* wait for MGI rsp to do any call clearing */
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S08
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirm 
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt;
    rscEvnt = (RmAlocCfmEvnt *)event;

  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
    {
      /* Outgoing resource has been verified by the RM */
      /* go ahead with the  switching of the resources */
      con->ogRscVal = TRUE;
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));


      /* Copy Additional Resource Information */
      if (rscEvnt->addnlRscInfo != NULLP)
        {
          cmMemcpy((U8 *) &con->icAddnlRscInfo, 
                   (U8 *)rscEvnt->addnlRscInfo, 
                   sizeof(RmAddnlRscInfo));   
        }
      else
        con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

      /* Copy the mBuf received from RM */
      if (con->icRscMBuf)
        SPutMsg(con->icRscMBuf);
      con->icRscMBuf = rscEvnt->mBuf;
      rscEvnt->mBuf = NULLP;


      /* Copy the modified traffic descriptor */
      cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc, 
               sizeof(RmTfcDesc));

    }
  else if (rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE)
    {
      /* The outgoing resource verification failed */
      /* Initiate release on both interfaces       */
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      ccCp.sts.fResUnavail++;
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                    con->ogProtType, CCTMPFAIL,NULL);
    }
         
  RETVALUE(ROK);
}


/*
 *      Fun:   ccConE11S08
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm 
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16            ret            = RFAILED;
  S16            ogret          = RFAILED;
  S16            tmpret         = RFAILED;
  S16            retICContext   = RFAILED;
  MgctCallProgItemId   signal   = MGCT_ITEM_ID_CG_MAX;
  MgctPackageId        pkgId    = MGCT_PACKAGE_ID_CG;
  MgctPackageId        ogpkgId  = MGCT_PACKAGE_ID_MAX;
  MgctCallProgItemId   ogsignal = MGCT_ITEM_ID_CG_MAX;
  MgctMode             mode     = MGCT_MODE_MAX;
  MgctMode             ogMode   = MGCT_MODE_MAX;
  MgctTxnCfm    *txnCfm         = NULLP;
  AinBCM_t      *pOtherBcm      = NULLP;
  CcConEvnt      ogEvnt;
  TknU8                   DSVal;

#ifdef CC_CALEA
  MgctEcho            ingressEcho;
  MgctEcho            egressEcho;
  MgctEcho            *pIngrEcho     = NULLP;
  MgctEcho            *pEgrEcho      = NULLP;
  MgctCallProgItemId         mgSignal       = MGCT_ITEM_ID_CG_MAX;
#endif
  CcFailCondId         failCnd = FC_NOT_APPLICABLE;
  ProtType             ogProtType   = CC_GET_PROTOCOL(con->ogProtType);
  MgctMediaDesc        mediaDesc, *pMediaDesc = NULLP;
  Bool                 precnd = FALSE;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  TRC3(ccConE11S08)
  CCDP(AIN_DBG_LEVEL_1, "ccConE11S08\n");
  
  txnCfm   = (MgctTxnCfm*) event;
  DSVal.pres = NOTPRSNT;
  DSVal.val = 0;

  cmMemset((U8*)&mediaDesc, 0, sizeof(MgctMediaDesc));
  pMediaDesc = &mediaDesc;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  ret = ccHandleMgResponse(con, txnCfm);
#ifdef CC_CALEA
  if (ret == ROUTRES)
  {
     /* This is the case where the LEA's addition failed, hence retry for the 
      *         subjects ONLY*/
     /*  generate an Alrm for the CALEA addition failure */ 
     ccGenAlarm(LCM_CATEGORY_SWITCHING, LCM_EVENT_SWITCHING_FAIL,
             LCM_CAUSE_CALEA_LEG_SWT_FAILED, (U8 *) &con->icSuConnId);
     ccUpdateCloseCauseForCaleas(con, CscSwitchFailure); 
     CCDP(AIN_DBG_LEVEL_0,
          "Release the Calea Legs as the MGI request failed \n");
     ccReleaseCaleaLegs(con);
     CCDP(AIN_DBG_LEVEL_0,"Sending MGI Request for Subjects only \n");

     if (con->icProtType != CC_LOCAL_SWT_PROT)
     {
         if (((ogProtType == CC_CS_LN) || (ogProtType == CC_GR303)) ||
             (ogProtType == CC_IN))
         {
            ccUpdateMgEchoParam(con, &ingressEcho, &egressEcho);
            if (ingressEcho.pres == PRSNT_NODEF)
            {
               /* Ingress Echo cancellation required */
               CCDP(AIN_DBG_LEVEL_0,"Enable outgoing half echo Device\n");
               pIngrEcho = &ingressEcho;
            }
            else
            {
               /* Ingress Echo cancellation not required */
               CCDP(AIN_DBG_LEVEL_0,"Disable outgoing half echo Device\n");
               pIngrEcho = NULLP;
            }
            if ( (((ogProtType == CC_CS_LN)||(ogProtType == CC_GR303)) 
                 && ccIsCsPBXDIDCall(con)) ||
                 ((ogProtType == CC_IN) &&
                  (con->icEvntType == CCIN_ET_PROGRESS)) )
               /* RingBack by the PBX on Egress */
               mgSignal = MGCT_ITEM_ID_CG_MAX;
            else
            {
               mgSignal = MGCT_SIG_ID_CG_RT;
               con->mgPlayingTone = TRUE;
               con->mgToneType    = MGCT_SIG_ID_CG_RT;
            }

            if(pIngrEcho)
            {
              mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                            pIngrEcho->pres, pIngrEcho->echoTail,
                            pIngrEcho->echoCntrlNLP, pIngrEcho->echoCntrlType,
                            0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
            }

            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_CG,
                                         mgSignal, MGCT_CMD_ADD,
                                         &(con->icBcm), NULLP, NULLP,
                                         NULLP, NULLP, pMediaDesc,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, con);
            if (egressEcho.pres == PRSNT_NODEF)
            {
               /* Egress Echo cancellation required */
               CCDP(AIN_DBG_LEVEL_0,"Enable incoming half echo Device\n");
               pEgrEcho = &egressEcho;

            }
            else
            {
               /* No Egress Echo cancellation */
               CCDP(AIN_DBG_LEVEL_0,"Disable incoming half echo Device\n");
               pEgrEcho = NULLP;

            }

            if(pEgrEcho)
            {
              mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                            pEgrEcho->pres, pEgrEcho->echoTail,
                            pEgrEcho->echoCntrlNLP, pEgrEcho->echoCntrlType,
                            0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
            }

            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                         &(con->ogBcm), NULLP, NULLP,
                                         NULLP, NULLP, pMediaDesc,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, con);
           CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
           ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                              CCS_CANNOTPROCESSEVENTS);
           con->mgBlock->con = con;
           ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
           if (ret != ROK)
           {
             CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                      con->icSuConnId);
             cleanUpMgQ(con);
             ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           }
           RETVALUE(ROK);
         }
         else if ((ogProtType == CC_SI) || (ogProtType == CC_BICC) ||
                 (ogProtType == CC_CS_TG) || (ogProtType == CC_SIPT))
         {
            /* When the outgoing is trunk */
            /* Send a Mgi Connect Request */
            /* Process Echo Stuff. */
            ccUpdateMgEchoParam(con, &ingressEcho, &egressEcho);
            /* Queue the MG Request */
            /* Bug# 10273 */
            if (ingressEcho.pres == PRSNT_NODEF)
            {
               /* Ingress Echo cancellation required */
               CCDP(AIN_DBG_LEVEL_0,
                    "Enable Outgoing Half Echo Cntrl Device\n");
               pIngrEcho = &ingressEcho;
            }
            else
            {
               /* Ingress Echo cancellation not required */
               CCDP(AIN_DBG_LEVEL_0,
                    "Disable Outgoing Half Echo Cntrl Device\n");
               pIngrEcho = NULLP;
            }

            if(pIngrEcho)
            {
              mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                            pIngrEcho->pres, pIngrEcho->echoTail,
                            pIngrEcho->echoCntrlNLP, pIngrEcho->echoCntrlType,
                            0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
            }

            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                         &(con->icBcm), NULLP, NULLP,
                                         NULLP, NULLP, pMediaDesc,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, con);
            if (egressEcho.pres == PRSNT_NODEF)
            {
              CCDP(AIN_DBG_LEVEL_0, "Enable Incoming Half Echo Cntrl Device\n");
              pEgrEcho = &egressEcho;
            }
            else
            {
              /* No Egress Echo cancellation */
              CCDP(AIN_DBG_LEVEL_0,"Disable Incoming Half Echo Cntrl Device\n");
              pEgrEcho = NULLP;
            }

            if(pEgrEcho)
            {
              mgctMediaDesc(&(con->ctl), NOTPRSNT, MGCT_MODE_SENDRECV,
                            pEgrEcho->pres, pEgrEcho->echoTail,
                            pEgrEcho->echoCntrlNLP, pEgrEcho->echoCntrlType,
                            0, FALSE, 0, DSVal, NULLP, NULLP, NULLP, pMediaDesc);
            }

            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                           MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                           &(con->ogBcm), NULLP,NULLP,
                                           NULLP, NULLP, pMediaDesc,
                                           (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                           MGCT_CONTEXT_CHOOSE, con);

            CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
            ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                               CCS_CANNOTPROCESSEVENTS);
            con->mgBlock->con = con;
            ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
            if (ret != ROK)
            {
               CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                        con->icSuConnId);
               cleanUpMgQ(con);
               ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            }
            RETVALUE(ROK);
         }
         else
         {
            CCLOGERR("INVALID outgoing protocol in ccConE11S08 \n");
            cleanUpMgQ(con);
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            RETVALUE(RFAILED);
         }
     }
     else
     {
        CCLOGERR("At this point con->icProtType cannot be CC_LOCAL_SWT_PROT\n");
        cleanUpMgQ(con);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
     }
  }
  else
#endif
  if (ret != ROK)
  {
    CCLOGERR( "ERROR: Response Handling FAILED, ret = %d\n", ret);

    /* Bug 78139 */
    if (con->keepGCCCallInfo == FALSE)
     {
       con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
     }

    failCnd = ccGetMegacoFailCnd(con);
    
    if(failCnd != FC_NOT_APPLICABLE)
    {
      /* check if ogRsc is valid or not. This can happen if the requested
       * txn is for a TONE on Incoming BCM with no terminating BCM in con*/
      if(!con->ogRscVal)
      {
        ccProcessFailCnd(con, failCnd, TRUE);
        RETVALUE(ROK);
      }

      con->failCndVal = failCnd;

      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
          con->mgBlock->con = con;
          con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
          RETVALUE(ROK);
        }
      }
      ccFreeTheRscFromCon(con, OUTTOINC);
      ccProcessFailCnd(con, failCnd, TRUE);
      RETVALUE(ROK);
    }
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
#ifdef CC_CALEA
    /* Case when Calea subReq are sent along with Tapped Sub's Signal_DATA request */ 
    if (con->mgiPendRelRsp)
    {
       CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S08\n");
       ccProcessCaleaMgiSubRsp(con, FALSE);
       con->mgiPendRelRsp = 0;
    }
    if (con->mgiPendAddRsp) 
    {
       CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S08\n");
       ccProcessCaleaMgiAddRsp(con, FALSE);
       con->mgiPendAddRsp = 0;
    }
#endif

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcConEvnt));

  if ((con->reconnectBcm == OBCM) || (con->reconnectBcm == TBCM))
  {
    CCDP(AIN_DBG_LEVEL_0, "Reconnected Call ccConE11S08: %ld,%ld,%ld\n",
                           con->icSuConnId, con->ogSuConnId,
                           (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
    con->reconnectBcm = 0;

    if (con->icBcm.pic != PicOActive)
      ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                     con->state, TRUE);
    else
    {
      /* Bug# 33580 */
      CCDP(AIN_DBG_LEVEL_0, "%s():: Send Reconnect Answer Indication to FIC\n",
           __FUNCTION__);
      ccProcessTAnswer(&(con->ogBcm));
      ccProcessOAnswer(&(con->icBcm));

      con->mgPlayingTone = FALSE;
      if (con->keepGCCCallInfo == FALSE)
      {
      con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
      }
      con->tmdRelApplied = CC_CHECK_TMD_RELEASE;
      
#ifdef ZC 
      cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
      upd.con = con;
      zcRunTimeUpd(ZC_CON_CB, CMPFTHA_CREATE_REQ, upd);
      zcUpdPeer();
#endif /* ZC */

      CC_STATE_CHANGE(con, CCS_ANSWERED); 
    }
    RETVALUE(ROK);
  }

  if ((con->lastState == CCS_AWTRSPFORDPE30) && 
      (con->ogBcm.cc) && ((con->ogBcm.cc->ccId == CiCallWaiting) ||
                          (con->ogBcm.cc->ccId == CiCallWaitingComplement)))
  {
    /* We come here after Offer Call */
    /* Even if CS 2 is in Ringing phase , we go in to Answered as this is 
     * and exception.
     * When we get a hook flash from Controller, we move the leg and dont change
     * Call States */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
    ogpkgId = MGCT_PACKAGE_ID_MAX;
    ogsignal = MGCT_ITEM_ID_CG_MAX;
    ogret = ccCheckMgContext(&(con->ogBcm), &ogpkgId, &ogsignal, &ogMode);
    if (ogret == ROKDNA)
    {
      CC_STATE_CHANGE(con, CCS_AWTANS);

      /* CHECK FOR TNOANSWER EVENT */
      ccProcessTNoAnswer(&(con->ogBcm));

      RETVALUE(ROK);
    }
  }
  else if (con->lastState == CCS_AWTBUSYREL_IC)
  {
     /* Bug# 18104 */
     /* come here when BusyTimer expires in CC4 for ROH */
     CC_STATE_CHANGE(con, con->lastState);
     RETVALUE(ROK);
  }

  if (con->icBcm.cc)
  {
    if ((con->icBcm.cc->ccId == CiTransfer) ||
        (con->icBcm.cc->ccId == CiRemoteTransferSetup))
    {
      if (con->mgPlayingTone)
      {
        CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);

        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_BUSY_TONE, con, (PTR)&ccCp.genCfg);
        RETVALUE(ROK);
      }

      pOtherBcm = ccFindOtherBcm(&(con->icBcm));
      if (pOtherBcm)
      {
        retICContext = ccCheckMgContext(pOtherBcm, &pkgId, &signal, &mode);
        if ((pkgId == MGCT_PACKAGE_ID_CG) && (signal == MGCT_SIG_ID_CG_RT))
        {
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_MODIFY,
                                       pOtherBcm, NULLP, NULLP,
                                       NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, con);
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
          ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                             CCS_CANNOTPROCESSEVENTS);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
          if (ret != ROK)
          {
            /* Bug 78139 */
            if (con->keepGCCCallInfo == FALSE)
            {
              con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
            }

            CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                     con->icSuConnId);
            cleanUpMgQ(con);
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            RETVALUE(ROK);
          }
        }
      }
    }
  }

  tmpret = ccCheckMgContext(&(con->icBcm), &pkgId, &signal, &mode);
      /* Bug  55039 */
  /* Check if a MGCT modify for a tone was sent */
  if (((pkgId == MGCT_PACKAGE_ID_CG) &&
               ((signal == MGCT_SIG_ID_CG_BT) ||
                 (signal == MGCT_SIG_ID_CG_CT) ||
                  (signal == MGCT_SIG_ID_CG_SIT) ||
                 (signal == MGCT_SIG_ID_CG_WT)))
               || 
       ((pkgId == MGCT_PACKAGE_ID_XCG) &&
                ((signal == MGCT_SIG_EVT_ID_NACK) ||
                  (signal == MGCT_SIG_EVT_ID_VAC))))
  {
     /* Bug# 21823 */
     if (ccIsIPSubscriber(&(con->icBcm)))
     {
       MgcpCctEvnt_t     *mgcp       = NULLP;
       CcAllSdus          ogEvnt;

       cmMemset((U8*) &ogEvnt, 0, sizeof(CcAllSdus));
       mgcp = &(ogEvnt.m.ccCnStEvnt.m.mgcpCctEvnt);
       INITEVENT(mgcp, sizeof(MgcpCctEvnt_t));
       mgcp->evntType = CC_CCT_EVNT_TYPE_CNSTREQ;
       mgcp->mode.pres = PRSNT_NODEF;
       mgcp->mode.val = MGCT_MODE_SENDRECV;

       ccFillProtSdp(ccInit.region, ccInit.pool, &con->icBcm,
                     &mgcp->sdp);
       ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                     con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                     con->icProtType, CCMGCP_ET_MODIFY_CONNECTION,
                     &(ogEvnt.m.ccCnStEvnt), NULLP);

    }
    else if (CC_GET_PROTOCOL(con->icProtType) == CC_BICC)
    {
      CcCnStEvnt     ogEvnt;
      /* Send ACM/CPG with Optional Backward Call Indicator set
       * to inband Tone available, no cause is sent as the
       * Annc/Tone is being played by FIC */

      if(!con->isACMSent)
        ccSendBiccApm(con, CC_ET_CONFWDNOTF, INCTOOUT, TRUE);
      else /*Bug:25304*/
        ccSendBiccApm(con, CC_ET_NOIND, INCTOOUT, TRUE);

      cmMemset((U8*) &ogEvnt, 0, sizeof(CcCnStEvnt));
      ccBuildSs7ACMOrCPGMsg(con, &(ogEvnt.m.siCnStEvnt), FALSE);
 
      CCDP(AIN_DBG_LEVEL_0,
                   "Sending BICC ACM/CPG for Inband Tone/Annc\n");

      ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                    con->icSapCb->spId, con->icSpConnId,
                    con->icSuConnId, con->icProtType,
                    con->ogEvntType, &ogEvnt, NULLP);

    }
    else if (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)
    {
        CcCnStEvnt     ogEvnt;

        cmMemset((U8*) &ogEvnt, 0, sizeof(CcCnStEvnt));
        ccBuildSs7ACMOrCPGMsg(con, &(ogEvnt.m.siCnStEvnt), FALSE);

        /* The local IP addr/port needs to be sent to SIP for 18x */
        ccFillProtSdp(ccInit.region, ccInit.pool, &con->icBcm,
                      &ogEvnt.m.siCnStEvnt.optElmnt.sipt.sdp);

        CCDP(AIN_DBG_LEVEL_0,
             "Sending SIPT ACM/CPG for Inband Tone/Annc\n");
        
        ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                      con->icSapCb->spId, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      con->ogEvntType, &ogEvnt, NULLP);
    }
    else if (CC_GET_PROTOCOL(con->icProtType) == CC_SIP)
    {
      CcCnStEvnt     ogEvnt;

      cmMemset((U8*) &ogEvnt, 0, sizeof(CcCnStEvnt));

      CCDP(AIN_DBG_LEVEL_0,
                   "Sending 183 for Inband Tone/Annc\n");
      con->ogEvntType = CCSIP_ET_183_CALLPRG;

      /* The local IP addr/port needs to be sent to SIP for 18x */
      ccFillProtSdp(ccInit.region, ccInit.pool, &con->icBcm,
          &ogEvnt.m.sipCnStEvnt.sdp);

      ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                    con->icSapCb->spId, con->icSpConnId,
                    con->icSuConnId, con->icProtType,
                    con->ogEvntType, &ogEvnt, NULLP);

    }
    else if ((CC_GET_PROTOCOL(con->icProtType) == CC_CS_LN) && (CHK_4_ALS70_MG))
    {
       /* Prevent a memory leak */
       /* for ALS70 MGs/DSLAMS, Signals are modified on a null context. */
       ccCleanUpMGCtx(con);
    }
#ifdef CALEA_3WC
    if (con->mgiPendRelReq)
    {
       ccProcessPendingCaleaMgiRelReq(con);
       con->mgiPendRelReq = 0;
       /* Send the Mg Queue. */
       CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
       ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                          CCS_CANNOTPROCESSEVENTS);
       con->mgBlock->con = con;
       ret = ccSendMgiQueue( con->mgBlock->mgCtx->suCtxId, con->mgBlock);
       if (ret != ROK)
       {
         CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                  con->icSuConnId);
         cleanUpMgQ(con);
         ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       }
       RETVALUE(ROK);
    }
#endif
    /* Bug 78139 */
    if (con->keepGCCCallInfo == FALSE)
     {
       con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
     }

    CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_BUSY_TONE, con, (PTR)&ccCp.genCfg);

    RETVALUE(ROK);
  }
  else if ((signal == MGCT_ITEM_ID_CG_MAX) || (CC_IS_CONTEXT_PRESENT(con)))
  {
    /* FID 15261.0 + */
    if (CC_IS_CALL_MULTI_MG(con))
    {
      if (con->ccmCb.ccn == CCN_1)
      {
        if (con->ccmCb.state == CC_EGRESS_MG)
        {
          EvntType tempEvtType = con->evntType;
          
          con->ccmCb.state = CC_INGRESS_MG;
          /* bug 74612 restore the held direction */
          con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          if (IS_MULTIMEDIA_4_BCM(&con->icBcm))
          {
            con->evntType = CCE_CONCFM;
          }
          ret = ccProcessConCfmWithSwitching(con, (PTR)con->ccEvntHold);
          con->evntType = tempEvtType;
          if(ret != ROK)
          {
            /* Bug 78139 */
            if (con->keepGCCCallInfo == FALSE)
            {
              con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
            }
            RETVALUE(RFAILED);
          }
          RETVALUE(ROK);
        }
      }
      else
      {
        if (con->ccmCb.state == CC_EGRESS_MG)
        {
          if (con->ccmCb.ccn == CCN_5)
          {
            con->ccmCb.state = CC_Y_MG;
            con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
            con->icEvntType = con->evntTypeHeld;
            return(ccProcessConCfmWithSwitching(con, (PTR)con->ccEvntHold));
          }
          else
          {
            con->ccmCb.state = CC_INGRESS_MG;
            con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
            con->icEvntType = con->evntTypeHeld;
            return(ccProcessConCfmWithSwitching(con, (PTR)con->ccEvntHold));
          }
        }
        else if (con->ccmCb.state == CC_Y_MG)
        {
          con->ccmCb.state = CC_INGRESS_MG;
          con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          return(ccProcessConCfmWithSwitching(con, (PTR)con->ccEvntHold));
        }
      }
    }
    /* FID 15261.0 - */
    /* FID15703 */
    if (CC_IS_STEROMONO_CALL(con))
    {
       if (con->ccmCb.state == CC_EGRESS_MG)
       {
          EvntType tempEvtType = con->evntType;
          con->ccmCb.state = CC_INGRESS_MG;
          con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
          con->icEvntType = con->evntTypeHeld;
          ret = ccProcessConCfmWithSwitching(con, (PTR)con->ccEvntHold);

          con->evntType = tempEvtType;
          if(ret != ROK)
          {
             /* Bug 78139 */
             if (con->keepGCCCallInfo == FALSE)
             {
                con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
             }
             RETVALUE(RFAILED);
          }
          RETVALUE(ROK);
       }
    }

    precnd = (!CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION)  &&
              ((con->icPrecndCb) && (con->ogPrecndCb) &&
              ((CC_GET_PROTOCOL(con->icProtType)== CC_SIP || CC_GET_PROTOCOL(con->icProtType)==CC_SIPT) &&
              (CC_GET_PROTOCOL(con->ogProtType)== CC_SIP || CC_GET_PROTOCOL(con->ogProtType)==CC_SIPT))));

    if ((CC_IS_CALL_TAPPED(con)) && (CC_IS_X3_ALLOWED(con)) &&
        (CC_IS_ANY_LI_TARGET_STEREO(con)) && 
        (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) || precnd) &&
        (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP))  &&
        (!CC_IS_LI_TERMS_ADDED_FOR_X3(con)))
    {
       ccProcessAddLi(con, (GccCallBakFunc)ccAnswerCallsCallBack,
                        (PTR) con, con->state);
       ret = ROK;
    }
    else
    {
      if (CC_IS_MRF(con->mrfFlag, MRF_200_ANNC))
      {
        CCDP(AIN_DBG_LEVEL_1, "ccConE11S08:MRF call!\n");
        CC_SET_MRF(con->mrfFlag, MRF_PLAYING_ANNC);

        if (CC_OFFANS_OGRMTOFFER_PENDING(con))
        {
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                           CC_OFFANS_STATE_RCVDOFFER,
                                           CC_OFFANS_GET_SUBSTATE(con),
                                           CC_OFFANS_METHOD_USED(con));
        }
        else if(CC_OFFANS_OGRMTANS_PENDING(con))
        {
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                        CC_OFFANS_STATE_NULL,
                                   CC_OFFANS_GET_SUBSTATE(con),
                                   CC_OFFANS_METHOD_USED(con));
        }
#if 0
        /* OG off-ans not done and IC have no following msg */
        if(( CC_GET_PROTOCOL(con->icProtType) == CC_SI)||
           (((( CC_GET_PROTOCOL(con->icProtType) == CC_SIP)||
             (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)) &&
            (!CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask))) && 
           (CC_OFFANS_OGANS_PENDING(con)))
          ) 
        {
          /* send ACK to MRF */
          ccSendAck(&con->ogBcm);
        } 
#endif
      if (((con->remoteSdpSentOnIcBCM&&con->renegSdpAfterAns) ||con->isAnsIndSent) &&
          (CC_OFFANS_ICOFFANS_STATE_NULL(con))
         )
        {
          CCDP(AIN_DBG_LEVEL_1,"will send update %lx\n",con->icSipMethodSupMask);
          if(CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask))
            ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, 0x00,
                             ccLcfUpdateCbFunc, (PTR)con, CCS_AWT_MRFRSP);
          else /* change the state back to 155 if incoming don't support update */
            CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
        }
        else
        {
          ret = ccSendBackwardMessageForAnnoucement(con, con->ainInfo.Resourcetype.val, FALSE, TRUE);
          if (ret != ROK)
          {
            CCLOGERR("%s: Error, ccSendBackwardMessageForAnnoucement failed icSu=0x%lx\n",
                __FUNCTION__,con->icSuConnId);
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          }

          CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
        }

        if (CC_OFFANS_ICOFFER_PENDING(con))
        {
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                           CC_OFFANS_STATE_NO_OP,
                                           CC_OFFANS_SUBSTATE_AWAITRMTANS_INVITENOSDP,
                                           CC_OFFANS_TYPE_200OKINVITE);

        }
        else if(CC_OFFANS_ICANS_PENDING(con))
        {
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                                   CC_OFFANS_STATE_NO_OP,
                                   CC_OFFANS_GET_SUBSTATE(con),
                                   CC_OFFANS_METHOD_USED(con));
        }
        RETVALUE(ROK);
      }
      else
      ret = ccAnswerCallsCallBack(con);
    }
    RETVALUE(ret);
  }
  else if (signal != MGCT_ITEM_ID_CG_MAX)
  {
    /* Queue the MG Request for Modify to signal = DATA and send it immed. */
    ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                 MGCT_ITEM_ID_CG_NULL, MGCT_CMD_MODIFY,
                                 &(con->icBcm), NULLP, NULLP,
                                 NULLP, NULLP, NULLP, 
                                 (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                 MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
    if (con->mgiPendRelReq)
    {     
      ccProcessPendingCaleaMgiRelReq(con);
      con->mgiPendRelReq = 0;
    }
#endif
    /* Send the Mg Queue. */
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                       CCS_CANNOTPROCESSEVENTS);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    if (ret != ROK)  
    {
      /* Bug 78139 */
      if (con->keepGCCCallInfo == FALSE)
      {
        con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
      }

      CCLOGERR( "UpdMg. or SendMgiQ. failed during Modify\n");
      cleanUpMgQ(con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
    }

    RETVALUE(ROK);
  }
  else if (tmpret == ROKDNA)
  {
    /* Bug 78139 */
    if (con->keepGCCCallInfo == FALSE)
    {
     con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
    }
    CCDP(AIN_DBG_LEVEL_3,"mgBlock not found may, UNEXPECTED CONDITION\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  else
  {
    /* Bug 78139 */
    if (con->keepGCCCallInfo == FALSE)
    {
     con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
    }
    CCLOGERR("UNEXPECTED CONDITION: icSu:%lx\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE13S08
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - InitRel
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE13S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;

  TRC3(ccConE13S08)

  /* The INITREL indication only comes from outgoing interface */
  /* Initiate release in both directions */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  con->relPend = BOTHREL;

  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcStaEvnt))) != ROK)
  {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC339, (ErrVal) ret,
                 "ccConE13S08() Failed, ccStoreEvnt failed");
#endif
      RETVALUE(RFAILED);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S08
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* Initiate release in both directions */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  
  if (con->mgPlayingTone == TRUE)
  {
    if (con->ogRscVal)
    {
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
    }
    con->relPend = ICRELONLY;
  }
  else
  {
    con->relPend = BOTHREL;
  }
  /* wait for MGI rsp to do any call clearing */
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE01S09
 *
 *      Desc:  Connection state function
 *             event - Connection Confirmation
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE01S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam              upd;
#endif /* ZC */
#ifdef CC_CALEA
  CcSurrogate            *pSurrogate     = NULLP; 
#endif
  U8                      mgiAction;
  S16                     ret            = RFAILED;
  Bool                    answerFlag     = FALSE;
  AinBCM_t               *pBcm           = NULLP;
  AinBCM_t               *pBcmComp       = NULLP;
  ProtType                icProtType     = CC_GET_PROTOCOL(con->icProtType);
  ProtType                ogProtType     = CC_GET_PROTOCOL(con->ogProtType);
  CcConEvnt              *conEvnt        = (CcConEvnt*)event;
  CasCctEvent_t          *conCfmEvnt     = &conEvnt->m.casCctEvnt;
  S16                     sdpRet         = ROK;
  ProtType                ingressCCS_IcProtType = 0;
  ProtType                egressCCS_OgProtType = 0;/* FID 15318 *//* FID 15401.1-add */
  U8                      icMode;
  U8                      ogMode;
  U8                      icSignal;
  U8                      ogSignal;
  CcSipPrflCb *sipPrflPtr = NULL; /*FID 15317.0 */
  Sdp*                    rmtSdp = NULLP;

  CCDP(AIN_DBG_LEVEL_0, "%s: evntType=%d, icEvntType=%d, icProtType=%d, ogProtType=%d\n",
       __FUNCTION__, con->evntType, con->icEvntType, icProtType, ogProtType);

  /* FID 15401.1 - Key performance measurements phase 1 */
  ProtType protType;
  if (CC_EGRESS_INTER_CCS_CALL(con))
  {
    CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);
    protType = CC_GET_PROTOCOL(egressCCS_OgProtType);
  } 
  else /* BUG 85596: Egress CCS and intra-CCS can't get protType
          in this condition and protType would be 0.
          The "else if (!CC_INGRESS_INTER_CCS_CALL
          (con))" should be changed to be only "else" here.
          */
  {
    protType = CC_GET_PROTOCOL(con->ogProtType);
  }

  /* FID 15319.0 ConCfm is received before bearer setup done */
  if((ogProtType == CC_EXT_BICC) && (con->ogExtBiccCb) &&
     CC_IS_EXTBICC_BEARERSTATE_LESSTHAN(con,CC_OUTGOING,CC_BICC_STATE_SENT_CONNECTED))
  {
      /* Release call with cause 31 for unexpected fast answer before
       * bearer setup is finished.
       */
      ccSendReleasesOnBothSidesWithSwitching(con, CCNORMUNSPEC);
      RETVALUE(ROK);
  }

  if ((protType == CC_SI) || (protType == CC_EXT_BICC) || (protType == CC_SIP) || (protType == CC_SIPT))
    con->callDtlInfo.cm.iamRspFlag = TRUE;
  CCDP(AIN_DBG_LEVEL_2, "iamRspFlag=%d\n", con->callDtlInfo.cm.iamRspFlag);

  /* + FID 17373.0 */
  if ((icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED) &&
      (con->ogPrecndCb) && 
      (!CC_IS_COT_RCVD_EXT_BICC(con)) &&
      (con->direction == OUTTOINC))
  {
       CCDP(AIN_DBG_LEVEL_2, "%s - Buffering 200 to wait for COT.\n", __FUNCTION__);
       ccBufferEventToQueue(con, bcm, event, CCE_CONCFM, sizeof(CcConEvnt), 0, NULLP, 0);
                
       CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);

       RETVALUE(ROK);
  }  
  /* - FID 17373.0 */

  /* FID 15317.0 P-Early-Media Support */
   if ((con->ogIntfcCb) && (con->ogIntfcCb->ccTgCb) && (ogProtType == CC_SIP))
   {
      sipPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr;

      if(sipPrflPtr && (sipPrflPtr->pEarlyMedia == TRUE))
      {
          /* FID15317.2 Add SIPT */
          /* FID 16203.0 */ 
          if(con->pEarlyMediaVal) 
          {
              CCDP(AIN_DBG_LEVEL_2, "%s: - before free, pEarlyMediaVal cnt=%d val=%d\n",
                    __FUNCTION__,con->pEarlyMediaVal->cnt, con->pEarlyMediaVal->params[0]);	
              SPutSBuf(ccInit.region, ccInit.pool, con->pEarlyMediaVal,
                                     (Size)(sizeof(SipPEarlyMedia)));
              con->pEarlyMediaVal = NULLP;
              CCT_RESET_SIP_PEM_MASK(con-> icSipMethodSupMask);
          }
       }   
   }

   /* FID 15068.0 */
   if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) && 
       (con->icPrecndCb) && (con->ogPrecndCb) && 
       (!IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)) &&
       (((icProtType == CC_SIP) || (icProtType == CC_SIPT)) &&
         ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT) || (ogProtType == CC_BICC))))
   {
     CCDP(AIN_DBG_LEVEL_0, "%s ingress precond ON but no 18x, clear CC_FLAG_PRECONDITION\n", __FUNCTION__);
     CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
   }

   /* FID 7803 +*/
   /* Update spConnId if spConnIdPres is set */
   if ((con->direction == OUTTOINC) && (ogProtType == CC_SIP) &&
         (((CcConEvnt *)event)->m.sipConEvnt.spConnIdPres))
   {
    con->ogSpConnId = ((CcConEvnt *)event)->m.sipConEvnt.spConnId;
    if (!con->forkedCallCnt &&
        (((CcConEvnt *)event)->m.sipConEvnt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
    {
      con->forkedCallCnt++;
    }
    CCDP(AIN_DBG_LEVEL_2, "ccConE01S09 - New SIP spConnId received, new spConnId=0x%08lx\n", con->ogSpConnId);
  }

  if ((con->direction == OUTTOINC) && (ogProtType == CC_SIPT) &&
      (((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.spConnIdPres))
  {
    con->ogSpConnId = ((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.spConnId;
    if (!con->forkedCallCnt &&
        (((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
    {
      con->forkedCallCnt++;
    }
    CCDP(AIN_DBG_LEVEL_2, "ccConE01S09 - New SIPT spConnId received, new spConnId=0x%08lx\n", con->ogSpConnId);
  }

  /* FID 14382.4 + */
  if(IS_IT_INTRA_CCS_CALL(con) || CC_EGRESS_INTER_CCS_CALL(con))
  {
    if(con->direction == OUTTOINC)
    {
     if((ogProtType == CC_SIP)||((con->ogIntfcCb != NULL) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType)==CC_SIP)))
     {
      ccExtractSipAccessNetInfo(con, &(((CcConEvnt *)event)->m.sipConEvnt) );
     }
    }
   }
  /* FID 14382.4 - */
  /*
   * If con->forkedCallCnt = 1 (First Fork has occurred) and 
   * con->ogSipMethodSupMask indicates that either Sequential or 
   * Parallel Forking is allowed, peg totalForkedCalls Count
   */
  if ((con->forkedCallCnt == 1) &&
     ((CCT_IS_SIP_SEQUENTIAL_FORK_SUPPORTED(con->ogSipMethodSupMask)) ||
     (CCT_IS_SIP_PARALLEL_FORK_SUPPORTED(con->ogSipMethodSupMask))))
  {
    /*
     * Bump con->forkedCallCnt to prevent pegging totalForkedCall twice
     */
    con->forkedCallCnt++;
    ccCp.sts.totalForkedCalls++;
    CCDP(AIN_DBG_LEVEL_2, "ccConE01S09 - Peg totalForkedCalls Count\n");
  }
  /* FID 7803 -*/

  /* Netherlands ISUP: CRG Tariff Indicator Handling.
   * For international calls from SIP to ISUP without encapsulation,
   * If no CRG with tariff indicator is received upon receipt of CON, release call on both sides.
   */
  if( con->direction == OUTTOINC && CC_IS_PROT_TYPE_KPNNL2(con->ogProtType) && con->icProtType == CC_SIP )
  {
      if ( con->isInternationalCall && !con->isCRGwithTariffGot )
      {
          CCDP(AIN_DBG_LEVEL_0,"Netherlands ISUP: CON received without CRG tariff indicator received yet. Will release call...\n");

          /* stop the Toiw2 Timer if running */
          ccStopConTmr(con, CC_TMR_TOIW2);

          ret = ccProcessDisconnectEvent(con, event);
          if (ret == ROK)
          {
              CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
              RETVALUE(ROK);
          }
          else if (ret == RFAILED)
          {
              CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
          }
          else if (ret == ROKDRSIG)
          {
              /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
                 notification is sent  and continue with release*/
              CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
          }
          else
             /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
             CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

          /* since the call is still in Establish phase, release the call
          * no matter who sends on-hook first */
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

          /* Stop the O and T_NO_ANSWER timer if it is started */
          ccStopConTmr(con, AIN_O_NO_ANS_TMR);
          ccStopConTmr(con, AIN_T_NO_ANS_TMR);

          /* STOP the AWAIT ANSWER Timer if running
           *
           * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0
           */
          ccStopConTmr(con, CC_TMR_AWAITANS);
          ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
          ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

          ccCleanAnsFraudCall(con);
          /* Bug 78139 */
          if (con->keepGCCCallInfo == FALSE)
          {
           con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
          }

          if (CC_IS_CONTEXT_PRESENT(con))
          {
              /* Blow off the switching and Release the Call */
              ccQSubBasedOnCcn(con);  /* FID 15261.0 */

              CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
              con->mgBlock->con = con;
              ret = ccSendMgiQueue(0, con->mgBlock);
              if (ret != ROK)
              {
                  CCLOGERR( "ERROR occured \n");
                  cleanUpMgQ(con);
                  ccCleanUpMGCtx(con);
              }
              else
              {
                  RETVALUE(ROK);
              }
          }

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCNORMUNSPEC, NULL);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                        con->ogSuConnId, con->ogProtType,
                        CCNORMUNSPEC, NULL);
          RETVALUE(ROK);
      }
  }/* End of Netherlands ISUP CRG Tariff Indicator Handling */

  /* FID 15261.0 + */
  if (CC_IS_CALL_MULTI_MG(con))
  {
    if (con->direction == OUTTOINC)
      con->ccmCb.state = CC_EGRESS_MG;
    else
      con->ccmCb.state = CC_INGRESS_MG;
  }
  /* FID 15261.0 - */


  /* FID17160 */
  if (CC_IS_STEROMONO_CALL(con))
  {
    if (con->direction == OUTTOINC)
    {
      con->ccmCb.state = CC_EGRESS_MG;
      /* ANM will first ADD icBcm and ogBcm */
    }
    else
    {
      con->ccmCb.state = CC_INGRESS_MG;
      /* Egress will add conCurBcm */
    }
  }

  /* + FID15083.0 */
  if (CC_IS_CALL_TAPPED(con))
  {
     CcAllSdus *tmpConEvnt = con->icEvnt;
     con->icEvnt = (CcAllSdus *)event;
     if (CC_IS_LEG_TAPPED(&con->icBcm))
     {
         CCDP(AIN_DBG_LEVEL_0, "IC leg Tapped generating\n");
         ccGenerateX2Continue(&con->icBcm, NULLP);
     }

     if (CC_IS_LEG_TAPPED(&con->ogBcm))
     {
         CCDP(AIN_DBG_LEVEL_0, "OG leg Tapped generating\n");
         ccGenerateX2Continue(&con->ogBcm, NULLP);
     }
     con->icEvnt = tmpConEvnt;
  }
  /* - FID15083.0 */
  /* FID 15045.1 */
  if (CC_IS_MSG_RCV_FROM_SRP(con))
  {
      ccExtractUUdata(con,(CcAllSdus*)event,CCE_CONCFM);
  }

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);
  
  /* bug:30062 */
  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
#if 1 /* EARLY_ACM */
  ccStopConTmr(con, CC_TMR_EARLYACM); 
#endif

  /* Stop the CC_TMR_PREANM timer if it is started */
  ccStopConTmr(con, CC_TMR_PREANM);

  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
     
  if ((con->reconnectBcm == OBCM) || (con->reconnectBcm == TBCM))
  {
    ccStopConTmr(con, TMR_RECONNECT); 
    if(event != NULLP)
      ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                        sizeof (CcConEvnt));
    else ret = ROK;

    if(ret != ROK)
    {
        CCLOGERR("ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
    }

    if (con->icBcm.pic != PicOActive)
      answerFlag = TRUE;
    if (con->direction == INCTOOUT)
    {
      pBcm     = &(con->icBcm);
      pBcmComp = &(con->ogBcm);
    }
    else
    {
      pBcm     = &(con->ogBcm);
      pBcmComp = &(con->icBcm);
    }
#if 0
    /* Bug# 20832 */ 
    CCDP(AIN_DBG_LEVEL_0, "%s():: Send Reconnect Answer Indication to FIC\n", 
         __FUNCTION__);
    ccProcessTAnswer(&(con->ogBcm));
    ccProcessOAnswer(&(con->icBcm));
#endif

    CCDP(AIN_DBG_LEVEL_0, "icSu:%ld, ogSu:%ld, direction:%d, suCtxId:%ld,"
         "answerFlag:%d, bcmType:%d, transId:%ld\n", con->icSuConnId,
         con->ogSuConnId, con->direction, 
         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
         answerFlag, pBcm->bcmType, pBcm->svcHeader.transId);
    if (ccIsIPSubscriber(pBcm))
    {
      con->reconnectBcm = 0;
      if (!answerFlag)
      {
        if (con->keepGCCCallInfo == FALSE)
        {
        con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
        }
        con->tmdRelApplied = CC_CHECK_TMD_RELEASE;

#ifdef ZC
        upd.con = con;
        zcRunTimeUpd(ZC_CON_CB, CMPFTHA_CREATE_REQ, upd);
        zcUpdPeer();
#endif
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
      if (CC_IS_CCID_CC10_AND_ABOVE(pBcmComp))
        ccCreateOnSwitchBearer(pBcm, NULLP, NULLP, NULLP,
                               pBcm->con->state, answerFlag);
      else
        ccCreateBearer(pBcmComp, pBcm, NULLP, NULLP, pBcm->con->state,
                       answerFlag);
      RETVALUE(ROK);
    }
    else
    {
      ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                   MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                   pBcm, NULLP, NULLP,
                                   NULLP, NULLP, NULLP, 
                                   (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                   MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
      if (pBcm->cc != NULLP)
      {
        if (isCaleaLegPresent(pBcm))
          ccAddCaleaToMgQForSpecificCon(pBcm, con);
  
        if ((isCaleaLegPresentInSurrogate(pBcm->con)) &&
            (pBcm->bcmType == BtTBcm))
        {
          if (pBcm->con->surrogate != NULLP)
          {
            /* Call Forward case. Add the Surrogate Calea's to the MgiCmdQ */
            pSurrogate = pBcm->con->surrogate;
            while (pSurrogate != NULLP)
            {
              CCDP(AIN_DBG_LEVEL_0,
                   "Adding Any remaining Calea Leg's attached to"
                   "Surrogate=%ld\n", pSurrogate->bcm.svcHeader.transId);
              ccAddCaleaToMgQForSpecificCon(&(pSurrogate->bcm), con);
              pSurrogate = pSurrogate->next;
            }
          }
        }
      }
#endif
      /* Send the Mg Queue. */
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                         CCS_CANNOTPROCESSEVENTS);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      CCDP(AIN_DBG_LEVEL_0, "SendMgi for Reconnect: %ld\n", con->icSuConnId);
      if (ret != ROK)
      {
        CCLOGERR("Error: Mgi Txn not sent: %ld\n", con->icSuConnId);
        cleanUpMgQ(con);

        con->reconnectBcm = 0;
        if (con->icBcm.pic != PicOActive)
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, TRUE);
        else
        {
          con->mgPlayingTone = FALSE;
          if (con->keepGCCCallInfo == FALSE)
          {
          con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
          }
          con->tmdRelApplied = CC_CHECK_TMD_RELEASE;

#ifdef ZC
          cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
          upd.con = con;
          zcRunTimeUpd(ZC_CON_CB, CMPFTHA_CREATE_REQ, upd);
          zcUpdPeer();
#endif /* ZC */
          CC_STATE_CHANGE(con, CCS_ANSWERED);
        }
      }
      RETVALUE(ROK);
    }
  }

  /* Feature 14704.0 - Enhance BTS to Support a Q.825 Biling Interface*/
  if ((con->direction == OUTTOINC) && (con->ogIntfcCb != NULL) && 
      ((CC_GET_PROTOCOL(con->ogIntfcCb->protType)==CC_SI) || (CC_GET_PROTOCOL(con->ogIntfcCb->protType)==CC_EXT_BICC)))
  {
      if( (conEvnt != NULL) && (conEvnt->m.siConEvnt.bckCallInd.cadPtyCatInd.pres)) /* bug#71157 */
      {
          con->callDtlInfo.cm.cadPtyCatInd.pres = conEvnt->m.siConEvnt.bckCallInd.cadPtyCatInd.pres;
          con->callDtlInfo.cm.cadPtyCatInd.val  = conEvnt->m.siConEvnt.bckCallInd.cadPtyCatInd.val;
          CCDP(AIN_DBG_LEVEL_0, "cadPtyCatInd from ISUP/BICC message, the value is %d\n", con->callDtlInfo.cm.cadPtyCatInd.val);
      }
  }
  
  /* FID 15318 IOI */  
  if(IS_IT_INTRA_CCS_CALL(con))        
  {        
      if(((CC_GET_PROTOCOL(con->icProtType) == CC_SI) ||
          (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC)||
          (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)) && 
         (CC_GET_PROTOCOL(con->ogProtType) == CC_SIP))        
      {        
          ccExtractPChargingVectorFromConEvent(con, &(((CcConEvnt *)event)->m.sipConEvnt) );        
      }        
  }        
  else if(CC_EGRESS_INTER_CCS_CALL(con))        
  {        
      CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);        
      if(((CC_GET_PROTOCOL(con->icProtType) == CC_SI) ||
          (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC)||
          (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)) && 
         (egressCCS_OgProtType == CC_SIP))        
      {        
          ccExtractPChargingVectorFromConEvent(con, &(((CcConEvnt *)event)->m.sipConEvnt) );        
      }       
  }   
  
  /* Feature 2290 - KPN ALS70 POTs (CAS) support */
  if((conCfmEvnt != NULLP) &&  (conCfmEvnt->als70KPNinfo.pres == PRSNT_NODEF))
  {
      /* populate the og portion of the ALS70 KPN info */
      con->als70KPNinfo |= (conCfmEvnt->als70KPNinfo.val & ALS70_OG_MASK);
  }

  /* FID 13979, copy histInfoEntries */
  CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCS_IcProtType);
  if ((icProtType == CC_SIP) || (ingressCCS_IcProtType == CC_SIP) ||
      (icProtType == CC_SIPT) || (ingressCCS_IcProtType == CC_SIPT))
  {
      if ((ogProtType == CC_SIP) &&
          (((CcConEvnt *)event)->m.sipConEvnt.sipHistInfo.eh.pres))
      {
          ccExtractHistInfoEntries(&(con->histInfoEntries), 
              &(((CcConEvnt *)event)->m.sipConEvnt.sipHistInfo.otherEntries));
      }
      else if ((ogProtType == CC_SIPT) &&
               (((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sipHistInfo.eh.pres))
      {
          ccExtractHistInfoEntries(&(con->histInfoEntries), 
            &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sipHistInfo.otherEntries));
      }
  }
  /* End of FID 13979 */

 /* FID 14732 */
 ccExtractSipwMBufFromConIndAndConCfm(con, CCE_CONCFM, (PTR) event);
 /* FID 14732 */

  /* Bug 79156 */
  if (!(con->callDtlInfo.cm.iamRspFlag))
   con->callDtlInfo.cm.iamRspFlag = TRUE;

  ccExtractCallReferenceForANM(con, event);
  /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
  sdpRet = ROK;
  if (con->direction == OUTTOINC)
  {
     switch (ogProtType)
     {
        case CC_MGCP_LN:  
        case CC_MGCP_TG:
           sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                                    &(((CcConEvnt *)event)->m.mgcpCctEvnt.sdp));
           break;

        case CC_BICC:
           sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                                     &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.bicc.sdp));
           break;
 
        case CC_SIPT:
            sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                                      &(((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.sdp));
            /* FID-2575: LMSD + */
           ccExtractSipMethodSupport(con, OUTTOINC,
             ((CcConEvnt *)event)->m.siConEvnt.optElmnt.sipt.headerSupportMask);
            /* FID-2575: LMSD - */

            break;

        case CC_SIP:
           sdpRet = ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                                    &(((CcConEvnt *)event)->m.sipConEvnt.sdp));
           /* FID-2575: LMSD + */
           ccExtractSipMethodSupport(con, OUTTOINC,
              ((CcConEvnt *)event)->m.sipConEvnt.headerSupportMask);
           /* FID-2575: LMSD - */

#if 0 /* 35279 */
          if (((CcConEvnt *)event)->m.sipConEvnt.ogSipIdPres == PRSNT_NODEF)
          {
            /* Set the call ID */
            con->callDtlInfo.un.ogSipIdPres = PRSNT_NODEF;
            memcpy(con->callDtlInfo.un.ogSipId, ((CcConEvnt *)event)->m.sipConEvnt.ogSipId,
                   CC_SIP_ID_LENGTH);
          }
#endif /* 35279 */
          break;
     }
  }
  /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
  if (sdpRet != ROK)
  {
     CCLOGERR("Error: SDP parsing failed - %d\n", sdpRet);
     con->failCndVal = FC_PROTERR;
     /* Bug 78139 */
     if (con->keepGCCCallInfo == FALSE)
     {
       con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
     }

     if (CC_IS_CONTEXT_PRESENT(con))
     {
        ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret != ROK)
        {
           CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
           cleanUpMgQ(con);
           ccCleanUpMGCtx(con);
        }
        else
        {
           CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
           con->mgBlock->con = con;
           con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
           RETVALUE(ROK);
        }
     } 
     ccFreeTheRscFromCon(con, OUTTOINC);
     ccProcessFailCnd(con, con->failCndVal, TRUE);
     RETVALUE(ROK);
  }
  
  /* + FID 16118.0 */
  CC_LOCATE_RMT_SDP(con, rmtSdp);
  if ((CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_AGNOSTIC_NO_OFFER_CANDIDATE)) &&
      (con->direction == OUTTOINC) && (rmtSdp) &&
      (!CC_IS_BCM_IN_CONTEXT(&con->ogBcm)))
  {
    ccAllocateMultiMediaCb(con);
    if (IS_MULTIMEDIA_4_BCM(&con->ogBcm))
    {
      /* FID 14941.0 */
      /* ccStoreMMBillingSdp is not invoked by ccExtractProtSdp for
         the initial offer */
      ccStoreMMBillingSdp(&con->ogBcm, FALSE, rmtSdp);
    
      MULTIMEDIACB_4_BCM(&con->ogBcm)->StreamCount = rmtSdp->numDecode;

      ccEnableMediaAwareStream_4_BCM (&con->ogBcm, rmtSdp);
    }

    if (IS_MULTIMEDIA_4_BCM(&con->icBcm))
    {
      MULTIMEDIACB_4_BCM(&con->icBcm)->StreamCount = rmtSdp->numDecode;
      ccEnableMediaAwareStream_4_BCM (&con->icBcm, rmtSdp);
    }

    if(IS_MULTIMEDIA_4_BCM(&con->ogBcm))
    {
      ccCheckToSkipStream(con, rmtSdp);
    }
    if (IS_MULTIMEDIA(con)) /* looks like MG is needed */
      ccFillIpVersion(con, CC_SWREQ_MAX);/* BUG:90566 */
  }
  /* - FID 16118.0 */

  ccGeoExtractProtCri(con, (CcAllSdus *)event, CCE_CONCFM);
  
  ccPopulateTmuFromANM(con, event);
  /* Stop the Answer Supervision fraud timer, if it is running */
  ccCleanAnsFraudCall(con);

#if 0 /* Will be done in ccAnswerCall() , Bug# 26435*/
  /* Start the Fraud Timer if it is digit Screen FraudCall */ 
  if (con->ainInfo.scrFraudPrflId)
  {
    if (con->fraudPrflbmap & SET_SCR_ZERODUR_CDR_FLAG)
    {
      ccGenZeroDurFraudCDR(con);
    }
    ccStartConTmr(SCR_FRAUD_TMR, con, (PTR)&ccCp.genCfg);
  }
#endif

  mgiAction = ccFindSwitchingAction(con, CCE_CONCFM, 0,
          con->direction, &con->icBcm, &con->ogBcm, &icMode, &ogMode,
              &icSignal, &ogSignal, event, TRUE);

  CCDP(AIN_DBG_LEVEL_3, "Action == %d, icMode == %d, icSignal == %d,"
          " ogMode == %d, ogSignal == %d\n", mgiAction, icMode, icSignal,
              ogMode, ogSignal);

  CCDP(AIN_DBG_LEVEL_3,"%s: EnhEchoLogicVal=0x%lx\n",
       __FUNCTION__, con->echoParam.EnhEchoLogicVal);

  /* FID 14677.0 */
  /* Backward direction procedure */
  if(mgiAction != CC_NO_MGI_ACTION)
  {
     if ((ccProcessBackwrdDirEcho(con, (CcAllSdus *)event)) != ROK)
     {
        /* Bug 78139 */
        if (con->keepGCCCallInfo == FALSE)
        {
          con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
        }

        CCDP(AIN_DBG_LEVEL_3, "ERROR: ccProcessBackwrdDirEcho FAILED\n");
        RETVALUE(RFAILED);
     }
  }
  else if ((mgiAction == CC_NO_MGI_ACTION) &&
           (IS_ECHO_ENHTYPE1_AND_INVOKE(con)))
  {
     if (((!CC_INGRESS_INTER_CCS_CALL(con) && !CC_EGRESS_INTER_CCS_CALL(con) &&
           !CC_IS_CALL_MULTI_MG(con)) ||
          CC_OPERATING_EGRESS_MG(con)) &&
         ((ogProtType == CC_SI) || (ogProtType == CC_SIPT)))
     {
        if ((ccProcessBackwrdDirEcho(con, (CcAllSdus *)event)) != ROK)
        {
           /* Bug 78139 */
           if (con->keepGCCCallInfo == FALSE)
           {
            con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
           }

           CCDP(AIN_DBG_LEVEL_3, "ERROR: ccProcessBackwrdDirEcho FAILED\n");
           RETVALUE(RFAILED);
        }
     }
     if ((!CC_OPERATING_EGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_INGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
     }
     if ((!CC_OPERATING_INGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_EGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
     }
  }

  CCDP(AIN_DBG_LEVEL_3, "Action=%d, icMode=%d, icSignal=%d, ogMode=%d, ogSignal=%d\n",
       mgiAction, icMode, icSignal, ogMode, ogSignal);

  if(mgiAction != CC_NO_MGI_ACTION)
  {
    /* FID 15261.0 + */
    ret=ccProcessConCfmWithSwitching(con, (PTR)event);
    if (ret!=ROK)
    {
     /* Bug 78139 */
     if (con->keepGCCCallInfo == FALSE)
     {
       con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
     }
      RETVALUE(RFAILED);
    }
    /* FID 15261.0 - */
  }
  else
  {
    /* FID 15261.0 + */
    ret=ccProcessConCfmNoSwitching(con, (PTR)event);
    if (ret!=ROK)
    {
      /* Bug 78139 */
      if (con->keepGCCCallInfo == FALSE)
      {
        con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
      }

      RETVALUE(RFAILED);
    }
    /* FID 15261.0 - */
  }
  RETVALUE(ROK);
}

/* FID 15261.0 + */
PUBLIC S16 ccProcessConCfmWithSwitching
(
CcConCb *con,
PTR     event
)
{
  AinBCM_t               *pOtherBcm      = NULLP;
#ifdef CC_CALEA
  U8                      alertingType   = CltMax;
#endif
  U8                      mgiAction;
  U8                      icMode;
  U8                      ogMode;
  U8                      icSignal;
  U8                      ogSignal;
  MgctEcho                ingressEcho;
  MgctEcho                egressEcho;
  S16                     ret            = RFAILED;
  AinBCM_t               *pTmpIcBcm      = NULLP;
  AinBCM_t               *pTmpOgBcm      = NULLP;
  MgctEcho               *pIngrEcho      = NULLP;
  MgctEcho               *pEgrEcho       = NULLP;
  MgctEventsDescriptor   *pIcEvDesc      = NULLP;
  MgctEventsDescriptor   *pOgEvDesc      = NULLP;
  S16                     con2Ret        = RFAILED;
  MgctEventsDescriptor    icEvDesc;
  MgctEventsDescriptor    ogEvDesc;
  MgctTermStateDesc       icTermStateDesc, *pIcTermStateDesc = NULLP;
  MgctTermStateDesc       ogTermStateDesc, *pOgTermStateDesc = NULLP;
  MgctMediaDesc           icMediaDesc, *pIcMediaDesc = NULLP;
  MgctMediaDesc           ogMediaDesc, *pOgMediaDesc = NULLP;
  ProtType                icProtType     = CC_GET_PROTOCOL(con->icProtType);
  ProtType                ogProtType     = CC_GET_PROTOCOL(con->ogProtType);
  U8                      ingrEchoPres = NOTPRSNT, egrEchoPres = NOTPRSNT;
  U16                     ingrEchoTail = 0, egrEchoTail = 0;
  TELICA_TGP_NLP_ENUM     ingrEchoCntrlNLP = TGP_NLP_MAX, egrEchoCntrlNLP = TGP_NLP_MAX;
  TELICA_TGP_EC_ENUM      ingrEchoCntrlType = TGP_EC_MAX, egrEchoCntrlType = TGP_EC_MAX;
  MgctMode                currentIcMode   = MGCT_MODE_MAX;
  MgctMode                currentOgMode   = MGCT_MODE_MAX;
  MgctPackageId           currentIcPkgId  = MGCT_PACKAGE_ID_MAX;
  MgctPackageId           currentOgPkgId  = MGCT_PACKAGE_ID_MAX;
  MgctCallProgItemId      currentIcSignal = MGCT_ITEM_ID_CG_MAX;
  MgctCallProgItemId      currentOgSignal = MGCT_ITEM_ID_CG_MAX;
  Sdp                    *rmtSdp          = NULLP;
  Sdp                    *compLocSdp      = NULLP;
  Bool                   lockDownCodecNeeded = FALSE;
  TknU8                   DSVal;
  U8                      needVBDModify = FALSE; /* FID 14844.1 */
  U8                      algorithm = LCC_CODECREORDER_NONE;

  cmMemset((U8*) &ingressEcho, 0, sizeof(MgctEcho));
  cmMemset((U8*) &egressEcho, 0, sizeof(MgctEcho)); 
  cmMemset((U8*) &icEvDesc, 0, sizeof(MgctEventsDescriptor));
  cmMemset((U8*) &ogEvDesc, 0, sizeof(MgctEventsDescriptor));
  cmMemset((U8*) &icMediaDesc, 0, sizeof(MgctMediaDesc));
  cmMemset((U8*) &ogMediaDesc, 0, sizeof(MgctMediaDesc));
  DSVal.pres = NOTPRSNT;
  DSVal.val = 0;

  mgiAction = ccFindSwitchingAction(con, CCE_CONCFM, 0,
          con->direction, &con->icBcm, &con->ogBcm, &icMode, &ogMode,
              &icSignal, &ogSignal, event, FALSE);

  CCDP(AIN_DBG_LEVEL_3, "Action == %d, icMode == %d, icSignal == %d,"
          " ogMode == %d, ogSignal == %d\n", mgiAction, icMode, icSignal,
              ogMode, ogSignal);

  CCDP(AIN_DBG_LEVEL_3,"%s: EnhEchoLogicVal=0x%lx\n",
       __FUNCTION__, con->echoParam.EnhEchoLogicVal);

  /* FID 14677.0 */
  if ((mgiAction == CC_NO_MGI_ACTION) &&
      (IS_ECHO_ENHTYPE1_AND_INVOKE(con)))
  {
     if ((!CC_OPERATING_EGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_INGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
        SET_IC_AND_OG_MODE_FOR_EC(con, currentIcPkgId, currentIcSignal, currentIcMode,
            currentOgPkgId, currentOgSignal, currentOgMode, icMode, icSignal, ogMode,
            ogSignal);
        con->echoParam.EnhEchoLogicVal &= ~CC_INGRESS_MGI_MODIFY;
        CCDP(AIN_DBG_LEVEL_3,"%s: EnhEchoLogicVal=0x%lx\n",
             __FUNCTION__, con->echoParam.EnhEchoLogicVal);
     }
     if ((!CC_OPERATING_INGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_EGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
        SET_IC_AND_OG_MODE_FOR_EC(con, currentIcPkgId, currentIcSignal, currentIcMode,
            currentOgPkgId, currentOgSignal, currentOgMode, icMode, icSignal, ogMode,
            ogSignal);
        con->echoParam.EnhEchoLogicVal &= ~CC_EGRESS_MGI_MODIFY;
        CCDP(AIN_DBG_LEVEL_3,"%s: EnhEchoLogicVal=0x%lx\n",
             __FUNCTION__, con->echoParam.EnhEchoLogicVal);
     }
  }
  else
  {
    if (!CC_OPERATING_EGRESS_MG(con))
    {
      con->echoParam.EnhEchoLogicVal &= ~CC_INGRESS_MGI_MODIFY;
    }
    if (!CC_OPERATING_INGRESS_MG(con))
    {
      con->echoParam.EnhEchoLogicVal &= ~CC_EGRESS_MGI_MODIFY;
    }
  }

  /* FID 15261.0 + */
  if ((mgiAction == CC_NO_MGI_ACTION))
  {
    if (con->ccmCb.state == CC_EGRESS_MG)
    {
      if(ogProtType == CC_SIP)
        ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(SipConEvnt));
      else if(event != NULLP)
        ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcConEvnt));
      else ret = ROK;

      if(ret != ROK)
      {
        CCLOGERR("ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
      }

      if (con->ccmCb.ccn == CCN_5)
        con->ccmCb.state = CC_Y_MG;
      else
        con->ccmCb.state = CC_INGRESS_MG;

      return(ccProcessConCfmWithSwitching(con, event));
    }
    else if (con->ccmCb.state == CC_Y_MG)
    {
      con->ccmCb.state = CC_INGRESS_MG;
      return(ccProcessConCfmWithSwitching(con, event));
    }
    else
    {
      return(ccProcessConCfmNoSwitching(con, event));
    }
  }
  /* FID 15261.0 - */

  if (CC_IS_STEROMONO_CALL(con))
  {
     if (con->ccmCb.state == CC_EGRESS_MG)
     {
        if(event != NULLP)
           ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcConEvnt));
        else ret = ROK;

        if(ret != ROK)
        {
           CCLOGERR("ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           RETVALUE(RFAILED);
        }
        /* Store the E01 event since we may need to map this out later */
     }
  }

  if(mgiAction == CC_MGI_ACTION_ADD) mgiAction = MGCT_CMD_ADD;
  else if(mgiAction == CC_MGI_ACTION_SFM_ADD) mgiAction = MGCT_CMD_ADD;
  else mgiAction = MGCT_CMD_MODIFY;

  /* BUG: 61139 : Deleted ccProcessOverLoadControl */

  if (con->icBcm.cc)
  {
    if ((con->icBcm.cc->ccId == CiStableMParty) &&
        (!isAnyOtherLegInAlerting(con->icBcm.cc->legId1)))
    {
      con->mgPlayingTone = FALSE;
      ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
      ccUpdateMgQForAddAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con, 0, FALSE,
                              MGCT_ITEM_ID_CG_MAX);
    }
    else if ((con->icBcm.cc->ccId == CiTransfer) ||
             (con->icBcm.cc->ccId == CiRemoteTransferSetup))
    {
      if (!CC_IS_CALL_MULTI_MG(con))
      {
        con->mgPlayingTone = FALSE;
        con2Ret = ccIsContextInConference(con->mgBlock->mgCtx);
        if (con2Ret == ROK) 
        {
          if (!isAnyOtherLegInAlerting(con->icBcm.cc->legId1))
          {
            DP("Adding RingBack as conf rsc:%ld,%ld\n",
               (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con->icSuConnId);
            ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
            ccUpdateMgQForAddAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con, 0, FALSE,
                                    MGCT_ITEM_ID_CG_MAX);
          }
        }
        else
        {
          DP("Need to put a signal descriptor :%ld, %ld, %d\n",
             con->icSuConnId, con->ogSuConnId, con->mgBlockDirection);
          pOtherBcm = ccFindOtherBcm(&(con->icBcm));
          if (pOtherBcm)
            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_NULL, MGCT_CMD_MODIFY,
                                         pOtherBcm, NULLP, NULLP,
                                         NULLP, NULLP, NULLP,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, con);
        }
        mgiAction = MGCT_CMD_MODIFY; 
      }
      else
      {
        con->mgPlayingTone = FALSE;
        mgiAction = MGCT_CMD_MODIFY;
      }
    }
  }

  CCDP(AIN_DBG_LEVEL_1, "%s: CCN=%d, state=%d\n", 
       __FUNCTION__, con->ccmCb.ccn, con->ccmCb.state);
  
  /* FID 14972.0 & FID 15261.0 + */
  CC_LOCATE_RMT_SDP(con, rmtSdp);

  CC_DERIVE_BCMS(con, pTmpIcBcm, pTmpOgBcm);

  CHECK_REPLACE_SDP_4_BCM(pTmpIcBcm, rmtSdp);

  if (IS_MULTIMEDIA_NO_MEDIA_AWARE(con))
  {
    icMode = ogMode = MGCT_MODE_SENDRECV;
    icSignal = ogSignal = MGCT_ITEM_ID_CG_MAX;
    /* bug93457 */
    if (((icProtType == CC_SIP) || (icProtType == CC_SIPT)) &&
        ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT)))
    {
        if (ccIsRmtSdpNotApplied(con))
        {
            if (con->remoteSdpSentOnIcBCM && ccIsForkedCall(con))
            {
                CCDP(AIN_DBG_LEVEL_0, "E01S09: Setting renegSdpAfterAns\n");
                con->renegSdpAfterAns = TRUE;
            }
        }

    }
  }
  else
  {
    /* We should take care of Echo Cancellation */
    ccUpdateMgEchoParam(con, &ingressEcho, &egressEcho);

    if (ingressEcho.pres == PRSNT_NODEF)
      pIngrEcho = &ingressEcho;
    if (egressEcho.pres == PRSNT_NODEF)
      pEgrEcho = &egressEcho;

    if (mgiAction == MGCT_CMD_ADD)
    {
      CCDP(AIN_DBG_LEVEL_0, "Building EventsDesc icSu = 0x%lx, ogSu = 0x%lx"
           "state = %d\n", con->icSuConnId, con->ogSuConnId, con->state);
      ccBuildMgctEventsDescriptor(con, &(con->icBcm), &(con->ogBcm), &icEvDesc,
                                  &ogEvDesc);
    }

    cmMemset((U8*)&icTermStateDesc, 0, sizeof(MgctTermStateDesc));
    cmMemset((U8*)&ogTermStateDesc, 0, sizeof(MgctTermStateDesc));

  #if 0
    /* GR changes +*/
    ccGeoPopulateCcCriIfNeeded(&con->icBcm, mgiAction, icMode, NULLP, NULLP);
    ccGeoPopulateCcCriIfNeeded(&con->ogBcm, mgiAction, ogMode, NULLP, NULLP);
    /* GR changes -*/
  #endif

    ccBuildT38TermStateDescInAddIfReqd(con, mgiAction, &icTermStateDesc, 
                                       &ogTermStateDesc, &icEvDesc, &ogEvDesc);

    /* Bug 75680 */
    ccBuildXnqTermStateDescInAddIfReqd(con, mgiAction, &icTermStateDesc,
                                       &ogTermStateDesc);

    if(ogTermStateDesc.propertyList)
      pOgTermStateDesc = &ogTermStateDesc;
    if(icTermStateDesc.propertyList)
      pIcTermStateDesc = &icTermStateDesc;

    /* FID 15261.0 + */
    if (CC_IS_CALL_MULTI_MG(con))
    {
      if (con->ccmCb.state == CC_INGRESS_MG)
      {
        pEgrEcho = NULLP;
      }
      else if (con->ccmCb.state == CC_EGRESS_MG)
      {
        pIngrEcho = NULLP;
      }
      else if (con->ccmCb.state == CC_Y_MG)
      {
        pIngrEcho = NULLP;
        pEgrEcho = NULLP;
      }
    }
    /* FID 15261.0 - */

    pIcMediaDesc = &icMediaDesc;
    pOgMediaDesc = &ogMediaDesc;

    /* Bug 65584 */
    if (CC_OFFANS_ICOFFER_PENDING(con))
    {
      if (pTmpIcBcm->bcmType == BtOBcm)  /* FID 15261.0 */
        mgctSetReservedValueOnBcm(pTmpIcBcm, pIcMediaDesc, &(con->ctl));
    }

    if(pIngrEcho)
    {
      ingrEchoPres      = pIngrEcho->pres;
      ingrEchoTail      = pIngrEcho->echoTail;
      ingrEchoCntrlNLP  = pIngrEcho->echoCntrlNLP;
      ingrEchoCntrlType = pIngrEcho->echoCntrlType;
    }

    /* + FID 14844.1 , Suppose VBD was offered and Answer came
       back with no VBD, we need to turnOff VBD on the Incoming leg */
    if (mgiAction == MGCT_CMD_ADD)
    {
      ccSetVBDFlagsInCon(con, rmtSdp);
    }
    else if (mgiAction == MGCT_CMD_MODIFY)
    { 
      /* Case where Offer/Ans is not complete on the Ingress */
      CC_PROCESS_VBD_ANSWER_SDP(rmtSdp, con, CC_FLAG_OG_VBD_NEGOTIATED, needVBDModify);
    }
      /* - FID 14844.1 */

    if((rmtSdp != NULL) && 
       CC_IS_MG_NEEDED_IN_IP_CALL(con) &&
       (ccIsPassThruDoneOnOffer(pTmpOgBcm) ||
        ((pTmpOgBcm->bcmType == BtTLiAdjBcm) && (mgiAction != MGCT_CMD_ADD) &&
         (!CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION))))) /* FID15068.0 */
    {
      lockDownCodecNeeded = TRUE;
      CC_SET_PASSTHRU_FLAG(con,CC_PASSTHRU_APPL_LOC_SDP);

      /* build locSdp for ingress leg based on rmtSdp, set ip/port */
      if (pTmpIcBcm->bcmType == BtTAdjBcm)
        ccCreateLocSdpFromSrcSdp(&compLocSdp, rmtSdp, PRSNT_NODEF, (con->ogAdjIpParam));
      else if (pTmpIcBcm->bcmType == BtOLiAdjBcm)
        ccCreateLocSdpFromSrcSdp(&compLocSdp, rmtSdp, PRSNT_NODEF, (con->icLiAdjIpParam));
      else
        ccCreateLocSdpFromSrcSdp(&compLocSdp, rmtSdp, PRSNT_NODEF, &(con->icIpParam));

      /* FID 15681.0 - Apply transcoding policy when processing Response SDP */
      algorithm = ccGetCodecReorderAlgorithm(pTmpOgBcm, CC_OWN_INTF);
      if (algorithm == LCC_CODECREORDER_PASSTHRU)
      {
         ccApplyTPOnAnsSdp( pTmpIcBcm, compLocSdp );
      }

      /* Bug 73456 make sure compLocSdp has ptime, if not, use the passThruPtime saved on con */
      ccSetAndSavePassThruPtime(&(con->icBcm), compLocSdp, TRUE); 
      mgctMediaDesc(&(con->ctl), NOTPRSNT, icMode, ingrEchoPres, ingrEchoTail,
                    ingrEchoCntrlNLP, ingrEchoCntrlType, 0, FALSE, 0, DSVal, compLocSdp,
                    NULLP, pIcTermStateDesc, pIcMediaDesc);
      mgctSetReservedValueOffBcm(pTmpIcBcm, pIcMediaDesc, &(con->ctl));
    }
    /* FID 14972.0 - */
    else
    {
      /* + FID 14844.1 */
      /* Suppose VBD was sent in Offer and Ans came with no VBD, then send localSdp 
         with VBD muted on the complement IP leg */
      compLocSdp = NULL;

      if (needVBDModify)
      {
        if (pTmpIcBcm->bcmType == BtTAdjBcm)
        {
          /* Egress MG */
          if (con->ogAdjIpParam && con->ogAdjIpParam->locDesc)
          {
            ccCreateLocSdpFromSrcSdp(&compLocSdp, con->ogAdjIpParam->locDesc, PRSNT_NODEF, (con->ogAdjIpParam));
          }
        }
        else
        {
          /* Ingress MG or single MG call */
          if (con->icIpParam.locDesc)
          {
            ccCreateLocSdpFromSrcSdp(&compLocSdp, con->icIpParam.locDesc, PRSNT_NODEF, &(con->icIpParam));
          }
        }

        if (compLocSdp)
        {
          mgctSetReservedValueOffBcm(pTmpIcBcm, pIcMediaDesc, &(con->ctl)); 
          /* Disable VBD codecs */
          ccDisableVBDCodecs(compLocSdp);
        }
      }
      /* - FID 14844.1 */

      mgctMediaDesc(&(con->ctl), NOTPRSNT, icMode, ingrEchoPres, ingrEchoTail,
                    ingrEchoCntrlNLP, ingrEchoCntrlType, 0, FALSE, 0, DSVal, compLocSdp, /* FID 14844.1 */
                    NULLP, pIcTermStateDesc, pIcMediaDesc);
    }

    if(pEgrEcho)
    {        
      egrEchoPres      = pEgrEcho->pres;
      egrEchoTail      = pEgrEcho->echoTail;
      egrEchoCntrlNLP  = pEgrEcho->echoCntrlNLP;
      egrEchoCntrlType = pEgrEcho->echoCntrlType;
    }

    /* FID 14972.0 + */
    if (lockDownCodecNeeded == TRUE)
    {
      mgctSetReservedValueOffBcm(pTmpOgBcm, pOgMediaDesc, &(con->ctl));
    }
    /* FID 14972.0 - */

    mgctMediaDesc(&(con->ctl), NOTPRSNT, ogMode,  egrEchoPres, egrEchoTail,
                  egrEchoCntrlNLP, egrEchoCntrlType, 0, FALSE, 0, DSVal, NULLP, NULLP,
                  pOgTermStateDesc, pOgMediaDesc);
  }
  /* if Hanging termination detect is on and timerx value is not zero */
  ccBuildHangtermEventDesc(con, mgiAction, &icEvDesc, &ogEvDesc);

  if (icEvDesc.pres == PRSNT_NODEF)
    pIcEvDesc = &icEvDesc;
  if (ogEvDesc.pres == PRSNT_NODEF)
    pOgEvDesc = &ogEvDesc;

  if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup))
  {
    if (CC_IS_CALL_MULTI_MG(con))
    {
      if (con->ccmCb.state == CC_INGRESS_MG)
      {
        pTmpIcBcm = NULLP;
      }
    }
    else
    {
      pTmpIcBcm = NULLP;
    }
  }
  ccProcessCcChangeforX2SIG(con); /*Bug85802*/

  /* FID17160.0 */
  if (CC_IS_STEROMONO_CALL(con) && (mgiAction == MGCT_CMD_ADD))
  {
     if ((con->direction == OUTTOINC)&&(con->ccmCb.state == CC_INGRESS_MG))
     {
        pTmpOgBcm = NULLP;
        pOgMediaDesc = NULLP;
        pOgEvDesc = NULLP;
        DP("If we are going to ADD concurBcm no need to add TDM again!\n");
     }
     if (con->ccmCb.state == CC_EGRESS_MG)
     {
        /*FID 17160.0 Store the event so when the ADD for third
         *termination done we have event for mapping */
     }
  }
  ccProcessForAddModify(con, pTmpIcBcm, pTmpOgBcm, mgiAction,
                        icMode, ogMode, icSignal, ogSignal, pIcMediaDesc,
                        pOgMediaDesc, pIcEvDesc, pOgEvDesc);

  /* Send the Mg Queue. */
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
  ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                     CCS_CANNOTPROCESSEVENTS);
  con->mgBlock->con = con;
  /* FID17160.0 */
  U32 suCtxId = 0;

  if (pTmpOgBcm&& pTmpOgBcm->mgCtx)
     suCtxId = pTmpOgBcm->mgCtx->suCtxId;
  else if (CC_IS_STEROMONO_CALL(con) && (mgiAction == MGCT_CMD_ADD))
  {
     if (con->ccmCb.state == CC_INGRESS_MG)
     {
        if (con->mgBlock &&con->mgBlock->mgCtx)
           suCtxId = con->mgBlock->mgCtx->suCtxId;
     }
  }
  ret = ccSendMgiQueue(suCtxId, con->mgBlock);
  if (ret != ROK)  
  { 
    CCLOGERR("ccSendMgiQueue : failed during Modify: %ld\n", con->icSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  /* FID 14972.0 & FID 15261.0 + */
  if (lockDownCodecNeeded == TRUE)
  {

    CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_APPL_LOC_SDP);

    if (algorithm == LCC_CODECREORDER_PASSTHRU)
    {
      CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_DONE_ON_FOFFER);
    }
    else
    {
        /* BUG: 80437 */
        if (ccIsLastPassThruNFMGHop(con))
          CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_DONE_ON_NFOFFER);
    }
  }
  /* FID 14972.0 & FID 15261.0 - */

#ifdef CC_CALEA
  if ((mgiAction == MGCT_CMD_ADD) || (mgiAction == MGCT_CMD_ADD))
  {
     /* This is the case where ConCfm was received directly */
     ccSendNetworkSignalMsg(con, FC_SIG_TONE, SigToneRingbackTone, 0, 0,
                         CC_INCOMING);

     if ((con->ogBcm.nel[EReqNetworkSignal] == NEL_NOTIFY) &&
         (con->ogBcm.svcHeader.transId != 0))
     {
        /* Terminating subject is being tapped */
        CCDP(AIN_DBG_LEVEL_1,"Terminating Subject is being tapped\n");
        /* Send NetworkSignal Notification with Dial Tone */
        /* Initializing the message buffers */
        alertingType = ccSetAlertingType(con);
        ccSendNetworkSignalMsg(con, 0,0, FC_SIG_ALERTING, alertingType,
                            CC_OUTGOING);
     }
     else
     {
        CCDP(AIN_DBG_LEVEL_1,"NetworkSignal Notifn. is not set for TBCM\n");
     }
  }
#endif /* End of CC_CALEA */

  /* FID 15261.0 + */
  if ((!CC_IS_CALL_MULTI_MG(con)) ||
      (CC_IS_CALL_MULTI_MG(con) && (con->ccmCb.state == CC_EGRESS_MG)))
  {
    /* Store Connect confirm event */
    if(ogProtType == CC_SIP)
      ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(SipConEvnt));
    else if(event != NULLP)
      ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcConEvnt));
    else ret = ROK;

    if(ret != ROK)
    {
        CCLOGERR("ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
    }
  }
  /* FID 15261.0 - */

  RETVALUE(ROK);
}  /* ccProcessConCfmWithSwitching */

PUBLIC S16 ccProcessConCfmNoSwitching
(
CcConCb *con,
PTR     event
)
{
  S16                     ret            = RFAILED;
  Buffer                 *uBuf           = NULLP;
  ProtType                icProtType     = CC_GET_PROTOCOL(con->icProtType);
  ProtType                ogProtType     = CC_GET_PROTOCOL(con->ogProtType);

  CCDP(AIN_DBG_LEVEL_0, "%s: evntType=%d, icEvntType=%d, icProtType=%d, ogProtType=%d\n",
       __FUNCTION__, con->evntType, con->icEvntType, icProtType, ogProtType);

  /* Bug 61542 */
  if (((icProtType == CC_SIP) || (icProtType == CC_SIPT)) &&
      ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT)))
  {
    if (ccIsRmtSdpNotApplied(con))
    {
      ccResetRmtSdpVersionChg(con);
      if (con->remoteSdpSentOnIcBCM && ccIsForkedCall(con))
      {
        CCDP(AIN_DBG_LEVEL_0, "E01S09: Setting renegSdpAfterAns\n");
        con->renegSdpAfterAns = TRUE;
      }
    }
  }

  /* FID 15261.0 + */
  if ((!CC_IS_CALL_MULTI_MG(con)) ||
      (CC_IS_CALL_MULTI_MG(con) && (con->ccmCb.state == CC_EGRESS_MG)))
  {
    /*euysal - 04/21/2005 - Support for O_Answer request */
    if(event != NULLP)
      ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                        sizeof (CcConEvnt));
    else ret = ROK;

    if(ret != ROK)
    {
      CCLOGERR("ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
    }
  }
  /* FID 15261.0 - */
    
  /* BUG:93930 */
  if (con->ogIntfcCb &&
      (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_IN) &&
      ((con->ogIntfcCb->sipHdrColpMap == ISDN_SIPHDRCOLPMAP_MAPSCRNORIG) ||
       (con->ogIntfcCb->sipHdrColpMap == ISDN_SIPHDRCOLPMAP_MAPSCRNTERM ))
     )
  {
    CCDP(AIN_DBG_LEVEL_1,"TAnswerReq may be armed process it!\n");
    ret = ccProcessTAnswer(&(con->ogBcm));
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_1,"TAnswerReq armed!\n");
      RETVALUE(ROK);
    }
  }
  else
    ccProcessTAnswer(&(con->ogBcm));

  ret = ccProcessOAnswer(&(con->icBcm));
  if (ret == ROK)
    RETVALUE(ROK);
  else if (ret == ROKDRSIG)
     ccAnswerCall(con, event, uBuf);
  else if (ret == RFAILED)
  {
    CCLOGERR("ERROR: ccprocessOAnswer FAILED: %ld\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  RETVALUE(ROK);
}  /* ccProcessConCfmNoSwitching */
/* FID 15261.0 - */

/*
 *
 *      Fun:   ccConE02S09
 *
 *      Desc:  Connection state function
 *             event - Address Indication
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 */

PRIVATE S16 ccConE02S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16    ret = RFAILED;
   Buffer *uBuf = NULLP;
   CcCnStEvnt      ogEvnt;
   /* FID 15174.0 + */
   CcConEvnt       ogEvnt1;
   SiCdPtyNum *CdPtyNum = NULLP;
   U8         calledLen;
   /* FID 15174.0 - */
   /* bug 91532 */
   cmMemset((U8 *)&ogEvnt1, 0, sizeof(ogEvnt1));

   CCDP(AIN_DBG_LEVEL_0, "con->icEvntType=%d\n",con->icEvntType);

   /* FID 15174.0 */
   CC_DISCARD_SAM(con);

   if ((con->direction != INCTOOUT) ||(CC_IS_OGOVERLAP_DISABLED(con)) ||
       (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) ||
       (con->isACMSent) || (con->isAnsIndSent) ||
       CC_IS_CALL_FLAG_SET(con->flag, CC_FLAG_IN_DIALOG_STOP))
   {
      CCDP(AIN_DBG_LEVEL_2, "ccConE02S09 - overlap not supported or has been stopped, ignore SAM\n");
      RETVALUE(ROK);
   }

   /* EARLY_ACM */
   if(CC_GET_PROTOCOL(con->icProtType) == CC_SI)
   {
       ccStopConTmr(con, CC_TMR_EARLYACM);
       CC_STARTTMR_EARLYACM(con);
   }
   ccStopConTmr(con, CC_TMR_TOIW3);

   if(CC_GET_PROTOCOL(con->icProtType) == CC_SI || /* FID 15174.0 */
         CC_GET_PROTOCOL(con->icProtType) == CC_BICC)
   {
       cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));

       CCDP(AIN_DBG_LEVEL_0, "%s:icEvntType:%d icSu:0x%lx\n",__FUNCTION__, con->icEvntType,con->icSuConnId);

       con->icEvnt = (CcAllSdus *)event;

       ccAddSubsqCalledDigits(con);

       if((con->ccEvntHold) && 
          CC_STDIGIT_PRESENT(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum))
       {
           con->STDigitRecd = TRUE;
       }

       /* Update con->ainInfo.cdPtyNum */
       ccConvertBcd2IsdnAddr(&(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum.oddEven),
                             (TknStrM *)&(con->ainInfo.cdPtyNum.nmbDigits), 
                             &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum.addrSig),
                             TRUE);
   }
   else
   {
      /* Should not happen here */
      RETVALUE(ROK);
   }

   ccBillUpdCdPtyNum (__FILE__, __LINE__, con);

   /* FID 15174.0 */
   CdPtyNum = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.cdPtyNum;
   calledLen = CC_FIND_NMB_DIGITS(CdPtyNum);
   CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 CdPN digits:CdPN=%d, minDigits=%d\n",
           calledLen, con->minDigits);

   if ((CC_GET_PROTOCOL(con->ogProtType) == CC_SI) ||
         (CC_GET_PROTOCOL(con->ogProtType) == CC_BICC))
   {
     /* ISUP overlap to ISUP overlap */
     con->ogEvnt = (CcAllSdus *)&ogEvnt;

     ret = ccMapEvent(con, CCE_ADDRIND, con->icEvntType);
     if (ret == CCIGNOREMAPPING)
     {
         ccDropUBuf(&con->uBuf);
         CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
         RETVALUE(ROK);
     }
     if (ret != ROK)
     {
         ccDropUBuf(&con->uBuf);
         CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                  " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                  con->ogProtType, con->icSuConnId, con->ogSuConnId);
         RETVALUE(ROK);
     }
     else
     {
         uBuf = con->uBuf;
         con->uBuf = NULLP;
         ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                       con->ogSapCb->spId, con->ogSpConnId,
                       con->ogSuConnId, con->ogProtType, con->ogEvntType,
                       &ogEvnt, uBuf);
         CCDP(AIN_DBG_LEVEL_0, "Mapped SAM message icSu :0x%lx\n",
              con->icSuConnId);
         RETVALUE(ROK);
     }
   }
   else if (CC_GET_PROTOCOL(con->ogProtType) == CC_SIPT)
   {
      /* ISUP overlap to SIPT Multi-Invite overlap */

      /* Check if outgoing side has no live session */
      if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_484_RCVD))
      {
         if ((con->minDigits > 0) && (calledLen < con->minDigits))
         {
            /* CdPN is less then minDigits, Wait for more digits */
            CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 Wait for more digits:CdPN=%d, minDigits=%d\n",
                 calledLen, con->minDigits);

            /* Restart Toiw3 Timer */
            ccStartConTmr(CC_TMR_TOIW3, con, (PTR)&ccCp.genCfg);

            RETVALUE(ROK);
         }
         else
         {
            /* Got enough CdPN digits, fall through */
            CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 :CdPN=%d >= minDigits:%d\n", calledLen, con->minDigits);

            /* Clear the 484 indicator */
            CC_CLR_CALL_FLAG(con->flag,CC_FLAG_484_RCVD);
         }
      }

      con->icEvnt = con->ccEvntHold;
      con->ogEvnt = (CcAllSdus *)&ogEvnt1;

      ret = ccMapEvent(con, CCE_CONIND, 0);

      if (ret != ROK)
      {
         ccDropUBuf(&con->uBuf);
         CCLOGERR("FID 15174.0 Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                  " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                  con->ogProtType, con->icSuConnId, con->ogSuConnId);
         RETVALUE(ROK);
      }
      else
      {
         uBuf = con->uBuf;
         con->uBuf = NULLP;

         CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 Mapped SAM message to Multi Invite icSu :0x%lx\n",
              con->icSuConnId);

         /* SEND CONNECT REQUEST TO LOWER LAYER */
         CcLiCctConReq(&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSuConnId,
                       &con->ogRsc, con->ogProtType, &ogEvnt1, uBuf, con);

         RETVALUE(ROK);
      }
   }
   else if (CC_GET_PROTOCOL(con->ogProtType) == CC_SIP)
   {
      /* Check if outgoing side has no live session */
      if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_484_RCVD))
      {
         if ((con->minDigits > 0) && (calledLen < con->minDigits))
         {
             /* CdPN is less then minDigits, Wait for more digits */
             CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 Wait for more digits:CdPN=%d, minDigits:%d\n",
                  calledLen, con->minDigits);

             /* Restart Toiw3 Timer */
             ccStartConTmr(CC_TMR_TOIW3, con, (PTR)&ccCp.genCfg);

             RETVALUE(ROK);
         }
         else
         {
            CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 :CdPN=%d >= minDigits:%d\n", calledLen, con->minDigits);

            con->icEvnt = con->ccEvntHold;
            con->ogEvnt = (CcAllSdus *)&ogEvnt1;

            ret = ccMapEvent(con, CCE_CONIND, 0);

            if (ret != ROK)
            {
               ccDropUBuf(&con->uBuf);
               CCLOGERR("FID 15174.0 Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                        " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                        con->ogProtType, con->icSuConnId, con->ogSuConnId);
            }
            else
            {
               uBuf = con->uBuf;
               con->uBuf = NULLP;

               /* Clear the 484 indicator */
               CC_CLR_CALL_FLAG(con->flag,CC_FLAG_484_RCVD);

               CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 Mapped SAM message to Multi Invite icSu :0x%lx\n",
                    con->icSuConnId);

               /* SEND CONNECT REQUEST TO LOWER LAYER */
               CcLiCctConReq(&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSuConnId,
                             &con->ogRsc, con->ogProtType, &ogEvnt1, uBuf, con);

            }

            /* Set addCalledLen to 0 since all the digits has been sent out */
            con->addCalledLen = 0;

            RETVALUE(ROK);
         }
      }

      /* ISUP overlap to SIP In-Dialog overlap */
      if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IN_DIALOG))
      {
         /* 183 w/o SDP has received, Map ISUP SAM to SIP INFO */
         con->ogEvnt = (CcAllSdus *)&ogEvnt;

         ret = ccMapEvent(con, CCE_ADDRIND, con->icEvntType);
         if (ret == CCIGNOREMAPPING)
         {
           ccDropUBuf(&con->uBuf);
           CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
           RETVALUE(ROK);
         }
         else if (ret != ROK)
         {
           ccDropUBuf(&con->uBuf);
           CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                    " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                    con->ogProtType, con->icSuConnId, con->ogSuConnId);
           RETVALUE(ROK);
         }
         else
         {
           uBuf = con->uBuf;
           con->uBuf = NULLP;
           ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                         con->ogSapCb->spId, con->ogSpConnId,
                         con->ogSuConnId, con->ogProtType, con->ogEvntType,
                         &ogEvnt, uBuf);
           CCDP(AIN_DBG_LEVEL_0, "Mapped SAM message icSu :0x%lx\n",
                con->icSuConnId);
           RETVALUE(ROK);
         }
      }
      else
      {
         /* 183 w/o SDP is not received, cached the digits and wait for it */
         SiSubNum *subNum = NULLP;

         subNum = &(((CcCnStEvnt *)event)->m.siCnStEvnt.subNum);
         con->addCalledLen += CC_FIND_NMB_DIGITS(subNum);
         CCDP(AIN_DBG_LEVEL_0, "FID 15174.0 cached digits length is:%d \n", con->addCalledLen);
      }
   }

   RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S09
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16                     ret            = RFAILED;
   Buffer                 *uBuf           = NULLP;
   CcCnStEvnt              ogEvnt;
   CcCnStEvnt              *ccCnStEvnt    = NULLP;
   ProtType                icProtType     = CC_GET_PROTOCOL(con->icProtType);
   ProtType                ogProtType     = CC_GET_PROTOCOL(con->ogProtType);

   U8                      mgiAction;
   U8                      icMode;
   U8                      ogMode;
   U8                      icSignal;
   U8                      ogSignal;
#if 0   
   Sdp                    *sdp            = NULLP;
#endif   
   /* euysal - 03/24/2006 - Enable following line when enabling GCC support for CPG before ANSWER
   for ISUP to SIP for Dual Call Hold */
#if 0      
   S16                     HoldXferFlag   = 0;
#endif
   S16 sdpRet = RFAILED; /* Bug#46983 */
   ProtType ingressCCS_IcProtType=0;
   ProtType egressCCS_OgProtType=0; /* FID 15401.1 */
   TknU16           inSipStatusCode;
   TknU16           outSipStatusCode;
/*FID 15317.0 P-Early-Media Support */
   CcSipPrflCb *sipPrflPtr = NULL;
   Sdp*                rmtSdp = NULLP; /* FID 16118.0 */
   U8       algorithm  = LCC_CODECREORDER_NONE;   /* Bug 88802 */ 
   Bool     relSdp     = FALSE;                   /* FID15068.0 */
   Bool     notRelSdp  = FALSE;                   /* FID15068.0 */
   Bool     allowUpdate = FALSE;                   /* FID15068.0 */
   Bool     clrPrecnd   = FALSE;                   /* FID15068.0 */
   SipPEarlyMedia  *pEarlyMedia = NULLP;
   UConnId  origSpConnId    = 0;                   /* FID17373.0 */
/*end FID 15317.0 P-Early-Media Support */

  CCDP(AIN_DBG_LEVEL_0, "%s: evntType=%d, icEvntType=%d, icProtType=%d, ogProtType=%d\n",
       __FUNCTION__, con->evntType, con->icEvntType, icProtType, ogProtType);

  /* FID 15401.1++ */
  ProtType protType;
  if (CC_EGRESS_INTER_CCS_CALL(con))
  {
    CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);
    protType = CC_GET_PROTOCOL(egressCCS_OgProtType);
  }
  else /* BUG 85596: Egress CCS and intra-CCS can't get protType
          in this condition and protType would be 0.
          The "else if (!CC_INGRESS_INTER_CCS_CALL
          (con))" should be changed to be only "else" here.
          */
  {
    protType = CC_GET_PROTOCOL(con->ogProtType);
  }
  if (protType == CC_SI || protType == CC_EXT_BICC) /* FID 15319.0 */
  {
    switch (con->ogEvntType)
    {
      case CC_ET_ACM:
      case CC_ET_CPG:
      case CC_ET_FAR:
      case CC_ET_IDREQ:
      case CC_ET_INR:
        con->callDtlInfo.cm.iamRspFlag = TRUE;
        break;
      default:
        break;
    }
  } else if ((protType == CC_SIP) || (protType == CC_SIPT))
    con->callDtlInfo.cm.iamRspFlag = TRUE;
  CCDP(AIN_DBG_LEVEL_2, "iamRspFlag=%d\n", con->callDtlInfo.cm.iamRspFlag);
 

  /* FID 14677.0 ITU99, ACM comes in then set the flag */
  if (con->icEvntType == CC_ET_ACM) 
  {
     con->isACMRecd = TRUE;

     /* FID 15319.0 */
     if((ogProtType == CC_EXT_BICC) && con->ogExtBiccCb && 
        CC_IS_EXTBICC_BEARERSTATE_LESSTHAN(con,CC_OUTGOING,CC_BICC_STATE_SENT_CONNECTED))
     {
         /* Release call with cause 31 for unexpected ACM */
         ccSendReleasesOnBothSidesWithSwitching(con, CCNORMUNSPEC);
         RETVALUE(ROK);
     }
  }

  /* FID 14234.0 */
  con->icEvnt = (CcAllSdus *)event;

  /* FID17378.0 */
  if(CCT_IS_SIP_FEATURE_CAPS_SUPPORTED(con->icSipMethodSupMask) &&
        (CC_IS_ACM_CPG_WITH_INBAND(con, con->icEvntType, (&(con->icEvnt->m.ccCnStEvnt)))) &&
        (con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.eh.pres == PRSNT_NODEF) &&
        (con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.pres == PRSNT_NODEF) &&
         ((!CC_INGRESS_INTER_CCS_CALL(con)) && icProtType == CC_SIP))
  {
     CC_SET_CALL_FLAG2(con, CC_FLAG_ICS_REL);
     CCDP(AIN_DBG_LEVEL_0,"%s:ICS call, received cause %d\n", __FUNCTION__, 
        con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val);
     /* according to 3GPP TS 29.163 V12.5.0 (2014-09) table 9, cause value 8, 9, 16, 53 and 62
      * should be treated as their class default. 
      */
     switch(con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val)
     {
        case CCQ850PREEMT:      /* 8 */
        case CCQ850PREECIRVD:   /* 9 */
        case CCCALLCLR:         /* 16 */
           con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val = CCNORMUNSPEC; /* 31 */
           ((CcAllSdus *)event)->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val = CCNORMUNSPEC;
           break;
        case CCOGBARRDCUG:      /* 53 */
        case CCINCOGACCSUBCLS:  /*62 */
           con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val = CCSERVUNAVAIL; /* 63 */
           ((CcAllSdus *)event)->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val = CCSERVUNAVAIL; /* 63 */
           break;
        default:
           break;
     }
    
     ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcCnStEvnt)); 
     ccSendReleasesOnBothSidesWithSwitching(con, con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt.causeDgn.causeVal.val);
     RETVALUE(ROK);
  }

  if(con->icEvntType == CC_ET_APPTRAN)
  {
      /* FID 15319.0 */
      if(icProtType == CC_EXT_BICC)
      {
          ccHandleBiccSignalApm(con, INCTOOUT, &con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt);
          RETVALUE(ROK);
      }
      else if((ogProtType == CC_EXT_BICC) &&
              (CC_IS_EXTBICC_BEARERSTATE_LESSTHAN(con,CC_OUTGOING,CC_BICC_STATE_SENT_CONNECTED)))
      {
          /* BUG93344 */
          if ((CC_IS_CALL_MULTI_MG(con)) && (con->direction == OUTTOINC))
          {
            con->ccmCb.state = CC_EGRESS_MG;
            CCDP(AIN_DBG_LEVEL_0,"%s change the state to Egress_MG\n", __FUNCTION__);
          }
          if (ccProcessOgExtBiccAPM(con, (CcAllSdus *)event) == ROK)
          {
              RETVALUE(ROK);
          }
      }
      if(ccProcessOApm(&(con->icBcm)) == ROK)
      {
          CCDP(AIN_DBG_LEVEL_0,"ccProcessOApm success,requested event dected.\n");
          RETVALUE(ROK);
      }
  }

  /* FID 15045.1 */
  if (CC_IS_MSG_RCV_FROM_SRP(con) && (con->icEvntType == CC_ET_ACM))
  {
      ccExtractUUdata(con,(CcAllSdus*)event,CCE_CNSTIND);
  }

  /* if SDM sent in the forward direction to SIPT after IAM and before ACM then buffer it */
  if ((con->icEvntType == CC_ET_SDM) && (con->direction == INCTOOUT) && 
          (ogProtType == CC_SIPT) && !(con->isACMSent) && !(con->isACMRecd))
  {
     CCDP(AIN_DBG_LEVEL_2, "ccConE03S09 - Buffering SDM in Queue\n");
     ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);

     RETVALUE(ROK);
  }
  /* End of FID 14677.0 ITU99 */

  /* FID 15174.1, FID 15174.0 handling INFO message */
  if((con->icEvntType == CCSIP_ET_INFO_OVERLAP) && (con->direction == INCTOOUT))
  {
     if (ccHandleSipInfoOverlap(con,event))
     {
        RETVALUE(ROK);
     }
  }

  /* FID 15174.0 +  handling backward 183 */
  if((con->icEvntType == CCSIP_ET_183_CALLPRG) &&
     (ogProtType == CC_SIP) &&
     CC_IS_ICOVERLAP_ENABLED(con) && CC_IS_OGOVERLAP_ENABLED(con))
  {
     if (ccHandleSip183Overlap(con,(PTR)(con->icEvnt)))
     {
        RETVALUE(ROK);
     }
  }
  /* FID 15174.0 - */

  /* FID 15174.0 */
  if (con->icEvntType == CCSIP_ET_MULTIINVITE)
  {
     CCDP(AIN_DBG_LEVEL_1, "ccConE03S09 - CCSIP_ET_MULTIINVITE received for SIPT OVERLAP \n");
     /* Handle SIPT Multi-Invite overlap */
     ret = ccHandleMultiInvite(con, (CcCnStEvnt *)event);
     if (ret != ROK)
     {
        /* Ignore the message */
        RETVALUE(ROK);
     }

     RETVALUE(ROK);
  }

  /* FID 15174.0 */
  if (con->icEvntType == CCSIP_ET_RELSESSION)
  {
    CCDP(AIN_DBG_LEVEL_1, "ccConE03S09 - CCSIP_ET_RELSESSION received.\n");

    if ((((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.errStatus.pres == PRSNT_NODEF) &&
        (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.errStatus.val == SIPCAUSE_484_ADDRINC))
    {
       CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCS_IcProtType);

       /* Receive 484 from egress SIPT side */
       if ((con->direction == OUTTOINC) &&
           (ogProtType == CC_SIPT) && (icProtType == CC_SI || ingressCCS_IcProtType == CC_SI) &&
           (CC_IS_OGOVERLAP_ENABLED(con) && CC_IS_SI_BICC_ICOVERLAP(con)))
       {
           CCDP(AIN_DBG_LEVEL_1, "ccConE03S09 - CCSIP_ET_RELSESSION with 484 eceived for ISUP to SIPT OVERLAP \n");

           /* For ISUP to SIPT Multi-Invite overlap, save the minDigits in 484 to con */
           if (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.minDigits > 0)
           {
             con->minDigits = ((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.minDigits;
             CCDP(AIN_DBG_LEVEL_1, "ccConE03S09 - Store minDigits in 484 to con con->minDigits=%d\n", con->minDigits);
           }
       }
    }

    RETVALUE(ROK);
  }
  
  /* FID 7803 +*/
  /* Update spConnId if spConnIdPres is set */
  /* FID15317.3 This logic is moved ahead of we save new PEM. The original logic
     will remove all PEM including the new received ones. */
  if ((con->direction == OUTTOINC) && (ogProtType == CC_SIP) &&
      (((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnIdPres))
  {
    origSpConnId = con->ogSpConnId;
    con->ogSpConnId = ((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnId;
	/* FID 17163.1 moved ahead of we save new PEM for parellel forking call when ParallelForkCutThru enabled*/ 
    if (((!con->forkedCallCnt) ||
         (con->forkedCallCnt && CC_IS_PARALLEL_FORK_CUTTHRU_18X(con))) &&  
        (((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
    {
/*FID 15317.0 P-Early-Media Support */	  
	  if(con->pEarlyMediaVal)
	  {
	     CCDP(AIN_DBG_LEVEL_2, "%s: - before free, pEarlyMediaVal cnt=%d\n", 
              __FUNCTION__, con->pEarlyMediaVal->cnt);
#if 0
        SPutSBuf(ccInit.region, ccInit.pool, con->pEarlyMediaVal,
                               (Size)(sizeof(SipPEarlyMedia)));
        con->pEarlyMediaVal = NULLP;
#endif
        memset(con->pEarlyMediaVal, 0, sizeof(SipPEarlyMedia));

            if ((icProtType != CC_SIP) && (icProtType != CC_SIPT))
            {
              /* For forking call, if ingress side is not SIP(-I), clear PEM flags. */
               CCDP(AIN_DBG_LEVEL_2, "%s: Call forked, clear PEM flags, icProtType %d\n",
                                      __FUNCTION__, icProtType);
              con->isPEMInMsg = FALSE;
              con->isPEMCall = FALSE; 
            }
	  }
/*end FID 15317.0 P-Early-Media Support */

      if(!con->forkedCallCnt)
      {
          con->forkedCallCnt++;
      }
    }
    CCDP(AIN_DBG_LEVEL_2, "ccConE03S09 - New SIP spConnId received, new spConnId=0x%08lx\n", con->ogSpConnId);
  }

/*
 * FID 15317.0 P-Early-Media Support
 *
 * Note: For ISUP to SIP call, when parallel forking happens, the PEM header 
 *       received and to be received will be both ignored, i.e. PEM header will
 *       no longer affect the early media for the call. 
 *
 *       This is specific requirement for FID 15317.0.
 *
 */
/* FID 17163.1 For ISUP to SIP parellel forking call, save PEM when ParallelForkCutThru enabled */
if ((con->direction == OUTTOINC) && 
      con->ogIntfcCb && (con->ogIntfcCb->ccTgCb) && (ogProtType == CC_SIP) &&
    ((con->forkedCallCnt && CC_IS_PARALLEL_FORK_CUTTHRU_18X(con)) ||
     (!con->forkedCallCnt) || (icProtType == CC_SIP) || (icProtType == CC_SIPT)))
{
   int    i, j;

   pEarlyMedia =&(((CcCnStEvnt *)event)->m.sipCnStEvnt.pEarlyMedia); 

   con->isPEMInMsg = FALSE; /*Bug86498*/
  
   sipPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr;

   if((sipPrflPtr && (sipPrflPtr->pEarlyMedia == TRUE)) && 
      (pEarlyMedia->cnt ))
   {
      /* FID 15317.2 SIPT and w/ MG */
       if(con->icIntfcCb && ((CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_SI) ||
          (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_EXT_BICC) || 
          ((CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_IN) && (con->icIntfcCb->priEarlyMedia)) ||
          (CC_IS_CONTEXT_PRESENT(con) && (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_SIPT)) ||
          (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_SIP)))
       {
          con->isPEMInMsg = TRUE;
          con->isPEMCall = TRUE; /*Bug 87073*/
          
          switch(con->icEvntType)
          {
             case CCSIP_ET_180_RINGING:
             case CCSIP_ET_183_CALLPRG:
             case CCSIP_ET_182_QUEUED:    /* 17163.1 */ 
                ccStopConTmr(con, CC_TMR_TOIW2);
             case CCSIP_ET_181_FORWDNG:
             case CCSIP_ET_UPDATE:
             case CCSIP_ET_UPDATE_RSP:
             case CCSIP_ET_PRACK_RSP:
                if(!con->pEarlyMediaVal)
                {
                   ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->pEarlyMediaVal),
                                       (Size) sizeof(SipPEarlyMedia));
                   if(ret != ROK || con->pEarlyMediaVal == NULLP)
                   {
                      CCLOGERR("pEarlyMediaVal memory allocation failed\n");
                      con->isPEMInMsg = FALSE;
                      con->isPEMCall = FALSE;
                      RETVALUE(RFAILED);
                   }
                }

                memset(con->pEarlyMediaVal, 0, sizeof(SipPEarlyMedia));

                for( i=0,j=0; i<pEarlyMedia->cnt; i++)
                {
                   switch(pEarlyMedia->params[i])
                   {
                        case SIP_PEM_SENDRECV:
                        case SIP_PEM_SENDONLY:
                        case SIP_PEM_RECVONLY:
                        case SIP_PEM_INACTIVE:
                        case SIP_PEM_GATED:
                           {
                              con->pEarlyMediaVal->params[j++] = pEarlyMedia->params[i];
                           }
                           break;
                        default:
                           break;
                   }
                }
                con->pEarlyMediaVal->cnt = j;
                CCDP(AIN_DBG_LEVEL_2, "%s:con->icEvntType %d, pEarlyMediaVal cnt= %d, val=%d\n", 
                      __FUNCTION__, con->icEvntType, con->pEarlyMediaVal->cnt, con->pEarlyMediaVal->params[0]);
                break;
             default: 
                break;
          }
       }

      /* 
       * BUG:91084 - If remote SDP is not available by far, no further processing 
       * is required for PRACK response. (It could be assumed this response was passed
       * from SIPA to deliver the PEM information only.)
       */
      if ((ccIsPrackRspRcvd(icProtType, ogProtType, con->icEvntType, con->direction)) &&
          (((CcCnStEvnt *)event)->m.sipCnStEvnt.sdp.pres == NOTPRSNT))
      {
        CC_LOCATE_RMT_SDP(con, rmtSdp);
        if (rmtSdp == NULLP)
        {
          CCDP(AIN_DBG_LEVEL_2, "%s: remote SDP is not available\n",
                                 __FUNCTION__);
          RETVALUE(ROK);
        }
      } /* BUG:91084 */
   }
}

  if ((con->direction == OUTTOINC) && (ogProtType == CC_SIPT) &&
      (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnIdPres))
  {
    origSpConnId    = con->ogSpConnId;
    con->ogSpConnId = ((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnId;
    if (!con->forkedCallCnt &&
       (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
    {
      con->forkedCallCnt++;
    }
    CCDP(AIN_DBG_LEVEL_2, "ccConE03S09 - New SIPT spConnId received, new spConnId=0x%08lx\n", con->ogSpConnId);
  }

  /*
   * If con->forkedCallCnt = 1 (First Fork has occurred) and 
   * con->ogSipMethodSupMask indicates that either Sequential or 
   * Parallel Forking is allowed, peg totalForkedCalls Count
   */
  if ((con->forkedCallCnt == 1) &&
     ((CCT_IS_SIP_SEQUENTIAL_FORK_SUPPORTED(con->ogSipMethodSupMask)) ||
     (CCT_IS_SIP_PARALLEL_FORK_SUPPORTED(con->ogSipMethodSupMask))))
  {
    /*
     * Bump con->forkedCallCnt to prevent pegging totalForkedCall if other
     * CPGs received while con->forkedCallCnt = 1
     */
    con->forkedCallCnt++;
    ccCp.sts.totalForkedCalls++;
    CCDP(AIN_DBG_LEVEL_2, "ccConE03S09 - Peg totalForkedCalls Count\n");
  }
  /* FID 7803 -*/

  /* + FID 16118.0 */
if (con->ogIntfcCb)
{
    ProtType protType = CC_GET_PROTOCOL(con->ogIntfcCb->protType);

    if (protType == CC_SIP)
    {
        if (con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr)
        {
            algorithm = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr->codecReorder;
        }
    }
    else if (protType == CC_SIPT)
    {
        if (con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr)
        {
            algorithm = con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr->codecReorder;
        }
    }
}

    if ((con->forkedCallCnt) && ((CC_OFFANS_OGRMTOFFER_PENDING(con)) ||
                (CC_OFFANS_OGANS_PENDING(con))
                ||((algorithm == LCC_CODECREORDER_AGNOSTIC)
                    && (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP))
                    && (CC_IS_CONTEXT_PRESENT(con))
                    && (!CCT_IS_SIP_SEQUENTIAL_FORK_SUPPORTED(con->ogSipMethodSupMask)
                        && (!CCT_IS_SIP_PARALLEL_FORK_SUPPORTED(con->ogSipMethodSupMask))))))
   {
      CCDP(AIN_DBG_LEVEL_0, "Releasing call as this is a forked response for "
            "a call that was waiting for an offer (sent with NO SDP on og\n");
      ccHandleCleanUpConCb(con, FALSE, CCTMPFAIL);
      RETVALUE(ROK);
   }
  /* + FID 16118.0 */

   /* FID15068.0 */
   if (con->forkedCallCnt) 
   {
     if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION))
     {
       CCDP(AIN_DBG_LEVEL_0, "Releasing call as this is a forked response for precondition call\n");
       ccHandleCleanUpConCb(con, FALSE, CCPRECONDFAIL);
       RETVALUE(ROK);
     }
   }

  CC_CHECK_STOP_TMR_PREANM(con);
  
  /* Netherlands ISUP: CRG Tariff Indicator Handling.
   * For the international calls from SIP to ISUP without encapsulation,
   * If no CRG with tariff indicator isn't received upon receipt of ACM, release call on both sides.
   */
   
  if( con->icEvntType == CC_ET_ACM && (con->direction == OUTTOINC) && CC_IS_PROT_TYPE_KPNNL2(con->ogProtType) && con->icProtType == CC_SIP )
  {
      if ( con->isInternationalCall && !con->isCRGwithTariffGot )
      {
          CCDP(AIN_DBG_LEVEL_0,"Netherlands ISUP: ACM received without CRG tariff indicator received yet. Call will be released...\n");
          /* stop the Toiw2 Timer if running */
          ccStopConTmr(con, CC_TMR_TOIW2);

          ret = ccProcessDisconnectEvent(con, event);
          if (ret == ROK)
          {
              CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
              RETVALUE(ROK);
          }
          else if (ret == RFAILED)
          {
              CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
          }
          else if (ret == ROKDRSIG)
          {
              /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
                 notification is sent  and continue with release*/
              CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
          }
          else
             /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
             CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

          /* since the call is still in Establish phase, release the call
          * no matter who sends on-hook first */
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

          /* Stop the O and T_NO_ANSWER timer if it is started */
          ccStopConTmr(con, AIN_O_NO_ANS_TMR);
          ccStopConTmr(con, AIN_T_NO_ANS_TMR);

          /* STOP the AWAIT ANSWER Timer if running
           *
           * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0
           */
          ccStopConTmr(con, CC_TMR_AWAITANS);
          ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
          ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

          ccCleanAnsFraudCall(con);

          if (CC_IS_CONTEXT_PRESENT(con))
          {
              /* Blow off the switching and Release the Call */
              ccQSubBasedOnCcn(con);  /* FID 15261.0 */

              CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
              con->mgBlock->con = con;
              ret = ccSendMgiQueue(0, con->mgBlock);
              if (ret != ROK)
              {
                  CCLOGERR( "ERROR occured \n");
                  cleanUpMgQ(con);
                  ccCleanUpMGCtx(con);
              }
              else
              {
                  RETVALUE(ROK);
              }
          }

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCNORMUNSPEC, NULL);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                        con->ogSuConnId, con->ogProtType,
                        CCNORMUNSPEC, NULL);
          RETVALUE(ROK);
      }
  }/* End of Netherlands ISUP CRG Tariff Indicator Handling*/

  /*FID16642.0 send update to incoming after receiving FAN from outgoing+*/
  if((con->oprAstCall == CC_OAC_CANSENT || con->oprAstCall == CC_OAC_OFRSENT) &&
     (con->direction == OUTTOINC) &&
     (con->icEvntType == CC_ET_FAN))
  {
      if(*HOLD_STATE(con) == HoldIngressEgress || *HOLD_STATE(con) == HoldIngress)
      {
         *HOLD_FLAG(con) = SDP_RECVONLY;
         *HOLD_STATE(con) = HoldIngress;
         ccUpdateSession (&con->icBcm, MGCT_MODE_RECV_ONLY, 0x00, ccLcfUpdateCbFunc, (PTR)con, CCS_AWTANS);
      }
      else
      {
         *HOLD_FLAG(con) = SDP_SENDRECV;
         *HOLD_STATE(con) = HoldNone;
         ccUpdateSession (&con->icBcm, MGCT_MODE_SENDRECV, 0x00, ccLcfUpdateCbFunc, (PTR)con, CCS_AWTANS);
      }
      RETVALUE(ROK);
  }
  /*FID16642.0 -*/

  /* FID16367.0 + Handling backward Facility message for SIP to ISDN call */
  if ((con->direction == OUTTOINC) && ((con->icIntfcCb) && (con->icIntfcCb->protType == CC_SIP)))
  {	
      if ((con->icEvntType == CCIN_ET_FACIL) ||
          ((con->icEvntType == CC_ET_FAC) && (egressCCS_OgProtType == CC_IN)))
      {
          if (con->ogIntfcCb && con->ogIntfcCb->callRerouting)
          {
              ccHandleFacCallRrtComp(con, event);
          }

          RETVALUE(ROK);
      }
      /* else fall through */
  }	  
  /* FID16367.0 - */

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));
  
  /* FID-2112: SIP UPDATE + */
  /* FID-2575: LMSD + */
  notRelSdp = ccIsRcvdSdpNotReliable(con, con->ogProtType, CCE_CNSTIND,
                           con->icEvntType, (CcAllSdus*)event);
  allowUpdate = ccIsRcvdAllowUpdateFor18X(con, con->ogProtType, CCE_CNSTIND,
                           con->icEvntType, (CcAllSdus*)event);

  if ((con->direction == OUTTOINC) &&
      (ccIsRcvdSdpReliable(con, con->ogProtType, CCE_CNSTIND,
                           con->icEvntType, (CcAllSdus*)event)))
  {
    TknStrVar *sdpPtr = NULLP;

    relSdp = TRUE;
    notRelSdp = FALSE;
    CCDP(AIN_DBG_LEVEL_0, "Reliable rsp from Egress\n");
    sdpPtr = ccFindSdpInMsg(ogProtType, CCE_CNSTIND, con->icEvntType,
                            (CcAllSdus*)event);
    if (sdpPtr && sdpPtr->pres)
    {
      if (CC_OFFANS_OGRMTANS_PENDING(con))
      {
        /* Since a reliable answer was received from egress,
         * reset the egress OffAns state.
         */
        CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP, CC_OFFANS_STATE_NULL,
                               CC_OFFANS_GET_SUBSTATE(con), CC_OFFANS_METHOD_USED(con));

        /* BUG 91848 */
        if ((icProtType == CC_SIP) &&
            (ogProtType == CC_BICC) &&
            (egressCCS_OgProtType != CC_EXT_BICC) &&
            ((con->icIntfcCb) && (con->icIntfcCb->ccTgCb) && 
             (con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr) && 
             (con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr->acmIwProc == LCC_SIP_IW_PROC_Q1912_5 || 
              con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr->acmIwProc == LCC_SIP_IW_PROC_3GPPTS29_163)))
        {
           /* Q1912.5: Set free SDP flag */
           CC_SET_CALL_FLAG2(con, CC_FLAG_FREESDPNEEDED);
        }
        else
        {
           /* We don't need old SDPs */
           if (con->ccHeldSdpForCfna)
              cmFreeSdp(ccInit.region, ccInit.pool, &con->ccHeldSdpForCfna);

           if (con->icIpParam.rmtDesc)
              cmFreeSdp(ccInit.region, ccInit.pool, &con->icIpParam.rmtDesc);
        }
      }
      else if (CC_OFFANS_OGRMTOFFER_PENDING(con))
      {
        CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP, CC_OFFANS_STATE_RCVDOFFER,
                               CC_OFFANS_SUBSTATE_NULL, CC_OFFANS_METHOD_USED(con));
      }
    }
  }
  /* FID-2575: LMSD - */
  /* FID-2112: SIP UPDATE - */

  /* FID 13979, copy histInfoEntries */
  CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCS_IcProtType);
  if ((icProtType == CC_SIP) || (ingressCCS_IcProtType == CC_SIP) || 
      (icProtType == CC_SIPT) || (ingressCCS_IcProtType == CC_SIPT))
  {
      if ((ogProtType == CC_SIP) &&
          (((CcCnStEvnt *)event)->m.sipCnStEvnt.sipHistInfo.eh.pres))
      {
          ccExtractHistInfoEntries(&(con->histInfoEntries), 
              &(((CcCnStEvnt *)event)->m.sipCnStEvnt.sipHistInfo.otherEntries));
      }
      else if ((ogProtType == CC_SIPT) &&
               (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.sipHistInfo.eh.pres))
      {
          ccExtractHistInfoEntries(&(con->histInfoEntries), 
           &(((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.sipHistInfo.otherEntries));
      }
  }
  /* End of FID 13979 */

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */

  /* FID 14525.0 ++*/
  if(((con->direction ==INCTOOUT)&&(icProtType == CC_SIPT)&&CC_IS_IC_SFRCPGIW(con))||
     ((con->direction ==OUTTOINC)&&(ogProtType == CC_SIPT)&&CC_IS_OG_SFRCPGIW(con))
    )
  {
   SiCnStEvnt* siptCnst = NULLP; 
   siptCnst = &((CcCnStEvnt *)event)->m.siCnStEvnt;
   if(siptCnst->optElmnt.sipt.icEvntType==CCSIP_ET_UPDATE)
   {

    if(siptCnst->evntInfo.eh.pres && siptCnst->evntInfo.evntInd.pres &&(siptCnst->evntInfo.evntInd.val == EV_PROGRESS))
     {
          CCDP(AIN_DBG_LEVEL_0, "notfiInd %d %d, %d\n",siptCnst->notifInd1.eh.pres, siptCnst->notifInd1.notifInd.pres, siptCnst->notifInd1.notifInd.val);
          if(siptCnst->notifInd1.eh.pres && siptCnst->notifInd1.notifInd.pres)
          {
            if(siptCnst->notifInd1.notifInd.val == CC_RMTEHOLD)
            {
              if(siptCnst->optElmnt.sipt.sdp.pres)
	      {
               ccModSdpModeWithSetVal(&siptCnst->optElmnt.sipt.sdp, con, SDP_SENDONLY,SDP_MTYPE_AUDIO);
	      }
	      else
	      {
               CCDP(AIN_DBG_LEVEL_0, "no Sdp appear in SFR SIPT UPDATE\n");
              }
            } /* for RemoteHold case */
	    else if(siptCnst->notifInd1.notifInd.val == CC_RMTERETR)
            {
               if(siptCnst->optElmnt.sipt.sdp.pres)
	       {
                ccModSdpModeWithSetVal(&siptCnst->optElmnt.sipt.sdp,con, SDP_SENDRECV,SDP_MTYPE_AUDIO);
	       }
	       else
	       {
                CCDP(AIN_DBG_LEVEL_0, "no Sdp appear in SFR SIPT UPDATE\n");
	       }
	    }
            else
	    {
               CCDP(AIN_DBG_LEVEL_0, "Ingore the unSupported GNI\n");
	    }
           }
           else
           {
               CCDP(AIN_DBG_LEVEL_0, "GNI not prnst, ingore\n");
           }
    }
    else
    {
        CCDP(AIN_DBG_LEVEL_0, "EvntId not valid, ingore\n");
    }
  }
 } 
 /* FID 14525.0 --*/

  /* Extract the SDP if rcvd from layer-3 */
  /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
  sdpRet = ccExtractSdpFromCnStInd(con, event);
  if (sdpRet != ROK)
  {
     CCLOGERR("Error: SDP parsing failed - %d\n", sdpRet);
     con->failCndVal = FC_PROTERR;

     if (CC_IS_CONTEXT_PRESENT(con))
     {
        ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
          con->mgBlock->con = con;
          con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
          RETVALUE(ROK);
        }
     }
     ccFreeTheRscFromCon(con, OUTTOINC);
     ccProcessFailCnd(con, con->failCndVal, TRUE);
     RETVALUE(ROK);
  }

  /* FID16061.0 insertSdp18x */
  con->noSdpIn18x = !ccIsSdpParamPresent(&con->ogIpParam);

  /* FID 15261.0 + */
  if (CC_IS_CALL_MULTI_MG(con))
  {
    if (con->direction == OUTTOINC)
      con->ccmCb.state = CC_EGRESS_MG;
    else
      con->ccmCb.state = CC_INGRESS_MG;
  }
  /* FID 15261.0 - */

  /* + FID 16118.0 */
  CC_LOCATE_RMT_SDP(con, rmtSdp);
  if ((CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_AGNOSTIC_NO_OFFER_CANDIDATE)) &&
      (con->direction == OUTTOINC) && (rmtSdp) &&
      (!CC_IS_BCM_IN_CONTEXT(&con->ogBcm)))
  {
    ccAllocateMultiMediaCb(con);
    if (IS_MULTIMEDIA_4_BCM(&con->ogBcm))
    {
      /* FID 14941.0 */
      /* ccStoreMMBillingSdp is not invoked by ccExtractProtSdp for
         the initial offer */
      ccStoreMMBillingSdp(&con->ogBcm, FALSE, rmtSdp);
      
      MULTIMEDIACB_4_BCM(&con->ogBcm)->StreamCount = rmtSdp->numDecode;

      ccEnableMediaAwareStream_4_BCM (&con->ogBcm, rmtSdp);
    }

    if (IS_MULTIMEDIA_4_BCM(&con->icBcm))
    {
      MULTIMEDIACB_4_BCM(&con->icBcm)->StreamCount = rmtSdp->numDecode;
      ccEnableMediaAwareStream_4_BCM (&con->icBcm, rmtSdp);
    }

    if(IS_MULTIMEDIA_4_BCM(&con->ogBcm))
    {
      ccCheckToSkipStream(con, rmtSdp);
    }
    if (IS_MULTIMEDIA(con)) /* looks like MG is needed */
      ccFillIpVersion(con, CC_SWREQ_MAX);/* BUG:90566 */
  }
  /* - FID 16118.0 */

  /* + FID 17163.1 For ISUP to SIP parellel forking call, do not save PEM for 3 cases which should be ignored when ParallelForkCutThru enabled:
   * case 1: 181/182/183 w/ SDP w/ PEM inactive/recvonly, after a 18x w/ SDP w/ PEM sendrecv/sendonly
   * case 2: 181/182/183 w/o SDP w/ PEM sendrecv/sendonly, before a 18x w/ SDP w/ PEM sendrecv/sendonly/notpresent
   * case 3: 181/182/183 w/o SDP , after a 18x w/ SDP w/ PEM sendrecv/sendonly/notpresent
   * */         
  if ((con->direction == OUTTOINC) && 
       (ccIsForkedCall(con)) && (con->pEarlyMediaVal) &&
       (CC_IS_PARALLEL_FORK_CUTTHRU_18X_NOT180(con)) &&
       (((rmtSdp) && (con->isParallelForkCutThru) &&
        ((con->pEarlyMediaVal->params[0] == SIP_PEM_INACTIVE) ||
         (con->pEarlyMediaVal->params[0] == SIP_PEM_RECVONLY))) ||
       ((!rmtSdp) && ((con->isParallelForkCutThru) || 
        (!(con->isParallelForkCutThru) && 
        ((con->pEarlyMediaVal->params[0] == SIP_PEM_SENDRECV) ||
         (con->pEarlyMediaVal->params[0] == SIP_PEM_SENDONLY)))))))
   {
       CCDP(AIN_DBG_LEVEL_2, "%s: - free pEarlyMediaVal for parellel forking call when ParallelForkCutThru enabled \n", __FUNCTION__);
       memset(con->pEarlyMediaVal, 0, sizeof(SipPEarlyMedia)); 
   } 
  /* - FID 17163.1 */

  /* FID-2593: Transcoding + */
  if (con->direction == OUTTOINC)
  {
    switch (ogProtType)
    {
    case CC_SIP:
	/* FID-2575: LMSD + */
	if (((CcCnStEvnt *)event)->m.sipCnStEvnt.reliable18X == CCT_SIP_REL18X_REL)
	{
          CCT_SET_SIP_REQUIRED_100REL_MASK(((CcCnStEvnt *)event)->m.sipCnStEvnt.headerSupportMask);
        }
	/* FID-2575: LMSD - */

      ccExtractSipMethodSupport(con, OUTTOINC,
        ((CcCnStEvnt *)event)->m.sipCnStEvnt.headerSupportMask);
      break;
    case CC_SIPT:
	/* FID-2575: LMSD + */
	if (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.reliable18X == CCT_SIP_REL18X_REL)
	{
          CCT_SET_SIP_REQUIRED_100REL_MASK(((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.headerSupportMask);
        }
	/* FID-2575: LMSD - */

      ccExtractSipMethodSupport(con, OUTTOINC,
        ((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.headerSupportMask);

      break;
    default:
      break;
    }
  }
  /* FID-2593: Transcoding - */

  /* 15068.0 */
  if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
      (icProtType == CC_SIPT || icProtType == CC_SIP) &&
      (con->icPrecndCb) &&
      (IS_PRECND_RMV_ISUP(con->icPrecndCb->flag)) &&
      (relSdp || notRelSdp) &&
      (con->direction == OUTTOINC) &&
      (!CC_EGRESS_INTER_CCS_CALL(con)))
  {
    CCDP(AIN_DBG_LEVEL_2, "%s FID15068 reset Rmv_Isup for 18x\n",__FUNCTION__);
    CLEAR_PRECND_RMV_ISUP(con->icPrecndCb->flag);
  }

  /* FID15068.0 R3003 update precond status table*/
  if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) &&
      (relSdp == TRUE) &&
      (allowUpdate == TRUE) &&
      ((CC_OFFANS_OGOFFANS_STATE_NULL(con) && (CC_OFFANS_ICANS_PENDING(con)))||
       (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP)) ||
       ((con->icPrecndCb) && IS_PRECND_OG18XRCVD(con->icPrecndCb->flag) &&
        (con->ogPrecndCb) && !IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)) || 
       ((icProtType==CC_SI||icProtType==CC_IN||icProtType==CC_EXT_BICC) && (ogProtType==CC_SIP||ogProtType==CC_SIPT) && /* FID17373.0 */
        (ccIs18XRcvd(con, con->ogProtType, CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event)) &&
        !IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)))&&
      ccIsSdpPrecndPres(rmtSdp) &&
      (con->direction == OUTTOINC))
  {
    S16 retPrecnd = ROK;

    if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP) &&
        CC_OFFANS_ICOFFANS_PENDING(con))   
      ccExtractPrecndWithReal(con->ogPrecndCb, rmtSdp, TRUE);
    else
      ccExtractPrecnd(con->ogPrecndCb, rmtSdp, FALSE);

    retPrecnd = ccValidatePrecnd(con, con->ogPrecndCb, rmtSdp);
    if (retPrecnd != ROK)
    {
      /* release the call as its precnd attributes not meet requirement */
      CCLOGERR("Release call due to SDP precondition attr validation failure icSu=%ld\n", con->icSuConnId);
      ccHandleCleanUpConCb(con, TRUE, CCPRECONDFAIL);
      RETVALUE(ROK);
    }

    if (!(CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP) &&
          CC_OFFANS_ICOFFANS_PENDING(con)))
    {
      retPrecnd = ccValidatePrecndForMultiStream(con, con->ogPrecndCb, rmtSdp);
      if (retPrecnd != ROK)
      {
        /* release the call as its precnd attributes not meet requirement */
        CCLOGERR("Release call due to SDP precondition attr validation failure for multistream icSu=%ld\n", con->icSuConnId);
        ccHandleCleanUpConCb(con, TRUE, CCPRECONDFAIL);
        RETVALUE(ROK);
      }
    }
    
    /* FID17373.0 if 181 is buffered, not to do precondition until COT received */
    if (con->ogPrecndCb)
     CCDP(AIN_DBG_LEVEL_2, "%s - flag2 0x%x\n", __FUNCTION__, con->ogPrecndCb->flag2);

    if ((icProtType == CC_EXT_BICC) && (ogProtType == CC_SIP) &&
        (con->ogPrecndCb) && (IS_PRECND_181_NON_PRECND(con->ogPrecndCb->flag)) &&
        (con->icEvntType == CCSIP_ET_181_FORWDNG))
    {
      CLEAR_PRECND_181_NON_PRECND(con->ogPrecndCb->flag);
      CCDP(AIN_DBG_LEVEL_2, "%s - 181 will have precondition handling\n", __FUNCTION__);
    }
    if ((ccIs18XRcvd(con, con->ogProtType, CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event)) &&
        (icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED) &&
        (ogProtType == CC_SIP) &&
        (con->ogPrecndCb) &&
        (!CC_IS_COT_RCVD_EXT_BICC(con)) &&
        (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_181_BUFFERED)))
    {
      Sdp tmpSdp;

      CCDP(AIN_DBG_LEVEL_2, "%s - Buffering 18x to wait for COT.\n", __FUNCTION__);

      if (SDP_IS_RAW_PRES(rmtSdp) && (rmtSdp == con->ogIpParam.rmtDesc))
      {
        CCDP(AIN_DBG_LEVEL_2, "%s - Move back rmtSdp to event\n", __FUNCTION__);
        memset((U8 *)&tmpSdp, 0, sizeof(Sdp));

        if ((con->ogRmtSdpVerCb) &&
            (con->ogRmtSdpVerCb->currId.sessionId.val == rmtSdp->sessionId.val) &&
            (con->ogRmtSdpVerCb->currId.versionId.val == rmtSdp->versionId.val))
        {
          CCDP(AIN_DBG_LEVEL_2, "%s - Free con->ogRmtSdpVerCb\n", __FUNCTION__);
          ccFreeRmtSdpVersionCb(con);
          con->ogRmtSdpVerCb = NULLP;
        }

        cmCpyAndFreeSdp(ccInit.region, ccInit.pool, &tmpSdp, &rmtSdp);

        /* Handoff raw sdp memory to event */
        ((CcCnStEvnt *)event)->m.sipCnStEvnt.sdp = tmpSdp.r.buf;

        tmpSdp.r.buf.val = (U8 *)NULL;
        tmpSdp.r.buf.len = 0;
        tmpSdp.r.buf.pres = NOTPRSNT;

        con->ogIpParam.rmtDesc = NULLP;
        rmtSdp = NULLP;

      }

      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);
      RETVALUE(ROK);
    }

    if ((con->ogPrecndCb) && (con->icPrecndCb) &&
        (((icProtType == CC_SIP) || (icProtType == CC_SIPT)) && 
         ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT) || (ogProtType == CC_BICC))) &&
        ((con->ogPrecndCb) && !IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)))
    {
      U32 *suppHdr = NULLP;
      Bool isSupportPrecnd = FALSE;

      if (ogProtType == CC_SIP)
        suppHdr = &(((CcCnStEvnt *)event)->m.sipCnStEvnt.headerSupportMask);
      else if (ogProtType == CC_SIPT)
        suppHdr = &(((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.headerSupportMask);

      if (suppHdr)
      {
        isSupportPrecnd = CCT_IS_PRECOND_SUPPORTED(*suppHdr)? TRUE: FALSE;
        CCDP(AIN_DBG_LEVEL_1, "%s: ogPrecndCb->mask %d suppHdr 0x%lx isSupportPrecnd %d\n", __FUNCTION__, 
             con->ogPrecndCb->mask, *suppHdr, isSupportPrecnd);

        if ((!CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP)) &&
            (CC_IS_CONTEXT_PRESENT(con)))
        {
          CCT_RESET_SIP_REQUIRED_PRECOND_MASK(*suppHdr);
          CCT_RESET_SIP_SUPPORTED_PRECOND_MASK(*suppHdr);
        }
      }

      if (((icProtType == CC_SIPT) || (icProtType == CC_SIP)) && (ogProtType == CC_SIP || ogProtType == CC_BICC) && 
          (!IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)))
      {
        SET_PRECND_RMV_ISUP(con->icPrecndCb->flag);
        CCDP(AIN_DBG_LEVEL_2, "%s setting rmvIsupBody to 0x%d for SIPT->SIP/BICC in precondtion negotiation\n",
             __FUNCTION__, con->icPrecndCb->flag);
      }

      if ((icProtType == CC_SIPT) && (ogProtType == CC_SIPT) && (!IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)))
      {
        if (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.rmvIsupBody == CCT_IS_ADDED_ISUP_SIPW)
        {
          SET_PRECND_RMV_ISUP(con->icPrecndCb->flag);
          CCDP(AIN_DBG_LEVEL_2, "%s setting rmvIsupBody to 0x%d for SIPT->SIPT in precondtion negotiation\n",
               __FUNCTION__, con->icPrecndCb->flag);
        }
      }

      if ((icProtType == CC_SIP) && (ogProtType == CC_SIPT))
      {
        SET_PRECND_RMV_ISUP(con->icPrecndCb->flag);
        CCDP(AIN_DBG_LEVEL_2, "%s setting rmvIsupBody to 0x%d for SIP->SIPT in precondtion negotiation\n",
             __FUNCTION__, con->icPrecndCb->flag);
      }

      if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP))
      {
        /* set the status table */

        if (!(con->remoteSdpSentOnIcBCM))
        {
          con->icPrecndCb->mask  = con->ogPrecndCb->mask;
          ccUpdatePrecndStaTblFromPeer(con, con->icPrecndCb, TRUE);
        }
        else
        {
          if ((ogProtType == CC_BICC) && 
              (!(con->remoteSdpSentOnIcBCM) || (IS_PRECND_OG18XRCVD(con->icPrecndCb->flag))))
          {
            ccEnablePrecndCb(con->icPrecndCb);
            ccTryToInsertPrecndConfStatus(con->icPrecndCb);
          }
          else
          {
            con->icPrecndCb->mask  = con->ogPrecndCb->mask;
            ccUpdatePrecndStaTblFromPeer(con, con->icPrecndCb, FALSE);
          }
        }

        if ((!isSupportPrecnd) && (suppHdr))
        {
          if (ccPrecndHasMandatoryAttr(con, con->ogPrecndCb) &&
              !CCT_IS_PRECOND_REQUIRED(*suppHdr))
          {
            CCT_SET_SIP_REQUIRED_PRECOND_MASK(*suppHdr);
            CCDP(AIN_DBG_LEVEL_1, "%s: setting the received support header to have precondition header\n", __FUNCTION__);
          }
          else if (!CCT_IS_PRECOND_SUPPORTED(*suppHdr))
          {
            CCT_SET_SIP_SUPPORTED_PRECOND_MASK(*suppHdr);
            CCT_RESET_SIP_REQUIRED_PRECOND_MASK(*suppHdr);
            CCDP(AIN_DBG_LEVEL_1, "%s: setting the received support header to have supported precondition header 0x%lx\n", __FUNCTION__, *suppHdr);
          }
        }
      }
      else
      {
        ccUpdatePrecndStaTblFromPeer(con, con->icPrecndCb, FALSE);

        if ((suppHdr) && (CC_IS_CONTEXT_PRESENT(con)))
        {
          if (ccPrecndHasMandatoryAttr(con, con->ogPrecndCb) && 
              !CCT_IS_PRECOND_REQUIRED(*suppHdr))
          {
            CCT_SET_SIP_REQUIRED_PRECOND_MASK(*suppHdr);
            CCDP(AIN_DBG_LEVEL_1, "%s: setting the received support header to have precondition header 0x%lx\n", __FUNCTION__, *suppHdr);
          }
          else if (!CCT_IS_PRECOND_SUPPORTED(*suppHdr))
          {
            CCT_SET_SIP_SUPPORTED_PRECOND_MASK(*suppHdr);
            CCT_RESET_SIP_REQUIRED_PRECOND_MASK(*suppHdr);
            CCDP(AIN_DBG_LEVEL_1, "%s: setting the received support header to have supported precondition header 0x%lx\n", __FUNCTION__, *suppHdr);
          }
        }
        ccTryToInsertPrecndConfStatus(con->icPrecndCb);

        if (ccIsPrecndFulfillRemote(con->icPrecndCb) && ccIsPrecndFulfillRemote(con->ogPrecndCb) && 
            (ogProtType == CC_BICC))
        {
          SET_PRECND_COMPLETED(con->icPrecndCb->flag);
          SET_PRECND_COMPLETED(con->ogPrecndCb->flag);
          CCDP(AIN_DBG_LEVEL_2,"Precondition completed for ogPrecndCb & icPrecndCb \n");
        }
      }
    }
  }
  else if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) && 
           ((con->ogPrecndCb) && !IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)) &&
           ((icProtType == CC_SIP) || (icProtType == CC_SIPT)) &&
           ((((ogProtType == CC_SIP) || (ogProtType == CC_SIPT)) &&
             (ccIs18XRcvd(con, con->ogProtType, CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event))) || 
            (ogProtType == CC_BICC)) &&
           (con->direction == OUTTOINC) &&
           ((notRelSdp) || (!allowUpdate) || (!ccIsSdpPrecndPres(rmtSdp))))
  {
        if ((CCT_IS_PRECOND_SUPPORTED(con->icSipMethodSupMask)) &&
            (!CCT_IS_PRECOND_REQUIRED(con->icSipMethodSupMask)))
        {
          CCDP(AIN_DBG_LEVEL_0, "%s ingress precond ON but not reliable 18x, clear CC_FLAG_PRECONDITION\n", __FUNCTION__);
          CCT_RESET_SIP_SUPPORTED_PRECOND_MASK(con->icSipMethodSupMask);
          clrPrecnd = TRUE;
          CLEAR_PRECND_SIP2SIPREROUTE(con->ogPrecndCb->flag);
        }
        else if (CCT_IS_PRECOND_REQUIRED(con->icSipMethodSupMask))
        {
          CCLOGERR("%s Release call due to require precondition but not reliable 18x  icSu=%ld\n", __FUNCTION__, con->icSuConnId);
          ccHandleCleanUpConCb(con, TRUE, CCPRECONDFAIL);
          RETVALUE(ROK);
        }
  }
  /* FID 15068.0 + */
  if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) &&
      (icProtType==CC_SI||icProtType==CC_IN||icProtType==CC_EXT_BICC) && /* FID17373.0 */
      (ogProtType==CC_SIP||ogProtType==CC_SIPT) &&
      (ccIs18XRcvd(con, con->ogProtType, CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event)) &&
      !IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag) &&
      (con->direction == OUTTOINC))
  {
    if((notRelSdp) || (!allowUpdate) || (!ccIsSdpPrecndPres(rmtSdp)))
    {
      /* FID17373.0 */
      if ((icProtType==CC_EXT_BICC) && (con->icEvntType == CCSIP_ET_181_FORWDNG)) 
      {
        if ((relSdp) && rmtSdp && (rmtSdp->eh.pres == PRSNT_NODEF))
        {
          CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
          memset(con->ogPrecndCb,0x0,sizeof(con->ogPrecndCb));
          CCDP(AIN_DBG_LEVEL_1, "%s: 181 Precondition was cancelled due to reliable SDP.\n", __FUNCTION__);
        }
        else
        {
          SET_PRECND_181_NON_PRECND(con->ogPrecndCb->flag);
          CCDP(AIN_DBG_LEVEL_1, "%s: 181 for EXT_BICC should be handled as of existing\n", __FUNCTION__);
        }
      }
      else
      {
        CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
        memset(con->ogPrecndCb,0x0,sizeof(con->ogPrecndCb));
        CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068.0 Precondition was cancelled due to NULL SDP.\n", __FUNCTION__);
      }
    }
  }

  if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) && con->ogPrecndCb && (relSdp || notRelSdp) &&
      (!IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)) &&
      ((icProtType == CC_SIP) || (icProtType == CC_SIPT)) &&
      ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT) || (ogProtType == CC_BICC)) )
  {
    SET_PRECND_OG18XRCVD(con->ogPrecndCb->flag);
    if ((con->icPrecndCb) && (!IS_PRECND_OG18XRCVD(con->icPrecndCb->flag)))
    {
      SET_PRECND_OG18XRCVD(con->icPrecndCb->flag);
      CCDP(AIN_DBG_LEVEL_0, "%s setting icPrecndCb received the 1st 18X\n", __FUNCTION__);
    }
    CCDP(AIN_DBG_LEVEL_0, "%s setting ogPrecndCb received the 1st 18X\n", __FUNCTION__);
  }

  if ((CC_GET_PROTOCOL(con->ogProtType) == CC_SIPT) && (con->direction == OUTTOINC) &&
      (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)))
    ccModSiptBCIForNoISUPBody(con);

  /* + FID 17373.0 */
  if (((!CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) || (clrPrecnd == TRUE)) &&
      (icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED) &&
      (con->ogPrecndCb) &&
      (!CC_IS_COT_RCVD_EXT_BICC(con)) &&
      ((con->icEvntType == CCSIP_ET_180_RINGING) ||
       (con->icEvntType == CCSIP_ET_181_FORWDNG) ||
       (con->icEvntType == CCSIP_ET_182_QUEUED) ||
       (con->icEvntType == CCSIP_ET_183_CALLPRG)) &&
      (con->direction == OUTTOINC)) ||
      (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) && 
       (icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED) &&
       (con->ogPrecndCb) &&
       (!CC_IS_COT_RCVD_EXT_BICC(con)) &&
       (con->icEvntType == CCSIP_ET_181_FORWDNG)))
  {
      if ((relSdp) && (rmtSdp) && (rmtSdp->eh.pres == PRSNT_NODEF) &&
          (SDP_IS_RAW_PRES(rmtSdp) && (rmtSdp == con->ogIpParam.rmtDesc)))
      {
        Sdp       tmpSdp;

        CCDP(AIN_DBG_LEVEL_2, "%s - Move back rmtSdp to event\n", __FUNCTION__);
        memset((U8 *)&tmpSdp, 0, sizeof(Sdp));

        if ((con->ogRmtSdpVerCb) &&
            (con->ogRmtSdpVerCb->currId.sessionId.val == rmtSdp->sessionId.val) &&
            (con->ogRmtSdpVerCb->currId.versionId.val == rmtSdp->versionId.val))
        {
          CCDP(AIN_DBG_LEVEL_2, "%s - Free con->ogRmtSdpVerCb\n", __FUNCTION__);
          ccFreeRmtSdpVersionCb(con);
          con->ogRmtSdpVerCb = NULLP;
        }

        cmCpyAndFreeSdp(ccInit.region, ccInit.pool, &tmpSdp, &rmtSdp);

        /* Handoff raw sdp memory to event */
        ((CcCnStEvnt *)event)->m.sipCnStEvnt.sdp = tmpSdp.r.buf;

        tmpSdp.r.buf.val = (U8 *)NULL;
        tmpSdp.r.buf.len = 0;
        tmpSdp.r.buf.pres = NOTPRSNT;

        con->ogIpParam.rmtDesc = NULLP;
        rmtSdp = NULLP;

      }

     CCDP(AIN_DBG_LEVEL_2, "%s - Buffering 18x to wait for COT.\n", __FUNCTION__);
     ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);

     if ((con->icEvntType == CCSIP_ET_181_FORWDNG) &&
         (icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED) &&
         (con->ogPrecndCb) &&
         (!CC_IS_COT_RCVD_EXT_BICC(con))) 
     {
       CCDP(AIN_DBG_LEVEL_2, "%s - 181 is buffered set.\n", __FUNCTION__);
       PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_181_BUFFERED);
     }

     if (origSpConnId)
     {
       CCDP(AIN_DBG_LEVEL_2, "%s forked 18X, origSpConnId 0x%lx ogSpConnId 0x%lx\n", __FUNCTION__,  origSpConnId, con->ogSpConnId);
       con->ogSpConnId = origSpConnId;

       if (con->forkedCallCnt >1)
         con->forkedCallCnt--;
     }

     if (clrPrecnd == TRUE)
        CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);

     RETVALUE(ROK);
  }
  /* - FID 17373.0 */

  /* Feature 14704.0 - Enhance BTS to Support a Q.825 Biling Interface*/
  if ((con->direction == OUTTOINC) && (con->ogIntfcCb != NULL) 
      && ((CC_GET_PROTOCOL(con->ogIntfcCb->protType)==CC_SI)||
          (CC_GET_PROTOCOL(con->ogIntfcCb->protType)==CC_EXT_BICC))) /* FID 15319.0 */
  {
     if( (((CcCnStEvnt *)event) != NULL) && (((CcCnStEvnt *)event)->m.siCnStEvnt.bckCallInd.cadPtyCatInd.pres) ) /* bug#71157 */
     {
        con->callDtlInfo.cm.cadPtyCatInd.pres = ((CcCnStEvnt *)event)->m.siCnStEvnt.bckCallInd.cadPtyCatInd.pres;
        con->callDtlInfo.cm.cadPtyCatInd.val  = ((CcCnStEvnt *)event)->m.siCnStEvnt.bckCallInd.cadPtyCatInd.val;
        CCDP(AIN_DBG_LEVEL_0, "cadPtyCatInd from ISUP/BICC message, the value is %d\n", con->callDtlInfo.cm.cadPtyCatInd.val);
     }
  }

  /* FID-2112: SIP UPDATE + */
  if (con->icEvntType == CC_ET_CPG) /* Chk for dir and prot is done inside*/
  {
    ret = ccCheckForSiHoldXferToSipPreAnswer(con, icProtType, ogProtType,
                                       (CcAllSdus*)event);
    CCDP(AIN_DBG_LEVEL_2, "ret = %d\n", ret);
    if (ret == ROKIGNORE)
    {
      /* Rcvd CPG (Hold/Retrieve) on ISUP-SIP(T) call */
       ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
           sizeof(CcCnStEvnt)); /* 55567 */
      RETVALUE (ROK);
    }

    /* BUG58738 -  CPG is not Hold/Retrive, so drop the message */
    if (ret == RIGNORE)
      RETVALUE (ROK);
    /* end of BUG58738 */
  }

  /* Bug 78663 ++ */  
  if( (con->direction == OUTTOINC )&& 
      (( (con->icEvntType == CCSIP_ET_3XX )&&(CC_GET_PROTOCOL(con->ogProtType) == CC_SIP))|| 
       ( ((con->icEvntType == CC_ET_302) ||(con->icEvntType == CC_ET_301)||(con->icEvntType == CC_ET_305))&&(CC_GET_PROTOCOL(con->ogProtType) == CC_BICC)) ) 
     )  
   { 
      if(CC_INGRESS_INTER_CCS_CALL(con) ) 
      { 
          if( ( (CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.pres )  
          { 
            if(((CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.val== SIPCAUSE_302_MOVEDT) 
               ccSendBiccApm(con, CC_ET_302, INCTOOUT, FALSE); 
            else if (((CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.val == SIPCAUSE_301_MOVEDP) 
               ccSendBiccApm(con, CC_ET_301, INCTOOUT, FALSE); 
            else if (((CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.val == SIPCAUSE_305_USEPROXY ) 
               ccSendBiccApm(con, CC_ET_305, INCTOOUT, FALSE); 
            else  
               CCDP(AIN_DBG_LEVEL_0, "Invalid 3XX status\n");  
          }  
       } 
      else 
      { 
           inSipStatusCode.pres = con->callDtlInfo.cm.ingressSipStatusCode.pres; 
           inSipStatusCode.val = con->callDtlInfo.cm.ingressSipStatusCode.val; 
           outSipStatusCode.pres = con->callDtlInfo.cm.egressSipStatusCode.pres; 
           outSipStatusCode.val = con->callDtlInfo.cm.egressSipStatusCode.val; 
   
           con->callDtlInfo.cm.ingressSipStatusCode.pres  = PRSNT_NODEF; 
           con->callDtlInfo.cm.egressSipStatusCode.pres = PRSNT_NODEF; 
           if( CC_GET_PROTOCOL(con->ogProtType) == CC_BICC )  
           { 
            if( con->icEvntType == CC_ET_302 ) 
             { 
              con->callDtlInfo.cm.ingressSipStatusCode.val = SIPCAUSE_302_MOVEDT; 
              con->callDtlInfo.cm.egressSipStatusCode.val = SIPCAUSE_302_MOVEDT; 
             } 
             else if ( con->icEvntType == CC_ET_301 ) 
             { 
              con->callDtlInfo.cm.ingressSipStatusCode.val = SIPCAUSE_301_MOVEDP; 
              con->callDtlInfo.cm.egressSipStatusCode.val = SIPCAUSE_301_MOVEDP; 
             } 
             else if ( con->icEvntType == CC_ET_305 ) 
             { 
              con->callDtlInfo.cm.ingressSipStatusCode.val = SIPCAUSE_305_USEPROXY; 
              con->callDtlInfo.cm.egressSipStatusCode.val = SIPCAUSE_305_USEPROXY; 
             } 
             else 
             { 
              con->callDtlInfo.cm.ingressSipStatusCode.pres  = NOTPRSNT; 
              con->callDtlInfo.cm.egressSipStatusCode.pres = NOTPRSNT; 
             } 
            } 
            else 
            { 
              con->callDtlInfo.cm.ingressSipStatusCode.val = ((CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.val;  
              con->callDtlInfo.cm.egressSipStatusCode.val = ((CcCnStEvnt *)event)->m.sipCnStEvnt.errStatus.val; 
            } 
   
          if(( con->callDtlInfo.cm.ingressSipStatusCode.pres == PRSNT_NODEF)&&(con->callDtlInfo.cm.egressSipStatusCode.pres == PRSNT_NODEF )) 
            ccGenACRBillingWrapper(con, C_CDRGEN_CAUSE_EVENT); 
   
            con->callDtlInfo.cm.ingressSipStatusCode.pres  = inSipStatusCode.pres; 
            con->callDtlInfo.cm.ingressSipStatusCode.val = inSipStatusCode.val; 
            con->callDtlInfo.cm.egressSipStatusCode.pres = outSipStatusCode.pres; 
            con->callDtlInfo.cm.egressSipStatusCode.val = outSipStatusCode.val; 
       } 
       /* Bug 77695 */ 
       if(!CC_EGRESS_INTER_CCS_CALL(con) ) 
       { 
        if(con->ogSpConnId ) 
        { 
        con->ogSpConnId = 0; 
        CCDP(AIN_DBG_LEVEL_0, "Update spConnId for redirect call\n"); 
        }  
       }
       /* BUG 91934 */
       if((con->isCOLPRequested == TRUE) && (con->connNum.eh.pres))
       {
          U8 j=0;
       
          for( j = 0; j < con->connNum.addrSig.len; j++)
          CCDP(AIN_DBG_LEVEL_0, "con->connNum.addrSig.val[%d]: %d\n", j,con->connNum.addrSig.val[j]);
      
          cmMemset((U8 *)&con->connNum, 0, sizeof(SiConnectedNum));
       } 
       RETVALUE (ROK); 
   } 
   /* Bug 78663 -- */ 

  if (ccIsUpdateRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
  {
    /* FID17373.0 update map to ACM for EXT_BICC to SIP precondition call */
    if ((CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION)) &&
        ((icProtType == CC_EXT_BICC) || (icProtType == CC_SI)) &&
        (ogProtType==CC_SIP || ogProtType==CC_SIPT) &&
        (!con->isACMSent) &&
        (con->ogPrecndCb) &&
        (IS_PRECND_COMPLETED(con->ogPrecndCb->flag)) &&
        (rmtSdp && !ccIsSdpPrecndPres(rmtSdp)))
    {
      if((con->isPEMInMsg) && (pEarlyMedia) && (pEarlyMedia->cnt) &&
         ((pEarlyMedia->params[0]==SIP_PEM_SENDRECV) || (pEarlyMedia->params[0]==SIP_PEM_SENDONLY)) &&
         ((con->icIntfcCb) && (con->icIntfcCb->ccTgCb) && 
          (con->icIntfcCb->ccTgCb->tgAtt.updateAcmMap == TRUE))) 
      {
        CcCnStEvnt          ogEvnt;
        cmMemset((U8*) &ogEvnt, 0, sizeof(CcConEvnt));
        CCDP(AIN_DBG_LEVEL_0, "%s map Update to ACM\n", __FUNCTION__);
        /* build the early ACM and send it backward */
        ccBuildSs7ACMOrCPGMsg(con, &(ogEvnt.m.siCnStEvnt), FALSE);
        ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                           con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                           con->icProtType, con->ogEvntType,
                           &ogEvnt, NULLP);
      }
    }

    /*FID 15068.0*/
    if(CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) &&
       (icProtType==CC_SI || icProtType==CC_IN || icProtType==CC_EXT_BICC) && /* FID17373.0 */
       (ogProtType==CC_SIP || ogProtType==CC_SIPT) &&
       IS_PRECND_COMPLETED(con->ogPrecndCb->flag) &&
       rmtSdp && ccIsSdpPrecndPres(rmtSdp) && 
       !ccIsPrecndFulfillRemoteInSdp(rmtSdp) &&
       !con->isACMSent)
    {
      CCDP(AIN_DBG_LEVEL_0, "FID15068.0 Update received, need to re-negotiation!\n"); 
      CLEAR_PRECND_COMPLETED(con->ogPrecndCb->flag);
    }

    ret = ccProcessUpdate(con, icProtType, ogProtType,
                          (CcAllSdus*)event);
    if (ret == ROKIGNORE)
    {
      RETVALUE (ROK);
    }
  }

  if (ccIsUpdateRspRcvd(icProtType, ogProtType, con->icEvntType,
                        con->direction))
  {
    ret = ccProcessUpdateRsp(con, icProtType, ogProtType,
                             (CcAllSdus*)event);
    if (ret == ROKIGNORE)
    {
      RETVALUE (ROK);
    }
  }

  if (ccIsPrackRcvd(icProtType, ogProtType, con->icEvntType,
                        con->direction))
  {
    ret = ccProcessPrackOrAck (con, icProtType, ogProtType, (CcAllSdus*)event);
    if (ret == ROKIGNORE)
    {
      RETVALUE (ROK);
    }
  }
  /* FID-2112: SIP UPDATE - */
  /* FID-2575: LMSD + */
  if (ccIsPrackRspRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
  {
    ret = ccProcessPrackRsp(con, icProtType, ogProtType, (CcAllSdus*)event);
    if (ret == ROKIGNORE)
    {
      RETVALUE (ROK);
    }
  }
  /* FID-2575: LMSD - */

  /* Add support for OSUSPENDED for CRBT */
  if ((con->direction == OUTTOINC) && (con->icEvntType == CC_ET_SUSP) &&
      ((ogProtType == CC_SI) || (ogProtType == CC_BICC)))
  {
      ret = ccProcessOSuspended (&(con->icBcm));
      if (ret == ROK)
      {
         CCDP(AIN_DBG_LEVEL_3, "OSuspended requested event sent to FIC\n");
         RETVALUE(ROK);
      }
      else if ( ret == RFAILED)
      {
         CCDP(AIN_DBG_LEVEL_3, "ccProcessOSuspended failed\n");
         RETVALUE(RFAILED);
      }
      else
      {
         CCDP(AIN_DBG_LEVEL_3, "OSuspended not armed as a requested event\n");
      }
   }

  /* Bug - 21880 */
  if (ccIsBillingUpdateRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                            con->direction))
  {
    CCDP(AIN_DBG_LEVEL_0, "Received Billing Update: icSu:0x%08lX, ogSu:0x%08lX,"
         " icSp:0x%08lX, ogSp:0x%08lX, dir:%d\n",con->icSuConnId, con->ogSuConnId,
         con->icSpConnId, con->ogSpConnId, con->direction);

    ccCnStEvnt = (CcCnStEvnt *) event;
    if (ccCnStEvnt != NULLP)
    { 
        if(ccCnStEvnt->m.casCctEvnt.pcIndicate.pres == PRSNT_NODEF)
        {
          con->callDtlInfo.un.telicaCDR_extention.dialdAndPresubInd =
               ccCnStEvnt->m.casCctEvnt.pcIndicate.val;
          CCDP(AIN_DBG_LEVEL_0,"dialdAndPresubInd = %d,  icSu:%ld\n",
               con->callDtlInfo.un.telicaCDR_extention.dialdAndPresubInd,
               con->icSuConnId);
        }
    }
    else
    { 
      CCLOGERR("Error: event is NULLP for EvntType = %d and icSu:%ld\n",
               con->icEvntType, con->icSuConnId);
      ABORT_DEBUG;
      RETVALUE(ROK);
    }
    RETVALUE(ROK);
  }

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
      if (con->icBcm.cc)
      {
        if (con->icBcm.cc->ccId < CiThreePartySetup)
        {
          CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
          RETVALUE(ROK);
        }
      }
      else
      {
        CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
        RETVALUE(ROK);
      }
      con->lastState = con->state;
      ret = ccProcessMidCallEvent(con);
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent success, event detected\n");
        RETVALUE(ROK);
      }
      else if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed\n");
      }
      /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
      CCDP(AIN_DBG_LEVEL_0, "Hook Flash event is not armed\n");
      con->icEvnt = (CcAllSdus *)event;
      con->ogEvnt = (CcAllSdus *)&ogEvnt;
      ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
      if (ret == CCIGNOREMAPPING)
      {
          ccDropUBuf(&con->uBuf);
          CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
          RETVALUE(ROK);
      }
      if (ret != ROK)
      {
          ccDropUBuf(&con->uBuf);
          CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                   " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                   con->ogProtType, con->icSuConnId, con->ogSuConnId);
          RETVALUE(ROK);
      }
      else
      {
          uBuf = con->uBuf;
          con->uBuf = NULLP;
          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                            con->ogSapCb->spId, con->ogSpConnId,
                            con->ogSuConnId, con->ogProtType, con->ogEvntType,
                            &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                            con->icSapCb->spId, con->icSpConnId,
                            con->icSuConnId, con->icProtType, con->ogEvntType,
                            &ogEvnt, uBuf);
          }
          CCDP(AIN_DBG_LEVEL_0, "Mapped Hook Flash icSu :0x%lx\n",
               con->icSuConnId);
          RETVALUE(ROK);
      }
  }

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
      if (con->direction == OUTTOINC)
      {
        DP("Not an Error:Lower layer sending an Onhook from"
            " dir = %d, %d, %ld, %ld\n",
            con->direction, con->state, con->ogSuConnId, con->ogSpConnId);
      }
      ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA 
      if (con->surrogate != NULLP)
         ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
        RETVALUE(ROK);
      }
      else if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
      }
      else if (ret == ROKDRSIG)
      {
        /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
                 notification is sent  and continue with release*/
        CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
      }
      else
         /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
         CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");


      /* since the call is still in Establish phase, release the call
       * no matter who sends on-hook first */
      ccStopConTmr(con, TMR_SETUP);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    
      ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
      /* Stop the O and T_NO_ANSWER timer if it is started */
      ccStopConTmr(con, AIN_O_NO_ANS_TMR);
      ccStopConTmr(con, AIN_T_NO_ANS_TMR);
      /* STOP the AWAIT ANSWER Timer if running
       *
       * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
       */
      ccStopConTmr(con, CC_TMR_AWAITANS); 
      ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
      ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

      ccCleanAnsFraudCall(con);

#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */ 
      if (icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         } 
      }
#endif
      if (CC_IS_CONTEXT_PRESENT(con))
      {
         /* Blow off the switching and Release the Call */
         ccQSubBasedOnCcn(con);  /* FID 15261.0 */

         CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
         con->mgBlock->con = con;
         ret = ccSendMgiQueue(0, con->mgBlock);
         if (ret != ROK)
         {
           CCLOGERR( "ERROR occured \n");
           cleanUpMgQ(con);
           ccCleanUpMGCtx(con);
         }
         else
         {
           RETVALUE(ROK);
         }
      }
      else
      {
#ifdef CC_CALEA
         /* Case where ONHOOK is received from CALEA leg when it is in AWTANS state */ 
         /* Two possiblities, either cut thru has been done or Not done in Tapped
          * State machine */ 
         if (con->icProtType == CC_LOCAL_SWT_PROT)
         {
            /* Already CutThru' has been done for the CALEA leg also in Tapped 
               State machine, hence need to send a MGI SubReq for this caleaLeg */
            if (con->icBcm.cc != NULLP)
            {
               if (con->icBcm.cc->tappedLegId != NULLP)
               {
                  CCDP(AIN_DBG_LEVEL_0,"Deswitching of CALEA  in Tapped con\n");
                  ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                                          event, CCE_RELIND, sizeof(CcRelEvnt));
                  RETVALUE(ROK);
               }
               else
               {
                  CCLOGERR( "ERROR: con->icBcm.cc->tappedLegId is NULLP\n");
               }         
            } 
            else
            {
               CCLOGERR( "ERROR: con->icBcm.cc is NULLP \n");
            } 
         }
         else
#endif
            CCLOGERR( "ERROR: No Switching Context Found\n");
      }

      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCCALLCLR, NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                    con->ogSuConnId, con->ogProtType,
                    CCCALLCLR, NULL);
      RETVALUE(ROK);
  }
  

/* BUG:93381 For annc the reroute case, we may receive Re-Invite
 * before ogLeg get answered, map Update out */
if (con->isAnsIndSent && con->ainInfo.AnswerIndicator &&
      con->ainInfo.Resourcetype.pres && con->ogRscVal &&
      ccIsXferRcvd(con->icProtType,con->ogProtType, con->icEvntType, con->direction))
{
   CCDP(AIN_DBG_LEVEL_0, "Xfer rvd for annc then reroute to real party, respond UPDATE \n");

   ret = ccHandleXfer(con, con->icProtType, con->ogProtType, con->direction, event);

   /* FID-2593: Transcoding + */
   if (ret == ROKIGNORE)
   {
      RETVALUE (ROK);
   }
   /* FID-2593: Transcoding - */

   if(ret == ROKPENDING) /* Save the event for later */
   {
      /* we will interwork  the event after MGI's response */
      ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
            sizeof(CcCnStEvnt));
      RETVALUE(ROK);
   }
}


  ccExtractCallReferenceForACMorProg(con, event);

  ccGeoExtractProtCri(con, (CcAllSdus *)event, CCE_CNSTIND);

  ccPopulateTmuFromACMOrCPG(con, event);

    /* Send Notify to transferer */
  if((con->direction == OUTTOINC) &&
     ((con->relPend == OG_RMT_XFER_AFTER_MGIT_CFM) ||
      (con->relPend == IC_RMT_XFER_AFTER_MGIT_CFM) ||
      (con->relPend == IC_RLT_FAILURE) ||
      (con->relPend == OG_RLT_FAILURE)))
    ccNotifyReferingLeg(con, INCTOOUT, CC_RMT_XFER_INPROGRESS,
        ccGetSipResponseCode(icProtType, CCE_CNSTIND, con->icEvntType));

  /* bug:24575 - update billing-ic/inc call event status.
     NOTE! The event may be from the outgoing side - but its stored in icEventType.
     Right now this func. is called in limited case(s) - but if it needs to be
     called in every one of the 99 interworking cases, then its better to have
     the billingupdate done in one func - than to cut&paste a line in 99 places */
  if (con->direction == OUTTOINC)
      updateBillingForExit(ogProtType, con->icEvntType, &con->callDtlInfo) ;

  /*FID16642.0 check if the call is an operator assisted call+*/
  if ((con->direction == OUTTOINC) &&
      (con->icEvntType == CC_ET_ACM) &&
      (con->oprAstCall == CC_NON_OAC) &&
      (!IS_MULTIMEDIA(con)))
  {
      ccCheckOprAstCall(con);
  }
  /*FID16642.0 -*/
  
  /* FID17160.0 */
  if (CC_IS_STEROMONO_CALL(con))
  {
     if (con->direction == OUTTOINC)
     {
        con->ccmCb.state = CC_EGRESS_MG;
     }
     else
     {
        con->ccmCb.state = CC_INGRESS_MG;
     }
  }

  mgiAction = ccFindSwitchingAction(con, CCE_CNSTIND, con->icEvntType,
      con->direction, &con->icBcm, &con->ogBcm, &icMode, &ogMode, 
      &icSignal, &ogSignal, event, TRUE);
     
  CCDP(AIN_DBG_LEVEL_3, "Action == %d, icMode == %d, icSignal == %d,"
      " ogMode == %d, ogSignal == %d\n", mgiAction, icMode, icSignal,
      ogMode, ogSignal);
  #if 0
  /* FID17160.0 */
  if (CC_IS_STEROMONO_CALL(con) && mgiAction != CC_NO_MGI_ACTION)
  {
     if (con->direction == OUTTOINC)
     {
        con->ccmCb.state = CC_EGRESS_MG;
     }
     else if (con->direction == INCTOOUT)
     {
        con->ccmCb.state = CC_INGRESS_MG;
     }
  }
  #endif
  /* FID 14677.0 */
  /* Backward direction procedure */
  if(mgiAction != CC_NO_MGI_ACTION)
  {
    if ((ccProcessBackwrdDirEcho(con, (CcAllSdus *)event)) != ROK)
    {
      CCDP(AIN_DBG_LEVEL_3, "ERROR: ccProcessBackwrdDirEcho FAILED\n");
      RETVALUE(RFAILED);
    }
  }
  else if ((mgiAction == CC_NO_MGI_ACTION) &&
      (IS_ECHO_BWDMSG(con)) &&
      (IS_ECHO_ENHTYPE1_AND_INVOKE(con)))
  {
     if (((!CC_INGRESS_INTER_CCS_CALL(con) && !CC_EGRESS_INTER_CCS_CALL(con) &&
           !CC_IS_CALL_MULTI_MG(con)) ||
          CC_OPERATING_EGRESS_MG(con)) &&
         ((con->icEvntType == CC_ET_NRESM) ||   
          ((ogProtType == CC_SI) || (ogProtType == CC_SIPT))))
     {
        if ((ccProcessBackwrdDirEcho(con, (CcAllSdus *)event)) != ROK)
        {
           CCDP(AIN_DBG_LEVEL_3, "ERROR: ccProcessBackwrdDirEcho FAILED\n");
           RETVALUE(RFAILED);
        }
     }
     if ((!CC_OPERATING_EGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_INGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
     }
     if ((!CC_OPERATING_INGRESS_MG(con)) &&
         (con->echoParam.EnhEchoLogicVal & CC_EGRESS_MGI_MODIFY))
     {
        mgiAction = CC_MGI_ACTION_MODIFY;
     }
  }

  if(mgiAction != CC_NO_MGI_ACTION)
  {
    ret=ROKDRSIG; /* Set default that OTermSeized is not a requested event */
    if (con->icBcm.pic < PicOAlerting)
    {
       /* FID 14234.0 put APP in OTermseized if it's present */
       con->icEvnt = (CcAllSdus *)event;
       ret=ccProcessOTermSeized(&(con->icBcm));
    }
    if (ret == ROK)
    {
       /* OTermSeized is a requested event, move CcCnStEvnt to the 
        * ccEvntHold, and bail out 
        */
       if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcCnStEvnt))) != ROK)
       {
           CCLOGERR( "ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           RETVALUE(RFAILED);
       }     
       if (clrPrecnd == TRUE) /* FID 15068.0 */
       {
         CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
       }
       RETVALUE(ROK); 
    }
    else if (ret == ROKDRSIG)
    {
       ret=ccProcessOAlertingWithSwitching(con, (PTR)event);
       if (clrPrecnd == TRUE) /* FID 15068.0 */
       {
         CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
       }

       if (ret!=ROK)
          RETVALUE(RFAILED);
    }
    else if (ret == RFAILED)
    {
       CCLOGERR("ERROR: ccProcessOTermSeized FAILED: %ld\n", con->icSuConnId);
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       RETVALUE(RFAILED);
    }
  } /* ADD or MODIFY - Done */
  else if (NMBRCATEGORY_NOT_IVR(con))
  {
    ret=ROKDRSIG;  /* Set default that OTermSeized is not a requested event */
    if (ccCheckOAlertingPICAndDetectionPoint(con, event))
    {
        if (con->icBcm.pic < PicOAlerting)
        {
           ret=ccProcessOTermSeized(&(con->icBcm));
        }
    }
    if (ret == ROK)
    {
       /* OTermSeized is a requested event, move CcCnStEvnt to the 
        * ccEvntHold, and bail out 
        */
       
       if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcCnStEvnt))) != ROK)
       {
           CCLOGERR( "ERROR: ccStoreEvnt FAILED: %ld\n", con->icSuConnId);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           RETVALUE(RFAILED);
       }

       if (clrPrecnd == TRUE) /* FID 15068.0 */
       {
         CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
       }

       RETVALUE(ROK);
    }
    else if (ret == ROKDRSIG)
    {
       if (clrPrecnd == TRUE) /* FID 15068.0 */
       {
         CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
       }
       ret=ccProcessOAlertingNoSwitching(con,(PTR)event);

       if (ret!=ROK)
          RETVALUE(RFAILED);
    }
    else if (ret == RFAILED)
    {
       CCLOGERR("ERROR: ccProcessOTermSeized FAILED: %ld\n", con->icSuConnId);
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       RETVALUE(RFAILED);
    }
  }

  if (clrPrecnd == TRUE) /* FID 15068.0 */
  {
    CC_CLR_CALL_FLAG2(con, CC_FLAG_PRECONDITION);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S09
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    CcRelEvnt     ogEvnt;
    S16           ret                = RFAILED;
    ProtType      icProtType         = CC_GET_PROTOCOL(con->icProtType);
    ProtType      ogProtType         = CC_GET_PROTOCOL(con->ogProtType);
#if 0
    Bool          interCcsLocalBusy  = FALSE;
#endif
    CcCause cause;
    TknU16  sipCause;
    TknU16  sipStatus;
    ProtType      icRealIcProtType = 0;

    CcAllSdus     *icEvnt = NULLP;
    ProtType ingressCCS_IcProtType=0;
    ProtType egressCCS_OgProtType = 0;

    #if 1 /* FID 15335.1 */
    CcSipTPrflCb *sipTPrflPtr = NULL;
    CcSipPrflCb *sipPrflPtr = NULL;
    Bool noReRoute=FALSE;
    #endif

    /*FID15210.0*/
    McgInfo *mcgInfo = NULLP;
    SvcHeader_t     header;
    OverloadUpdate_t overloadUpdate;
    U8               i;
    CcMgcPcCb       *ccMgcPc = NULL;
    /* BUG: 88130 + */ 
    U8  networkBusyRelType = FC_NB_REMOTE_RELEASE;
    /* BUG: 88130 - */ 
    /* bug 91532 */
    cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

    CCDP(AIN_DBG_LEVEL_1, "ccConE04S09 :icSu:%ld,ogSu:%ld,direction:%d\n",
         con->icSuConnId, con->ogSuConnId, con->direction);

    /* FID 15401.1 - Key performance measurements phase 1 */
    ProtType protType;
    if (CC_EGRESS_INTER_CCS_CALL(con))
    {
      CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);
      protType = CC_GET_PROTOCOL(egressCCS_OgProtType);
    }else if (!CC_INGRESS_INTER_CCS_CALL(con))
    {
      protType = CC_GET_PROTOCOL(con->ogProtType);
    }
    if((con->direction == OUTTOINC) &&
      ((protType == CC_SI) || (protType == CC_EXT_BICC) || (protType == CC_SIP) || (protType == CC_SIPT)))
      con->callDtlInfo.cm.iamRspFlag = TRUE;
    CCDP(AIN_DBG_LEVEL_2, "iamRspFlag=%d\n", con->callDtlInfo.cm.iamRspFlag);

    /* BUG 63002 initialize variable */
    cmMemset ((U8 *)&sipCause, 0, sizeof(TknU16));
    cmMemset ((U8 *)&sipStatus, 0, sizeof(TknU16));
    cmMemset ((U8 *)&cause, 0, sizeof(CcCause)); /*Bug:71993*/

    /* Feature 1789 - German ISUP */
    /* stop the Toiw2 Timer if running */
    ccStopConTmr(con, CC_TMR_TOIW2);
    
    /* Stop the CC_TMR_PREANM timer if it is started */
    ccStopConTmr(con, CC_TMR_PREANM);

    if (((con->direction == INCTOOUT) && (ccIsLEGSubscriber(&(con->icBcm)))) ||
        ((con->direction == OUTTOINC) && (ccIsLEGSubscriber(&(con->ogBcm)))))
    {
        CCLOGERR("Invalid combination:icSu:%ld, ogSu:%ld, direction:%d\n",
                 con->icSuConnId, con->ogSuConnId, con->direction);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
    }
    if (((ogProtType == CC_SI) || (ogProtType == CC_EXT_BICC)) && (event) &&
        (((CcRelEvnt *)(event))->m.siRelEvnt.causeDgn.dgnVal.pres == PRSNT_NODEF) &&
        (((CcRelEvnt *)(event))->m.siRelEvnt.causeDgn.dgnVal.len == 0))
    {
       ABORT_DEBUG;
    }

/* JJL */
#if 0    
    CCLOGERR(":");
#endif    
  /* FID 13979, copy histInfoEntries */
  CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCS_IcProtType);
  CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);
  if (con->direction ==INCTOOUT)
  {
      if ((ogProtType == CC_SIP) || (egressCCS_OgProtType == CC_SIP) || 
          (ogProtType == CC_SIPT) || (egressCCS_OgProtType == CC_SIPT))
      {
          if ((icProtType == CC_SIP) &&
              (((CcRelEvnt *)event)->m.sipRelEvnt.sipHistInfo.eh.pres))
          {
              ccExtractHistInfoEntries(&(con->histInfoEntries), 
                  &(((CcRelEvnt *)event)->m.sipRelEvnt.sipHistInfo.otherEntries));
          }
          else if ((icProtType == CC_SIPT) &&
                  (((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sipHistInfo.eh.pres))
          {
              ccExtractHistInfoEntries(&(con->histInfoEntries), 
                  &(((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sipHistInfo.otherEntries));
          }
      }
  }
  else
  {
      if ((icProtType == CC_SIP) || (ingressCCS_IcProtType == CC_SIP) ||
          (icProtType == CC_SIPT) || (ingressCCS_IcProtType == CC_SIPT))
      {
          if ((ogProtType == CC_SIP) &&
              (((CcRelEvnt *)event)->m.sipRelEvnt.sipHistInfo.eh.pres))
          {
              ccExtractHistInfoEntries(&(con->histInfoEntries), 
                  &(((CcRelEvnt *)event)->m.sipRelEvnt.sipHistInfo.otherEntries));
          }
          else if ((ogProtType == CC_SIPT) &&
                  (((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sipHistInfo.eh.pres))
          {
              ccExtractHistInfoEntries(&(con->histInfoEntries), 
                  &(((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sipHistInfo.otherEntries));
          }
      }
  }
  /* End of FID 13979 */

    /* FID 14732 */
    ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
    /* FID 14732 */

    icEvnt = (CcAllSdus *) event;
    /* BUG73119 REL Event for FailCnd */ 
    con->icEvnt = (CcAllSdus *) event;
    con->ogEvnt = (CcAllSdus *) &ogEvnt;

    /* FID 15045.1 */
    if (CC_IS_MSG_RCV_FROM_SRP(con))
    {
        ccExtractUUdata(con,(CcAllSdus*)event,CCE_RELIND);
    }

    /* Get protocol release cause */
#if 0
    ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType),
                  (CcRelEvnt *)event, &cause, &sipCause, &sipStatus);
#else
    if (ccFillFailCndFromRelEvnt(con, (CcRelEvnt *)event) == ROKDNA)
    {
      ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType),
                    (CcRelEvnt *)event, &cause, &sipCause, &sipStatus);
    }
#endif

    /* FID 15174.0 Handle release indication for Overlap */
    if ((con->direction == OUTTOINC) && ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT)) &&
        ((sipStatus.pres == PRSNT_NODEF) && (sipStatus.val == SIPCAUSE_484_ADDRINC)) &&
        (CC_IS_ICOVERLAP_ENABLED(con) && CC_IS_OGOVERLAP_ENABLED(con) &&
        (icProtType != CC_EXT_BICC)))
    {
       ret = ccHandleReleaseForOverlap(con, (CcRelEvnt *)event);

       if (ret == ROK)
       {
          RETVALUE(ROK);
       }
    }

    if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
    {
        con->tempHolderForReleaseCause = cause.causeVal.val;
        con->ainInfo.diconnectCause    = cause.causeVal.val;
    }

    /* FID15210.0 */
    if ((con->direction == OUTTOINC)
                && (con->callDtlInfo.un.telicaCDR_extention.mcgInfo.pres))
    {
        mcgInfo = &con->callDtlInfo.un.telicaCDR_extention.mcgInfo;

        for(i = 0; i < mcgInfo->count; i++)
        {
            if ((mcgInfo->result[i] == MCG_ALLOWED) &&
                (mcgInfo->mcgType[i] == MCG_TYPE_LEAKYBUCKET))
            {
                cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
                cmMemset((U8 *)&overloadUpdate, 0, sizeof(OverloadUpdate_t));

                overloadUpdate.appType.pres = PRSNT_NODEF;
                overloadUpdate.appType.val = LB_APP_TYPE_MCG; // meant for mcg
                overloadUpdate.u.mcgCodeId[i].pres = PRSNT_NODEF; 
                overloadUpdate.u.mcgCodeId[i].val = mcgInfo->codeId[i];

                CCDP(AIN_DBG_LEVEL_4, "CcUiFctOverloadUpdate: mcgCodeId = %ld\n", 
                                      overloadUpdate.u.mcgCodeId[i].val);
                if (CcUiFctOverloadUpdate(&overloadUpdate, &header) != ROK)
                  CCDP(AIN_DBG_LEVEL_4, "ERROR: MCG CcUiFctOverloadUpdate FAILED\n");

            }
        }
    }

    /* FID15169.0 */
    if ((cause.eh.pres == PRSNT_NODEF)
         && (cause.causeVal.pres == PRSNT_NODEF)
         && ((ogProtType == CC_SI) || (egressCCS_OgProtType == CC_SI))
         && (((CcRelEvnt *)(event))->m.siRelEvnt.autoCongLvl.eh.pres == PRSNT_NODEF)
         && (((CcRelEvnt *)(event))->m.siRelEvnt.autoCongLvl.auCongLvl.val > 0))
    {
        ret = cmHashListFind(&ccMgcPcTbl, (U8 *)&(con->ogIntfcCb->intfc.t.tgrpDesc.dpc),
                               (U16)sizeof(Dpc), 0, (PTR *)&ccMgcPc);

        if ((ret != ROK) || (ccMgcPc == NULL))
        {
            CCLOGERR("Error: dpc not found\n");
        }
        else
        {  
            if ((ccMgcPc->prflLeakBucketId)
                 &&((ccMgcPc->relCauseVal == 0)
                    ||(cause.causeVal.val == ccMgcPc->relCauseVal)))
            {
                CCDP(AIN_DBG_LEVEL_4, "CcUiFctOverloadUpdate: causeVal=%d, relCauseVal= %d\n",
                cause.causeVal.val, ccMgcPc->relCauseVal);

                cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
                cmMemset((U8 *)&overloadUpdate, 0, sizeof(OverloadUpdate_t));

                overloadUpdate.appType.pres = PRSNT_NODEF;
                overloadUpdate.appType.val = LB_APP_TYPE_AACC; // meant for aacc
                overloadUpdate.u.dpc = con->ogRsc.intfc.t.tgrpDesc.dpc;

                CCDP(AIN_DBG_LEVEL_4, "CcUiFctOverloadUpdate: dpc=%ld\n",
                                      overloadUpdate.u.dpc);

                if (CcUiFctOverloadUpdate(&overloadUpdate, &header) != ROK)
                    CCDP(AIN_DBG_LEVEL_4, "ERROR: AACC CcUiFctOverloadUpdate FAILED\n");
            }
        }

    }
 
    /* FID16784.0 */
    if((con->direction == OUTTOINC) &&
       (((ogProtType == CC_SIP) &&
       (((CcRelEvnt *)event)->m.sipRelEvnt.overloadInd)) ||
       ((ogProtType == CC_SIPT) &&
       (((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.overloadInd)))) 
    {
       CCDP(AIN_DBG_LEVEL_4, "E0409 calling CcUiFctOverloadUpdate \n");
       cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
       cmMemset((U8 *)&overloadUpdate, 0, sizeof(OverloadUpdate_t));
       overloadUpdate.appType.pres = PRSNT_NODEF;
       overloadUpdate.appType.val = LB_APP_TYPE_SIP;
       overloadUpdate.u.intfcId = con->ogRsc.intfc.t.sipDesc.tgrpId;

       if (CcUiFctOverloadUpdate(&overloadUpdate, &header) != ROK)
          CCDP(AIN_DBG_LEVEL_4, "ERROR: SIP SOC CcUiFctOverloadUpdate FAILED\n");

       /* Need to clear the indicator, so that GCC will not carry it back to SIPA. */
       if(ogProtType == CC_SIP)
          ((CcRelEvnt *)event)->m.sipRelEvnt.overloadInd = FALSE;
       else if(ogProtType == CC_SIPT)
          ((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.overloadInd = FALSE;
    }

    if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                           sizeof(CcRelEvnt))) != ROK)
    {
      CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
    }

    if (((ogProtType == CC_SI) || (ogProtType == CC_EXT_BICC)) && (con->ccEvntHold) &&
        (con->ccEvntHold->m.ccRelEvnt.m.siRelEvnt.causeDgn.dgnVal.pres == PRSNT_NODEF) &&
        (con->ccEvntHold->m.ccRelEvnt.m.siRelEvnt.causeDgn.dgnVal.len == 0))
    {
       ABORT_DEBUG;
    }

    /* FID 14841.2 */
    if ((con->direction == OUTTOINC) &&
        (CC_EGRESS_INTER_CCS_CALL(con))&&
        ((con->failCndVal == FC_REJECT_MEDIA_CAC) ||
         (con->failCndVal == FC_MG_OOS)))
    {
      /* FID 15261.0 + */
      /* Need to populate the CAC policy name */
      strncpy (con->callDtlInfo.cm.CACCause.CACProfileName.val,
               con->routeEvnt->cacPrflInfo.routeMgPrflName.val,
               con->routeEvnt->cacPrflInfo.routeMgPrflName.len);
               con->callDtlInfo.cm.CACCause.CACProfileName.len =
                    con->routeEvnt->cacPrflInfo.routeMgPrflName.len;
      /* FID 15261.0 - */

      if  (CC_IS_MGW_AVAIL_MG_LIST(con))
      {
        CCDP(AIN_DBG_LEVEL_0, "%s: Egress CCS CAC failed, Re-try Another MG\n", 
             __FUNCTION__);
        ccReRouteCall(con, CC_EGRESS_MG);
        RETVALUE(ROK);      
      }
      else if ((ccCheckForInterfaces(con) == ROK)&&
               (CC_EGRESS_INTER_CCS_CALL(con) ? \
                  ((con->routeEvnt)&& \
                   (++con->routeEvnt->currentInterface)&& \
                   (ccCheckForInterfaces(con) == ROK)) : TRUE))
      {
        CCDP(AIN_DBG_LEVEL_0, "%s: Egress CCS CAC failed, Re-try Another Route\n", 
             __FUNCTION__);
        ccReRouteCall(con, CC_MG_NULL);
        RETVALUE(ROK);            
      }
      else
      {
        /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
        if (CC_IS_SIP_CONTACTURI_AVAIL(con))
        {
          CC_ADVANCE_CONTACT_URI_LIST(con, ret);
        
          if (ret == ROK)
          {
             CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                 "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                 con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
            RETVALUE(ROK);
          }
        } 
        else if (CC_IS_SIP3XXCALL(con))
        {
          /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
             is needed for reroute due to default failCndId processing */
          ccRestoreEvntHold(con);
          ccRestoreOrigParamFor3xxCall(con);
        }

        CC_FREE_SIP3XX_BLOCK(con);
        /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */

        CCDP(AIN_DBG_LEVEL_0, "%s: Egress CCS CAC failed, Apply FailCond \n", 
             __FUNCTION__);


        if (con->failCndVal == FC_MG_OOS)
        {
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          if (con->ogRscVal)
          {
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
          }
          ccProcessFailCnd(con, FC_NOROUTDST, TRUE);
        }
        else
        {
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          if (con->ogRscVal)
          {
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
          }
          ccProcessFailCnd(con, con->failCndVal, TRUE);
        }
        RETVALUE(ROK);      
      }
    }

    /* Clean the answer fraud Call */
    ccCleanAnsFraudCall(con);

    if (con->direction == OUTTOINC)
    {
      switch (ogProtType)
      {
        case CC_SI:
        case CC_EXT_BICC:
          ccUpdateBusyCauseForTermNot(con, con->ogProtType,
                                      cause.location.val, cause.cdeStand.val,
                                      cause.causeVal.val); /*Bug:30414*/
          if (CC_IS_PROT_TYPE_AUSTRALIA(con->ogProtType))
          {
            /* For Telstra if CAUSE 14 is received after we send the IAM,
             * then try re-routing the call by calling ccProcessFailCnd()
             *
             * Changes made for Bug 31651, RV Suresh , 5.0 
             */
            if (CC_CAUSE_IS_VAL(&cause, CCLNPMISROUTE, CSTD_CCITT))
            {
                CCDP(AIN_DBG_LEVEL_2,"%s:LNP MIS ROUTE \n", __FUNCTION__);
                ccSendReleaseRsp(con);
                ccDeallocateResource(con, CC_OUTGOING);
                con->ogRscVal = FALSE;
                ccProcessFailCnd(con, FC_LNP_MISROUTE, TRUE);
                RETVALUE(ROK);
            } /* if (relCause == CCNOCIRCUIT) */
          }

          if (CC_CAUSE_IS_VAL(&cause, CCNOCIRCUIT, CSTD_CCITT) || 
              CC_CAUSE_IS_VAL(&cause, CCUSRBSY, CSTD_CCITT))
          {
#ifdef CC_CALEA
            if (icProtType == CC_LOCAL_SWT_PROT)
              ccUpdateCloseCause(con, CC_BOTH, CscRmtBusy);
#endif
#if 1 /*FGD*/
            /* 
             * For SS7-MF interworking at AT, if AT fails to complete the
             * AT-IXC leg it will release the call with relCause=34.
             * In this case, EO will play the appropriate announcement
             */
            if (CC_CAUSE_IS_VAL(&cause, CCNOCIRCUIT, CSTD_CCITT) && 
                (ccIsLEGSubscriber(&(con->icBcm))) &&
                (!CC_ROUTE_ADVANCE(con))) /* Bug 47535 */
            {
                ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);
		/* 33261+ */
		if (con->noRspReqd == FALSE)
		  ccSendReleaseRsp(con);   		
		/* 33261- */
                RETVALUE(ROK); /*Bug:30414*/
            } /* if (relCause == CCNOCIRCUIT) */
#endif /*FGD*/
          }
          else if (icProtType == CC_LOCAL_SWT_PROT)
            ccUpdateCloseCause(con, CC_BOTH, CscRmtFailure);
          break;  /* case CC_SI */
        case CC_IN:
          if (CC_CAUSE_IS_VAL(&cause, CCNOCIRCUIT, CSTD_CCITT) || 
              CC_CAUSE_IS_VAL(&cause, CCUSRBSY, CSTD_CCITT))
          {
            ccUpdateBusyCauseForTermNot(con, con->ogProtType,
              cause.location.val, cause.cdeStand.val, cause.causeVal.val);
          }
          break;
        case CC_CS_TG:
#if 1 /*FGD*/
          /*
           * Handle Failure cases. When AT/IXC/INC fails to return WINK CAS-SP
           * reports it as RelInd. Play announcement to the user.
           */
          /*
           * If we are AT and we fail to seize the egress trunk to IXC/INC,
           * send a steady offhook to EO and play announcement to the ingress
           * trunk
           * If we are EO and fail to see a WINK from AT/IXC/INC at any stage,
           * play the announcement to the subscriber
           */
          switch(icEvnt->m.ccRelEvnt.m.casCctEvnt.relType.val)
          {
            case CS_REL_IND_DUMP_CALL:
              CCDP(AIN_DBG_LEVEL_2,"%s:CS_REL_IND_DUMP_CALL\n", __FUNCTION__);
              break;
            case CS_REL_IND_NO_WINK_AFTER_SEIZE_AT_IXC:
            case CS_REL_IND_NO_WINK_AFTER_SEIZE:
            case CS_REL_IND_NO_WINK_AFTER_OUTPULSE:
            case CS_REL_IND_NO_WINK_AFTER_FINAL_OUTPULSE:
              /* Send RelRsp to Egress BUG:21515*/
              CCDP(AIN_DBG_LEVEL_2,"%s:CAS REL IND\n", __FUNCTION__);
              ccSendReleaseRsp(con);
              ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;
              ccProcessFailCnd(con, FC_CASTG_RELIND, TRUE);
              RETVALUE(ROK);
            default:
              CCDP(AIN_DBG_LEVEL_2, "ccConE04S09:Invalid RelInd from CAS-SP\n");
              break;
          } /* switch (relCause) */
#endif /*FGD*/
            ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER,
                                        CSTD_CCITT, CCCALRABANDON);
            break; /* case CC_CS_TG */

        case CC_SIP:
          CC_FILL_BUSY_CAUSE(con->ainInfo.BusyCause, cause, sipCause,
                             sipStatus);
          break;
          /* BUG72246 */
        case CC_BICC:
            ccUpdateBusyCauseForTermNot(con,con->ogProtType,
                                        cause.location.val, cause.cdeStand.val,
                                        cause.causeVal.val); 
          break;
        default:
          ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER,
                                      CSTD_CCITT, CCCALRABANDON);
          break;  /* default */
      } /* switch (ogProtType) */

#if 1 /* BUG: 51409 - the verification of handle_acc should be specific to outgoing ISUP protocol */
    if ((con->direction == OUTTOINC) && ((ogProtType == CC_SI) || (ogProtType == CC_EXT_BICC)))
      {
#endif
         /* Bug 66794 prevent stack from overflow when tightly coupled ccRelInd
          * is called in egress CCS.
          */
         if (((((CcRelEvnt *)(event))->m.siRelEvnt.optElmnt.m.isup.handle_acc == TRUE) ||
              (CC_INGRESS_INTER_CCS_CALL(con))) &&
             (reEntryFlag == TRUE))
         {
             DP("ccConE04S09:%ld,%ld\n", con->icSuConnId, con->ogSuConnId);
             ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,NULLP, 0);
             ccPostEventToSelf(con);
             RETVALUE(ROK);
         }

         /* BUG:79684 engress not reroute in ACC call */
         if ((((CcRelEvnt *)(event))->m.siRelEvnt.optElmnt.m.isup.handle_acc == TRUE) &&
            (reEntryFlag == FALSE) && (!CC_INGRESS_INTER_CCS_CALL(con)) && (CC_ROUTE_ADVANCE(con)))
         {
             CCDP(AIN_DBG_LEVEL_2, "ccConE04S09: Re-Route ACC Call\n");
             ccReRouteCall(con, CC_MG_NULL);
             RETVALUE(ROK);
         }
#if 1 /* BUG: 51409 */
      }
#endif
     
      /* FID 14732.0 */
      if (con->icIntfcCb)
          icRealIcProtType = CC_GET_PROTOCOL(con->icIntfcCb->protType);

      CCDP(AIN_DBG_LEVEL_0, "mgAdvance:%d, mgAdvancemet:%d, maxReroute:%d,"
              "icRealIcProtType: %d\n", CC_IS_MG_ADVANCE(con),
         CC_IS_MG_ADVANCE_COND_MET(con->failCndVal), !CC_IS_MAX_MG_REROUTE(con),
              icRealIcProtType);

      if (CC_IS_MG_ADVANCE(con) &&
          (CC_IS_MG_ADVANCE_COND_MET(con->failCndVal)) &&
          (!CC_IS_MAX_MG_REROUTE(con)) &&
          (icRealIcProtType != CC_CS_TG))
      {
          if (CC_IS_MGW_AVAIL_MG_LIST(con))
          {
              /* reroute to the next in the MG list */
              CCDP(AIN_DBG_LEVEL_0, "%s: MGWAdvance to the next MG in the MG"
                                    " list\n", __FUNCTION__);
              ccReRouteCall(con, CC_EGRESS_MG);
              RETVALUE(ROK);
          }
          else
          {
              CCDP(AIN_DBG_LEVEL_0, "MGW List exhausted for this route"
                                    " playing treatment\n");
              con->failCndVal = FC_MG_RLIST_EXHAUST;
          }
      }

      /* BUG:79684 inter-ccs ACC call */
      if (CC_IS_REMOTE_REL(con->mntRelProc) && CC_EGRESS_INTER_CCS_CALL(con) &&
          (con->failCndVal == FC_CKTCONG) && (CC_ROUTE_ADVANCE(con)))
      {
         CCDP(AIN_DBG_LEVEL_2, "ccConE04S09 ACC Re-route inter call \n");

         /* FID 14716.0 */
         CC_SET_CALL_FLAG(con->flag, CC_FLAG_GROVRFLW_SKIP);

         if (CC_EGRESS_INTER_CCS_CALL(con))
            con->routeEvnt->currentInterface++;

         if ((ret = ccCheckForInterfaces(con)) != ROK)
         {

             /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
             if (CC_IS_SIP_CONTACTURI_AVAIL(con))
             {   
               CC_ADVANCE_CONTACT_URI_LIST(con, ret);
        
               if (ret == ROK)
               {
                  CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                      "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                      con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
                 RETVALUE(ROK);
               }
             }
             else if (CC_IS_SIP3XXCALL(con))
             {
               /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
                  is needed for reroute due to default failCndId processing */
               ccRestoreEvntHold(con);
               ccRestoreOrigParamFor3xxCall(con);
             }

             CC_FREE_SIP3XX_BLOCK(con);
             /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */

             /* Bug 88130 + */
             if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_HPCQ_AR) && (!con->interCcsLocalBusy))
             {
               if ((con->icBcm.nel[EReqNetworkBusy] == NEL_REQUEST) &&
                   (con->icBcm.svcHeader.transId)) 
               {
                 con->icBcm.nel[EReqNetworkBusy] = NEL_UNARMED;
               }
             }
            
             if (con->interCcsLocalBusy)
             {
                /* Default is FC_NB_REMOTE_RELEASE */
                networkBusyRelType = FC_NB_LOCAL_RELEASE;
             }
             /* Bug 88130 - */

             CCDP(AIN_DBG_LEVEL_0, "Need to detect NetworkBusy Event: %ld\n",
                  con->icSuConnId);
             ccFillBusyCauseFromRelCause(con, &cause);
             ret = ccProcessNetworkBusy(&(con->icBcm), networkBusyRelType);
             if (ret == ROK)
             {
                 CCDP(AIN_DBG_LEVEL_0, "Network Busy Detected: %ld\n",
                      con->icSuConnId);
                 RETVALUE(ROK);
             }
             else
             {
                 CCDP(AIN_DBG_LEVEL_0, "Network Busy Not Armed: %ld\n",
                      con->icSuConnId);
                 /* Drop down for default treatment */
             }
         }
         else
         {
             ccReRouteCall(con, CC_MG_NULL);
             RETVALUE(ROK);
         }
      }

      /* FID 16794.0 */
      if ((CC_IS_REMOTE_REL(con->mntRelProc) &&
          (ccIsRelCauseRaProtRel(con, cause, sipCause, sipStatus) ||
           CC_IS_GETS_UNSUPP(con, sipStatus)))     ||  /* FID 14457.0 */
           (con->interCcsLocalBusy))
      {

        /* Bug 88130 + */
        if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_HPCQ_AR) && (!con->interCcsLocalBusy))
        {
          if ((con->icBcm.nel[EReqNetworkBusy] == NEL_REQUEST) &&
              (con->icBcm.svcHeader.transId)) 
          {
            con->icBcm.nel[EReqNetworkBusy] = NEL_UNARMED;
          }
        }
        
        if (con->interCcsLocalBusy)
        {
           /* Default is FC_NB_REMOTE_RELEASE */
           networkBusyRelType = FC_NB_LOCAL_RELEASE;
        }
        else
        {
	  /* FID 14716.0 */
          CC_SET_CALL_FLAG(con->flag, CC_FLAG_GROVRFLW_SKIP);
        }
        /* Bug 88130 - */

	#if 1 /* FID 15335.1 Begin*/
	if( (con->direction==OUTTOINC) && ((ogProtType==CC_SIP)||(ogProtType==CC_SIPT)||((ogProtType==CC_BICC)&&(egressCCS_OgProtType==CC_SIP||egressCCS_OgProtType==CC_SIPT))) )
	{
	    if( (sipStatus.pres == PRSNT_NODEF) && (sipStatus.val == SIPCAUSE_483_HOPCNT) )
	    {
		if( (ogProtType == CC_SIPT)||(egressCCS_OgProtType==CC_SIPT) ) 
		{
		    CCDP(AIN_DBG_LEVEL_0, "Check routeSIP483 flag in SIPT-PRFL.\n");
		    if ( (con->ogIntfcCb) && (con->ogIntfcCb->ccTgCb) )
		    {
			sipTPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr;
		    }
		    if( sipTPrflPtr && sipTPrflPtr->noRouteSIP483 )
		    {
			CCDP(AIN_DBG_LEVEL_0, "routeSIP483 set to N, do not reroute.\n");
			noReRoute = TRUE;
		    }
		}else
		{
		    CCDP(AIN_DBG_LEVEL_0, "Check routeSIP483 flag in SIP-PRFL.\n");
		    if ( (con->ogIntfcCb) && (con->ogIntfcCb->ccTgCb) )
		    {
			sipPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr;
		    }
		    if( sipPrflPtr && sipPrflPtr->noRouteSIP483 )
		    {
			CCDP(AIN_DBG_LEVEL_0, "routeSIP483 set to N, do not reroute.\n");
			noReRoute = TRUE;
		    }
		}
	    }
	}
	#endif /* FID 15335.1 End */

	con->tempHolderForReleaseCause = cause.causeVal.val;

	/* FID 15335.1 begin*/
	if(!noReRoute)
	{
	    ret = ccCheckForInterfaces(con);
	}
	if ( !noReRoute && (ret == ROK) && ((CC_ROUTE_ADVANCE(con)) || (con->interCcsLocalBusy)))
	/* FID 15335.1 end*/
        {
          CCDP(AIN_DBG_LEVEL_0, "Proceeding with ReRoute: icSu: %ld\n",
                                con->icSuConnId);
          if (CC_EGRESS_INTER_CCS_CALL(con))
            con->routeEvnt->currentInterface++;

#if 1 /* BUG:71993. Do not use same BGN when doing ROUTE_ADVANCE due to
         NETWRK_BSY condition. Skip over to find index of new BGN*/
	  /* FID 16794.0 */
          /* Bug91984, don't skip TG when it is interCcsLocalBusy */   
          if ((!con->interCcsLocalBusy) && (ccIsRelCauseRaProtRel(con, cause, sipCause, sipStatus))) 
          {
            RmInterface currIntfc;
            RmInterface prevIntfc;

            currIntfc = 
              con->routeEvnt->ogInterface[con->routeEvnt->currentInterface];

            prevIntfc =
              con->routeEvnt->ogInterface[con->routeEvnt->currentInterface - 1];

            /* Skip indexes till new TGN is found */
            while ((ROK == ccCheckForInterfaces(con)) &&
                   (CC_ROUTE_ADVANCE_NOT_MULTIRR(con) && 
                    (CC_IS_SAME_INTFC(prevIntfc, currIntfc) || 
                     ccCheckDupIsdnPseudoTgnForCurIntfc(con)))) /*FID 16796.0*/
            {
              currIntfc = 
                con->routeEvnt->ogInterface[++con->routeEvnt->currentInterface];
              CCDP(AIN_DBG_LEVEL_0, " Skipping to %ld. prevbgn %d-%d\n",
                  con->routeEvnt->currentInterface, prevIntfc.intfType,
                  prevIntfc.t.tgrpDesc.tgrpId);
            }
          }
#endif /* BUG:71993. End 2*/

          if ((ret = ccCheckForInterfaces(con)) != ROK)
          {
              /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
              if (CC_IS_SIP_CONTACTURI_AVAIL(con))
              {
                CC_ADVANCE_CONTACT_URI_LIST(con, ret);
        
                if (ret == ROK)
                {
                   CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                       "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                       con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
                  RETVALUE(ROK);
                }
              }
             else if (CC_IS_SIP3XXCALL(con))
             {
               /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
                  is needed for reroute due to default failCndId processing */
               ccRestoreEvntHold(con);
               ccRestoreOrigParamFor3xxCall(con);
             }

              CC_FREE_SIP3XX_BLOCK(con);
              /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */

              /* FID-15801 (LGP-74)*/
              CCDP(AIN_DBG_LEVEL_0, "Need to detect NetworkBusy Event: %ld\n",
                   con->icSuConnId); 
              ccFillBusyCauseFromRelCause(con, &cause);
              ret = ccProcessNetworkBusy(&(con->icBcm), networkBusyRelType);
              if (ret == ROK)
              {
                  CCDP(AIN_DBG_LEVEL_0, "Network Busy Detected: %ld\n",
                       con->icSuConnId);
                  RETVALUE(ROK);
              }
              else
              {
                  CCDP(AIN_DBG_LEVEL_0, "Network Busy Not Armed: %ld\n",
                       con->icSuConnId);
                  /* Drop down for default treatment */
              }
          }
          else
          {
              ccReRouteCall(con, CC_MG_NULL);
              RETVALUE(ROK);
          }
        }
        else
        {
          /* FID 14457.0 */
          if (CC_IS_GETS_UNSUPP(con, sipStatus))
          {
             /* Route to the last Route with RphDowngrade and will not route again*/
             con->routeEvnt->currentInterface -- ;
             if (ccCheckForInterfaces(con) == ROK)
             {
                /* Set CC_RPH_DOWNGRADE in specialCall, Clear it after setting SipRscPriority */
                CC_SET_RPH_DOWNGRADE_FLAG(con, CC_RPH_DOWNGRADE);  

                ccReRouteCall(con, CC_MG_NULL); 
                RETVALUE(ROK);
             }             
          }

          /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
          if (CC_IS_SIP_CONTACTURI_AVAIL(con))
          {
            CC_ADVANCE_CONTACT_URI_LIST(con, ret);
        
            if (ret == ROK)
            {
               CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                   "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                   con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
              RETVALUE(ROK);
            }
          }
          else if (CC_IS_SIP3XXCALL(con))
          {
            /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
               is needed for reroute due to default failCndId processing */
            ccRestoreEvntHold(con);
            ccRestoreOrigParamFor3xxCall(con);
          }

          CC_FREE_SIP3XX_BLOCK(con);
          /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */


          CCDP(AIN_DBG_LEVEL_0, "Need to detect NetworkBusy Event: %ld\n",
                                con->icSuConnId);

          ccFillBusyCauseFromRelCause(con, &cause);
          ret = ccProcessNetworkBusy(&(con->icBcm), networkBusyRelType);
          if (ret == ROK)
          {
            CCDP(AIN_DBG_LEVEL_0, "Network Busy Detected: %ld\n",
                                  con->icSuConnId);
            RETVALUE(ROK);
          }
          else
          {
            CCDP(AIN_DBG_LEVEL_0, "Network Busy Not Armed: %ld\n",
                                  con->icSuConnId);
            /* Drop down for default treatment */
          }
        }
      }

      /* Do a special handling for BRAZAIL FID16901.0 */
      ProtType ogProtRealType =0;
      if (CC_EGRESS_INTER_CCS_CALL(con))
      {
        if (con->ogIntfcCb)
        {
          ogProtRealType = con->ogIntfcCb->protType;
        }
        else
        {
          ogProtRealType = con->realLegProtType;
        }
      }
      else
        ogProtRealType = con->ogProtType;


      CCDP(AIN_DBG_LEVEL_2, "ogProtRealType %d\n", ogProtRealType);

      if ((con->direction == OUTTOINC) &&  CC_IS_PROT_TYPE_BRAZIL(ogProtRealType))
      {
        /* If we received REL from BRAIL ISUP need to some special
         * handling */
        ret = ccProcessArmEventsForSpecialCustomer(con, event, &cause);
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Event Armed as req Detected: %ld\n",
              con->icSuConnId);
          RETVALUE(ROK);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "No req event Armed: %ld\n", con->icSuConnId);
        }

      }


      if ((!CC_CAUSE_IS_VAL(&cause, CCCALLCLR, CSTD_CCITT)) &&
          (!CC_CAUSE_IS_VAL(&cause, CCNORMUNSPEC, CSTD_CCITT)) &&
          (con->icBcm.pic != PicOActive))
      {
        /* + FID-15801 :: LGP-74 changes to advance to the next Contact URI */
        if (CC_IS_SIP_CONTACTURI_AVAIL(con))
        {
          CC_ADVANCE_CONTACT_URI_LIST(con, ret);
          
          if (ret == ROK)
          {
            CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
                 "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
                 con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
            RETVALUE(ROK);
          }
        }
        else if (CC_IS_SIP3XXCALL(con))
        {
          /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
             is needed for reroute due to default failCndId processing */
          ccRestoreEvntHold(con);
          ccRestoreOrigParamFor3xxCall(con);
        }

        CC_FREE_SIP3XX_BLOCK(con);
        /* - FID-15801 :: LGP-74 changes to advance to the next Contact URI */

        con->tempHolderForReleaseCause = cause.causeVal.val;

        ret = ccProcessOCalledPartyBusy(&(con->icBcm));
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Detected OCdPtyBsy icSu:%ld, ogSu:%ld,"
            " icTsId:%ld\n", con->icSuConnId, con->ogSuConnId,
            con->icBcm.svcHeader.transId);
          RETVALUE(ROK);
        }
      } /* if (relCause == CCUSRBSY) */

      /* + FID 15801.0 */
      if ((con->direction == OUTTOINC) && ((ogProtType == CC_SIP) || (ogProtType == CC_SIPT))  
          && CC_IS_SIP_3XX_REDIRECT(sipStatus) && (icProtType != CC_EXT_BICC))
      {
        Sip3xxBlock *pSip3xxBlock = NULL;

        con->tempHolderForReleaseCause = cause.causeVal.val; 

        if (ogProtType == CC_SIP)
          pSip3xxBlock = &(((CcRelEvnt *)event)->m.sipRelEvnt.sip3xxBlock); 
        else
          pSip3xxBlock = &(((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sip3xxBlock);

        /* Bug# 86992 - Process ORedirect only if we receive contHeaders */
        if (pSip3xxBlock && pSip3xxBlock->numHeaders && pSip3xxBlock->contHdr)
        {
          ccExtractSip3xxBlock(con, pSip3xxBlock);

          ret = ccProcessORedirect(&(con->icBcm));
   
          if (ret == ROK)
          {
            CCDP(AIN_DBG_LEVEL_0, "Detected ORedirect icSu:%ld, ogSu:%ld,"
                 " icTsId:%ld\n", con->icSuConnId, con->ogSuConnId,
                  con->icBcm.svcHeader.transId);
            RETVALUE(ROK);
          }
        }
        else
        {
          CCLOGERR("%s():: SIP3XX_HANDLING_ADVANCED coming with ZERO numHeaders. "
                   "Go with the Default Rel Procedure\n", __FUNCTION__);
            
        }
        /* - FID 15801.0 */
        /* FID 17026.0 + */
        if (con->ogIntfcCb && CC_SIP3XX_HANDLING_PASSTHRU(con->ogIntfcCb))
        {
           CCDP(AIN_DBG_LEVEL_0, "%s():SIP3XX_HANDLING_PASSTHRU\n",__FUNCTION__);   
 
           TknStrVar *Sip3xxContact = NULL; 

           if(ogProtType == CC_SIP)
              Sip3xxContact = &(((CcRelEvnt *)event)->m.sipRelEvnt.sip3xxContact);
           else
              Sip3xxContact = &(((CcRelEvnt *)event)->m.siRelEvnt.optElmnt.m.sipt.sip3xxContact);

           if(Sip3xxContact && Sip3xxContact->pres)
           {
              /* Reuse ccExtractHistInfoEntries to extract sip3xxContact */
              ccExtractHistInfoEntries(&(con->sip3xxContact), Sip3xxContact);
              CCDP(AIN_DBG_LEVEL_0, "%s: sip3xxContact.len:%d, val:%.*s\n",
                 __FUNCTION__, con->sip3xxContact.len, con->sip3xxContact.len,con->sip3xxContact.val);
           }
           else
           {
              CCLOGERR("%s():ERROR!! SIP3XX_HANDLING_PASSTHRU with no Sip3xxContact. "
                                "Go with the Default Rel Procedure\n", __FUNCTION__);
           }
        }  
      }  
      /* FID 17026.0 - */

      if (ret != ROKIGNORE) /* If OCalledParty is was reported then go ahead
                           * and release call */
      {
        /*Bug 37463 -- Check for ODisconnect*/
        ret = ccProcessDisconnectEvent(con, event);
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
          RETVALUE(ROK);
        }
        else if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
        }
        /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
        CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
      }
    } /* if (con->direction == OUTTOINC) */

    if ((con->direction == INCTOOUT) ||
        ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup)))
    {
      ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
      if (con->surrogate != NULLP)
        ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
        RETVALUE(ROK);
      }
      else if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
      }
      /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
      CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
            "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif
    }
    UPDATE_OPIC(con, PicSelectRoute);
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
#if 1 /* EARLY_ACM */
    ccStopConTmr(con, CC_TMR_EARLYACM); 
#endif

    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      /* BUG: 82235 for BICC to SIP call, possible reroute triggered by failcnd will
       * not subtract OBcm.
       */
      if((icProtType == CC_EXT_BICC) && (con->direction == OUTTOINC) && 
          (con->icBcm.nel[EReqIDisconnect] != NEL_REQUEST))
      {
         con->failCndVal = ccMapProtRel2FailCnd (con, &cause, &sipCause, &sipStatus);

         if((con->failCndVal > FC_UNEXPECTED_MSG) &&
            ((con->exceptionIndCtr + 1) < CC_MAX_EXCEPTIONS))
         {
             CcFailCond_t *failCndPrflPtr = NULLP;
             CcFailCndKey failCndKey;
             CcFailCndKey *keyPtr  = &failCndKey;
    
             keyPtr->prflId = con->ccFailCndInfo.failCndPrflId;
             keyPtr->cnd    = con->failCndVal;
             keyPtr->protType = CC_EXT_BICC;
    
             ret = RFAILED;
             ret = cmHashListFind(&ccFailCndPrflTbl,(U8 *)(keyPtr),(U16)sizeof(CcFailCndKey),
                                  (U16)0, (PTR *)&failCndPrflPtr);
             if(ret != ROK)
             {
                if (keyPtr->prflId != LRS_DEFAULT_FAIL_COND_ID)
                {
                    keyPtr->prflId = LRS_DEFAULT_FAIL_COND_ID;
                    ret = cmHashListFind(&ccFailCndPrflTbl,(U8 *)(keyPtr),(U16)sizeof(CcFailCndKey),
                                         (U16)0, (PTR *)&failCndPrflPtr);
                }
             }
    
             if((ret == ROK) && (failCndPrflPtr->failType == LRS_COND_TREAT))
             {
                CCDP(AIN_DBG_LEVEL_1, "no SUB to EXT_BICC for possible reroute\n");

                /* Bug 84555 + */
                if (CC_IS_CALL_MULTI_MG(con))
                {
                   con->ccmCb.mgPend = 0;
                   if(CC_IS_BCM_IN_CONTEXT(con->icAdjBcm))
                   {
                      con->ccmCb.mgPend++;
                      ccUpdateMgQForSubRsc(con->icAdjBcm, con->icAdjBcm->mgCtx->suCtxId,con);
                   }
                   if((CC_IS_BCM_IN_CONTEXT(&con->ogBcm)) ||
                      (CC_IS_BCM_IN_CONTEXT(con->ogAdjBcm)))
                   {
                      con->ccmCb.mgPend++;
                      ccUpdateMgQForSubRsc((PTR) NULLP,
                            (con->ogBcm.mgCtx)?con->ogBcm.mgCtx->suCtxId:con->ogAdjBcm->mgCtx->suCtxId, con);
                   }
                }
                else
                {
                    ccUpdateMgQForSubRsc(&(con->ogBcm), con->mgBlock->mgCtx->suCtxId, con);
                } /* Bug 84555 - */
             }
             else 
             {
                 ccQSubBasedOnCcn(con);  /* FID 15261.0 */
             }
         }
         else
         {
              ccQSubBasedOnCcn(con);  /* FID 15261.0 */
         }
         CCDP(AIN_DBG_LEVEL_1, "con->failCndVal:%ld\n",con->failCndVal);
      } /* End of bug 82235 */
      else
      {
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */
      }

      if ((con->direction == OUTTOINC) && ((con->reconnectBcm == OBCM)||(con->reconnectBcm == TBCM)) )
      {
         con->relPend = OUTRELRSPANDINREL;
      }
      else if (con->direction == OUTTOINC) /*Bug65493*/
      {
        con->relPend = OUTRELRSPANDINTONE; 
      }
      else
      {
        ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
        con->relPend = INRELRSPANDOUTREL;
      }

      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR( "Error: ccSendMgiQueue failed\n");
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        RETVALUE(ROK);
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "No Switching Ctx found:%d\n", con->ogProtType);
#ifdef CC_CALEA
      if (con->icProtType == CC_LOCAL_SWT_PROT)
      {
        if ((con->icBcm.cc != NULLP) && (con->icBcm.cc->tappedLegId != NULLP))
        {
          CCDP(AIN_DBG_LEVEL_0,"Deswitching of CALEA  in Tapped con\n");
          ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                                        event, CCE_RELIND, sizeof(CcRelEvnt));
          RETVALUE(ROK);
        }
        else
          CCLOGERR( "ERROR: con->ogBcm.cc is NULLP \n");
      }
#endif
    }
    /* As de-switching request has failed, clear the other stuff */
    if (con->noRspReqd == FALSE)
      ccSendReleaseRsp(con);
    if (con->direction == OUTTOINC)
    {
        con->failCndVal = ccMapProtRel2FailCnd (con, &cause, &sipCause, &sipStatus); 
    }

    if (con->direction == INCTOOUT)
    {
      ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
      /* Deallocate the IC Resources */
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_INCOMING);
#else
          ccDeallocateResource(con, CC_INCOMING);
#endif
          con->icRscVal = FALSE;

      /* FID 14234.0 */
      if(con->ogRscVal == FALSE && !con->assocBlock)
      {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
          RETVALUE (ROK);
      }
    }
    
    else if (con->direction == OUTTOINC)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ccDeallocateResource(con, CC_OUTGOING);
#endif
      con->ogRscVal = FALSE;
      /* FID 14234.0 */
      if(con->icRscVal == FALSE && !con->assocBlock)
      {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
          RETVALUE (ROK);
      }
    }

    /* if required, PLAY BUSY Tone or REORDER Tone */
    if (con->direction == OUTTOINC)
    {
        ccStopConTmr (con, TMR_RELEASE);
        ccStartConTmr (TMR_SETUP, con, (PTR)&ccCp.genCfg);
        ret = ccProcessFailCnd (con, con->failCndVal, FALSE);
        if (ret == ROK)
            RETVALUE (ROK);
    }

    /*Bug 80906 reset handle_acc flag after ACC processing*/
    if(((con->direction == INCTOOUT) && (icProtType == CC_SI) 
        &&(con->icEvnt->m.ccRelEvnt.m.siRelEvnt.optElmnt.m.isup.handle_acc == TRUE))
      ||((con->direction == OUTTOINC) && (ogProtType == CC_SI)
        &&(con->ogEvnt->m.ccRelEvnt.m.siRelEvnt.optElmnt.m.isup.handle_acc == TRUE)))
    {  /* Bug89740 if it's ISUP call and ACC processed, reset the handle_acc flag */
        ((CcRelEvnt *)(event))->m.siRelEvnt.optElmnt.m.isup.handle_acc = FALSE;
    }

    ret = ccMapEvent(con, CCE_RELIND, 0);
    
    if (ret != ROK)
    {
       if (con->direction == INCTOOUT)
       {
           ccSendRelease (con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, CCPROTERR,NULL);
       }
       else if (con->direction == OUTTOINC)
       {
           ccSendRelease (con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CCPROTERR,NULL);
       }
       RETVALUE(ROK);
   }

    /* Delayed Release Process */
    /* For Spain, the process is not valid in this state */
    if (!(CC_IS_PROT_TYPE_SPAIN(con->ogProtType) ||
          CC_IS_PROT_TYPE_SPAIN(con->icProtType)))
    {
       ret = ccProcessDelayedRelease(con);

       switch (ret)
       {
         case ROK:
            /* ROK - proceed normally with the call */
            break; 

         case ROKIGNORE:
            /* Delayed Release Process executed - The RelReq will not be sent*/
            ccStopConTmr(con, TMR_RELEASE);
            CCDP(AIN_DBG_LEVEL_1,"Delayed Release Process started\n");
            CC_STATE_CHANGE(con, CCS_AWTDELAYEDREL);
            RETVALUE(ROK);

         default:
            break;
       }
    }

    ccSendReleaseReq(con);


    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S09
 *
 *      Desc:  Connection state function
 *             event - Release Confirmation
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                     ret            = RFAILED;
  CcRelEvnt               ogEvnt;
  ProtType                icProtType     = CC_GET_PROTOCOL(con->icProtType);

  TRC3(ccConE05S09)
  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  /* Initiate Deswitching */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Otherwise, the call is to be released */
  /* Initiate Deswitching */
  /* Stop the O_NO_ANSWER timer if it is started */
  ccStopConTmr(con, AIN_O_NO_ANS_TMR);

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  /* Stop the T_NO_ANSWER timer if it is started */
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
  #if 1 /* EARLY_ACM */
  ccStopConTmr(con, CC_TMR_EARLYACM); 
  #endif

  ccCleanAnsFraudCall(con);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELCFM, (PTR) event);
  /* FID 14732 */                 

  /* copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/
  ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt)); 

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
    ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
#ifdef CC_CALEA
  if (icProtType != CC_LOCAL_SWT_PROT)
  {
    /* Make sure ur in Tapped Con */
    ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
    if (ret != ROK)
    {
      CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
    }
  }
#endif
  ret = RFAILED;
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    if (con->direction == INCTOOUT)
      con->relPend = INRELRSPANDOUTREL;
    else
      con->relPend = OUTRELRSPANDINREL;

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other
         side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCLOGERR( "ERROR: No Switching Ctx found \n");
  }

  con->icEvnt = (CcAllSdus *) event;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;

    {
      /* Send Resource Dealocation for initiating side */
      /* Map the release    */

      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      if (con->direction == INCTOOUT)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccDeallocateResource(con, CC_INCOMING);
          con->icRscVal = FALSE;     
        }
      else if (con->direction == OUTTOINC)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;    
        }

      ret = ccMapEvent(con, CCE_RELCFM, 0);
      if (ret != ROK)
        {
          if (con->direction == INCTOOUT)
          {
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                          con->ogProtType, CCPROTERR,NULL);
          }
          else if (con->direction == OUTTOINC)
          {
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                          con->icProtType, CCPROTERR,NULL);
          }
          RETVALUE(ROK);
        }
      ccSendReleaseReq(con);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE07S09
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - Reattempt
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PUBLIC S16 ccConE07S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16                  ret     = RFAILED;
    MgctCallProgItemId   signal   = MGCT_ITEM_ID_CG_MAX;
    MgctPackageId        pkgId    = MGCT_PACKAGE_ID_CG;
    MgctMode             mode     = MGCT_MODE_MAX;
    U32                  ctxtId   = 0; /* BUG:88040 Context for SUBTRACT command */

    /* Bug 69330 */
    if (reEntryFlag == TRUE)
    {
        DP("ccConE07S09:%ld,%ld\n", con->icSuConnId, con->ogSuConnId);
        ccBufferEventToQueue(con, bcm, event, CCE_REATIND, sizeof(CcCnStEvnt), 0,NULLP, 0);
        ccPostEventToSelf(con);
        RETVALUE(ROK);
    }

    /* Bug 84743 */
    if ((CC_GET_PROTOCOL(con->ogProtType) != CC_EXT_BICC) &&
        (CC_IS_CONTEXT_PRESENT(con)) &&
        (!con->reattemptFlag) /* if we are this set to true, we will
				 eventually release the call so there
				 is no point in doing extra work.  */)
    {
        /* BUG:88040 Move ogBcm-check down here, since in OG-COT failure case,  */
        /*           ogBcm has alread been subtracted. The subtraction is done  */
        /*           in ccConE07S30. We need to go through this function as     */
	/*           well as E11S87 to make sure old Li-terms get removed and   */
	/*           new OG-CIC and Li-terms get installed.                     */
	if(ccCheckMgContext(&con->ogBcm, &pkgId, &signal, &mode) == ROK)
	{
	    ccUpdateMgQForSubRsc(&(con->ogBcm), con->ogBcm.mgCtx->suCtxId, con);
	    ctxtId = con->ogBcm.mgCtx->suCtxId;        /* BUG:88040 find correct Context */
	}

        if ((CC_IS_CALL_TAPPED(con)) && (CC_IS_X3_ALLOWED(con)) &&
            ((con->ccmCb.ccn == CCN_4) || (con->ccmCb.ccn == CCN_2)))
        {
            ccGenerateCcCloseForLi(con);

            if ((con->icLiBcm) && (con->icLiBcm->mgCtx))
	    {
		ccUpdateMgQForSubRsc(con->icLiBcm, con->icLiBcm->mgCtx->suCtxId, con);
		if(!ctxtId)      /* ogBcm not in Context for COT failure case */
		    ctxtId = con->icLiBcm->mgCtx->suCtxId;
	    }
            if ((con->ogLiBcm) && (con->ogLiBcm->mgCtx))
	    {
		ccUpdateMgQForSubRsc(con->ogLiBcm, con->ogLiBcm->mgCtx->suCtxId, con);
		if(!ctxtId)      /* ogBcm not in Context for COT failure case */
		    ctxtId = con->ogLiBcm->mgCtx->suCtxId;
	    }
        }
	if(ctxtId)
	{
	    con->relPend = CONTINUEWITHREATTEMPT;
	    CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORDP);
	    con->mgBlock->con = con;
	    ret = ccSendMgiQueue(ctxtId, con->mgBlock);

	    if (ret != ROK)
	    {
		CCLOGERR("Error: ccSendMgiQueue failed:suCtxId = %ld,"
			 " icSu:%ld\n", ctxtId,
			 con->icSuConnId);
		ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
		RETVALUE(ROK);
	    }
	    /* Store the StaEvnt here */
	    ccStoreEvnt(con->evntType, con->icEvntType, con,
			(U8 *)event, sizeof(CcStaEvnt));
	    RETVALUE(ROK);
	}
    }
    ccProcessReAttempt(con, event, bcm, event2);
    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE13S09
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - InitRel
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE13S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16        ret       = RFAILED;
  U8         cause     = CCTMPFAIL;
  CcStaEvnt *ccStaEvnt = NULLP;
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  U8 relCause = CCCALLCLR;


  TRC3(ccConE13S09)

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  /* Start of Bug#16346 : gb - Play tone after ISDN/SS7 finsh the RelCfm */
  if((con->direction == OUTTOINC) && (ogProtType == CC_IN))
  {
    CcStaEvnt *ccStaEvnt = (CcStaEvnt*)(event);

    if(ccStaEvnt == NULLP)
     relCause = CCSWTCHCONG;
    else
      relCause = ccStaEvnt->ccRelCalEvnt.ccCause.causeVal.val;
  }
  else
    relCause = CCSWTCHCONG;

  if((relCause != CCCALLCLR) &&
     (icProtType == CC_GR303 || icProtType == CC_CS_LN || icProtType == CC_CS_TG))
  {
  }
  ccStaEvnt = (CcStaEvnt *) event;

  if ((ccStaEvnt->ccRelCalEvnt.ccCause.eh.pres == PRSNT_NODEF) &&
      (ccStaEvnt->ccRelCalEvnt.ccCause.causeVal.pres == PRSNT_NODEF))
    cause = ccStaEvnt->ccRelCalEvnt.ccCause.causeVal.val;

  /* The INITREL indication only comes from outgoing interface */
  /* Initiate release in both directions */
  /* Initiate Deswitching */

  #if 1 /* EARLY_ACM */
  ccStopConTmr(con, CC_TMR_EARLYACM); 
  #endif
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Release all connections */
  /* Bugzilla 9072 &9074 :taraveti */
  /* Store the event and use this event in E11S54 for ccProcRelCall */
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcStaEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
  }

  /* Initiate De-switching */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    if (ret == ROK)
    {
      con->lastState = con->state;
      con->tempHolderForReleaseCause = cause;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
    }
    if (ret != ROK)
    {
      CCLOGERR( "ERROR occured :%ld\n", con->icSuConnId);
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
    {
      RETVALUE(ROK);
    }
  }

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
  ccProcRelCall(con, (CcStaEvnt *)event);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S09
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                      ret            = RFAILED;
  CcConCb                 *CS1con         = NULLP;
  CcMidCallReqEvnt         midCallReq;
  Bool                     multiPartyCall = FALSE;
  ODisconnect_t            oDisconnect;
  SvcHeader_t              header;
  U8                       index          = 0;
  Bool                     notIndFlag     = FALSE;
  AinBCM_t                 *pBcm          = NULLP;

  TRC3(ccConE14S09)
  CCDP(AIN_DBG_LEVEL_1, "ccConE14S09: \n");
  CCLOGERR("SETUP Timer Expired: %ld\n", con->icSuConnId);

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

 /*  ccSendIDisconnect sends FIC IDisconnect, sets a new state 
  *  for requested event and returns.
  */
  pBcm = &(con->icBcm);

  if (pBcm->nel[EReqIDisconnect] == NEL_REQUEST)
  {
      ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
                 LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

     /* Send FIC appropriate error back.  
      * Selected from telica_errtreat.h 
      */

      ret=ccSendIDisconnect(pBcm,FC_TMRRCVRY);
      if (ret != ROK)
      {
#if 1
         CCDP(AIN_DBG_LEVEL_1,"IDisconnect failed to send to FIC\n");
         ABORT_DEBUG;
#endif
      }
      return(ROK);
  }

  if (con->icBcm.cc)
  {
    /* Bug# 18044  and Bug# 18131*/
    if (con->mgPlayingTone)
    {
       CCDP(AIN_DBG_LEVEL_0,
            "Busy Timer Expiry in MultiParty (TWC) call \n");
       if ((con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ||
           (con->icBcm.nel[EReqODisconnect] == NEL_NOTIFY))
       {
         if (con->icBcm.svcHeader.transId)
         {
           cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
           cmMemset((U8 *)&oDisconnect, 0, sizeof(ODisconnect_t));
           /* Store legId */
           if (con->icBcm.cc)
           {
             if (con->icBcm.cc->ccId >= CiThreePartySetup)
               con->ainInfo.legId = 2;
             else
               con->ainInfo.legId = 1;
           }
           else
             con->ainInfo.legId = 1;

           /* Bug# 18104 */
           ccUpdateccId(&(con->icBcm.cc->ccId), con->ainInfo.legId);

           CCDP(AIN_DBG_LEVEL_2, "LegId disconnected:%d\n",
                              con->ainInfo.legId);
           ccFillSvcHeader(&header, &(con->icBcm), MSG_O_Disconnect);
           CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

           notIndFlag = (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ?
                        FALSE: TRUE;

           ccFillODisconnectParam(&oDisconnect, &(con->icBcm), notIndFlag);
           CCDP(AIN_DBG_LEVEL_0," Filled O_Disconnect, TransID=%ld\n",
                header.spTransId);

           /* Bug# 11386 */
           if (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST)
           {
              /* Cleaning up the NEL as per R5-241 GR1298 */
              for (index = 0; index < EReqMax; index++)
              {
                  con->icBcm.nel[index] = NEL_UNARMED;
              }

              /* Send the msg as it is not needed to be buffered */
              con->lastState = con->state;
              CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE9);
              ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                                 CCS_CANNOTPROCESSEVENTS);
              CcUiFctODisconnect(&oDisconnect, &header);
              RETVALUE(ROK);
           }
           else
           {
              CCDP(AIN_DBG_LEVEL_0, "Disconnect Notification:%d\n",
                   con->icBcm.nel[EReqODisconnect]);
              CcUiFctODisconnect(&oDisconnect, &header);
           }
         }
         else
         {
           CCLOGERR("Error: transId is zero:%ld,%ld\n", con->icSuConnId,
                                                      con->ogSuConnId);
         }
       }
       else
          CCLOGERR("BusyTimer expired and ODisconnect event is not armed\n");
    }

    if ((con->icBcm.cc->ccId >= CiThreePartySetup) && 
        (con->icBcm.cc->ccId <= CiRemoteTransferSetup))
      multiPartyCall = TRUE;
  }

  if (multiPartyCall)
  {
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  /* Else Fall down and do the regular clean up */

  /* Initiate release in both directions */
  /* Initiate Deswitching */
  /* Release all connections */

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Also Stop the CWT tone as we are going back to Two Party Call */
  ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);

  /* Initiate De-switching */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    con->lastState = con->state;
    if (con->ogRscVal == FALSE)
    {
      if (con->ogBcm.cc)
      {
        if ((con->ogBcm.cc->ccId == CiCallWaiting) ||
            (con->ogBcm.cc->ccId == CiCallWaitingComplement))
        {
          CS1con = con->ogBcm.cc->legId02->con; 
          if (con->ogBcm.cc->legId02->bcmType == BtOBcm)
          {
            CcLiCctMidCallReq(&CS1con->icSapCb->pst, CS1con->icSapCb->spId,
                               CS1con->icSpConnId, CS1con->icSuConnId,
                               CS1con->icProtType, &midCallReq);
            CS1con->icBcm.cc->legId01 = &(CS1con->icBcm);
            CS1con->icBcm.cc->legId02 = NULLP;
            CS1con->icBcm.cc->legId2  = NULLP;
            CS1con->icBcm.cc->ccId    = CiStable2Party;
          }
          else if (con->ogBcm.cc->legId02->bcmType == BtTBcm)
          {
            CcLiCctMidCallReq(&CS1con->ogSapCb->pst,CS1con->ogSapCb->spId,
                               CS1con->ogSpConnId, CS1con->ogSuConnId,
                               CS1con->ogProtType, &midCallReq);
            CS1con->ogBcm.cc->legId01 = &(CS1con->ogBcm);
            CS1con->ogBcm.cc->legId02 = NULLP;
            CS1con->ogBcm.cc->legId2  = NULLP;
            CS1con->ogBcm.cc->ccId    = CiStable2Party;
          }
          else
          {
            CCLOGERR("Invalid bcmType: %d\n",
                                       con->ogBcm.cc->legId02->bcmType);
            RETVALUE(RFAILED);
          }

          con->ogBcm.cc             = NULLP;
          ccCloseTBcmTransaction (con);
        }
      }

      con->relPend = ICRELONLY;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
    }
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      CCLOGERR( "ERROR occured \n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0, ": No Switching Context Found\n");
  }

  if (con->ogRscVal == FALSE)
  {
    /* Also Stop the CWT tone as we are going back to Two Party Call */
    if (con->ogBcm.cc)
    {
      if ((con->ogBcm.cc->ccId == CiCallWaiting) ||
          (con->ogBcm.cc->ccId == CiCallWaitingComplement))
      {
        CS1con = con->ogBcm.cc->legId02->con;
        if (con->ogBcm.cc->legId02->bcmType == BtOBcm)
        {
          CcLiCctMidCallReq(&CS1con->icSapCb->pst, CS1con->icSapCb->spId,
                             CS1con->icSpConnId, CS1con->icSuConnId,
                             CS1con->icProtType, &midCallReq);
          CS1con->icBcm.cc->legId01 = &(CS1con->icBcm);
          CS1con->icBcm.cc->legId02 = NULLP;
          CS1con->icBcm.cc->legId2  = NULLP;
          CS1con->icBcm.cc->ccId    = CiStable2Party;
        }
        else if (con->ogBcm.cc->legId02->bcmType == BtTBcm)
        {
          CcLiCctMidCallReq(&CS1con->ogSapCb->pst,CS1con->ogSapCb->spId,
                             CS1con->ogSpConnId, CS1con->ogSuConnId,
                             CS1con->ogProtType, &midCallReq);
          CS1con->ogBcm.cc->legId01 = &(CS1con->ogBcm);
          CS1con->ogBcm.cc->legId02 = NULLP;
          CS1con->ogBcm.cc->legId2  = NULLP;
          CS1con->ogBcm.cc->ccId    = CiStable2Party;
        }
        else
        {
          CCLOGERR("Invalid bcmType: %d\n", con->ogBcm.cc->legId02->bcmType);
          RETVALUE(RFAILED);
        }

        con->ogBcm.cc             = NULLP;
        ccCloseTBcmTransaction (con);
      }
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL,NULL);
    }
  }
  else
  {
#ifdef CC_CALEA
    if (con->icProtType == CC_LOCAL_SWT_PROT)
    {
       ccUpdateCloseCause(con, CC_BOTH, CscRmtTscTimeout);
       ret = ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                             event, CCE_SETUPTMREXP, 0 );
       RETVALUE(ROK);
    }
#endif

    /* Anyway go ahead and clean up the call */
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                  con->icProtType, CCTMPFAIL,NULL);
    ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                  con->ogProtType, CCTMPFAIL,NULL);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S10
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret               = RFAILED;
  Bool     multiPartyCall    = FALSE;
  Bool     ogmultiPartyCall  = FALSE;

  TRC3(ccConE14S10)
  if (con->icBcm.cc)
  {
    if ((con->icBcm.cc->ccId >= CiThreePartySetup) &&
        (con->icBcm.cc->ccId <= CiRemoteTransferSetup))
      multiPartyCall = TRUE;
  } 

  if (con->ogBcm.cc)
  {
    if ((con->ogBcm.cc->ccId >= CiThreePartySetup) &&
        (con->ogBcm.cc->ccId <= CiRemoteTransferSetup))
      ogmultiPartyCall = TRUE;
  }

  if ((multiPartyCall) || (ogmultiPartyCall))
  {
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  /* Else Fall down and clean up the normal way */

  /* Initiate release in both directions */
  /* Initiate Deswitching */
  /* Release all connections */

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CCLOGERR( "ccConE14S10(): How can someone forget to stop" 
       "SETUP timer when the call is already in ANSWERED state?\n");
  CCLOGERR( "ccConE14S10(): Clearing the call. \n");

  /* Initiate De-switching */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    con->lastState = con->state;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      CCLOGERR( "ERROR occured \n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCLOGERR( "ERROR: No Switching Context Found\n");
#ifdef CC_CALEA
    if (con->icProtType == CC_LOCAL_SWT_PROT)
    {
       ccUpdateCloseCause(con, CC_BOTH, CscRmtTscTimeout);
       ret = ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                             event, CCE_SETUPTMREXP, 0 );
       RETVALUE(ROK);
    }
#endif
  }

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL,NULL);
  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL,NULL);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S10
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16              ret          = RFAILED;
    CcCnStEvnt       ogEvnt;
    Buffer           *uBuf        = NULLP;
    ProtType         icProtType   = CC_GET_PROTOCOL(con->icProtType);
    ProtType         ogProtType   = CC_GET_PROTOCOL(con->ogProtType);
    S16              HoldXferFlag = 0;
    ProtType         egressCCS_OgProtType = 0;
    /* euysal - 03/22/2006 - BUG:45322 SIP UPDATE fix */
#if 0    
    Sdp              *sdp         = NULLP;
#endif    
    Bool        memFreeRequired = FALSE;
    /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
    S16 sdpRet = ROK;
    /* FID 14844 */
    Bool  vbdEventSup = FALSE; /* FID 15913.0 */

#ifdef ZC
    ZcUpdParam upd;
#endif /* ZC */

    /* First verify if a HOLD is in progress,  Both incoming and */
    /* outgoing resources shall be valid  if no HOLD is in progress */

    cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));
    /* map connection status event */
    con->icEvnt = (CcAllSdus *)event;
    con->ogEvnt = (CcAllSdus *)&ogEvnt;

    if(con->icEvntType == CC_ET_APPTRAN)
    {
        /* FID 15319.0 */
        if(((con->direction == INCTOOUT) && (icProtType == CC_EXT_BICC)) ||
           ((con->direction == OUTTOINC) && (ogProtType == CC_EXT_BICC)))
        {
            CCDP(AIN_DBG_LEVEL_0, "DBG: dir:%d, icProtType:%d, ogProtType:%d\n",
                 con->direction, icProtType, ogProtType );
            ccHandleBiccSignalApm(con, con->direction, &con->icEvnt->m.ccCnStEvnt.m.siCnStEvnt);
            RETVALUE(ROK);
        }

    }
    /* CPDI_FIX: we need relinguish old rel event in the buffer */
    /* logic: whenever ccRelEvntHold != NULL, ccEvntHold isn't CCE_RELIND */ 
    CC_FREE_REL_EVNT_HOLD(con);
    CCDP(AIN_DBG_LEVEL_0, "ccConE03S10\n");

    /* FID 15045.1 + */
    if (CC_IS_MSG_RCV_FROM_SRP(con) && (con->icEvntType == CC_ET_U2U))
    {
        /* A USR message was received from the SRP.
         * Pass User 2 User Info from USR Msg to FIC. 
         * USR message is not interworked from SRP.
         */
         ccProcessOUui(&(con->icBcm));
         RETVALUE(ROK);
    }
    /* FID 15045.1 - */

  /* FID 15261.0 + */
  if (CC_IS_CALL_MULTI_MG(con))
  {
    if (con->direction == OUTTOINC)
      con->ccmCb.state = CC_EGRESS_MG;
    else
      con->ccmCb.state = CC_INGRESS_MG;
  }
  /* FID 15261.0 - */


  /* FID17160.0 */
  if (CC_IS_STEROMONO_CALL(con))
  {
     if (con->direction == OUTTOINC)
        con->ccmCb.state = CC_EGRESS_MG;
     else
        con->ccmCb.state = CC_INGRESS_MG;
  }
    
  if(ccIsFaxModemOrTextRecd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {

    /* FID 15913.0 */
    if((ccIsIPResource(&con->ogBcm)) &&
       (!ccIsIPResource(&con->icBcm)))
    {   
      if (con->icIntfcCb)
        vbdEventSup = con->icIntfcCb->vbdEventSup;

      if (vbdEventSup == TRUE)
      {
        CCDP(AIN_DBG_LEVEL_1,"%s: vbdEventSup=%d ignore fax/modem/text event.\n",
         __FUNCTION__, vbdEventSup); 
        RETVALUE(ROK);
      }
    }

    ret = ccProcessFaxModemTextDetectForCAS((PTR)con, ROK);
    if (ret == ROK)
    {
        CCDP(AIN_DBG_LEVEL_0, "%s: returning\n", __FUNCTION__);
        RETVALUE(ROK);
    }
  }

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
    {
      /* Remove this Code after FSM buffering works */
      CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

      ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(ROK);
    }

    /* AAG */
    if ((ccIsInfoRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                     con->direction)) && (CC_ENDPOINT_CALL(con)))
    {
        /* Processing this only in the ANSWERED STATE as per requirement */
        if (((con->direction == INCTOOUT) && (CC_ENDPOINT_BCM(&con->ogBcm))) ||
            ((con->direction == OUTTOINC) && (CC_ENDPOINT_BCM(&con->icBcm))))
        {
            ccBuildAndSendCWTInfo(con, (CcCnStEvnt *)event);
            RETVALUE(ROK);
        }
    }
    /* AAG */

#if 1 /* BUG: 22819, 22929, kparikh */
   /* If CPG is received from SS7 side in Answered state will result in
      release of call for incoming protocol SIP and ISDN.
      So, just ignore the received CPG message from SS7 side */
      if ((con->state == CCS_ANSWERED) && (con->direction == OUTTOINC)
          && (icProtType == CC_IN)
          && (ogProtType == CC_SI) && (con->icEvntType == CC_ET_CPG))
      {
	  /* BUG:47211 */
          if( !( con->icProtType == CC_INETSI))
	  {
              CC_DP(AIN_DBG_LEVEL_2,(con),"Ignoring CPG from outgoing SS7 side in Answered State.\n");
              RETVALUE (ROK);
	  }
	  /*End of 47211 */
      }
#endif    

    /* Added for ISUP - SIP interworking, 
     * CPG with remote hold should map to Re-invite (HOLD)
     * SUSPEND should map to re-invite (HOLD)
     *
     * CPG with remote retrieval should map to Re-invite (XFER)
     * RESUME should map to re-invite (XFER)
     *
     *
     * RV Suresh, International Development
     */

/*pengding--BUG:43906*/
            if ((con->icEvntType == CC_ET_UMSG) &&
                (((con->direction == INCTOOUT) && 
                  ((icProtType == CC_SI) ||
                   (icProtType == CC_EXT_BICC) ||
                   (icProtType == CC_BICC) ||
                   (icProtType == CC_SIPT))) ||
                 ((con->direction == OUTTOINC) && 
                  ((ogProtType == CC_SI) ||
                   (icProtType == CC_EXT_BICC) ||
                   (ogProtType == CC_BICC) ||
                   (ogProtType == CC_SIPT)))))
            {
               ret = ROKIGNORE;
            }
            /* FID 7812  + FID 16747.0 */
            else if((con->icEvntType == CC_ET_FAC) &&
                    (CC_IS_PROT_TYPE_ANSI_ISUP(con->icProtType)||
                     CC_IS_PROT_TYPE_ANSI_ISUP(con->ogProtType)||
                     CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb) ||
                     CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb)))
            {
               ret = ROKIGNORE;
            }
            else
            {
               ret = ccCheckForSiHoldXferToSip(con, &HoldXferFlag);
            }
/*end--pengding--BUG:43906*/
    if (ret == ROK)
    {
      /* case of CPG with remote hold or retrieval to SIP */
      AinBCM_t *pBcm1;
      AinBCM_t *pBcm2;
      
      CC_DP(AIN_DBG_LEVEL_2,(con),"Handling Hold and Xfer from outgoing SS7 side to SIP in Answered State \n");
      CCDP(AIN_DBG_LEVEL_0,"HoldXferFlag = %d -- con->holdState = %d -- con->holdFlag = %d \n",
           HoldXferFlag, con->holdState, con->holdFlag);
        
      if(con->direction == OUTTOINC)
      {
        /* FID 15261.0 + */
        if (CC_IS_CALL_MULTI_MG(con))
        {
          pBcm1 = con->ogAdjBcm;
          pBcm2 = &con->ogBcm;
        }
        else
        {
           pBcm1 = &con->icBcm;
           pBcm2 = &con->ogBcm;
         }
         /* FID 15261.0 - */
      }
      else 
      {
        /* FID 15261.0 + */
        if (CC_IS_CALL_MULTI_MG(con))
        {
          pBcm1 = con->icAdjBcm;
          pBcm2 = &con->icBcm;
        }
        else
        {
          pBcm1 = &con->ogBcm;
          pBcm2 = &con->icBcm;
        }
        /* FID 15261.0 - */
      }
      ccHoldXferSwitchBearer(pBcm1, pBcm2, NULLP, NULLP, con->state,HoldXferFlag);
      /* Bug 89253, we will interwork the event after MGI's response */
      if(ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcCnStEvnt)) != ROK)
      {
          CCLOGERR("ERROR: ccStoreEvnt()failed.\n");
      }
      CC_INIT_CON_ICEVNT_PTR(con);
      RETVALUE(ROK);
    }
    else 
    if (ret == RFAILED)
    {
      /* case of CPG to SIP, but with no notification indicator,
       * so dump the message 
       *
       * Bug: 36043 found in TELSTRA
       */
      CC_DP(AIN_DBG_LEVEL_0,(con),"Ignoring CPG from SS7 for SIP case in ANSWERED state \n");
      RETVALUE (ROK);
    }
    else 
    if (ret == RIGNORE)
    {
      /* euysal - 03/15/2006 - BUG:45236 - Problem 2 Dual Call Hold
       * case of DUPLICATE CPG to SIP,
       * so dump the message 
       */
      CCDP(AIN_DBG_LEVEL_0, "Ignoring DUPLICATE CPG from SS7 for SIP case in ANSWERED state \n");
      CCDP(AIN_DBG_LEVEL_0, "con->holdState: %d -- con->holdFlag: %d\n",con->holdState, con->holdFlag);
      RETVALUE (ROK);
    }
    /* ROKIGNORE 
     *
     * case of CPG for other protocols, or non CPG message 
     */

    /* If not a 911 caller */
    if (ccIs911HoldCall(con) == FALSE)
    {
       if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
       {
            con->lastState = con->state;
            ret = ccProcessMidCallEvent(con);
            if (ret == ROK)
            {
                CCDP(AIN_DBG_LEVEL_0, "ccProcessMidCallEvent success,"
                    " event detected\n");
                RETVALUE(ROK);
            }
            else if (ret == RFAILED)
            {
                CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC"
                     " failed\n");
            }
            CCDP(AIN_DBG_LEVEL_0, "Hook Flash event is not armed\n");
            /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
            con->icEvnt = (CcAllSdus *)event;
            con->ogEvnt = (CcAllSdus *)&ogEvnt;

            ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
            if (ret == CCIGNOREMAPPING)
            {
                ccDropUBuf(&con->uBuf);
                CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
                RETVALUE(ROK);
            }
            if (ret != ROK)
            {
                ccDropUBuf(&con->uBuf);
                CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:"
                         " %d, icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                         con->ogProtType, con->icSuConnId, con->ogSuConnId);
                RETVALUE(ROK);
            }
            else
            {
                uBuf = con->uBuf;
                con->uBuf = NULLP;
                if (con->direction == INCTOOUT)
                {
                    ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                                  con->ogSapCb->spId, con->ogSpConnId,
                                  con->ogSuConnId, con->ogProtType,
                                  con->ogEvntType, &ogEvnt, uBuf);
                }
                else
                {
                    ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                                  con->icSapCb->spId, con->icSpConnId,
                                  con->icSuConnId, con->icProtType,
                                  con->ogEvntType, &ogEvnt, uBuf);
                }
                CCDP(AIN_DBG_LEVEL_0, "Mapped Hook Flash icSu :0x%lx\n",
                     con->icSuConnId);
                RETVALUE(ROK);
          }
       }

       /* euysal - 05/25/2005 - ACC Support */
       if (((ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType, con->direction)) && 
            (con->direction == OUTTOINC)) || 
           ((con->icEvntType == CC_ET_SUSP) && (con->direction == OUTTOINC)
#if 1
            /* Bug:57596 The test for the SUS type is needed */
            && (ccFindIsupSuspendType(con) == SR_NETINIT)
#endif
            ))
           /* euysal - 02/09/2006 - Bug:44492 We do not need to check for SUS type anymore. 
              Treating SUS(user) different during ACC was causing problems */
#if 0           
           ((con->icEvntType == CC_ET_SUSP) && (con->direction == OUTTOINC) &&
            (ccFindIsupSuspendType(con) == SR_NETINIT))) /* 41124 */
#endif /*Bug:44492 */            
       {
          CC_UPDATE_PIC(&con->ogBcm, PicTSuspended);
          CC_UPDATE_PIC(&con->icBcm, PicOSuspended);
          /* we will interwork the event after MGI's response */
          ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
              sizeof(CcCnStEvnt));
          ret = ccProcessOSuspended (&(con->icBcm));
          if (ret == ROK)
          {
             /* Bug 89560 */
             CC_INIT_CON_ICEVNT_PTR(con);
             CCDP(AIN_DBG_LEVEL_3, "OSuspended requested event sent to FIC\n");
             RETVALUE(ROK);
          }   
          else if ( ret == RFAILED)
          {
             /* Bug 89560 */
             CC_INIT_CON_ICEVNT_PTR(con);
             CCDP(AIN_DBG_LEVEL_3, "ccProcessOSuspended failed\n");
             RETVALUE(RFAILED);
          } 
          else
             CCDP(AIN_DBG_LEVEL_3, "OSuspended not armed as a requested event\n");
             
       }   

        if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                           con->direction))
        {
           ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
            ccProcessSuspendForMPartyCall(con, event);
            RETVALUE(ROK);
        }

        /* Look for SS7 suspend */
        /* Bug: 32512, RV Suresh 5.0, International  
         *
         * SUSPEND and RESUME can be initiated by the calling party also in ISUP for USER initiated SUSPEND
         */
        if ((((con->direction == OUTTOINC) && (ogProtType == CC_SI)) ||
            ((con->direction == INCTOOUT) && (icProtType == CC_SI)) ||
            ((CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb)) &&
             (con->icIntfcCb) && (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_IN) &&
             (con->direction == OUTTOINC))) && /* FID16747.0 */
            (con->icEvntType == CC_ET_SUSP))
        {
           /* Bug# 19408 */
           ccProcessSuspendForMPartyCall(con, event);
           RETVALUE(ROK);
        }
    }
    /* This is 911 */
    /* bug#26611, rkhan added cas TG also, ONHOOK and then OFHOOK of the caller send out 
     * to 911 trunk releases the call */
    else if ((con->direction == INCTOOUT) && ( (ogProtType == CC_SI) || (ogProtType == CC_CS_TG) ))
    {
      /* IC releases the Call when connection the Emergency call
       * category type, DO NOT PASS THE RELEASE TO OG */

      CCDP(AIN_DBG_LEVEL_0, "No need to Map: %ld\n", con->icSuConnId);
/***********PROCESS On-Hook and Flash*******************************/
      if(ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
      {
        con->lastState = con->state;
        ret = ccProcessMidCallEvent(con);
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent event detected:%ld\n",
                                con->icSuConnId);
          RETVALUE(ROK);
        }
        /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
        con->icEvnt = (CcAllSdus *)event;
        con->ogEvnt = (CcAllSdus *)&ogEvnt;

        ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
        if (ret == CCIGNOREMAPPING)
        {
            ccDropUBuf(&con->uBuf);
            CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
            RETVALUE(ROK);
        }
        if (ret != ROK)
        {
            ccDropUBuf(&con->uBuf);
            CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:"
                     " %d, icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                     con->ogProtType, con->icSuConnId, con->ogSuConnId);
            RETVALUE(ROK);
        }
        else
        {
            uBuf = con->uBuf;
            con->uBuf = NULLP;
            if (con->direction == INCTOOUT)
            {
                ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                              con->ogSapCb->spId, con->ogSpConnId,
                              con->ogSuConnId, con->ogProtType, 
                              con->ogEvntType, &ogEvnt, uBuf);
            }
            else
            {
                ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                              con->icSapCb->spId, con->icSpConnId,
                              con->icSuConnId, con->icProtType,
                              con->ogEvntType, &ogEvnt, uBuf);
            }
            CCDP(AIN_DBG_LEVEL_0, "Mapped Hook Flash icSu :0x%lx\n",
                 con->icSuConnId);
            RETVALUE(ROK);
          }

      }
      else if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                           con->direction))
      {
        ret = ccProcessDisconnectEvent(con, event);
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0,"Disconnect , event detected:%ld\n",
                                con->icSuConnId);
          RETVALUE(ROK);
        }
      }
      RETVALUE(ROK);
    }
    /* For All Other Cases */
/***********PROCESS On-Hook and Flash*******************************/
    if(ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
    {
      con->lastState = con->state;
      ret = ccProcessMidCallEvent(con);
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent event detected:%ld\n",
                              con->icSuConnId);
        RETVALUE(ROK);
      }
      /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
      con->icEvnt = (CcAllSdus *)event;
      con->ogEvnt = (CcAllSdus *)&ogEvnt;

      ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
      if (ret == CCIGNOREMAPPING)
      {
          ccDropUBuf(&con->uBuf);
          CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping\n");
          RETVALUE(ROK);
      }
      if (ret != ROK)
      {
          ccDropUBuf(&con->uBuf);
          CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:"
                   " %d, icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,
                   con->ogProtType, con->icSuConnId, con->ogSuConnId);
          RETVALUE(ROK);
      }
      else
      {
          uBuf = con->uBuf;
          con->uBuf = NULLP;
          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                            con->ogSapCb->spId, con->ogSpConnId,
                            con->ogSuConnId, con->ogProtType, 
                            con->ogEvntType, &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                            con->icSapCb->spId, con->icSpConnId,
                            con->icSuConnId, con->icProtType,
                            con->ogEvntType, &ogEvnt, uBuf);
          }
          CCDP(AIN_DBG_LEVEL_0, "Mapped Hook Flash icSu :0x%lx\n",
               con->icSuConnId);
          RETVALUE(ROK);
      }
    }
    else if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                           con->direction))
    {
      ret = ccProcessDisconnectEvent(con, event);
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0,"Disconnect , event detected:%ld\n",
                              con->icSuConnId);
        RETVALUE(ROK);
      }
    }

    ccGeoExtractProtCri(con, (CcAllSdus *)event, CCE_CNSTIND);

    /* FID 14732 */
    ccExtractSipwMBufFromCnStInd(con, event);
    /* FID 14732 */

  /* FID 14525.0 Req 1090++*/
  if(((con->direction ==INCTOOUT)&&(icProtType == CC_SIPT)&&CC_IS_IC_SFRCPGIW(con))||
     ((con->direction ==OUTTOINC)&&(ogProtType == CC_SIPT)&&CC_IS_OG_SFRCPGIW(con))
    )
  {
   SiCnStEvnt* siptCnst = NULLP;
   siptCnst = &((CcCnStEvnt *)event)->m.siCnStEvnt;
   if((siptCnst->optElmnt.sipt.icEvntType==CCSIP_ET_UPDATE)||(siptCnst->optElmnt.sipt.icEvntType==CCSIP_ET_XFER))
   {
    if(siptCnst->evntInfo.eh.pres && siptCnst->evntInfo.evntInd.pres &&(siptCnst->evntInfo.evntInd.val == EV_PROGRESS))
     {
         CCDP(AIN_DBG_LEVEL_0, "notfiInd %d %d, %d\n",siptCnst->notifInd1.eh.pres, siptCnst->notifInd1.notifInd.pres, siptCnst->notifInd1.notifInd.val);
         if(siptCnst->notifInd1.eh.pres && siptCnst->notifInd1.notifInd.pres)
         {
            if(siptCnst->notifInd1.notifInd.val == CC_RMTEHOLD)
            {
             if(siptCnst->optElmnt.sipt.sdp.pres)
	     {
              ccModSdpModeWithSetVal(&siptCnst->optElmnt.sipt.sdp, con, SDP_SENDONLY,SDP_MTYPE_AUDIO);
	     }
	     else
	     {
               CCDP(AIN_DBG_LEVEL_0, "no Sdp appear in SFR SIPT UPDATE/REINVITE\n");
	     }
            }
            else if(siptCnst->notifInd1.notifInd.val == CC_RMTERETR)
            {
	      if(siptCnst->optElmnt.sipt.sdp.pres)
	      {
               ccModSdpModeWithSetVal(&siptCnst->optElmnt.sipt.sdp, con, SDP_SENDRECV,SDP_MTYPE_AUDIO);
              }
              else
	      {
                 CCDP(AIN_DBG_LEVEL_0, "no Sdp appear in SFR SIPT UPDATE/REINVITE\n");
              }
            }
            else
            {	
              CCDP(AIN_DBG_LEVEL_0, "GNI not support, ingore\n");
            }
         }
	 else 
	 {
           CCDP(AIN_DBG_LEVEL_0, "GNI not prnst, ingore\n");
	 }
      }
      else 
      {
        CCDP(AIN_DBG_LEVEL_0, "EvntId not supported, ingore\n");
      }
    }
  }
  /* FID 14525.0 --*/
    /* Extract the SDP if rcvd from layer-3 */
    
    sdpRet = ccExtractSdpFromCnStInd(con, event);
    /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
    if (sdpRet != ROK)
    {
       CCLOGERR("Error: SDP parsing failed - %d\n", sdpRet);
       con->failCndVal = FC_PROTERR;

       if (CC_IS_CONTEXT_PRESENT(con))
       {
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */

          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret != ROK)
          {
             CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
             cleanUpMgQ(con);
             ccCleanUpMGCtx(con);
          }
          else
          {
             CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
             con->mgBlock->con = con;
             con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
             RETVALUE(ROK);
          }
       } 
       ccFreeTheRscFromCon(con, OUTTOINC);
       ccProcessFailCnd(con, con->failCndVal, TRUE);
       RETVALUE(ROK);
    }

    /* FID17160.0 Need to seperate the received SDP */
    if (CC_IS_STEROMONO_CALL(con))
    {
       if ( ccIsUpdateRcvd(icProtType, ogProtType, con->icEvntType, con->direction) || 
            ccIsXferRcvd(icProtType,con->ogProtType, con->icEvntType, con->direction))
       {
          DP("For now we only process Re-Invite and Update\n");
          U8 tmpret = ROK;
          tmpret = ccCheckStereoMonoCall(con) ;

          if (tmpret == ROKDNA)
          {
            CCDP(AIN_DBG_LEVEL_0, "Xfer/Update contain no SDP\n");
          }
          if (tmpret == ROKIGNORE)
          {
            CCDP(AIN_DBG_LEVEL_0, "Xfer/Update contain invalid info!\n");
            
            if (ccIsXferRcvd(con->icProtType,con->ogProtType, con->icEvntType, con->direction))
              ccSendXferRsp((con->direction == INCTOOUT) ? &con->icBcm: &con->ogBcm,
                  PRSNT_NODEF, SIPCAUSE_488_NOTACCH);
            
            if (ccIsUpdateRcvd(con->icProtType, con->ogProtType, con->icEvntType, con->direction))
              ccSendUpdateRsp((con->direction == INCTOOUT) ? &con->icBcm: &con->ogBcm,
                  PRSNT_NODEF, SIPCAUSE_488_NOTACCH);
            
            RETVALUE(ROK);
          }
          if (tmpret == RFAILED)
          {
             con->failCndVal = FC_PROTERR;
             if (CC_IS_CONTEXT_PRESENT(con))
             {
                ccQSubBasedOnCcn(con);  /* FID 15261.0 */
                ret = ccSendMgiQueue(0, con->mgBlock);
                if (ret != ROK)
                {
                   CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
                   cleanUpMgQ(con);
                   ccCleanUpMGCtx(con);
                }
                else
                {
                   CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
                   con->mgBlock->con = con;
                   con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
                   RETVALUE(ROK);
                }
             }
             ccFreeTheRscFromCon(con, OUTTOINC);
             ccProcessFailCnd(con, con->failCndVal, TRUE);
             RETVALUE(ROK);
          }

       }
       else
       {
	    /* Will just to ignore!\n*/
       }
    }

    if(((con->direction == INCTOOUT) && 
        ((icProtType == CC_SIP) || (icProtType == CC_BICC) || (icProtType == CC_SIPT))) ||
       ((con->direction == OUTTOINC) &&
        ((ogProtType == CC_SIP) || (ogProtType == CC_BICC) || (ogProtType == CC_SIPT))))
    {
      /* Handle  HOLD/QUERY/XFER and respective RSP for SIP/BICC calls */
      /* Note: MGCP will not send HOLD/QUERY/XFER to GCC */

      /* FID-2112: SIP UPDATE + */
      /* FID-2575: LMSD + */
      if (ccIsUpdateRcvd(icProtType, ogProtType, con->icEvntType,
                         con->direction))
      {
        ret = ccProcessUpdate(con, icProtType, ogProtType,
                              (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }

      if (ccIsUpdateRspRcvd(icProtType, ogProtType, con->icEvntType,
                            con->direction))
      {
        ret = ccProcessUpdateRsp(con, icProtType, ogProtType,
                                 (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }

      if (ccIsPrackRspRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
      {
        ret = ccProcessPrackRsp(con, icProtType, ogProtType, (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }
      /* FID-2575: LMSD - */

      if ((ccIsAckRcvd(icProtType, ogProtType, con->icEvntType,
                            con->direction)) ||
          (ccIsPrackRcvd(icProtType, ogProtType, con->icEvntType,
                        con->direction)))
      {
        ret = ccProcessPrackOrAck(con, icProtType, ogProtType,
                                  (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }
      /* FID-2112: SIP UPDATE - */

      /* FID-2593: Transcoding + */
      if (ccIsXferRspRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
      {
        ret = ccProcessXferRsp(con, icProtType, ogProtType, (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }

      if (ccIsQueryRspRcvd(icProtType, ogProtType, con->icEvntType,
                            con->direction))
      {
        ret = ccProcessQryRsp(con, icProtType, ogProtType, (CcAllSdus*)event);
        if (ret == ROKIGNORE)
        {
          RETVALUE (ROK);
        }
      }
      /* FID-2593: Transcoding - */

      /* FID16465.0 */
      if (ccIsDtmfInfoRcvd(icProtType, ogProtType, con->icEvntType,
                            con->direction))
      {
         bcm = con->direction == INCTOOUT? &con->icBcm : &con->ogBcm;
         ret = ccHandleDtmfInfo(con, bcm, (CcAllSdus*)event);
         RETVALUE(ROK);
      }

      if (ccIsDtmfInfoRspRcvd(icProtType, ogProtType, con->icEvntType,
                            con->direction))
      {
         /* DtmfInfoRsp will revert bcm for mapping checking */
         bcm = con->direction == INCTOOUT? &con->ogBcm : &con->icBcm;
         ret = ccHandleDtmfInfoRsp(con, bcm, (CcAllSdus*)event);
         RETVALUE(ROK);
      }

      /* Dual Call Hold -- XFER will be handling seperately */
      if (ccIsXferRcvd(CC_GET_PROTOCOL(con->icProtType),
            CC_GET_PROTOCOL(con->ogProtType), con->icEvntType, con->direction))
      {
        /* SIP can send XFER incase of INVITE(newDialogue replacing oldDialogue
         * + SDP). In this case SIPA is going to generate new SpConnId.*/
        ccUpdateConWithNewInfoInXfer(con, event);

         CC_GET_EGRESS_CCS_GENERIC_OGPROTTYPE(con, egressCCS_OgProtType);
         if( CC_EGRESS_INTER_CCS_CALL(con) &&
             (con->direction == OUTTOINC) && 
             (icProtType == CC_SIP) &&
             (egressCCS_OgProtType == CC_SI || egressCCS_OgProtType == CC_SIPT) &&        
             (con->sipSiptTunnelInfo != NULL) && 
             (con->sipSiptTunnelInfo->susResInd.susResInd.val == SR_NETINIT))
         {
           U8 oPic = con->icBcm.pic;
           U8 tPic = con->ogBcm.pic;

           CC_UPDATE_PIC(&con->ogBcm, PicTSuspended);
           CC_UPDATE_PIC(&con->icBcm, PicOSuspended);
           
           ret = ccProcessOSuspended (&(con->icBcm));
           if (ret == ROK)  
           {       
              /* we will interwork the event after MGI's response */
              ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                          sizeof(CcCnStEvnt));
              /* Bug 89560 */
              CC_INIT_CON_ICEVNT_PTR(con);
              CCDP(AIN_DBG_LEVEL_3, "OSuspended requested event sent to FIC\n");
              RETVALUE(ROK); 
           }
           else if ( ret == RFAILED)
           {       
              CCDP(AIN_DBG_LEVEL_3, "ccProcessOSuspended failed\n");
              CC_UPDATE_PIC(&con->icBcm, oPic);
              CC_UPDATE_PIC(&con->ogBcm, tPic);
              RETVALUE(RFAILED);
           }    
           else 
           {
              CCDP(AIN_DBG_LEVEL_3, "OSuspended not armed as a requested event\n");
              CC_UPDATE_PIC(&con->icBcm, oPic);
              CC_UPDATE_PIC(&con->ogBcm, tPic);
           }
        } 

        ret = ccHandleXfer(con, icProtType, ogProtType, con->direction, event);
      }
      else
      {
          ret = ccHandleQryXferHold(con, icProtType, ogProtType,
                                    con->direction, event);
      }

      /* FID-2593: Transcoding + */
      if (ret == ROKIGNORE)
      {
        RETVALUE (ROK);
      }
      /* FID-2593: Transcoding - */

      if(ret == ROKPENDING) /* Save the event for later */
      {
        /* FID 15261.0 + */
        if ((!CC_IS_CALL_MULTI_MG(con)) ||
            (CC_IS_CALL_MULTI_MG(con) && CC_OPERATING_FIRST_MG(con)))
        {
          /* we will interwork the event after MGI's response */
          ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                      sizeof(CcCnStEvnt));
        }
        /* FID 15261.0 - */
        /* Bug 89560 */
        CC_INIT_CON_ICEVNT_PTR(con);
        RETVALUE(ROK);
      }
    }

    ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
    if (ret == CCIGNOREMAPPING)
    {
        ccDropUBuf(&con->uBuf);
        RETVALUE(ROK);
    }
    else if (ret != ROK)
    {
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

        /* Release all connections */
        ccDropUBuf(&con->uBuf);
        if (CC_IS_CONTEXT_PRESENT(con))
        {
          /* Blow off the switching and Release the Call */
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */

          ccStopConTmr(con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

          con->lastState = con->state;
          con->relPend = BOTHREL;

          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
#ifdef ZC      
          upd.icSuConnId = con->icSuConnId;
          zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
#endif  
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret != ROK)
          {
            CCLOGERR( "ccUpdateMgQForSubRsc() failed \n");
            cleanUpMgQ(con);
            ccCleanUpMGCtx(con);
          }
          else
            RETVALUE(ROK);
        }
        else
        {
            CCLOGERR( "ERROR: No Switching Context Found\n");
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            RETVALUE(ROK);
        }
    }

    if (CC_EGRESS_INTER_CCS_CALL(con) && (con->direction == INCTOOUT))
    {
      /* Send CRI information to Egress CCS */
       memFreeRequired = TRUE;
       ccGeoSendCriInfoToEgressCcs(con, (CcAllSdus*)&ogEvnt, CCE_CNSTREQ);
    }

    uBuf = con->uBuf;
    con->uBuf = NULLP;
    if (con->direction == INCTOOUT)
    {
        ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                      con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
    }
    else
    {
        ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                      con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                      con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
    }

    /* Free memory in Cri entries of ogEvnt */
    if (memFreeRequired)
      ccGeoFreeCriMemoryInCctEvnt(con, (CcAllSdus*)&ogEvnt, CCE_CNSTREQ);

    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S10
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16               ret          = RFAILED;
  CcRelEvnt         ogEvnt;
#ifdef CC_CALEA
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
#endif
  CcCause           cause;
  TknU16            sipCause;
  TknU16            sipStatus;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  TRC3(ccConE04S10)
  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  /* FID 15045.1 */
   if (CC_IS_MSG_RCV_FROM_SRP(con))
   {
       ccExtractUUdata(con,(CcAllSdus*)event,CCE_RELIND);
   }

  /* FID14734-0220, Upon reception of an on-hook in the backward direction at the
     ISDN leg, MGC-8 shall send a suspend (network) message to the preceding exchange.
   */
  if ((con->direction == OUTTOINC) && 
      (con->ogProtType == CC_INETSI) &&
      ((con->icProtType == CC_SIVN) ||
       (con->icProtType == CC_BICCVN)))
  {
      CCDP(AIN_DBG_LEVEL_0,"%s\n", __FUNCTION__);
      ccSendSuspendToPreceding(con, event);
      RETVALUE(ROK);
  }

      /* CPDI */
  ccStopConTmr(con, CC_TMR_TIMEOUT);
  /* euysal - 06/08/2005 - BUG:38645 We need to populate con->ainInfo.diconnectCause before 
   * we call ccProcessDiscWithTmdRel, so moving this up here */
#if 1   
   /* Get protocol release cause */
  ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType),
                 (CcRelEvnt *)event, &cause, &sipCause, &sipStatus);
  if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
  {
      con->tempHolderForReleaseCause = cause.causeVal.val;
      con->ainInfo.diconnectCause    = cause.causeVal.val;
  }
  /* BUG:52036 peg the protocol error */
  if (CC_CAUSE_IS_VAL(&cause, CCPROTERR, CSTD_CCITT))
  {
      U32 failCndVal = FC_PROTERR; 

      GCC_SET_RELCOND (con, failCndVal);
   }
   /* End 52036 */

#endif   

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* euysal - 07/13/2005 - BUG:39551 */
#if 1  
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
     CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
  }
#endif  
  if (con->direction == OUTTOINC)
    {
      ret = ccProcessDiscWithTmdRel(con, event);
      /* TEMP BLOCK MCAO_DOUBT */
      if (ret == ROK)
      {
  /* euysal - 07/13/2005 - BUG:39551 moving up */
#if 0  
         /* Bug 27447: copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/
         if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
         {
            CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
         }
#endif         
          RETVALUE(ROK);
      }
    }    
  
  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
     ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

  ccStopConTmr(con, CC_TMR_CALLDTL);

  /* Release all connections */
  /* Blow off the the switching fabric Connection */
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
  /* CALL release before the Tapped subject goes to ANSWERED state */
  if (icProtType != CC_LOCAL_SWT_PROT)
  {
     /* Make sure ur in Tapped Con */
     ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
     if (ret != ROK)
     {
        CCDP(AIN_DBG_LEVEL_4,
         "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
     }
  }
#endif
  con->icEvnt = (CcAllSdus *) event;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;

  /* euysal - 06/08/2005 - BUG:38645 */
#if 0  
  /* Get protocol release cause */
   ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:con->icProtType),
                  (CcRelEvnt *)event, &cause, &sipCause, &sipStatus);
   if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
   {
       con->tempHolderForReleaseCause = cause.causeVal.val;
       con->ainInfo.diconnectCause    = cause.causeVal.val;
   }
#endif   
  /* copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/

  /* euysal - 07/13/2005 - BUG:39551 moving up*/
#if 0  
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
  }
#endif  
#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    if (con->direction == INCTOOUT)
    {
      /* FID 16706 + */
      CCDP(AIN_DBG_LEVEL_2, "%s(): CC_BOTH_TG_SUPPORT_AOC_XML(con) %d, INGRESS %d, EGRESS %d!\n", __FUNCTION__, CC_BOTH_TG_SUPPORT_AOC_XML(con), CC_INGRESS_TG_SUPPORT_AOC_XML(con), CC_EGRESS_TG_SUPPORT_AOC_XML(con));
      if (!CC_BOTH_TG_SUPPORT_AOC_XML(con))  /* FID 16706 Delay response if AOC XML supported */
      {
        con->relPend = INRELRSPANDOUTREL;
      }
      else
      {
        con->relPend = INRELRSPDELAYANDOUTREL;
        CCDP(AIN_DBG_LEVEL_2, "%s(): set relPend=INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);
      }
      /* FID 16706 - */
    }
    else
      con->relPend = OUTRELRSPANDINREL;

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      CCLOGERR( "ERROR: No Switching Ctx found\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    if ((icProtType == CC_LOCAL_SWT_PROT) && (con->icBcm.cc != NULLP) &&
        (con->icBcm.cc->tappedLegId != NULLP))
    {
      CCDP(AIN_DBG_LEVEL_0,"Deswitching of CALEA  in Tapped con\n"); 
      ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                                    event, CCE_RELIND, sizeof(CcRelEvnt));
      RETVALUE(ROK); 
    }
    else
      CCDP(AIN_DBG_LEVEL_0, "No Switching Ctx found \n");
  }
    
  /* De-Switching failed, go ahead and clear the call anyway */
  /* Send Resource Dealocation for initiating side */
  /* Send Release response and map the release    */

  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  if (con->direction == INCTOOUT)
  {
    /* Deallocate the IC Resources */
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_INCOMING);
#else
    ccDeallocateResource(con, CC_INCOMING);
#endif
    con->icRscVal = FALSE;
  }
  else if (con->direction == OUTTOINC)
  {
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
    ccDeallocateResource(con, CC_OUTGOING);
#endif
    con->ogRscVal = FALSE;
  }

  ret = ccMapEvent(con, CCE_RELIND, 0);
  if (ret != ROK)
  { 
     if (con->direction == INCTOOUT)
     {
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, con->tempHolderForReleaseCause,NULL);
     }
     else if (con->direction == OUTTOINC)
     {
#ifdef CC_CALEA
        /* For CALEA when mapping fails just don't send Release to the other side */ 
        if (con->icProtType != CC_LOCAL_SWT_PROT)
        {
#endif
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, con->tempHolderForReleaseCause,NULL);
#ifdef CC_CALEA
        }
#endif
    }
    RETVALUE(ROK);
  }
 
  /* Delayed Release Process */
  ret = ccProcessDelayedRelease(con);
  
  switch (ret)
  {
    case ROK:
      /* ROK - proceed normally with the call */
      break;

    case ROKIGNORE:
      /* Delayed Release Process executed - The RelReq will not be sent*/
      ccStopConTmr(con, TMR_RELEASE);
      CCDP(AIN_DBG_LEVEL_0,"Delayed Release Process started\n");
      CC_STATE_CHANGE(con, CCS_AWTDELAYEDREL);
      RETVALUE(ROK);

    default:
      break;
  }

  ccSendReleaseReq(con);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S10
 *
 *      Desc:  Connection state function
 *             event - Release Confirmation
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  CcRelEvnt ogEvnt;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  TRC3(ccConE05S10)

  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELCFM, (PTR) event);
  /* FID 14732 */                 

  /* CPDI */
  ccStopConTmr(con, CC_TMR_TIMEOUT);
  if (con->direction == OUTTOINC)
    {
      ret = ccProcessDiscWithTmdRel(con, event);
	    if (ret == ROK)
               {
         /* Bug 27447: copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/
         if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
         {
            CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
         }       
                   RETVALUE(ROK);
               }
    }
  
  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
   if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CCLOGERR("ccConE05S10():ERROR: Rcvd RelCfm. dir==%d, ic/og==%d/%d\n",
       con->direction, con->icProtType, con->ogProtType);

  /* Initiate Deswitching */
  /* Stop the O_NO_ANSWER timer if it is started */
  ccStopConTmr(con, AIN_O_NO_ANS_TMR);

  /* Stop the T_NO_ANSWER timer if it is started */
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);


  /* copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/
  ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt)); 

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    if (con->direction == INCTOOUT)
      con->relPend = INRELRSPANDOUTREL;
    else
      con->relPend = OUTRELRSPANDINREL;

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other
         side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0, "ERROR: No Switching Ctx found \n");
  }

      /* Send Resource Dealocation for initiating side */
      /* Map the release    */

      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      if (con->direction == INCTOOUT)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccDeallocateResource(con, CC_INCOMING);
        }
      else if (con->direction == OUTTOINC)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccDeallocateResource(con, CC_OUTGOING);
        }
#ifdef ZC
      /* REL CON */
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif

      ret = ccMapEvent(con, CCE_RELCFM, 0);
      if (ret != ROK)
        {
          if (con->direction == INCTOOUT)
          {
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                          con->ogProtType, CCPROTERR,NULL);
          }
          else if (con->direction == OUTTOINC)
          {
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                          con->icProtType, CCPROTERR,NULL);
          }
          RETVALUE(ROK);
        }
      ccSendReleaseReq(con);

  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE60S44
*
*      Desc:  Connection state function
*             event - Ignore Event from FIC
*             state - AWTRSPFORDPE9 (O_DISCONNECT)
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE60S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam upd; 
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE60S44:%ld\n", con->icSuConnId);

  CCDP(AIN_DBG_LEVEL_0, "Ignored Disconnect, back to state:%d\n",
                        con->lastState);

  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccStopConTmr(con, TMR_SETUP);
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);


  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
#ifdef ZC
    cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.ccAinUpdType = CC_UPDATE_BCM;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
  }

  CC_STATE_CHANGE(con, con->lastState);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE09S44
 *
 *      Desc:  Connection state function
 *             event - Route Confirmation
 *             state - AWTRSPFORDPE9 (O_DISCONNECT)
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt;
  CCDP(AIN_DBG_LEVEL_2,"Entering ccConE09S44\n");
  rscEvnt = (RmAlocCfmEvnt *) event;
  /* Check the status of allocated resource */

  rscEvnt = (RmAlocCfmEvnt *) event;
  /* The following code of saving RM response is taken from ccConE09S12() */  
  if (rscEvnt->rscSta2 == RMT_RES_ALOC_SUCC)
  {
     con->ogRscVal = TRUE;
     cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc2, sizeof(RmRsc));
  }

  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
     if (!con->icRscVal)
     {
        if (con->icRsc.rscPres == NOTPRSNT)
        {
           cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
        }
        else if (ccIsDifferentRscAllocated(con->icProtType, &con->icRsc,
                                            rscEvnt->rsc1))
        {
            cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
        }
        con->icRscVal = TRUE;
     }
     else if (!con->ogRscVal)
     {
        con->ogRscVal = TRUE;
        cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
     }
  }
  /* Remain in the same state CCS_AWTRSPFORDPE9 */ 

  RETVALUE(ROK);
} /* End of ccConE09S44() - 03/13/2002 */

/*
 *      Fun:   ccConE09S60
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirmation.
 *             state - CCS_AWTRSCCFMNOTIFY
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S60
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                      ret         = RFAILED;
  RmAlocCfmEvnt           *rscEvnt     = NULLP;
  CcConEvnt                ogEvnt;

  rscEvnt = (RmAlocCfmEvnt *) event;
  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
    if ((ret = ccGetPsSap(&con->icSapCb, &(rscEvnt->rsc1->intfc)))!= ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC335, (ErrVal) ret,
                 "ccConE09S60() Failed, ccGetPsSap failed");
#endif
      CCLOGERR("Error: Failed in ccGetPsSap: %ld\n", con->icSuConnId);
      ccSendFailureReport(&(con->icBcm), FlcApplicationError);
      cmHashListDelete(&ccicBCMInsTbl, (PTR)&(con->icBcm));
      ccDropIcBcmMember(con);
      con->icBcm.svcHeader.transId = 0;
      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ccDeallocateResource(con, CC_INCOMING);
      RETVALUE(ROK);
    }
    con->icSapCb->nmbActvConn++;

    if ((ret = ccGetIntfcSap (&con->icIntfcCb, &(rscEvnt->rsc1->intfc))) != ROK)
    {
      CCLOGERR("Error: Failed in ccConE09S60: %ld\n", con->icSuConnId);
      ccSendFailureReport(&(con->icBcm), FlcApplicationError);
      cmHashListDelete(&ccicBCMInsTbl, (PTR)&(con->icBcm));
      ccDropIcBcmMember(con);
      con->icBcm.svcHeader.transId = 0;
      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ccDeallocateResource(con, CC_INCOMING);
      RETVALUE(RFAILED);
    }
    if (con->icIntfcCb)
       con->icIntfcCb->sts.numIcCallAttempt++;

    con->icRscVal = TRUE;

    if (con->icRsc.rscPres == NOTPRSNT)
    {
      cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
    }

    if (rscEvnt->tfcDesc != NULLP)
    {
      if (rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.pres == PRSNT_NODEF)
      {
        con->echoCntrl.icResEchoCntrlDevInd =
                              rscEvnt->tfcDesc->nbTfcDesc.echoCntrlDevInd.val;
      }
    }

    /* Copy Additional Resource Information */
    if (rscEvnt->addnlRscInfo != NULLP)
    {
      cmMemcpy((U8 *) &con->icAddnlRscInfo, (U8 *)rscEvnt->addnlRscInfo,
               sizeof(RmAddnlRscInfo));
    }
    else
      con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

    /* This is For CAS Line Specific */
    if (con->icProtType == CC_CS_LN)
       con->icSpConnId = 0 /*con->icRsc.t.ds0Rsc*/;
    else if (con->icProtType == CC_GR303)
       CC_SET_G3CONNID(con->icSpConnId, con->icRsc.intfc.t.intfcId, con->icRsc.t.gr3Rsc.crv)
    else
       con->icSpConnId = 0;

    /* Copy the mBuf received from RM */
    if (con->icRscMBuf)
      SPutMsg(con->icRscMBuf);
    con->icRscMBuf = rscEvnt->mBuf;
    rscEvnt->mBuf = NULLP;
    /* Copy the modified traffic descriptor */
    if(rscEvnt->tfcDesc)
      cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc,
                sizeof(RmTfcDesc));

    /* Send Connection Requestion to CAS */
    ccCp.genCfg.tmr.tNotify.val    = con->ainInfo.NotDur.val;

    ccStartConTmr(TMR_NOTIFYCC, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_NOTIFYRSPFORMSUB);
    cmMemset((U8 *)&ogEvnt, 0, sizeof(CcConEvnt));

    ccBuildReminderIndicationForACB(con, &ogEvnt, BtOBcm);
#ifdef SAVE_PRFLID
    ccSaveProfileId(con); 
#endif
    /* 57460 */
    ccUpdInterCcsTermPbxSubId(con);

    ccProcessOCallSent(&con->icBcm);
    CcLiCctConReq (&con->icSapCb->pst, con->icSapCb->spId, con->icSuConnId,
                   &con->icRsc, con->icProtType, &ogEvnt, NULLP, con);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("ERROR: Resource Allocation Result: %d\n", rscEvnt->rscSta1);
    ccSendFailureReport(&(con->icBcm), FlcChannelsBusy);
    cmHashListDelete(&ccicBCMInsTbl, (PTR)&(con->icBcm));
    ccDropIcBcmMember(con);
    con->icBcm.svcHeader.transId = 0;
    ccRelCon(con);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE09S84
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirmation.
 *             state - CCS_AWTRSCALLOCCFM_MWI
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S84
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt         *rscEvnt = NULLP;
  CcConEvnt             ogEvnt;
  VmsMwiCfm_t           vmsMwiCfm;
  SvcHeader_t           header;

  cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));      

  rscEvnt = (RmAlocCfmEvnt *) event;
  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
 
      CCDP(AIN_DBG_LEVEL_0,
       " resource alloc successful.\n");

      con->icRscVal = TRUE;

      /* if there's not already a RmRsc present in our con block, 
     then copy in the one we just got */
      if (con->icRsc.rscPres == NOTPRSNT)
      {
      cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }
 
      cmMemset((U8 *)&ogEvnt, 0, sizeof(CcConEvnt));

         /* 
      * the particulars of what to do with lamp and ring    
      * are stored in ogEvnt, a ccConEvnt type
      */

      if ( (con->icProtType == CC_CS_LN) ||
       (con->icProtType == CC_GR303) )
      {
      ogEvnt.m.casCctEvnt.conType.pres = PRSNT_NODEF;
      ogEvnt.m.casCctEvnt.conType.val = CS_CON_EVNT_LINE_MWI;
      }
      else if (con->icProtType == CC_MGCP_LN)
      {
      ogEvnt.m.mgcpCctEvnt.evntType = CC_CCT_EVNT_TYPE_CONREQ;
      ogEvnt.m.mgcpCctEvnt.conReqType = MGCP_CONREQ_TYPE_VMWI;
      ogEvnt.m.mgcpCctEvnt.signalDesc.ValidFields = SIG_DESC_V2_NUM_SIG_FIELD;
      }

      switch(con->mwiType) 
      {
/*****************/
/* Turn the Lamp On */

      case CC_MWI_OP:
      {
      if (con->icProtType == CC_MGCP_LN)
      {
          ogEvnt.m.mgcpCctEvnt.signalDesc.NumSigs = 1;
          ogEvnt.m.mgcpCctEvnt.signalDesc.Sig[0].SigId = MGCP_LINE_VMWI;
      }
      else
      {
         ogEvnt.m.casCctEvnt.lampToggle.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.lampToggle.val = CS_LAMP_ON;
      }

      CCDP(AIN_DBG_LEVEL_0,
           " VMS request for lamp on.\n");

      break;
      } /* CC_MWI_OP */

/*****************/
/* Turn the lamp Off */
    case CC_MWI_RMV:
    {
      if (con->icProtType == CC_MGCP_LN)
      {
          ogEvnt.m.mgcpCctEvnt.signalDesc.NumSigs = 0;
          /* there is no signal to turn off light... its assumed if
           * there is no request to turn the light ON */
      }
      else
      {
         ogEvnt.m.casCctEvnt.lampToggle.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.lampToggle.val = CS_LAMP_OFF;
      }

    CCDP(AIN_DBG_LEVEL_0,
           " VMS request for lamp off.\n");
    break;
    } /* CC_MWI_RMV */

/*****************/
/* Play abbreviated Ring */

    case CC_MWI_ABR:
    {
    if (con->icProtType == CC_MGCP_LN)
    {
        ogEvnt.m.mgcpCctEvnt.signalDesc.NumSigs = 1;
        ogEvnt.m.mgcpCctEvnt.signalDesc.Sig[0].SigId = MGCP_LINE_DIST_RING5_ABBREV;
    }
    else
    {
         ogEvnt.m.casCctEvnt.ringType.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.ringType.val = PATTERN_5;
    }

    CCDP(AIN_DBG_LEVEL_0,
           " VMS request for abbreviated ring.\n");
    break;

    } /* CC_MWI_ABR */

/*****************/
/* Lamp on and play abbrev ring */

    case CC_MWI_OP_ABR:
    {
    if (con->icProtType == CC_MGCP_LN)
    {
        ogEvnt.m.mgcpCctEvnt.signalDesc.NumSigs = 2;
        ogEvnt.m.mgcpCctEvnt.signalDesc.Sig[0].SigId = MGCP_LINE_VMWI;
        ogEvnt.m.mgcpCctEvnt.signalDesc.Sig[1].SigId = MGCP_LINE_DIST_RING5_ABBREV;
    }
    else
    {
         ogEvnt.m.casCctEvnt.ringType.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.ringType.val = PATTERN_5;

         ogEvnt.m.casCctEvnt.lampToggle.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.lampToggle.val = CS_LAMP_ON;
    }

    CCDP(AIN_DBG_LEVEL_0,
           " VMS request for lamp on AND abbreviated ring.\n");
    break;
    } /* CC_MWI_OP_ABR */

/*****************/
/* Lamp OFF and play abbrev ring */

    case CC_MWI_RMV_ABR:
    {
    if (con->icProtType == CC_MGCP_LN)
    {
        ogEvnt.m.mgcpCctEvnt.signalDesc.NumSigs = 1;
        ogEvnt.m.mgcpCctEvnt.signalDesc.Sig[0].SigId = MGCP_LINE_DIST_RING5_ABBREV;
    }
    else
    {
         ogEvnt.m.casCctEvnt.ringType.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.ringType.val = PATTERN_5;

         ogEvnt.m.casCctEvnt.lampToggle.pres = PRSNT_NODEF;
         ogEvnt.m.casCctEvnt.lampToggle.val = CS_LAMP_OFF;
    }

    CCDP(AIN_DBG_LEVEL_0,
           " VMS request for lamp off AND abbreviated ring.\n");

    break;
    } /* CC_MWI_RMV_ABR */

/*****************/
/* mwiType is checked prior to here, so this is unlikely. */
    default:
    {
        CCLOGERR("ERROR: Invalid MWIType: %d\n", con->mwiType);
    
    break;
    } /* default */
    } /* switch */

        /* Send Connection Requestion to CAS */
    /* #20323 */
    if(con->icProtType == CC_CS_LN)
       con->icSpConnId = 0 /*con->icRsc.t.ds0Rsc*/;

    if(con->icProtType == CC_GR303)
       CC_SET_G3CONNID(con->icSpConnId, con->icRsc.intfc.t.intfcId,
           con->icRsc.t.gr3Rsc.crv);

    ccStartConTmr(TMR_NOTIFYCC, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTMWIUPDCFM);
#ifdef SAVE_PRFLID
    ccSaveProfileId(con); 
#endif
    /* 57460 */
    ccUpdInterCcsTermPbxSubId(con);

    ccProcessOCallSent(&con->icBcm);
    CcLiCctConReq (&con->icSapCb->pst, con->icSapCb->spId, con->icSuConnId,
                   &con->icRsc, con->icProtType, &ogEvnt, NULLP, con);
    RETVALUE(ROK);
  }
  else /* We didn't get the resource, so we need to fail and back out */
  {
        
    ccStopConTmr(con, TMR_SETUP);
    
        CCLOGERR("ERROR: Resource Allocation Result: %d\n", rscEvnt->rscSta1);
  
    /* send failure report message to FCT */

    if ( (rscEvnt->rscSta1 == RMT_RES_ALOC_BUSY) ||
         (rscEvnt->rscSta1  == RMT_RES_ALOC_BY_PEER) )
        vmsMwiCfm.mwiDlvrStatus = FC_MWI_DLVR_CP_BUSY;

    else if (rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE)
        vmsMwiCfm.mwiDlvrStatus = FC_MWI_DLVR_FAIL; 
    
    else if (rscEvnt->rscSta1 == RMT_RES_INTERNAL_BUSY)
        vmsMwiCfm.mwiDlvrStatus = FC_MWI_DLVR_MNT_BUSY;
    
    else vmsMwiCfm.mwiDlvrStatus = FC_MWI_DLVR_FAIL;

    ccFillSvcHeader(&header, &(con->icBcm), MSG_Close); 
    header.lastTransactionFlag = TRUE;

    vmsMwiCfm.srvcId        = con->icBcm.svcHeader.srvcId;
    CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);
    CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
        
        RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE09S84 */

/*
*
*      Fun:   ccConE58S61
*
*      Desc:  Connection state function
*             event - CCE_NOTIFYTIMEREXP.
*             state - CCS_AWTRSCCFMNOTIFY
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: This call path is used for features like ACB( when a create
*             Call is initiated).
*             This could also be used for a Generic call, which is told to be
*             initialted by SCP (FIC/TUFS).
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE58S61
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE58S61: %ld\n", con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

/********************************************************************
 *     NEED TO SEND A REPORT ERROR MESSAGE TO FIC with cause        *
 *     AS TIMER EXPIRY                                              *
 *******************************************************************/
  ccSendFailureReport (&(con->icBcm), FlcTimerExpired);
  cmHashListDelete(&ccicBCMInsTbl, (PTR)&(con->icBcm));
  ccDropIcBcmMember(con);
  con->icBcm.svcHeader.transId = 0;

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL, NULL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S12
 *
 *      Desc:  Connection state function
 *             event - Resource Aloc Confirmation
 *             state - AWTRSCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S12
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt      = NULLP;
  S16            ret          = RFAILED; /* Return value */

  TRC3(ccConE09S12)
  CCDP(AIN_DBG_LEVEL_0,"ccConE09S12\n");

  /* Check the status of allocated resource */
  rscEvnt = (RmAlocCfmEvnt *) event;
      
  if (rscEvnt->rscSta2 == RMT_RES_ALOC_SUCC)
    {
      con->ogRscVal = TRUE;
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc2, sizeof(RmRsc));
    }

  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
    if (!con->icRscVal)
    {
      if (con->icRsc.rscPres == NOTPRSNT)
      {
        cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }
      else if (ccIsDifferentRscAllocated(con->icProtType, &con->icRsc,
                                         rscEvnt->rsc1))
      {
        cmMemcpy((U8 *) &con->icRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }
      con->icRscVal = TRUE;
    }
    else if (!con->ogRscVal)
    {
      con->ogRscVal = TRUE;
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
    }
  }
  /* Send Release response */
  con->direction = INCTOOUT;
  con->icEvnt = (CcAllSdus *) con->ccEvntHold;
  if ((con->psSapDisabled & IC_PSSAP_DIS) == 0)
    ccSendReleaseRsp(con);

  if(con->ogRscVal)
    ccDeallocateResource(con, CC_OUTGOING);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
  ret = ccDeallocateResource(con, CC_INCOMING);
  if (ret == RFAILED)
  {
    /* error */
    CC_STATE_CHANGE(con, CCS_IDLE);
    ccRelCon(con);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S12
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTRSCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S12
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* Set ogRscVal and icRscVal to true to force a deallocation */
  /* request even though we have not received the allocation cfm */
  con->icRscVal = TRUE;
  con->ogRscVal = TRUE;

  /* pretty much INC to OUT */
  con->direction = INCTOOUT;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  /* 26928 */
  ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE06S13
 *
 *      Desc:  Connection state function
 *             event - Resource Confirmation
 *             state - AWTOGRSC_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE06S13
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  CcRelEvnt ogEvnt;

  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
        /* Send Resource Dealocation for incoming side */
        /* Send Release response and map the release    */

        con->direction = INCTOOUT;
        con->icEvnt = (CcAllSdus *) con->ccEvntHold;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;
#if 1 /* EARLY_ACM */
        if (CC_IS_CONTEXT_PRESENT(con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP,
                               con->mgBlock->mgCtx->suCtxId, con);

          con->relPend = INRELRSPANDOUTREL;

          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
          if (ret != ROK)
          {
            CCLOGERR( "Error: ccSendMgiQueue failed\n");
            cleanUpMgQ(con);
            ccCleanUpMGCtx(con);
          }
          else
            RETVALUE(ROK);
        }

#endif
        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccDeallocateResource(con, CC_INCOMING);
        ret = ccMapEvent(con, CCE_RELIND, 0);
        if (ret != ROK)
          {
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                          con->ogProtType, CCPROTERR,NULL);
            RETVALUE(ROK);
          }
        ccSendReleaseReq(con);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S13
 *
 *      Desc:  Connection state function
 *             event - Release Indicatio (from outgoing i/f)
 *             state - AWTOGRSC_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S13
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret;                /* Return value */

    /* Send Resource Dealocation for */
    /* if another release from incoming direction- dump it */
    if ( con->direction == INCTOOUT)
      RETVALUE(ROK);

  /* FID 14732 */
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* Send Release responses to both outgoing and incoming i/fs */
  con->direction = INCTOOUT;
  con->icEvnt = (CcAllSdus *) con->ccEvntHold;
  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  con->direction = OUTTOINC;
  con->icEvnt = (CcAllSdus *) event;
  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

   /* Not allowed to do CC_ALL anymore */
   if(con->icRscVal)
    ccDeallocateResource(con, CC_INCOMING);

   CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
   ret = ccDeallocateResource(con, CC_OUTGOING);
   if (ret == RFAILED)
   {
     /* error */
     CC_STATE_CHANGE(con, CCS_IDLE);
     ccRelCon(con);
   }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S13
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTOGRSC_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S13
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  
  /* the dir of release would pretty much be INC to OUT */
  con->direction = INCTOOUT;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Blow off the switching and Release the Call */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    con->relPend = INRELRSPANDOUTREL;

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other
         side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0, "ERROR: No Switching Ctx found \n");
  }

  /* Send Release response */
  con->icEvnt = (CcAllSdus *) con->ccEvntHold;
  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  if(con->ogRscVal)
  ccDeallocateResource(con, CC_OUTGOING);

  /* Send Resource Dealocation for incoming interface if allocated */
  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
  ccDeallocateResource(con, CC_INCOMING);
  if (ret == RFAILED)
  {
     /* error */
     CC_STATE_CHANGE(con, CCS_IDLE);
     ccRelCon(con);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S15
 *
 *      Desc:  Connection state function
 *             event - Connection Status Indication
 *             state - CCS_AWTRSCALLOCCFM_GLARE 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S15
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16  ret = RFAILED;

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    { 
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    } 
    else if (ret == RFAILED)
    { 
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    } 
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

#ifdef CC_CALEA
    /* CALL release before the Tapped subject goes to ANSWERED state */
    if (con->icProtType != CC_LOCAL_SWT_PROT)
    {
       /* Make sure ur in Tapped Con */
       ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
       if (ret != ROK)
       {
          CCDP(AIN_DBG_LEVEL_4,
            "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
       }
    }
#endif 
    /* Wait for  resource confirmation to clear the call */
    con->relPend = ICRELONLY;
    /* stay in the same state : Coz, Sate:AWT_RSCALLOCCFM_TOCLR may not send
     * release request to incoming CAS-line/trunk */
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR(
      "ccConE03S15(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE03S15 */


/*
 *
 *      Fun:   ccConE04S15
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - CCS_AWTRSCALLOCCFM_GLARE 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S15
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret    = RFAILED;

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  else if (ret == ROKDRSIG)
  {
    /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect 
             notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
  }
  else
    /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
    CCDP(AIN_DBG_LEVEL_0, "O_Disconnect event is not Armed\n");

  /* Store the release event */
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR("ERROR: ccStoreEvnt failed\n");
  }

  /* Wait for  resource confirmation to clear the call */
  CC_STATE_CHANGE(con, CCS_AWTRSCCFM_TOCLR);
  RETVALUE(ROK);
} /* ccConE04S15 */


/*
 *
 *      Fun:   ccConE09S15
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation cofirmation
 *             state - CCS_AWTRSCALLOCCFM_GLARE 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S15
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  RmAlocCfmEvnt *rscEvnt;

#if 1 /*FGD*/
  CcTgCb *tgCb = NULL;
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);
#endif /*FGD*/

   rscEvnt = (RmAlocCfmEvnt *) event;
   /* Check if RscCfmEvnt is from 2WayPriAlocReq or not */
   /* Check pointers in RscCfmEvnt */
   CCDP(AIN_DBG_LEVEL_2,"Entering ccConE09S15()\n");
   if(rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
      {
      CCDP(AIN_DBG_LEVEL_2,"Received RMT_RES_ALOC_SUCC from RM\n");

#if 1 /*FGD*/
         /* Store trunk group attributes in con */
         if((ogProtType == CC_SI) || (ogProtType == CC_EXT_BICC) || (ogProtType == CC_CS_TG))
         {
           tgCb = con->ogIntfcCb->ccTgCb;
           if(tgCb)
            {
               con->ogTgAtt = 0;
               CCDP(AIN_DBG_LEVEL_2, "ccConE09S15:OWN:%d,FEC:%d,COS:%d\n", 
                   tgCb->tgAtt.ownClass, tgCb->tgAtt.Class,
                   tgCb->tgAtt.ClassOfSvc);
               ccFillTgAttr(con, tgCb->tgAtt.ownClass, tgCb->tgAtt.Class,
                   tgCb->tgAtt.ClassOfSvc, tgCb->tgAtt.Direction, 1);
            }
            else
               CCDP(AIN_DBG_LEVEL_2, "ccConE09S15: ogIntfcCb->ccTgCb is NULL"
                   " ogProtType=%d\n", ogProtType);
         }
#endif /*FGD*/
      /* store outgoing sap */
      if ((ret = ccGetPsSap(&con->ogSapCb,
                            &rscEvnt->rsc1->intfc))!= ROK)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
        CCLOGERROR(ERRCLS_DEBUG, ECC335, (ErrVal) ret,
                   "ccConE09S15() Failed, ccGetPsSap failed");
#endif
        CCDP(AIN_DBG_LEVEL_2,"ccGetPsSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogSapCb)
        con->ogSapCb->nmbActvConn++;

      if ((ret = ccGetIntfcSap (&con->ogIntfcCb,
                                &(rscEvnt->rsc1->intfc))) != ROK)
      {
        CCDP(AIN_DBG_LEVEL_2,"ccGetIntfcSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogIntfcCb)
         con->ogIntfcCb->nmbActvConn++;
      con->ogRscSta = rscEvnt->rscSta1;
      con->ogRscVal = TRUE;

      if (rscEvnt->rsc1 != NULLP)
      { 
        CCDP(AIN_DBG_LEVEL_2,"Copying the rsc to con->ogRsc\n");
        cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }

      /* check if we have outStanding ON-HOOK from CAS protocol */
      if(con->relPend == ICRELONLY)
      {
        /* Don't do no more. Send disconnect to CAS */
        /* Release timer has already started  E03S15*/
        CCDP(AIN_DBG_LEVEL_2,"Sending Release as con->relPend == ICRELONLY\n");
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
        RETVALUE(ROK);
      }

/* Added to implement new SS7 cut thru' */
       /* Bug# 10273 */
       ccProcessFwdDirEcho(con); 

       /* CHECK FOR TNOANSWER EVENT */
       ccProcessTNoAnswer(&(con->ogBcm));

       /* + BUG:83045 */
       if ((con->ogProtType != CC_CS_TG_INTFC) &&/* for CAS trk we could come
                                                  this path, so excluding it */
           (CC_GET_PROTOCOL(con->ogProtType) != CC_EXT_BICC) &&
               (CC_IS_CONTEXT_PRESENT(con)))
       {
         ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_RECV_ONLY, MGCT_PACKAGE_ID_MAX,
                                      MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                      &con->ogBcm, NULLP, NULLP,
                                      NULLP, NULLP, NULLP,
                                      (CC_IS_CALL_MULTI_MG(con))?
                    ((con->ogAdjBcm->mgCtx)?con->ogAdjBcm->mgCtx->suCtxId:0):
                     ((con->icBcm.mgCtx)?con->icBcm.mgCtx->suCtxId:0) ,
                     MGCT_CONTEXT_CHOOSE, con);

         con->relPend = CONTINUEWITHREATTEMPT1;
         CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORDP);
         con->mgBlock->con = con;
         ret = ccSendMgiQueue((con->ogBcm.mgCtx)?con->ogBcm.mgCtx->suCtxId:0,
                               con->mgBlock);
      
         if (ret != ROK) 
         {
           CCLOGERR("Error: ccSendMgiQueue failed:suCtxId = %ld,"
                    " icSu:%ld\n", 
                    ((con->ogBcm.mgCtx)?con->ogBcm.mgCtx->suCtxId:0),
                     con->icSuConnId);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
         }
       }
       else
       {
         CC_STATE_CHANGE(con, CCS_AWTANS);
         ccSendConReqForOgIpCalls(con);
       }
       RETVALUE(ROK);
       /* - BUG:83045 */
   } /* RMT_RES_ALOC_SUCC */
   else
   {
     ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);
     RETVALUE(ROK);
   } /* Bad rsc allocation. Call released and/or tones are played */

  RETVALUE(ROK);
} /* ccConE09S15 */


/*
 *
 *      Fun:   ccConE09S28
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation cofirmation
 *             state - CCS_AWTOGSWTCFM 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S28
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
  RmAlocCfmEvnt *rscEvnt;

   TRC3(ccConE09S28)

   rscEvnt = (RmAlocCfmEvnt *) event;
   CCDP(AIN_DBG_LEVEL_2,"ccConE09S28: rscSta==%d\n", rscEvnt->rscSta1);
   if(rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
   {
      /* store outgoing sap */
      if ((ret = ccGetPsSap(&con->ogSapCb,
                            &rscEvnt->rsc1->intfc))!= ROK)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
        CCLOGERROR(ERRCLS_DEBUG, ECC335, (ErrVal) ret,
                   "ccConE09S28() Failed, ccGetPsSap failed");
#endif
        CCDP(AIN_DBG_LEVEL_2,"ccGetPsSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogSapCb)
        con->ogSapCb->nmbActvConn++;

      if ((ret = ccGetIntfcSap (&con->ogIntfcCb,
                                &(rscEvnt->rsc1->intfc))) != ROK)
      {
        CCDP(AIN_DBG_LEVEL_2,"ccGetIntfcSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogIntfcCb)
         con->ogIntfcCb->nmbActvConn++;
      con->ogRscSta = rscEvnt->rscSta1;
      con->ogRscVal = TRUE;

      if (rscEvnt->rsc1 != NULLP)
      { 
        CCDP(AIN_DBG_LEVEL_2,"Copying the rsc to con->ogRsc\n");
        cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }

   } /* RMT_RES_ALOC_SUCC */
   else
   {
     ccStopConTmr(con, TMR_SETUP);
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
     /* CALL release before the Tapped subject goes to ANSWERED state */
     if (con->icProtType != CC_LOCAL_SWT_PROT)
     {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
     }
#endif
     /* Wait for  SFT confirm to clear the call */
     con->relPend = ICRELONLY;
     CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
   }

   RETVALUE(ROK);
} /* ccConE09S28 */


/*
 *
 *      Fun:   ccConE09S39
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation cofirmation
 *             state - CCS_AWTRSPFORDPE20 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
#ifdef ANSI
PRIVATE S16 ccConE09S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
#else
PRIVATE S16 ccConE09S39(con, event, bcm, event2)
CcConCb *con;                    /* connection */
PTR     event;                   /* event */
AinBCM_t *bcm;                    /* bcm */
PTR     event2;                   /* event */
#endif
{
   S16            ret       = RFAILED;
   RmAlocCfmEvnt *rscEvnt   = NULLP;

   rscEvnt = (RmAlocCfmEvnt *) event;

   CCDP(AIN_DBG_LEVEL_0,"ccConE09S39: rscSta==%d\n", rscEvnt->rscSta1);
   if(rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
   {
      /* store outgoing sap */
      if ((ret = ccGetPsSap(&con->ogSapCb,
                            &rscEvnt->rsc1->intfc))!= ROK)
      {
#if (ERRCLASS & ERRCLS_DEBUG)
        CCLOGERROR(ERRCLS_DEBUG, ECC335, (ErrVal) ret,
                   "ccConE09S28() Failed, ccGetPsSap failed");
#endif
        CCDP(AIN_DBG_LEVEL_2,"ccGetPsSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogSapCb)
        con->ogSapCb->nmbActvConn++;

      if ((ret = ccGetIntfcSap (&con->ogIntfcCb,
                                &(rscEvnt->rsc1->intfc))) != ROK)
      {
        CCDP(AIN_DBG_LEVEL_2,"ccGetIntfcSap() failed\n");
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId,
                      con->icSuConnId, con->icProtType,
                      CCTMPFAIL,NULL);
        RETVALUE(RFAILED);
      }
      if (con->ogIntfcCb)
         con->ogIntfcCb->nmbActvConn++;
      con->ogRscSta = rscEvnt->rscSta1;
      con->ogRscVal = TRUE;

      if (rscEvnt->rsc1 != NULLP)
      {
        CCDP(AIN_DBG_LEVEL_2,"Copying the rsc to con->ogRsc\n");
        cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
      }

   } /* RMT_RES_ALOC_SUCC */
   else
   {
     ccStopConTmr(con, TMR_SETUP);
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

     /* CALL release before the Tapped subject goes to ANSWERED state */
     if (con->icProtType != CC_LOCAL_SWT_PROT)
     {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
     }
     /* Wait for  FIC confirm to clear the call */
     con->relPend = ICRELONLY;
     CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
   }

   RETVALUE(ROK);
} /*ccConE09S39 */
/*
 *
 *      Fun:   ccConE14S15
 *
 *      Desc:  Connection state function
 *             event - SETUP timer expiry
 *             state - CCS_AWTRSCALLOCCFM_GLARE 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S15
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL,NULL);
  RETVALUE(ROK);
} /* ccConE14S15 */


/*
 *
 *      Fun:   ccConE15S15
 *
 *      Desc:  Connection state function
 *             event - RELEASE timer expiry
 *             state - CCS_AWTRSCALLOCCFM_GLARE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S15
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  if(con->relPend != ICRELONLY)
  {
    /* This should never happen for Non-cas-as-incoming protocol type */
    CCLOGERR("ERROR: Unepected relPend %d\n", con->relPend);
  }

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL,NULL);
  RETVALUE(ROK);
} /* ccConE15S15 */


/*
 *
 *      Fun:   ccConE04S17
 *
 *      Desc:  Connection state function
 *             event - Connection Release Indication
 *             state - AWTRELCFM_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S17
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret;
  CcRelEvnt ogEvnt;

    /* For ISDN case multiple release Indication can arrive
       from the same direction(on getting REL COMPLETE from peer)
       , we have already processed one from the outgoing side so 
       dump this one */ 

  /* Bug# Bug# 19229 */
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  } 

    if (con->direction == OUTTOINC)
      RETVALUE(ROK);

  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

      /* FID 16706.0 + */
      if ((CC_IS_OGREL_IN_EVNT_HOLD(con)) &&
          (CC_INGRESS_TG_SUPPORT_AOC_XML(con)))
      {

        con->direction = OUTTOINC;
        con->icEvnt = (CcAllSdus *)con->ccEvntHold;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        ret = ccMapEvent(con, CCE_RELCFM, 0);
        if (ret != ROK)
        {
          con->direction = INCTOOUT;

          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
        }
        else
        {
          ccSendReleaseRspReq(con);
        }
      } /* FID 16706.0 - */
      else
      {
      /* Send Resource Dealocation for incoming interface */
      /* send release response back to the incoming side */

      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *)event;

        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      }

      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

      if(con->icRscVal == FALSE)
      {
        /* Can happen if Call fails during incoming RSC alloc failure */
        /* PSIF-XYZ should actually send RelCfm instead of RelInd.
         * but GCC is gracefull in clearing the call right here */

        /* This is the end (of Call !!!) */
        /* Connection shall be cleared by the state machine driver */
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
        RETVALUE(ROK);
      }

#ifdef GUARD_TIMER /* Guard Timer */
      ret = ccGuardOrDeallocResource(con, CC_INCOMING);
#else
      ret = ccDeallocateResource(con, CC_INCOMING);
#endif
      if (ret == RFAILED)
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S17
 *
 *      Desc:  Connection state function
 *             event - Connection Release confirmation
 *             state - AWTRELCFM_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S17
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    U8 CauseValue;

    CauseValue = con->callDtlInfo.cm.relCause.causeVal.val;

  /* check the direction before the relCfm is entertained! */
  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

#if 1 /* START - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */
   if ((con->direction == INCTOOUT) && 
       ( (con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303) )&& 
       (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
       (con->icRscVal) )
   {
       ccPermSignalHack(&con->icRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */ 
       ccSendNetworkSignalMsg(con, FC_SIG_TONE, SigToneReceiverOffHookTone, 
                              0, 0, CC_INCOMING);
#endif
   }
   else if ((con->direction == OUTTOINC) && 
            ( (con->ogProtType == CC_CS_LN) || (con->ogProtType == CC_GR303) )&&
            (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
            (con->ogRscVal))
   {
       ccPermSignalHack(&con->ogRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */
       ccSendNetworkSignalMsg(con, 0,0,FC_SIG_TONE, SigToneReceiverOffHookTone, 
                              CC_OUTGOING);
#endif
   }
#endif /* END - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */
   

      /* Send Resource Dealocation for incoming interface */

      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
#ifdef CC_CALEA
      if (con->icProtType != CC_LOCAL_SWT_PROT)
         ccReleaseCaleaLegs(con); 
#endif
      if(con->icRscVal == FALSE)
      {
        /* Can happen if Call fails during incoming RSC alloc failure */
        /* Even in this case, we happen to come here */

        /* this is the end (of Call !!!) */
        /* Connection shall be cleared by the state machine driver */
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
      else /* Some other case, resource is valid */
       ccDeallocateResource(con, CC_INCOMING);
     
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE10S17
 *
 *      Desc:  Connection state function
 *             event - Resource Deallocation Confirm
 *             state - AWTRELCFM_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE10S17
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->ogRscVal)
  {
    con->ogRscVal = FALSE;
  }
  else
  {
    /* Check - This is an error */
    RETVALUE(RFAILED);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S17
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTRELCFM_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S17
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
  /* Deallocate resources and clear */
  ret = ccDeallocateResource(con, CC_INCOMING);
  if (ret == RFAILED)
  {
      /* error */
      CC_STATE_CHANGE(con, CCS_IDLE);
      ccRelCon(con);
      RETVALUE(ROK);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S18
 *
 *      Desc:  Connection state function
 *             event - Connection Release Indication
 *             state - AWTRELCFM_OG
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S18
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret;
  CcConEvnt ogEvnt;


    cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

    /* For ISDN case multiple release Indication can arrive
       from the same direction(on getting REL COMPLETE from peer)
       , we have already processed one from the incoming side so 
       dump this one */ 

    if ((con->direction == INCTOOUT) && (con->lastState != CCS_AWTRSPFORDPE32))
    {
      CCDP(AIN_DBG_LEVEL_3,"Dropping the release\n");
      RETVALUE(ROK);
    }
    else if (con->lastState == CCS_AWTRSPFORDPE32)
    {
      /* GCC is in a process of Forwarding the call */
      DP("Buffered an Event :%ld, %d\n", con->icSuConnId, con->icEvntType);
      ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                           NULLP, 0);
      RETVALUE(ROK);
    }

  /* Bug# Bug# 19229 */ 
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }

      if (con->lastState == CCS_AWTRSPFORDPE32)
      {
        /* GCC is in a process of Forwarding the call */
        DP("Buffered an Event :%ld, %d\n", con->icSuConnId, con->icEvntType);
        ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                             NULLP, 0);
        RETVALUE(ROK);
      }

      /* FID 16706.0 + */
      if ((con->relPend == INRELRSPDELAYANDOUTREL) &&
          (CC_BOTH_TG_SUPPORT_AOC_XML(con)) &&
          (con->icRscVal == TRUE))
      {

        con->icEvnt = (CcAllSdus *) event;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        CCDP(AIN_DBG_LEVEL_2, "%s(): relPend==INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);
        con->direction = OUTTOINC;

        ret = ccMapEvent(con, CCE_RELCFM, 0);
        if (ret != ROK)
        {
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCPROTERR,NULL);
        }
        else
        {
          ccSendReleaseRspReq(con);
        }
      }
           
      /* FID 16706.0 - */

      /* FID 14732 */                      
      ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
      /* FID 14732 */

      /* Send Resource Dealocation for outgoing interface */
      /* send release response back to the outgoing side */

      con->direction = OUTTOINC;
#if 1 /* MCAO-05/29/03 Bug:21331 require its original RelInd event */
      con->icEvnt = (CcAllSdus *) con->ccEvntHold;
#else
      con->icEvnt = (CcAllSdus *) event;
#endif
      
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

      if(con->icRscVal == TRUE)
        ccDeallocateResource(con, CC_INCOMING);

      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER /* Guard Timer */
      ret = ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ret = ccDeallocateResource(con, CC_OUTGOING);
#endif
      if (ret == RFAILED)
      {
        /* error */
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S18
 *
 *      Desc:  Connection state function
 *             event - Connection Release confirmation
 *             state - AWTRELCFM_OG
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S18
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       ret;
  CcConEvnt ogEvnt;

  /* check the direction before the relCfm is entertained! */
  if(con->direction == INCTOOUT)
    RETVALUE(ROK);

  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

#if 1 /* START - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */
   if ((con->direction == INCTOOUT) && 
       ( (con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303) )&& 
       (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
       (con->icRscVal) )
   {
       ccPermSignalHack(&con->icRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */
       ccSendNetworkSignalMsg(con, FC_SIG_TONE, SigToneReceiverOffHookTone, 
                              0, 0, CC_INCOMING);
#endif
   }
   else if ((con->direction == OUTTOINC) && 
            ( (con->ogProtType == CC_CS_LN) || (con->ogProtType == CC_GR303) )&&
            (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
            (con->ogRscVal))
   {
       ccPermSignalHack(&con->ogRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */
       ccSendNetworkSignalMsg(con, 0, 0, FC_SIG_TONE, 
                              SigToneReceiverOffHookTone, CC_OUTGOING);
#endif
   }
#endif /* END - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */

      if (con->lastState == CCS_AWTRSPFORDPE32)
      {
        /* If we stay in CCS_AWTRELCFM_OG, we may loose out icRsc, as it returns to
           GCC FSM */
  
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE32);
        con->ogBcm.keepTransactionOpen = TRUE;
        ccDeallocateResource(con, CC_OUTGOING);
        con->ogRscVal = FALSE;

        /* At this point Call the ForwardCallAPI */
        ret = ccForwardCallAPI(con);
        if (ret == RFAILED)
        {
          ccStopConTmr(con, TMR_SETUP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCALLCLR, NULL);
        }
        RETVALUE(ROK);
      }
      else
      {
        /* FID 16706 + */
        /* Map release confirm event from SIP to release confirm event to ISDN */
        /* when release pending type indicates a delayed response.             */
        if(con->relPend == INRELRSPDELAYANDOUTREL)
        {
          CCDP(AIN_DBG_LEVEL_2, "%s(): relPend==INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);

          con->icEvnt = (CcAllSdus *) event;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;

          con->direction = OUTTOINC;
          ret = ccMapEvent(con, CCE_RELCFM, 0);
          if (ret != ROK)
          {
            con->direction = INCTOOUT;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con); 
          }
          else
          {
            ccSendReleaseRspReq(con);
          }

          if(con->icRscVal == TRUE) 
          {
#ifdef GUARD_TIMER
            ccGuardOrDeallocResource(con, CC_INCOMING);
#else
            ccDeallocateResource(con, CC_INCOMING);
#endif
          }
        }
       /* FID 16706 - */

        CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
#ifdef CC_CALEA 
        if (con->icProtType != CC_LOCAL_SWT_PROT)
           ccReleaseCaleaLegs(con);
#endif
        if(con->ogRscVal == TRUE)
        {
          ccDeallocateResource(con, CC_OUTGOING);
        }
        else
        {
          /* Can happen if Call fails during outgoing ISDN channel 
           * negotiation failure. Or any case where the ogRsc is not valid but
           * still are waiting for RelCfm from layer-3.*/
 
          /* this is the end (of Call !!!) */
          /* Connection shall be cleared by the state machine driver */
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
        RETVALUE(ROK);
      }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE10S18
 *
 *      Desc:  Connection state function
 *             event - Resource Deallocation Confirm
 *             state - AWTRELCFM_OG
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE10S18
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->icRscVal)
  {
    con->icRscVal = FALSE;
  }
  else
  {
    /* Check - This is an error */
    RETVALUE(RFAILED);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S18
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTRELCFM_OG
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S18
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;

        /* Send Resource Dealocation for outgoing interface */
        ret = ccDeallocateResource(con, CC_OUTGOING);
        if(ret == RFAILED)
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
          RETVALUE(ROK);
        }

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);
  if (con->dealocPend > 0)
    {
      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    }
  else
    {
      CC_STATE_CHANGE(con, CCS_IDLE);
      ccRelCon(con);
    }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S19
 *
 *      Desc:  Connection state function
 *             event - Connection Release Ind
 *             state - AWTRELCFM_BOTH
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S19
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->direction == INCTOOUT)
  {
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
  }
  else if (con->direction == OUTTOINC)
  {
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  }

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

      if (con->direction == INCTOOUT)
        {
          /* Send Release response to incoming i/f */
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_INCOMING);
#else
          ccDeallocateResource(con, CC_INCOMING);
#endif
          con->icRscVal = FALSE;
          con->icEvnt = (CcAllSdus *) event;
        }
  else if (con->direction == OUTTOINC)
  {
          /* Send Release response to outgoing i/f */
         if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
#ifdef GUARD_TIMER
         ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
         ccDeallocateResource(con, CC_OUTGOING);
#endif
          con->ogRscVal = FALSE;
          con->icEvnt = (CcAllSdus *) event;
        }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE05S19
 *
 *      Desc:  Connection state function
 *             event - Connection Release confirmation
 *             state - AWTRELCFM_BOTH
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S19
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 1 /* START - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */
   if ((con->direction == INCTOOUT) && 
       ((con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303))&& 
       (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
       (con->icRscVal) )
   {
       ccPermSignalHack(&con->icRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */
       ccSendNetworkSignalMsg(con, FC_SIG_TONE, SigToneReceiverOffHookTone,
                              0,0, CC_INCOMING);
#endif
   }
   else if ((con->direction == OUTTOINC) && 
            ((con->ogProtType == CC_CS_LN) || (con->ogProtType == CC_GR303))&&
            (((CcRelEvnt *)event)->m.casCctEvnt.relType.val == CS_RELCFM_EVENT_FAILURE) && 
            (con->ogRscVal))
   {
       ccPermSignalHack(&con->ogRsc);
#ifdef CC_CALEA
       /* Need to send NetworkSignal with FC_SIG_TONE, SigToneReceiverOffHookTone */
       ccSendNetworkSignalMsg(con, 0,0,FC_SIG_TONE, SigToneReceiverOffHookTone, 
                              CC_OUTGOING);
#endif
   }
#endif /* END - Temporary hack to enable permanent signal handling.  This code will be deleted for GA release. */

  if (con->direction == INCTOOUT)
    {
      /*Bug:29451 -- Billing indicator will be reset when SUSP is sent on in-coming leg*/
      if(con->callDtlInfo.cm.tckRelIndRcvd.pres == NOTPRSNT)
         con->callDtlInfo.cm.tckRelIndRcvd.pres = PRSNT_NODEF;

      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
    }
  else if (con->direction == OUTTOINC)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    }

      if (con->direction == INCTOOUT)
        {
          /* Send Resource Dealocation for incoming interface */
          ccDeallocateResource(con, CC_INCOMING);
          con->icRscVal = FALSE;
        }
      else if (con->direction == OUTTOINC)
        {
          if(con->ogRscVal == TRUE)
          {
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
          }
          else
          {
            /* Can happen if Call fails during outgoing ISDN channel 
             * negotiation failure or ISUP re-attempt failure  Or any 
             * case where the ogRsc is not valid but still are 
             * waiting for RelCfm from layer-3.*/

            /* continue with the call: wait for incoming RelCfm! */
          }
        }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S19
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTRELCFM_BOTH
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S19
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  ccDeallocateResource(con, CC_OUTGOING);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

  ret = ccDeallocateResource(con, CC_INCOMING);
  if(ret == RFAILED)
  {
    CC_STATE_CHANGE(con, CCS_IDLE);
    ccRelCon(con);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S20
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirm 
 *             state - AWTSWTCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S20
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt;
    rscEvnt = (RmAlocCfmEvnt *)event;

  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
    {
      /* Outgoing resource has been verified by the RM */
      con->ogRscVal = TRUE;
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, sizeof(RmRsc));
    }

  /* if a relase due to reattempt is required, send release to i/c interface */
  if (con->reatRelProc)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
    }
  else /* it's a case of initrel, send release to both i/f s */
    {
      /* Release calls */
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCSWTCHCONG,NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                    con->ogProtType, CCSWTCHCONG,NULL);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE11S20
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm 
 *             state - AWTSWTCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S20
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16                  mgret      = RFAILED; 
    S16                  ret        = RFAILED; 
    MgctTxnCfm          *txnCfm     = NULLP;
    CcConEvnt            ogEvnt; 
    ProtType             icProtType = CC_GET_PROTOCOL(con->icProtType);
    CcCause              cause;
    TknU16               sipCause;
    TknU16               sipStatus;

    txnCfm   = (MgctTxnCfm*) event;

    /* 27133 */
    ccRestoreReleaseInEvntHold (con);
    
    CC_STATE_CHANGE(con, CCS_AWTANS);
    mgret = ccHandleMgResponse(con, txnCfm);

    UPDATE_OPIC(con, PicSelectRoute); /*Bug69336*/

    /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  /* changing state, so that we are something else than 8 and 20 state*/
  CC_STATE_CHANGE(con, CCS_AWTANS);
  if (con->direction == OUTTOINC)
  {
    cmMemset((U8 *)&cause, 0, sizeof(CcCause));
    ccRestoreReleaseInEvntHold(con);
    ccGetRelCause(con, con->ogProtType, (CcRelEvnt *)con->ccEvntHold, &cause,
                  &sipCause, &sipStatus);
    if ((cause.eh.pres == PRSNT_NODEF) && (cause.causeVal.pres == PRSNT_NODEF))
    {
        con->tempHolderForReleaseCause = cause.causeVal.val;
        con->ainInfo.diconnectCause    = cause.causeVal.val;
    }
    CC_FILL_BUSY_CAUSE(con->ainInfo.BusyCause, cause, sipCause, sipStatus);

    if ((!CC_CAUSE_IS_VAL(&cause, CCCALLCLR, CSTD_CCITT)) &&
        (!CC_CAUSE_IS_VAL(&cause, CCNORMUNSPEC, CSTD_CCITT)) &&
        (con->icBcm.pic != PicOActive))
    {
      con->tempHolderForReleaseCause = cause.causeVal.val;
      ret = ccProcessOCalledPartyBusy(&(con->icBcm));
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "Detected OCdPrtyBusy:%ld\n", con->icSuConnId);
        RETVALUE(ROK);
      }
    }
  }

  if (ret != ROKIGNORE) /* If OCalledParty is was reported then go ahead
                         * and release call */
  {
      ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCLOGERR("Failed to Check if (O/T)Disc event is armed\n");
    }
    /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
    CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

#ifdef CC_CALEA
    if (icProtType != CC_LOCAL_SWT_PROT)
    {
       /* Make sure ur in Tapped Con */
       ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
       if (ret != ROK)
       {
          CCDP(AIN_DBG_LEVEL_4,
          "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
       }
    }
#endif
  }

#ifdef CC_CALEA
    /* This is when CaleaSubReq was sent along with the MGCT_ITEM_ID_CG_MAX for one of the
     * Tapped Subject */
    if (con->mgiPendRelRsp)
    {
        CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S20\n");
        ccProcessCaleaMgiSubRsp(con, FALSE);
        con->mgiPendRelRsp = 0;
    }
#endif
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

#if 1 /* EARLY_ACM */
    ccStopConTmr(con, CC_TMR_EARLYACM);
#endif

    if (CC_IS_CONTEXT_PRESENT(con))
    {
      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      con->mgBlock->con = con;
      mgret = ccSendMgiQueue(0, con->mgBlock);
      if(mgret != ROK)
      {
          CCLOGERR("ccHandleMgResponse or ccUpdateMgQForSubRsc or SendMgiQ."
                   " failed \n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
          switch(con->relPend)
          {
          case ICRELONLY:
              if(con->ogRscVal == TRUE)
                  ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;

              ccSendRelease(con, con->icSapCb, con->icSpConnId,
                             con->icSuConnId, con->icProtType, CCTMPFAIL,NULL);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              break;

          case OGRELONLY:
              ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                            con->ogSuConnId, con->ogProtType, CCTMPFAIL,NULL);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
              break;

          case INRELRSPANDOUTREL:
              con->direction = INCTOOUT; /* bug#34293 */
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
              ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                            con->ogSuConnId, con->ogProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
              ccGuardOrDeallocResource(con, CC_INCOMING);
#else 
              ccDeallocateResource(con, CC_INCOMING);
#endif
              con->icRscVal = FALSE;
              break;

          case OUTRELRSPANDINREL:
              con->direction = OUTTOINC; /* bug#34293 */
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId,
                            con->icSuConnId, con->icProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
              ccGuardOrDeallocResource(con, CC_OUTGOING);
#else 
              ccDeallocateResource(con, CC_OUTGOING);
#endif
              con->ogRscVal = FALSE;
              break;

          case OUTRELRSPANDINTONE: /* always IC CAS-line/trunk --> SS7/ISDN */
          {
              CcCause cause;

              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

              if (con->direction == OUTTOINC)
              {
                  con->failCndVal = ccMapProtRel2FailCnd (con, &cause, 
                            &sipCause, &sipStatus);
              }

#ifdef GUARD_TIMER
              ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
              ccDeallocateResource(con, CC_OUTGOING);
#endif
              con->ogRscVal = FALSE;

              con->direction = OUTTOINC;
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              /* Get protocol release cause */
              ccGetRelCause(con, (con->direction == OUTTOINC?con->ogProtType:\
                             con->icProtType), 
                            (CcRelEvnt *) con->ccEvntHold, &cause, 
                            &sipCause, &sipStatus);

              if ((con->failCndVal == FC_NOT_APPLICABLE) &&
                  ((cause.causeVal.val == CCUSRBSY) ||
                   (cause.causeVal.val == CCNOUSRRSP)) &&
                  (CC_ENDPOINT_BCM(&con->icBcm)))
                  con->failCndVal = FC_USRBUSY;

              if ((icProtType == CC_CS_TG) ||
                  (ccIsLEGSubscriber(&(con->icBcm))) ||
                  (con->direction == OUTTOINC && CC_IS_CAUSEMAP_SUPPORTED (con->ogProtType)))
              {
                  ccStopConTmr(con, TMR_RELEASE);
                  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
                  ret = ccProcessFailCnd (con, con->failCndVal, FALSE);
                  if (ret == ROK)
                      RETVALUE(ROK);
              }

              con->icEvnt = (CcAllSdus *) con->ccEvntHold;
              con->ogEvnt = (CcAllSdus *) &ogEvnt;

              ret = ccMapEvent(con, CCE_RELIND, 0);
              if (ret != ROK)
              {
                  ccSendRelease(con, con->icSapCb, con->icSpConnId,
                                con->icSuConnId,
                                con->icProtType, CCPROTERR,NULL);
                  RETVALUE(ROK);
              }
              ccSendReleaseReq(con);
              RETVALUE(ROK);
          }
          break;

          case BOTHREL:
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                            con->icProtType, CCTMPFAIL,NULL);
              ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                            con->ogProtType, CCTMPFAIL,NULL);
              break;

          case OUTRELRSPANDNOREL:
              con->direction = OUTTOINC; /* bug#34293 */
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
              ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;
              break;

          case INRELRSPANDNOREL :
              con->direction = INCTOOUT; /* bug#34293 */
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              /* outgoing resource is to be released here */
              /* This happens if outGoing SS7 call gets released in state-28 */
              /* Its better that we check the state of the ogRscVal */
              if(con->ogRscVal == TRUE)
                  ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;

              CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
              ccDeallocateResource(con, CC_INCOMING);
              break;

          case INRELRSPANDOUTRELRSP:

              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
              if( con->direction == INCTOOUT)
                  con->direction = OUTTOINC;
              else
                  con->direction = INCTOOUT;
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

              ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;
              CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
              ccDeallocateResource(con, CC_INCOMING);
              break;

          default :
              CCLOGERR( "ERROR : not supporting this relPend==%d\n",
                        con->relPend);
              break;
          }
          RETVALUE(RFAILED);
      }
    }

    switch(con->relPend)
    {
    case ICRELONLY:
    case OGRELONLY:
    case INRELRSPANDOUTREL:
    case OUTRELRSPANDINREL:
    case OUTRELRSPANDINTONE:
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        break;

    case BOTHREL:
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
        break;

    case INRELRSPANDNOREL :
        /* outgoing resource is to be released here */
        /* This happens if outGoing SS7 call gets released in state-28 */
        if (con->ogRscVal == TRUE)
        {
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
        }
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

    case OUTRELRSPANDNOREL:
    case INRELRSPANDOUTRELRSP:
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

    default :
        CCLOGERR( "Warning: not supporting this relPend==%d\n",
                  con->relPend);
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
        break;

    }
    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S20
 *
 *      Desc:  Connection state function
 *             event - Release Indication(incoming)
 *             state - AWTSWTCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S20
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* Store the release event for future mapping */
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: Could not store the CcRelEvnt\n");
  }
  
  if(con->direction == INCTOOUT)
  {
    switch(con->relPend)
    {
      case ICRELONLY: 
        con->relPend = INRELRSPANDNOREL;
        break;
  
      case BOTHREL: 
        con->relPend = INRELRSPANDOUTREL;
        break;
  
      case OUTRELRSPANDINREL: 
        con->relPend = INRELRSPANDOUTRELRSP;
        break;

      case INRELRSPANDNOREL: 
        /* Do nothing */
        break;

      default :
        CCLOGERR( "ERROR: Unexpected direction==%d," 
          "con->relPend=%d in ccConE04S20\n", con->direction, con->relPend);
        break;
    }
  }
  else /* OUTTOINC */
  {
    switch(con->relPend)
    {
      case OGRELONLY: 
        con->relPend = OUTRELRSPANDNOREL;
        break;
  
      case BOTHREL: 
        con->relPend = OUTRELRSPANDINREL;
        break;
  
      case INRELRSPANDOUTREL: 
        con->relPend = INRELRSPANDOUTRELRSP;
        break;

      case OUTRELRSPANDNOREL: 
        /* Do nothing */
        break;

      default :
        CCLOGERR( "ERROR: Unexpected direction==%d," 
          "con->relPend=%d in ccConE04S20\n", con->direction, con->relPend);
        break;
    }
  }

  /* con->relPend should reflect the release direction */
  /* Do not change the state */
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S20
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTSWTCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S20
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcMgCtx_t   *mgCtx = NULLP;
  CcMgCtx_t   *next  = NULLP;

  CCLOGERR("Response from MGI - TimedOut:%ld\n", con->icSuConnId);

  cleanUpMgQ(con);

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  /* Need to clean up all the mgCtxs this con owns */
  /* Delete the entry from the hash list */
  mgCtx = con->mgBlock->mgCtx;

  while(mgCtx)
  {
    next = mgCtx->next;

    cmHashListDelete(&ccMgctInsTbl, (PTR) mgCtx);
    if(mgCtx->mgSapCb)
      cmHashListDelete(&mgCtx->mgSapCb->ccMgInsTbl, (PTR) mgCtx);
    mgCtx->suCtxId = 0;
    mgCtx->contextId = 0;

    mgCtx = next;
  }
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  /* if a relase due to reattempt is required, send release to i/c interface */
  /* Or if it is a release during playTone sequence */
  if ((con->reatRelProc) || (con->mgPlayingTone == TRUE))
  {
      con->mgPlayingTone = FALSE;
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
  }
  else /* it's a case of initrel, send release to both i/f s */
  {
      /* Bug# 18646 - Handle E13 in S20*/
      switch(con->relPend)
      {
        case ICRELONLY:
          if(con->ogRscVal == TRUE)
            ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);
          break;

        case OGRELONLY:
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
          break;

        case INRELRSPANDOUTREL:
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_INCOMING);
#else
          ccDeallocateResource(con, CC_INCOMING);
#endif
          con->icRscVal = FALSE;
          break;
        case OUTRELRSPANDINREL:

          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
          ccDeallocateResource(con, CC_OUTGOING);
#endif
          con->ogRscVal = FALSE;
          break;

        case BOTHREL:
          /* Release calls */
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                        con->icProtType, CCSWTCHCONG,NULL);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                        con->ogProtType, CCSWTCHCONG,NULL);
          break;

        case OUTRELRSPANDNOREL:
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
          break;
        case INRELRSPANDNOREL :
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          /* outgoing resource is to be released here */
          /* This happens if outGoing SS7 call gets released in state-28 */
          /* Its better that we check the state of the ogRscVal */
          if(con->ogRscVal == TRUE)
           ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;

          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
          break;

        case INRELRSPANDOUTRELRSP:

          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          if( con->direction == INCTOOUT)
            con->direction = OUTTOINC;
          else
            con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
          break;

        default :
          CCLOGERR( "ERROR : not supporting this relPend==%d\n",
              con->relPend);
          break;
      }
  }

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE10S21
 *
 *      Desc:  Connection state function
 *             event - Resource Deallocation Confirm
 *             state - AWTDEALOCCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE10S21
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   
  if (con->dealocPend == 0)
    /* it was already decremented as part of CcLiRmtDealocCfm */
    {
      /* this is the end (of Call !!!) */
      /* Connection shall be cleared by the state machine driver */
      CC_STATE_CHANGE(con, CCS_IDLE);
      ccRelCon(con);
    }
  
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S21
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - AWTDEALOCCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S21
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    /* Forget about the deallocCfm and clear the connection */
    CC_STATE_CHANGE(con, CCS_IDLE);
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);
  ccRelCon(con);
  
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE17S10
 *
 *      Desc:  Connection state function
 *             event - Layer Management Initiated Release
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE17S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  TRC3(ccConE17S10)

  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  DP("**%s: Disconnecting call (icSu:%lx-ogSu:%lx) on request from operator\n",
      __FUNCTION__, con->icSuConnId, con->ogSuConnId);

#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

  con->callDtlInfo.cm.forcedRelType = CALL_REL_OPERATOR_FORCED;

  if(isThisBcmInMPartyCall(&con->icBcm) || isThisBcmInMPartyCall(&con->ogBcm))
  {
    ccHandleCleanUpConCb(con, FALSE, CCTMPFAIL);
  }
  else
  {
    con->failCndVal = FC_LM_INITIATED_REL;

    if (CC_IS_CONTEXT_PRESENT(con))
    {
      /* Blow off the switching and Release the Call */
      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      /* disconnect the outgoing leg but, continue processing
       * failure condition on incoming BCM */
      con->relPend = OUTRELANDINFAILCOND;

      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        RETVALUE(ROK);
    }
    else
    {
      ccFreeTheRscFromCon(con, OUTTOINC);
      ccProcessFailCnd(con, con->failCndVal, TRUE);
      RETVALUE(ROK);
    }
  }

  RETVALUE(ROK);
} /* CcConE17S10 */


/*
 *
 *      Fun:   ccConE18S10
 *
 *      Desc:  Connection state function
 *             event - Connection Hold Indication
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE18S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcCnStEvnt ogEvnt;
  S16 ret;
  Buffer   *uBuf;

  /* Deallocate concerned resource */

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));
  if (con->direction == INCTOOUT)
    {
      ccDeallocateResource(con, CC_INCOMING);
      con->icRscVal = FALSE;
    }
  else if (con->direction == OUTTOINC)
    {
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
    }
 
  /* Send a switching disconnect to Switching Fabric */

  /* Map the Hold on the other side. The Hold Ack would be sent */
  /* from the mapping matrix.                                      */

  con->icEvnt = (CcAllSdus *) event;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;
  ret = ccMapEvent(con, CCE_HLDIND, con->icEvntType);
  uBuf = con->uBuf;
  con->uBuf = NULLP;

  if (con->direction == INCTOOUT)
    {
      ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
          con->ogSapCb->spId, 
          con->ogSpConnId, con->ogSuConnId, con->ogProtType,
          con->ogEvntType, &ogEvnt, uBuf);
    }
  else
    {
      ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
          con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
          con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
    }

  RETVALUE(ret);
}


/*
 *
 *      Fun:   ccConE19S10
 *
 *      Desc:  Connection state function
 *             event - Connection Retrieve Indication
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE19S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocReqEvnt rscEvnt;
  S16 ret;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  TRC3(ccConE19S10)
   
    /* Extract the new resource from the RETRIEVE event */  
    ccExtractNewRscInfo(con, (CcRtrEvnt *)event, &rscEvnt);

  /* Store the event */
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRtrEvnt))) != ROK)
    {
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC351, (ErrVal) ret,
                 "ccConE19S10() Failed, ccStoreEvnt failed");
#endif
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL,NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                    con->ogProtType, CCTMPFAIL,NULL);
      RETVALUE(RFAILED);
    }

  if (con->direction == INCTOOUT)
    {
      /* Send Resource Allocation for incoming interface */
      con->retrieveInProg = ICRETRIEVE;
      /* Save the intfc type of the new resource - same as the old resource */
      cmMemcpy((U8 *)&(rscEvnt.resource1.intfc), (U8 *) &(con->icRsc.intfc), 
               sizeof(RmInterface));
      cmMemcpy((U8 *) &con->icRsc, (U8 *)&(rscEvnt.resource1), sizeof(RmRsc));
      CC_STATE_CHANGE(con, CCS_RETRIEVE); 
      ccAllocateResource(con, (CcConEvnt *)NULLP, 
                         CC_INCOMING, rscEvnt.alocType);
    }
  else if (con->direction == OUTTOINC)
    {
      /* Send Resource Allocation for outgoing interface */
      con->retrieveInProg = OGRETRIEVE;
      /* Save the intfc type of the new resource - same as the old resource */
      cmMemcpy((U8 *)&(rscEvnt.resource1.intfc), (U8 *) &(con->ogRsc.intfc), 
               sizeof(RmInterface));
      cmMemcpy((U8 *) &con->ogRsc, (U8 *)&(rscEvnt.resource1), sizeof(RmRsc));
      CC_STATE_CHANGE(con, CCS_RETRIEVE); 
      ccAllocateResource(con, (CcConEvnt *)NULLP,
                         CC_OUTGOING, rscEvnt.alocType);
    }
#ifdef ZC
  /* UPD CON */
  upd.con = con;
  zcRunTimeUpd(ZC_CON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S22
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - CCS_RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  if (con->direction == INCTOOUT)
    {
      con->relPend = INRELPEND;
      CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
    }
  else if (con->direction == OUTTOINC)
    {
      con->relPend = OGRELPEND;
      CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
    }

#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif
   
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S22
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirmation
 *             state - CCS_RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocReqEvnt rscAlocEvnt;
  RmAlocCfmEvnt *rscCfmEvnt;
  CcCnStEvnt ogEvnt;
  S16 ret;
  Buffer   *uBuf;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));
    rscCfmEvnt = (RmAlocCfmEvnt *) event;

  if (rscCfmEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
    {
      if (con->retrieveInProg == ICRETRIEVE)
        {
          con->icRscVal = TRUE;
          cmMemcpy((U8 *) &con->icRsc, (U8 *)rscCfmEvnt->rsc1, 
                   sizeof(RmRsc));


          /* Copy Additional Resource Information */
          if (rscCfmEvnt->addnlRscInfo != NULLP)
            {
              cmMemcpy((U8 *) &con->icAddnlRscInfo, 
                       (U8 *)rscCfmEvnt->addnlRscInfo, 
                       sizeof(RmAddnlRscInfo));   
            }
          else
            con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

          /* Copy the mBuf received from RM */
          if (con->icRscMBuf)
            SPutMsg(con->icRscMBuf);
          con->icRscMBuf = rscCfmEvnt->mBuf;
          rscCfmEvnt->mBuf = NULLP;

   
          /* Copy the modified traffic descriptor */
          cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscCfmEvnt->tfcDesc, 
                   sizeof(RmTfcDesc));

          /* Map the Retrieve on the outgoing side. The Retrieve Ack would be */
          /* sent from the mapping matrix.                                    */

          con->direction = INCTOOUT;
          con->icEvnt = (CcAllSdus *) con->ccEvntHold;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          ret = ccMapEvent(con, CCE_RTRIND, con->evntTypeHeld);
          uBuf = con->uBuf;
          con->uBuf = NULLP;
          ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst, con->ogSapCb->spId, 
                        con->ogSpConnId, con->ogSuConnId, con->ogProtType,
                        con->ogEvntType, &ogEvnt, uBuf);

          if (con->retrievePend)
            {
              con->retrievePend = FALSE;
              con->retrieveInProg = OGRETRIEVE;

              /* Extract the new resource from the RETRIEVE event */
              ccExtractNewRscInfo(con, (CcRtrEvnt *)con->ccEvntHold, 
                                  &rscAlocEvnt);

              /* Save the intfc type of the new resource - same as */
              /* the old resource */
              cmMemcpy((U8 *)&(rscAlocEvnt.resource1.intfc), 
                       (U8 *) &(con->ogRsc.intfc), sizeof(RmInterface));
              cmMemcpy((U8 *)&con->ogRsc, (U8 *)&(rscAlocEvnt.resource1), 
                       sizeof(RmRsc));

              ccAllocateResource(con, (CcConEvnt *)NULLP,
                                 CC_OUTGOING, rscAlocEvnt.alocType);
            }
          else
            {
              /* if no hold is in progress, send switch connect */
              if ((con->icRscVal) && (con->ogRscVal))
                {
                  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
                  CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
                  ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                                     CCS_CANNOTPROCESSEVENTS);
                }
            }
        }
      else if (con->retrieveInProg == OGRETRIEVE)
        {
          con->ogRscVal = TRUE;
          cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscCfmEvnt->rsc1, 
                   sizeof(RmRsc));


          /* Copy Additional Resource Information */
          if (rscCfmEvnt->addnlRscInfo != NULLP)
            {
              cmMemcpy((U8 *) &con->icAddnlRscInfo, 
                       (U8 *)rscCfmEvnt->addnlRscInfo, 
                       sizeof(RmAddnlRscInfo));   
            }
          else
            con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

          /* Copy the mBuf received from RM */
          if (con->icRscMBuf)
            SPutMsg(con->icRscMBuf);
          con->icRscMBuf = rscCfmEvnt->mBuf;
          rscCfmEvnt->mBuf = NULLP;

   
          /* Copy the modified traffic descriptor */
          cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscCfmEvnt->tfcDesc, 
                   sizeof(RmTfcDesc));

          /* Map the Retrieve on the incoming side. The Retrieve Ack would be */
          /* sent from the mapping matrix.                                    */

          con->direction = OUTTOINC;
          con->icEvnt = (CcAllSdus *) con->ccEvntHold;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          ret = ccMapEvent(con, CCE_RTRIND, con->evntTypeHeld);
          uBuf = con->uBuf;
          con->uBuf = NULLP;

          ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst, con->icSapCb->spId, 
                        con->icSpConnId, con->icSuConnId, con->icProtType,
                        con->ogEvntType, &ogEvnt, uBuf);

          if (con->retrievePend)
            {
              con->retrievePend = FALSE;
              con->retrieveInProg = ICRETRIEVE;

              /* Extract the new resource from the RETRIEVE event */
              ccExtractNewRscInfo(con, (CcRtrEvnt *)con->ccEvntHold, 
                                  &rscAlocEvnt);

              /* Save the intfc type of the new resource - same as */
              /* the old resource */
              cmMemcpy((U8 *)&(rscAlocEvnt.resource1.intfc), 
                       (U8 *) &(con->icRsc.intfc), sizeof(RmInterface));
              cmMemcpy((U8 *)&con->icRsc, (U8 *)&(rscAlocEvnt.resource1), 
                       sizeof(RmRsc));

              ccAllocateResource(con, (CcConEvnt *)NULLP,
                                 CC_INCOMING, rscAlocEvnt.alocType);
            }
          else
            {
              /* if no hold is in progress, send switch connect */
              if ((con->icRscVal) && (con->ogRscVal))
                {
                  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
                  CC_STATE_CHANGE(con, CCS_AWTSWTCFM);
                  ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                                     CCS_CANNOTPROCESSEVENTS);
#ifdef ZC
                  /* REL CON */
                  upd.icSuConnId = con->icSuConnId;
                  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
                  zcUpdPeer();
#endif
                }
            }
        }
    }
  else
    {
      /* Send Retrieve Reject */
      if (con->retrieveInProg == ICRETRIEVE)
        con->direction = INCTOOUT;
      else if (con->retrieveInProg == OGRETRIEVE)
        con->direction = OUTTOINC;

      ccSendRetrieveRej(con);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE17S22
 *
 *      Desc:  Connection state function
 *             event - LM Release Request
 *             state - CCS_RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE17S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  con->callDtlInfo.cm.forcedRelType = CALL_REL_OPERATOR_FORCED;
    ccStopConTmr(con, CC_TMR_CALLDTL);
  con->relPend = LMRELPEND;
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE18S22
 *
 *      Desc:  Connection state function
 *             event - Hold Indication
 *             state - CCS_RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE18S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcCnStEvnt ogEvnt;
  S16 ret;
  Buffer   *uBuf;

  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));

  if (con->direction == OUTTOINC)
    {
      /* We got a Hold Indication from outgoing direction */
      /* verify that outgoing direction is not already on hold */
      if (con->ogRscVal)
        {
          /* Send Resource Dealocation for outgoing interface */
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
        }
    }
  else if (con->direction == INCTOOUT)
    {
      /* We got a Hold Indication from incoming direction */
      /* verify that outgoing direction is not already on hold */
      if (con->icRscVal)
        {
          /* Send Resource Dealocation for outgoing interface */
          ccDeallocateResource(con, CC_INCOMING);
          con->icRscVal = FALSE;
        }
    }

  /* Map the Hold on the outgoing side. The Hold Ack would be sent */
  /* from the mapping matrix.                                      */

  con->icEvnt = (CcAllSdus *) event;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;
  ret = ccMapEvent(con, CCE_HLDIND, con->icEvntType);
  uBuf = con->uBuf;
  con->uBuf = NULLP;

  if (con->direction == INCTOOUT)
    {
      ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
          con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
          con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
    }
  else
    {
      ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
          con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
          con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
    }

  RETVALUE(ret);
}


/*
 *
 *      Fun:   ccConE19S22
 *
 *      Desc:  Connection state function
 *             event - Retrieve Indication
 *             state - CCS_RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE19S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

    con->retrievePend = TRUE;

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRtrEvnt))) != ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC352, (ErrVal) ret,
                 "ccConE19S22() Failed, ccStoreEvnt failed");
#endif
      ccStopConTmr(con, CC_TMR_CALLDTL);
      con->relPend = INITRELPEND;
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
#ifdef ZC
      /* REL CON */
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif
      RETVALUE(RFAILED);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S23
 *
 *      Desc:  Connection state function
 *             event - Release Indication
 *             state - ANSWERED-AWTALOCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S23
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    if (con->direction == INCTOOUT)
      {
        if (con->relPend == OGRELPEND)
          con->relPend = BOTHRELPEND;
      }
    else if (con->direction == OUTTOINC)
      {
        if (con->relPend == INRELPEND)
          con->relPend = BOTHRELPEND;
      }
   
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE09S23
 *
 *      Desc:  Connection state function
 *             event - Resource Allocation Confirmation
 *             state - ANSWERED-AWTALOCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE09S23
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscCfmEvnt;
  CcRelEvnt ogEvnt;
  S16 ret;

    rscCfmEvnt = (RmAlocCfmEvnt *) event;
  
  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt)); 

  if (rscCfmEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
    {
      if (!con->icRscVal)
        {
          if (con->icRsc.rscPres == NOTPRSNT)
            {
              cmMemcpy((U8 *) &con->icRsc, (U8 *)rscCfmEvnt->rsc1, sizeof(RmRsc));
            }
          else if (ccIsDifferentRscAllocated(con->icProtType, &con->icRsc,
                                             rscCfmEvnt->rsc1))
            {
              cmMemcpy((U8 *) &con->icRsc, (U8 *)rscCfmEvnt->rsc1, sizeof(RmRsc));
            }

          con->icRscVal = TRUE;
        }
      else if (!con->ogRscVal)
        {
          con->ogRscVal = TRUE;
          cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscCfmEvnt->rsc1, sizeof(RmRsc));
        }
    }

  switch (con->relPend)
    {
    case INRELPEND:
        {
          /* Send Resource Dealocation for initiating side */
          /* Send Release response and map the release    */
      
          con->icEvnt = (CcAllSdus *) con->ccEvntHold;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccDeallocateResource(con, CC_INCOMING);
      
          ret = ccMapEvent(con, CCE_RELIND, 0);
          if (ret != ROK)
          {
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                          con->ogProtType, CCPROTERR,NULL);
          }
          else
            ccSendReleaseReq(con);
        }
      break;
    case OGRELPEND:
        {
          /* Send Resource Dealocation for initiating side */
          /* Send Release response and map the release    */
      
          con->icEvnt = (CcAllSdus *) con->ccEvntHold;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccDeallocateResource(con, CC_OUTGOING);
      
          ret = ccMapEvent(con, CCE_RELIND, 0);
          if (ret != ROK)
          {
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                          con->icProtType, CCPROTERR,NULL);
          }
          else
            ccSendReleaseReq(con);
        }
      break;
    case BOTHRELPEND:
      /* Release resources and send Release responses to both interfaces */
      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *) con->ccEvntHold;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      if(con->icRscVal)
      ccDeallocateResource(con, CC_INCOMING);

      con->direction = OUTTOINC;
      con->icEvnt = (CcAllSdus *) con->ccEvntHold;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ret = ccDeallocateResource(con, CC_OUTGOING);
      if (ret == RFAILED)
      {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
          RETVALUE(ROK);
      }
      break;
    case LMRELPEND:
    case INITRELPEND:
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL, NULL);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                    con->ogProtType, CCTMPFAIL, NULL);
      RETVALUE(ROK);
      break;

     case ICRELONLY:
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

      if(con->ogRscVal)
      {
        ccDeallocateResource(con, CC_OUTGOING);
        con->ogRscVal = FALSE;
      }

      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL, NULL);
      RETVALUE(ROK);
      break;

    case INRELRSPANDNOREL :
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

      /* Its better that we check the state of the ogRscVal */
      if(con->ogRscVal == TRUE)
        ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;

      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ccDeallocateResource(con, CC_INCOMING);
      break;

    default:
      CCLOGERR("*****%s: relPend not found %d******\n", __FUNCTION__,
          con->relPend);
      CC_TRACE_DUMP(con);
      CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
      ccDeallocateResource(con, CC_INCOMING);
      break;
    }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE17S23
 *
 *      Desc:  Connection state function
 *             event - LM Initiated Release Request
 *             state - AWTALOCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE17S23
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  con->callDtlInfo.cm.forcedRelType = CALL_REL_OPERATOR_FORCED;
    con->relPend = LMRELPEND;
  CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
  RETVALUE(ROK);
}

#if 0 /* GB - Turned off untill E21 is supported in otherthan 10 & 31 */

/*
*
*      Fun:   ccConE21S02
*
*      Desc:  Connection state function
*             event - Deallocation Indication Received
*             state - AWTROUTEDGT
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE21S02
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  CcRmDealocIndEvnt *rscEvnt;

    /* First check and store the allocated resources */
    rscEvnt = (CcRmDealocIndEvnt *) event;

  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;

      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

      /* Stop timer, Send release to incoming side, Generate Alarm? */
      ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
                 LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

      ccStopConTmr(con, TMR_INTERDGT);

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL, NULL);
    }
  else
    {
      RETVALUE(RFAILED);
    }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE21S03
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTROUTECFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S03
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

    rscEvnt = (CcRmDealocIndEvnt *) event;

  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;

      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

      /* Send release to incoming side, Generate Alarm? */
      ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
                 LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                    con->icProtType, CCTMPFAIL, NULL);
    }
  else
    {
      RETVALUE(RFAILED);
    }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE21S04
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTRSCALOCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S04
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

    rscEvnt = (CcRmDealocIndEvnt *)event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
      con->ogRscVal = TRUE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
        con->icRscVal = TRUE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

  /* Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL, NULL);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE21S05
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTENBLOCSND
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S05
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

    rscEvnt = (CcRmDealocIndEvnt *) event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  ccStopConTmr(con, TMR_INTERDGT);

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

  /* Send release to incoming side, Generate Alarm?   */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCNORTTODEST, NULL);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE21S06
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTOGRSC, AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S06
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

    rscEvnt = (CcRmDealocIndEvnt *) event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  /* Initiate release on both interfaces       */
  ccStopConTmr(con, TMR_SETUP);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccCp.sts.fResUnavail++;

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  /* Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL, NULL);

  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL, NULL);

  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE21S08
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S08
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

  rscEvnt = (CcRmDealocIndEvnt *) event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  /* Initiate release on both interfaces       */
  ccStopConTmr(con, TMR_SETUP);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccCp.sts.fResUnavail++;

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  /* Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL, NULL);

  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL, NULL);


  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE21S09
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTANS, ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  rscEvnt = (CcRmDealocIndEvnt *) event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  /* Initiate release on both interfaces       */
  ccStopConTmr(con, TMR_SETUP);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccCp.sts.fResUnavail++;

  if (con->state == CCS_ANSWERED)
    {
      ccStopConTmr(con, CC_TMR_CALLDTL);
    }
#ifdef ZC
  if (con->state == CCS_ANSWERED)
    {
      /* REL CON */
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
#endif
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  /* Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  /* Initiate release in both directions */
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL, NULL);

  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL, NULL);

  RETVALUE(ROK);
}
#endif /* Turned off */


/*
 *
 *      Fun:   ccConE21S10
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  rscEvnt = (CcRmDealocIndEvnt *) event;

  if ((!con->replicatedCall) &(CC_GET_PROTOCOL(con->ogProtType) != CC_IVT))
    RETVALUE(ROK);

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  /* Initiate release on both interfaces       */
  ccStopConTmr(con, CC_TMR_TIMEOUT);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  ccStopConTmr(con, CC_TMR_CALLDTL);
  if (con->keepGCCCallInfo == FALSE)
  { 
  con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
  }

#ifdef ZC
   /* REL CON */
   upd.icSuConnId = con->icSuConnId;
   zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
   zcUpdPeer();
#endif

/* BEGIN: Bug 43247*/
  /* 
   * There are 2 cases.
   * 1) Layer 3 has the call and GCC does not
   * 2) GCC has the call and Layer 3 does not
   *
   * In both the cases, PAP audit (rm_bdy8.c) calls DeAlocInd. But in
   * some corner cases, there were inconsistencies between what RM and
   * GCC think about a CIC. So in both the cases, it was decided that
   * we will,
   *
   * 1) De-allocate both the resources
   * 2) send releases to both the legs
   */
  ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
/*END: Bug:43247*/
  
  RETVALUE(ROK);
}

#if 0 /* GB - Turned off untill E21 is supported in otherthan 10 & 31 */

/*
 *
 *      Fun:   ccConE21SXX
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - AWTROUTECFM_TOCLR
 *                     AWTRSCCFM_TOCLR
 *                     AWTOGRSC_TOCLR
 *                     AWTSWTCFM_INREL
 *                     AWTSWTCFM_BOTHREL
 *                     AWTRELCFM_IC
 *                     AWTRELCFM_OG
 *                     AWTRELCFM_BOTH
 *                     AWTSWTCFM_TOCLR
 *                     AWTDEALOCCFM
 *                     AWTALOCCFM_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;
    rscEvnt = (CcRmDealocIndEvnt *) event;

  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE21S22
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - RETRIEVE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S22
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

    rscEvnt = (CcRmDealocIndEvnt *) event;
  if ((con->icRscVal) && (rscEvnt->suConnId == con->icSuConnId)) 
    {
      con->icRscVal = FALSE;
         
    }
  else
    if ((con->ogRscVal) && (rscEvnt->suConnId == con->ogSuConnId)) 
      {
        con->ogRscVal = FALSE;
      }
    else 
      {
        RETVALUE(RFAILED);
      }

  ccStopConTmr(con, CC_TMR_CALLDTL);
  con->relPend = INITRELPEND;
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

  RETVALUE(ROK);
}
#endif /* Turned off */


/*
 *
 *      Fun:   ccConE22SOK
 *
 *      Desc:  Connection state function
 *             event - Call Detail Timer expiry
 *             state - ANSWERED, RETRIEVE
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE22SOK
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   const char    *func = __FUNCTION__;
   U32           elapsed;
   U32           current;
   U32           initial;
   U32           sub;
   U32           temp = 0;

#if 1 /* cc026.15 : addition */
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#endif /* cc026.15 : addition */
    /* Currently we do not see any need why, but in future maybe we would 
     * have to clear the call on expiry of this timer 
     */
 /*FID 2294 ++*/
   initial = ccBillingSystem.initialThreshold;
   sub = ccBillingSystem.subsequentThreshold;
   SGetSysTime (&elapsed);
   SGetSysTime (&current);
   /* calculate the call elapsed time */
   if (con->callDtlInfo.cm.tckOgConCfmRcvd.pres == PRSNT_NODEF)
   {
     elapsed = (elapsed - con->callDtlInfo.cm.tckOgConCfmRcvd.val)/10;
   }
   else if (con->callDtlInfo.cm.tckIcConRspSent.pres == PRSNT_NODEF)
   {
     elapsed = (elapsed - con->callDtlInfo.cm.tckIcConRspSent.val)/10;
   }
   else
   {
     CCLOGERR ("%s: ERROR, no connect time, \n", func);
     RETVALUE(ROK);
   }
 /*FID 2294 --*/

/* Bukucu - do these after we generate cdr */
  /*
   * Generate accounting information
   */
  if (ccBillingSystem.ldcType == LEGACY)
  {
  /* Bukucu - 12049 */
    if (con->timerIterations == 1)
    {
        /* tckStartLongDur is now updated by ccGenAcntgInd */
        ccGenAcntgInd (con, C_CDRGEN_CAUSE_CALLDTLTMR);
    }
  }
/* FID 2294 ++*/
  else /* for configurable LDC */
  {
    /* generate the billing record according to call elapsed time. If elapsed time <= initial, generate
     * first LDC record. Else generate the continuation records.
     */
    if (initial >= elapsed)
    {
      if ((initial - elapsed ) > 1)
      {
        CCDP(AIN_DBG_LEVEL_1, "not generate any record since it doesn't come the end of initial interval \n");
      }
      else
      {
        if ((elapsed % (15 * 60)) <= (2 * 60))
        /* if STATS timeout before LONGDUR timeout in 1 or 2 mins, let STATS wait to
           send recored with billing records together */
        {
          CCDP(AIN_DBG_LEVEL_1,"generate billing and stats records for both\n");
          ccGenAcntgInd (con, C_CDRGEN_CAUSE_BOTH);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_1,"generate billing record only\n");
          ccGenAcntgInd (con, C_CDRGEN_CAUSE_CALLDTLTMR);
        }
      }
    }
    else  /* to generate the continuation records */
    {
      /* calculate the correct left time to the subsequentThreshold interval */
      if (con->callDtlInfo.cm.tckOgConCfmRcvd.pres == PRSNT_NODEF)
      {
        if (con->callDtlInfo.cm.tckStartLongDur.val > con->callDtlInfo.cm.tckOgConCfmRcvd.val)
        {
          temp = con->callDtlInfo.cm.tckStartLongDur.val/10 + sub- current/10;
        }
        else
        {
          temp = con->callDtlInfo.cm.tckGenAcntInd.val/10 + sub- current/10;
        }
      }
      else if (con->callDtlInfo.cm.tckIcConRspSent.pres == PRSNT_NODEF)
      {
        if (con->callDtlInfo.cm.tckStartLongDur.val > con->callDtlInfo.cm.tckIcConRspSent.val)
        {
          temp = con->callDtlInfo.cm.tckStartLongDur.val/10 + sub- current/10;
        }
        else
        {
          temp = con->callDtlInfo.cm.tckGenAcntInd.val/10 + sub- current/10;
        }
      }
      if (temp > 1)
      {
        CCDP(AIN_DBG_LEVEL_1, "not generate any record since it doesn't come the end of sub interval.\n");
      }
      else
      {
        if ((elapsed % (15 *60)) <= (2 * 60))
        /* if STATS timeout before LONGDUR timeout in 1 or 2 mins, let STATS wait to
         send recored with billing records together */
        {
          CCDP(AIN_DBG_LEVEL_1,"generate continuation billing and stats records for both\n");
          ccGenAcntgInd (con, C_CDRGEN_CAUSE_BOTH);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_1,"generate continuation billing record only\n");
          ccGenAcntgInd (con, C_CDRGEN_CAUSE_CALLDTLTMR);
        }
      }
    }
  }
  /* FID 2294 --*/

   CCDP(AIN_DBG_LEVEL_1, "restart long dur timer.\n");


   ccStartConTmr(CC_TMR_CALLDTL, con, (PTR)&ccCp.genCfg);
   (Void) SGetSysTime(&con->cdrStartTick);

#ifdef ZC
   if (CC_IS_OBCM_PIC_ACTIVE(con))
   {
      /* Create ConCb */
      upd.con = con;

      zcRunTimeUpd(ZC_CALLDTL, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
   }
#endif

  RETVALUE(ROK);
}


/*
 *      * TELICA-amir 01-19-00 added for Telica stats *
 *      Fun:   ccConE32SOK
 *
 *      Desc:  Connection state function - NO FTHA handling
 *             event - Stats Call Detail Timer expiry
 *             state - ANSWERED, RETRIEVE
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE32SOK
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  const char    *func = __FUNCTION__;
  U32      elapsed;
  U32      current;
  U32      initial;
  U32      sub;

  /* FID2294 ++*/
  initial = ccBillingSystem.initialThreshold;
  sub = ccBillingSystem.subsequentThreshold;

  SGetSysTime (&elapsed);
  SGetSysTime (&current);
  /* calculate the call elapsed time */
  if (con->callDtlInfo.cm.tckOgConCfmRcvd.pres == PRSNT_NODEF)
  {
    elapsed = (elapsed - con->callDtlInfo.cm.tckOgConCfmRcvd.val)/10;
  }
  else if (con->callDtlInfo.cm.tckIcConRspSent.pres == PRSNT_NODEF)
  {
    elapsed = (elapsed - con->callDtlInfo.cm.tckIcConRspSent.val)/10;
  }
  else
  {
    CCLOGERR ("%s: ERROR, no connect time, \n", func);
    RETVALUE(ROK);
  }

  if (ccBillingSystem.ldcType == LEGACY)
  {
    ccGenAcntgInd(con, C_CDRGEN_CAUSE_STATS_CALLDTLTMR);
  }
  else
  {
    /* for LDC first record, if stats timer is only 1 or 2 mins before billing record, do not generate the
     * stats record here and generate the combined stats and billing records together when billing
     * timer expires, else generate stats record as usual.
     */
    if (initial >= elapsed)
    {
      if ((initial - elapsed) > 2*60)
      {
        CCDP(AIN_DBG_LEVEL_1, "generate stats record only.\n");
        ccGenAcntgInd(con, C_CDRGEN_CAUSE_STATS_CALLDTLTMR);
      }
    }
    /* for LDC continuation record, it has the same hanlding as the LDC first record. */
    else if (elapsed > initial)
    {
      if (2*60 < ((con->callDtlInfo.cm.tckStartLongDur.val/10 + sub) - current/10))
      {
        CCDP(AIN_DBG_LEVEL_1, "generate stats record only.\n");
        ccGenAcntgInd(con, C_CDRGEN_CAUSE_STATS_CALLDTLTMR);
      }
    }
  }
  /* FID2294 --*/
  CCDP(AIN_DBG_LEVEL_1, "restart stats timer.\n");




    /* Currently we do not see any need why, but in future maybe we would 
     * have to clear the call on expiry of this timer 
     */


  ccStartConTmr(CC_TMR_CALLDTL_STATS, con, (PTR)&ccCp.genCfg);

  /*
   * Generate accounting information
   *
   * ccGenAcntgInd(con, C_CDRGEN_CAUSE_STATS_CALLDTLTMR);
   */

  RETVALUE(ROK);
}



/*
 *
 *      Fun:   ccConE21S31
 *
 *      Desc:  Connection state function
 *             event - Deallocation Indication Received
 *             state - 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE21S31
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcRmDealocIndEvnt *rscEvnt;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  rscEvnt = (CcRmDealocIndEvnt *) event;

  if(rscEvnt->suConnId == con->icSuConnId) 
  {
    con->icRscVal = FALSE;
  }
  else if ((rscEvnt->suConnId == con->ogSuConnId)) 
  {
    con->ogRscVal = FALSE;
  }

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    cleanUpMgQ(con);
    ccCleanUpMGCtx(con);
  }

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  if(con->icRscVal)
  {
     CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
     ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                   con->icProtType, CCTMPFAIL, NULL);
 
  }
  else
  {
     CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
     ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                   con->ogProtType, CCTMPFAIL, NULL);
  }
  RETVALUE(ROK);
} 


/*
 *
 *      Fun:   ccConE04S28
 *
 *      Desc:  Connection state function
 *             event - Cct Release Indication 
 *             state - AWTOGSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S28
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16  ret;

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if (con->direction == INCTOOUT)
  {
    /* Bug71923 this release event maybe triggered by SIP REFER */
    if((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup))
    {
      CCDP(AIN_DBG_LEVEL_0, "SIP REFER triggers RELEASE:%ld\n", con->icSuConnId);
      ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
      RETVALUE(ROK);
    }

    /* Wait for switch confirmation to clear the call */
    ccStopConTmr(con, TMR_SETUP);

    /* This processing to be reviewed */
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
    if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
    {
      con->relPend = INRELRSPANDNOREL;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC348, (ErrVal) ret,
                 "ccConE04S28() Failed, ccStoreEvnt failed");
#endif
       RETVALUE(RFAILED);
     }

     con->relPend = INRELRSPANDNOREL;
     CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
     RETVALUE(ROK);
  }
  else /* This is an unexpected RelInd. during reattempt? */
  {
    DP("ERROR:E%02dS%02d:OUTTOINC su:0x%08X, icsp:0x%08X icProt:%d,"
       " ogsp:0x%08X ogProt=%d\n", con->evntType, con->state,
        (unsigned int)con->icSuConnId, 
        (unsigned int)con->icSpConnId, con->icProtType,
        (unsigned int)con->ogSpConnId, con->ogProtType);
     con->ogSpConnId = 0; /* Reset this value */

  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE11S28
 *
 *      Desc:  Connection state function
 *             event -
 *             state -
 *             This guy got called in the case:
 *             ccCSTG2CSTGMapS12M00: Mapping CAS TRUNK ADDRCFM to CAS TRUNK
 *             CONREQ
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S28
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16             ret          = RFAILED;
   MgctTxnCfm     *txnCfm       = NULLP;
   /* Feature 1789: German ISUP */
   ProtType        icProtType   = CC_GET_PROTOCOL(con->icProtType);
   ProtType        ogProtType   = CC_GET_PROTOCOL(con->ogProtType);
   ProtType        icRealIcProtType = 0;
   AinBCM_t  *pTmpOgBcm = NULLP;
   AinBCM_t  *pTmpIcBcm = NULLP;
   Bool            isClearModePref = FALSE;
   Bool            isFaxSdp        = FALSE;

   CCDP(AIN_DBG_LEVEL_1, "ccConE11S28\n");

   CC_DERIVE_BCMS(con, pTmpIcBcm, pTmpOgBcm);
   
   if (con->icIntfcCb)
        icRealIcProtType = CC_GET_PROTOCOL(con->icIntfcCb->protType);

   txnCfm   = (MgctTxnCfm*) event;
   ret = ccHandleMgResponse(con, txnCfm);
   if (ret == ROK)
   {
       /*Bug 87179*/
       if (CC_IS_AGNOSTIC_CANDIDATE_WITH_NO_OFFER_CALL(con) &&
           (!CC_IS_ASSOCBLOCK_PRESENT(con)) &&
           (!CC_OFFANS_ICOFFANS_PENDING(con)) &&
           (!con->isAnsIndSent) && 
           pTmpIcBcm && pTmpOgBcm)
       {
         CcBearerIpParams_t *pTmpIpParam = NULLP;
         Sdp *pTmpLoc = NULLP;
         int agnosticFlag = 0;
         int i;

         CC_DERIVE_IPPARAM(pTmpIcBcm, pTmpIpParam);
         if(pTmpIpParam && pTmpIpParam->locDesc)  
         {
           pTmpLoc = pTmpIpParam->locDesc;
           for (i=0; i<pTmpLoc->numDecode; i++)
           {
             if(pTmpLoc->p[i].agnostic)   
             {
               agnosticFlag = 1;            
               break;
             }
           }
         } 
         CC_DERIVE_IPPARAM(pTmpOgBcm, pTmpIpParam);
         if(!agnosticFlag && pTmpIpParam && pTmpIpParam->locDesc)  
         {
           pTmpLoc = pTmpIpParam->locDesc;
           for (i=0; i<pTmpLoc->numDecode; i++)
           {
             if(pTmpLoc->p[i].agnostic)   
             {
               agnosticFlag = 1;            
               break;
             }
           }
         } 
         if(agnosticFlag) 
         {
           //Release the call
           CCDP(AIN_DBG_LEVEL_2, "Agnostic sdp from MG, release call.\n");
           ccStopConTmr(con, TMR_SETUP);

           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;

           if (CC_IS_CONTEXT_PRESENT(con))
           {
               ccQSubBasedOnCcn(con);
               con->mgBlock->con = con;
               ret = ccSendMgiQueue(0, con->mgBlock);
               if (ret != ROK)
               {
                   CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
                   cleanUpMgQ(con);
                   ccCleanUpMGCtx(con);
               }
               else 
               {
                   con->relPend = ICRELONLY;
                   con->tempHolderForReleaseCause = CCPROTERR;
                   con->mgBlock->con = con;
                   CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
                   RETVALUE(RFAILED);
               }
           }
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           ccSendRelease(con,con->icSapCb, con->icSpConnId, con->icSuConnId, 
                         con->icProtType, CCBCAPUNAVAIL, NULL);
           RETVALUE(RFAILED);

         }
       }

       /* FID 16204.1 */
       if (CC_BOTH_SUPPORT_UUI(con) && (con->icProtType == CC_INETSI))
       {
           ConEvnt      *in = NULLP;
           FacilityStr  *pFacilityStr1 = NULLP; 
           
           if (con->ccEvntHold)
           {
               in = &(con->ccEvntHold->m.ccConEvnt.m.inConEvnt);
               pFacilityStr1 = &in->facilityStr1;
           }
       
           /* FID 16204.1 Decode facility IE from ISDN conEvnt + */
           if (pFacilityStr1)
           {
               if (pFacilityStr1->eh.pres == PRSNT_NODEF)
               {
                   CCDP(AIN_DBG_LEVEL_1, "Extracting and decode UUS info from facility IE\n");
                   ret = ccFacStr2FacInfo(&pFacilityStr1->facilityStr, &con->uusInfo, INV_COMP_OPRA_UUS);
                   if (ret != ROK)
                   {
                       CCDP(AIN_DBG_LEVEL_0, "ccFacStr2FacInfo failed\n");
                   }
                   else
                   {
                       CCDP(AIN_DBG_LEVEL_1, "%s: UUS info:(eh.pres=%d,invokeId=%d,service=%d,discReq=%d)\n",
                               __FUNCTION__, con->uusInfo.eh.pres, con->uusInfo.invokeId,
                               con->uusInfo.service, con->uusInfo.discReq);
                   }
               }
           }

           if ((con->uusInfo.eh.pres == PRSNT_NODEF) &&
               (con->uusInfo.discReq == TRUE))
           {
               /* FID 16204.1 Release the call if service is required in UUS1/2/3 here */
               CCDP(AIN_DBG_LEVEL_0, " Release the call due to UUS service required!\n");

               ccStopConTmr(con, TMR_SETUP);
               ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
               
               ccDeallocateResource(con, CC_OUTGOING);
               con->ogRscVal = FALSE;
               if (CC_IS_CONTEXT_PRESENT(con))
               { 
                   ccQSubBasedOnCcn(con);
                   if(con->mgBlock != NULLP)
                   {
                       con->mgBlock->con = con;
                       ret = ccSendMgiQueue(0, con->mgBlock);
                       if (ret != ROK)
                       {
                           CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
                           cleanUpMgQ(con);
                           ccCleanUpMGCtx(con);
                       }
                       else
                       {   
                           con->relPend = ICRELONLY;
                           con->tempHolderForReleaseCause = CCPROTERR;
                           con->mgBlock->con = con;
                           CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
                           RETVALUE(RFAILED);
                       }
                   }
                   else
                   {
                       CCLOGERR( "**** ERROR: mgBlock is NULL *******\n");
                       RETVALUE(RFAILED);
                   }
               }
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
               ccSendRelease(con, con->icSapCb, con->icSpConnId,
                       con->icSuConnId, con->icProtType, CCFACNOTIMP, NULL);

               RETVALUE(RFAILED);
           }
       }

        /* BUG 84386 - Check for PassThru trunk on outgoing BCM */
       if ((((IS_MULTIMEDIA_4_BCM(pTmpOgBcm)) &&
            (!IS_SINGLE_AWARE_STREAM_4_BCM(pTmpOgBcm))) ||
            (ccIsPassThruDoneOnOffer(pTmpOgBcm))) &&
           !(CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) &&
             ((con->ccmCb.flags&CC_IW_TDM)!=0)))
       {
        if ((pTmpIcBcm->bcmType == BtTAdjBcm)&& (con->ogAdjIpParam))
        {
          CCDP(AIN_DBG_LEVEL_0, "%s: Free con->ogAdjIpParam->locDesc for BtTAdjBcm\n", __FUNCTION__);

          /* BUG 87954 free the sdp before assign new one */
          if (con->HeldIcLocDesc != NULL)
          {
             CCDP(AIN_DBG_LEVEL_0, "%s: freeing existing held sdp:0x%0x \n",
                  __FUNCTION__, (int) con->HeldIcLocDesc );
             cmFreeSdp(ccInit.region, ccInit.pool, &con->HeldIcLocDesc);
          }

          con->HeldIcLocDesc = con->ogAdjIpParam->locDesc;
          con->ogAdjIpParam->locDesc = NULLP;
          CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_IC_SDP_DONE);
        }
        else if (pTmpIcBcm->bcmType == BtOBcm)
        {
          CCDP(AIN_DBG_LEVEL_0, "%s: Free con->icIpParam.locDesc for BtOBcm\n", __FUNCTION__);
          if (!(CC_IS_CALL_MULTI_MG(con)))
          {
             /* BUG91684 memory leak in mgct.c for locDesc for re-route call*/
             if (con->HeldIcLocDesc != NULL)
             { 
               CCDP(AIN_DBG_LEVEL_0, "%s: freeing existing held sdp:0x%0x \n",
                    __FUNCTION__, (int) con->HeldIcLocDesc );
               cmFreeSdp(ccInit.region, ccInit.pool, &con->HeldIcLocDesc);
             }
             con->HeldIcLocDesc = con->icIpParam.locDesc;
          } else {
             cmFreeSdp(ccInit.region, ccInit.pool, &con->icIpParam.locDesc);
          }
          con->icIpParam.locDesc = NULLP;
          CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_IC_SDP_DONE);
        }
        else if ((pTmpIcBcm->bcmType == BtOLiAdjBcm) && (con->icLiAdjIpParam))
        {
          CCDP(AIN_DBG_LEVEL_0, "%s: Free con->icLiAdjIpParam->locDesc for BtOLiAdjBcm\n", __FUNCTION__);
          cmFreeSdp(ccInit.region, ccInit.pool, &con->icLiAdjIpParam->locDesc);
          con->icLiAdjIpParam->locDesc = NULLP;
          CC_CLR_PASSTHRU_FLAG(con,CC_PASSTHRU_IC_SDP_DONE);
        }
       }

       /* FID 15261.0 & FID 15083.0  */
       if (CC_IS_CALL_MULTI_MG(con))
       {
         if ((!CC_OPERATING_LAST_MG(con)) && ((con->ccmCb.flags & CC_IW_TDM) == 0)) 
         {
           if (con->ccmCb.ccn == CCN_1)
           {
             if (con->ccmCb.state == CC_INGRESS_MG)
             {
               con->ccmCb.state = CC_EGRESS_MG;
               ccProcessAuthTermSwtReqTrue(con);
               RETVALUE(ROK);
             }
           }
           else /* CCN_3, CCN_4 & CCN_5 */
           {
             if (con->ccmCb.state == CC_INGRESS_MG)
             {
                if (con->ccmCb.ccn == CCN_5)
                {
                  con->ccmCb.state = CC_Y_MG;
                  ccProcessAuthTermSwtReqTrue(con);
                  RETVALUE(ROK);
                }
                else
                {
                  con->ccmCb.state = CC_EGRESS_MG;
                  ccProcessAuthTermSwtReqTrue(con);
                  RETVALUE(ROK);
                }
             }
             else if (con->ccmCb.state == CC_Y_MG)
             {
               con->ccmCb.state = CC_EGRESS_MG;
               ccProcessAuthTermSwtReqTrue(con);
               RETVALUE(ROK);
             }
           }
         }else /*FID 15068.0*/ 
         {
            if ((con->ccmCb.flags&CC_IW_TDM)==0 && CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) &&
                (CC_GET_PROTOCOL(con->icProtType)==CC_SIPT || CC_GET_PROTOCOL(con->icProtType)==CC_SIP) &&
                (CC_GET_PROTOCOL(con->ogProtType)==CC_SI || CC_GET_PROTOCOL(con->ogProtType)==CC_IN ||
                 CC_GET_PROTOCOL(con->ogProtType)==CC_EXT_BICC) && /* FID17373.0 */
                (con->direction==INCTOOUT) && ccIsOgContChkRqstd(con)!=CONTCHK_REQ)
            {
              con->ccmCb.flags |= CC_IW_TDM;
              con->direction = OUTTOINC;
            }

            if (con->ccmCb.flags&CC_IW_TDM)
            {
              if (!CC_OPERATING_LAST_MG(con))
              {
                if ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_EGRESS_MG))
                  con->ccmCb.state = CC_Y_MG;
                else
                  con->ccmCb.state = CC_INGRESS_MG;

                ccProcessXferRsp1OnSwitchPassThru(con, CC_GET_PROTOCOL(con->icProtType),
                             CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
                CC_STATE_CHANGE(con, CCS_AWTOGSWTCFM);

                return ROK;
              }else
              {
                con->ccmCb.flags &= ~CC_IW_TDM;
                con->direction = INCTOOUT;
              }
            }           
         }      
       }
       /* FID 15261.0 & FID 15083.0 - */
       /* FID17160.0 Need to do the ADD for ConCurBcm */
       if (CC_IS_STEROMONO_CALL(con))
       {
          if (con->ccmCb.state == CC_INGRESS_MG)
          {
             con->ccmCb.state = CC_EGRESS_MG;
             ccProcessAuthTermSwtReqTrue(con);
             RETVALUE(ROK);
          }
       }
       /* Bug# 72705 - Context is successfully created on Ingress CCS , so clean the saved
          con->ccHeldSdpForCfna - saved in E11S28 */

       if (con->ccHeldSdpForCfna)
       {
          isClearModePref = ccIsClearModePrefCodec(con->ccHeldSdpForCfna);
          isFaxSdp = ( ccTestSDPForFax(con->ccHeldSdpForCfna) == ROK ) ? TRUE : FALSE;
          CCDP(AIN_DBG_LEVEL_0, "isClearModePref:%d, isFaxSdp: %d\n", isClearModePref, isFaxSdp);
         cmFreeSdp(ccInit.region, ccInit.pool, &con->ccHeldSdpForCfna);
       }


       if (ogProtType == CC_IVT) /* FID 14221.0 */
       {
           ccAnswerIVTCall(con);
           RETVALUE(ROK);
       }

       /* FID-14209: Enhanced Transcoding + */
       if (CC_IS_MG_NEEDED_IN_IP_CALL(con) && CC_OFFANS_ICANS_PENDING(con))
       {
         ccCodecReorderPostCfm(&con->ogBcm, con->ogIpParam.locDesc);
       }
       /* FID-14209: Enhanced Transcoding - */

#ifdef CC_CALEA
      /* Check if TermResourceAvailable requested event is armed */
      ret = ccProcessTermResourceAvailable(&(con->ogBcm));
      if (ret == ROK)
      {
         CCDP(AIN_DBG_LEVEL_0, "TermRscAva requested event armed:%ld, %ld\n",
              con->icSuConnId, con->ogSuConnId);
         RETVALUE(ROK);
      }
#endif /* End of CALEA */

      /* CHECK FOR TNOANSWER EVENT */
      ccProcessTNoAnswer(&(con->ogBcm));

      /* FID15068.0 */
      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (CC_IS_CONTEXT_PRESENT(con)) &&
          (ccPrecndConfigOn(con->ogIntfcCb,con->ogProtType)))
      /* set the egress precond cb */
      {
        if ((con->ogPrecndCb) && (con->icPrecndCb) &&
            ((icProtType == CC_SIP || icProtType == CC_SIPT) &&
             (ogProtType == CC_SIP || ogProtType == CC_SIPT)))
        {
          con->ogPrecndCb->mask  = con->icPrecndCb->mask;
          ccUpdatePrecndStaTblFromPeer(con, con->ogPrecndCb, TRUE);

          if(!CC_OFFANS_ICOFFANS_PENDING(con))
          {
            SET_PRECND_SIP2SIPREROUTE(con->ogPrecndCb->flag);

            if (!(con->remoteSdpSentOnIcBCM) &&
                (con->icBcm.pic < PicOActive) &&
                !(con->isAnsIndSent) &&
                !(CC_OFFANS_ICOFFANS_PENDING(con)) &&
                (CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask)) &&
                (CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask)) &&
                CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP) &&
                ccHasPrecndConfStatus(con->icPrecndCb))
            {
              SET_SDPSENTONICBCM(con);
            }
          }
        }
      }
      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
               (ogProtType == CC_BICC))
      {
        if ((con->ogPrecndCb) && (con->icPrecndCb))
        { 
          con->ogPrecndCb->mask  = con->icPrecndCb->mask;
          ccUpdatePrecndStaTblFromPeerNonMg(con, con->ogPrecndCb, FALSE);
        }
        if ((con->icPrecndCb) && (IS_PRECND_INACTION(con->icPrecndCb->flag)) &&
            (ccIsPrecndFulfillRemote(con->icPrecndCb)) &&
            IS_PRECND_COMPLETED(con->icPrecndCb->flag) && 
            CC_OFFANS_ICOFFANS_STATE_NULL(con))
        {
          CCT_RESET_SIP_SUPPORTED_PRECOND_MASK(con->icSipMethodSupMask);
          CCT_RESET_SIP_REQUIRED_PRECOND_MASK(con->icSipMethodSupMask);
          CCDP(AIN_DBG_LEVEL_1, "%s: inter-ccs reset the icSipMethodSupMask 0x%lx not precondition\n",__FUNCTION__, con->icSipMethodSupMask);
          ccClearPrecndStatus(con->ogPrecndCb);
        }
        else if (ccPrecndHasMandatoryAttr(con, con->ogPrecndCb) && 
                 !CCT_IS_PRECOND_REQUIRED(con->icSipMethodSupMask))
        {
          CCT_RESET_SIP_SUPPORTED_PRECOND_MASK(con->icSipMethodSupMask);
          CCT_SET_SIP_REQUIRED_PRECOND_MASK(con->icSipMethodSupMask);
          CCDP(AIN_DBG_LEVEL_1, "%s: inter-ccs set the icSipMethodSupMask 0x%lx to include require\n",__FUNCTION__, con->icSipMethodSupMask);
        }

        if(!CC_OFFANS_ICOFFANS_PENDING(con) && 
           !IS_PRECND_COMPLETED(con->icPrecndCb->flag))
        {
          if((CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP)) &&
             ccHasPrecndConfStatus(con->icPrecndCb))
          {
            ccEnablePrecndCb(con->icPrecndCb);
            ccTryToInsertPrecndConfStatus(con->icPrecndCb);
            ccSendUpdate(&con->icBcm);
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                           CC_OFFANS_STATE_NULL,
                                           CC_OFFANS_SUBSTATE_NULL,
                                           CC_OFFANS_TYPE_UPDATE);
          }
          else  /* changed to add else */
          {
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));
          }

          SET_PRECND_SIP2SIPREROUTE(con->ogPrecndCb->flag);
          CC_STATE_CHANGE(con, CCS_AWT_PRECONDITION);
          return ROK;
        }
        
      }

      /* FID 15068.0 */ 
      if(CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION))
      {
        if((icProtType == CC_SIP || icProtType == CC_SIPT || icProtType == CC_BICC) && 
           (ogProtType == CC_IN || 
            (ogProtType == CC_SI && ccIsOgContChkRqstd(con)!=CONTCHK_REQ) ||
            (ogProtType == CC_EXT_BICC && ccIsOgContChkRqstd(con)!=CONTCHK_REQ) ||
            (ogProtType == CC_EXT_BICC && ccIsOgContChkRqstd(con)==CONTCHK_REQ &&
             CC_IS_CALL_MULTI_MG(con) && (con->ccmCb.state == CC_INGRESS_MG) &&
             CC_IS_BCM_IN_CONTEXT(&con->ogBcm))) && /* FID17373.0 */
           !IS_PRECND_COMPLETED(con->icPrecndCb->flag))  
        {
          if (CC_OFFANS_ICRMTANS_PENDING(con))  
          {
              CCDP(AIN_DBG_LEVEL_1, "%s: Reroute happened with incoming answer not received, release call!\n",__FUNCTION__);
              ccHandleCleanUpConCb(con, TRUE, CCPRECONDFAIL);
              RETVALUE(ROKIGNORE); 
          }
          if (!CC_OFFANS_ICOFFANS_PENDING(con))
          {
            if((CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_IP_CALL_NO_INITIAL_SDP)) &&
               ccHasPrecndConfStatus(con->icPrecndCb))
            {
              ccEnablePrecndCb(con->icPrecndCb);
              ccTryToInsertPrecndConfStatus(con->icPrecndCb);
              ccSendUpdate(&con->icBcm);
              CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                             CC_OFFANS_STATE_NO_OP,
                                             CC_OFFANS_SUBSTATE_NULL,
                                             CC_OFFANS_TYPE_UPDATE);
            }
            CC_STATE_CHANGE(con, CCS_AWT_PRECONDITION);
            return ROK;
          }else if (CC_OFFANS_ICOFFER_PENDING(con))
          {
            Sdp* icLoc = NULLP;
            if(con && con->icIpParam.locDesc) 
            {
              CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068 Sending 183 OFFER to incoming side\n",__FUNCTION__);

              icLoc = con->icIpParam.locDesc; 
              ccUpdatePrecndStaTblIniNonPeer(con, con->icPrecndCb, PRECND_STRENGTH_MANDATORY, icLoc->numDecode);
              ccSend183ToInc(con);
              CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                             CC_OFFANS_STATE_NO_OP,
                                             CC_OFFANS_SUBSTATE_AWAITRMTANS_INVITENOSDP,
                                             CC_OFFANS_TYPE_REL18X_INVITENOSDP);

            
              CC_STATE_CHANGE(con, CCS_AWT_PRECONDITION);
              return ROK;
            }else
            {
              CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068 incoming leg's sdp is NULL! \n",__FUNCTION__);
            }
          }else if(CC_OFFANS_ICANS_PENDING(con))
          {
            U8 done = RFAILED;
            ccEnablePrecndCb(con->icPrecndCb);
            done = ccTryToInsertPrecndConfStatus(con->icPrecndCb);
            ccSetPrecndLocalStatus(con->icPrecndCb, PRECND_DIR_SENDRECV);

            CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068 Sending 183 ANSWER to incoming side\n",__FUNCTION__);

            ccSend183ToInc(con);
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                                   CC_OFFANS_STATE_NO_OP,
                                   CC_OFFANS_GET_SUBSTATE(con),
                                   CC_OFFANS_METHOD_USED(con));

            if(done==ROK)  {
              CC_STATE_CHANGE(con, CCS_AWT_PRECONDITION);  
              return ROK;
            }else 
            {
              CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068 Precondition has completed\n",__FUNCTION__);
              SET_PRECND_COMPLETED(con->icPrecndCb->flag);
              ccClearPrecndStatus(con->icPrecndCb);
            }
          }
          /* For re-route, send UPDATE */
        } else if((icProtType == CC_SI || icProtType == CC_IN || icProtType == CC_EXT_BICC) &&  /* FID17373.0 */
          (ogProtType == CC_SIP || ogProtType == CC_SIPT)) 
        {
          Sdp* ogLoc = NULLP;
          if(con && con->ogIpParam.locDesc) 
          {
            CCDP(AIN_DBG_LEVEL_1, "%s: FID 15068 Prepare preconditions for INVITE\n",__FUNCTION__);

            ogLoc = con->ogIpParam.locDesc; 
            ccUpdatePrecndStaTblIniNonPeer(con, con->ogPrecndCb, PRECND_STRENGTH_OPTIONAL, ogLoc->numDecode);
          }
        }
      }


      /* FID 15319.0  FID 16747.0 */
      if ( (icProtType == CC_EXT_BICC ) && 
            (CC_IS_EXTBICC_BEARERSTATE(con,CC_INCOMING,CC_BICC_STATE_RCVD_CONFWD)))
      {
         if (CC_IS_EXTBICC_FLAVOR(con,CC_INCOMING,CC_BICC_FLAVOR_FAST_FWD))
         {
              CC_SET_EXTBICC_BEARERSTATE(con,CC_INCOMING,CC_BICC_STATE_RCVD_IPBCPREQ);
              CC_STATE_CHANGE(con, CCS_BICC_AWT_MGCT_CFMNOT);
         }
         else
         {
              BiccApmUserInfo apmUserInfo;
              cmMemcpy((U8*)&apmUserInfo.hdr, (U8*)&con->icExtBiccCb->apmUsrInfoHdr, sizeof(BiccApmEncHdr));
              cmMemcpy((U8*)&apmUserInfo.data, (U8*)con->icExtBiccCb->apmUsrInfoData, sizeof(BiccApmEncData));
              BiccApmEncData  *appInfo = &apmUserInfo.data;
              CcCnStEvnt      apmEvnt;
              Sdp *sdp = NULLP;
              MediaStream_t *msPtr = NULLP;
              U8 idx;
              U8 tgtCdcIdxVal;             
              U8 orgId;
              U8 cdcType;
              U8 cdcTypeFlag;

              cmMemset((U8*)&apmEvnt, 0, sizeof(CcCnStEvnt));

              /* fill the Action Indicator based on profile & IAM's codec info */
              appInfo->actInd.pres = PRSNT_NODEF;

              /* CSD call backward 1st APM with or without single codec depends on codec list from IAM */
              if ((con->callDtlInfo.cm.tMR.pres == PRSNT_NODEF) &&
                  (con->callDtlInfo.cm.tMR.val == TMR_64KBITS))
              {
                 if (appInfo->cdcLst.pres == PRSNT_NODEF)
                 {
                    appInfo->sglCdc.pres = PRSNT_NODEF;
                    appInfo->sglCdc.orgId = OI_ITU_T;

                    if (CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb))
                    {
                       appInfo->sglCdc.cdcInfo.cdcType = CT_G711_64K_M;
                    }
                    else
                    {
                       for (idx = 0; idx < MAX_CDC_LIST; idx++)
                       {
                          tgtCdcIdxVal = con->icExtBiccCb->tgtCdcIdx[idx];
                          orgId   = appInfo->cdcLst.cdc[tgtCdcIdxVal].orgId;
                          cdcType = appInfo->cdcLst.cdc[tgtCdcIdxVal].cdcInfo.cdcType;
                          CC_MAP_CT_FLAG(orgId, cdcType, cdcTypeFlag);
                          if (CC_IS_CT_FLAG_SET(con->icExtBiccCb->tgtCdcTypeFlag, cdcTypeFlag) != 0)
                          {
                             appInfo->sglCdc = appInfo->cdcLst.cdc[tgtCdcIdxVal];
                             break;
                          }
                       }
                    }

                    if (CC_IS_EXTBICC_NOTIFY(con,CC_INCOMING))
                    {
                       appInfo->actInd.val = AI_CONFWDPNSC;
                    }
                    else
                    {
                       appInfo->actInd.val = AI_CONFWDNNSC;
                    }
                 }
                 else
                 {
                    appInfo->sglCdc.pres = NOTPRSNT;  
                    if(CC_IS_EXTBICC_NOTIFY(con,CC_INCOMING))
                    {
                       appInfo->actInd.val = AI_CONFWDPN;
                    }
                    else
                    {
                       appInfo->actInd.val = AI_CONFWDNN;
                    }
                 }
                 appInfo->cdcLst.pres = NOTPRSNT;
              }
              else
              {
                 if (CC_IS_EXTBICC_NOTIFY(con,CC_INCOMING))
                 {
                    appInfo->actInd.val = AI_CONFWDPNSC;
                 }
                 else
                 {
                    appInfo->actInd.val = AI_CONFWDNNSC;
                 }

                 /* fill the selected codec & availabel codec list if not existing */
                 appInfo->sglCdc.pres = PRSNT_NODEF;
                 appInfo->sglCdc.orgId = OI_ITU_T;
                 
                 appInfo->cdcLst.pres = PRSNT_NODEF;
                 appInfo->cdcLst.numCdcs = 1;
                 appInfo->cdcLst.cdc[0].orgId = OI_ITU_T;
    
                 if (CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb))
                 {
                    appInfo->sglCdc.cdcInfo.cdcType = CT_G711_64K_M;
                    appInfo->cdcLst.cdc[0].cdcInfo.cdcType = CT_G711_64K_M;
                 }
                 else if (con->icIpParam.locDesc)
                 {
                    sdp = con->icIpParam.locDesc;
                    msPtr = (MediaStream_t *)&sdp->p[0];
                    appInfo->sglCdc.orgId = msPtr->m.voip.codecCfg[0].orgnId.val;
                    appInfo->sglCdc.cdcInfo.cdcType = msPtr->m.voip.codecCfg[0].codecInfo.val;
                    if (appInfo->sglCdc.cdcInfo.cdcType == CTE_UMTS_AMR2)                                     
                    {
                       if (msPtr->m.voip.codecCfg[0].bitMap.pres &&
                           strlen(msPtr->m.voip.codecCfg[0].bitMap.val) == 6)
                       {
                          ccStr2Hex(appInfo->sglCdc.cdcInfo.cdcCfg, 
                                    msPtr->m.voip.codecCfg[0].bitMap.val, 3, &appInfo->sglCdc.cdcInfo.length);
                       }
                    }
                    cmMemcpy((U8 *)&appInfo->cdcLst.cdc[0], (U8 *)&appInfo->sglCdc, sizeof(Codec));
                 }
              }

              CC_SET_EXTBICC_BEARERSTATE(con,CC_INCOMING,CC_BICC_STATE_SENT_CONFWD_NOTFY);
      
              /* SEND APM */
              con->ogEvntType = CC_ET_APPTRAN;
              ccSetBiccAppTransParam(&(apmEvnt.m.siCnStEvnt.appTransParam));
              
              ccSetAppApmUserInfo(&(apmEvnt.m.siCnStEvnt), &apmUserInfo); 

              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                            con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                            con->icProtType, con->ogEvntType, (CcCnStEvnt *)(&(apmEvnt)), NULL);

              CC_STATE_CHANGE(con, CCS_BICC_AWTICBEARER);
         } 
         RETVALUE(ROK);
      }
      /* FID17373.0 */
      else if ((icProtType == CC_EXT_BICC) &&
               (CC_IS_EXTBICC_BEARERSTATE(con,CC_INCOMING,CC_BICC_STATE_WT_COT)) &&
               (con->cotBlock.contType == CC_IAM_INITIATED) &&
               (!CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
               (!CC_IS_COT_RCVD_EXT_BICC(con)))
      {
        CCDP(AIN_DBG_LEVEL_2,"%s: enter state %d for non-precondition reroute call\n", __FUNCTION__, CCS_BICC_AWTICBEARER);
        CC_STATE_CHANGE(con, CCS_BICC_AWTICBEARER);
        RETVALUE(ROK);
      }
      else if ( ogProtType == CC_EXT_BICC )
      {
          /* FID17373.0 */
          CCDP(AIN_DBG_LEVEL_2,"%s: contChkInd: %d.\n", __FUNCTION__, con->tfcDsc.nbTfcDesc.contChkInd.val);
          /* Send Bearer done to BICC layer to trigger COT sending out */
          if ((ccIsOgContChkRqstd(con) == CONTCHK_REQ) &&
              (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
              (CC_IS_CALL_MULTI_MG(con)) &&
              (IS_PRECND_COMPLETED(con->icPrecndCb->flag)))
          {
             CCDP(AIN_DBG_LEVEL_2,"%s: Need to send out COT for EXT BICC in precondition.\n", __FUNCTION__);

             CC_STATE_CHANGE(con, CCS_AWTANS);
             CcCnStEvnt biccBearerDoneCnst;
             cmMemset((U8 *)&biccBearerDoneCnst, 0, sizeof(CcCnStEvnt));

             con->ogEvntType = CC_ET_BICCBEARERDONE;

             ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                              con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                              con->ogProtType, con->ogEvntType, &biccBearerDoneCnst, NULL);
             RETVALUE(ROK);
          }
          else
          {
             ccPrepareExtBiccConReq(con);
          }
      }
      else if (ccIsRscCfmRequired(con->ogProtType) == TRUE)
      {
         CC_STATE_CHANGE(con, CCS_AWTOGRSC);
      }
      else
      {
         /* FID17174.0 For MRF-ANNC change to new state */
         if (con->mrfFlag)
         {
           CCDP(AIN_DBG_LEVEL_1, "mrfFlag %d\n", con->mrfFlag);
           CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
         }
         else
           CC_STATE_CHANGE(con, CCS_AWTANS);
      }

      /* + FID 15083.0 */
      if ((CC_IS_CALL_TAPPED(con)) && (CC_IS_X3_ALLOWED(con)) &&
          ((CC_IS_ANY_LI_TARGET_STEREO(con)))) /* FID 15083.1 */
      {
         /* As long as there is one stereo target, LI terms will be added */
         ccProcessAddLi(con, (GccCallBakFunc)ccSendConReqForOgIpCalls, 
                        (PTR) con, con->state);
      }
      else
      {
         ccSendConReqForOgIpCalls(con);
      }
      /* + FID 15083.0 */

   }
   else
   {
      CCDP(AIN_DBG_LEVEL_1, "%s: Failure processing\n", __FUNCTION__);

      if ((CC_IS_CALL_TAPPED(con)) &&
          (((CC_IS_LI_BITMASK(con, SwtchOnlyForLi)) &&
            (con->ccmCb.ccn == CCN_2)) ||
           ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_Y_MG)) ||
           ((con->ccmCb.ccn == CCN_4) && (CC_EGRESS_INTER_CCS_CALL(con)) &&
            (con->ccmCb.state == CC_EGRESS_MG)/* BUG: 80734 */ )))
      {
         if (con->ccHeldSdpForCfna)
            cmCopySdp(ccInit.region, ccInit.pool, 
                                 &con->icIpParam.rmtDesc,con->ccHeldSdpForCfna);
         CC_SET_X2ONLY(con);
         CC_CLEAR_LI_BITMASK(con,SwtchOnlyForLi); /* BUG 84329 */
         if (CC_IS_CONTEXT_PRESENT(con))
         {
           ccQSubBasedOnCcn(con);
           con->relPend = CONTINUEWITHCALLWITHOUTLI;
           CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORDP);
           con->mgBlock->con = con;
           ret = ccSendMgiQueue(0, con->mgBlock);

           if (ret != ROK) 
           {
             CCLOGERR("Error: ccSendMgiQueue failed:suCtxId = %ld,"
                      " icSu:%ld\n", con->mgBlock->mgCtx->suCtxId,
                       con->icSuConnId);
             cleanUpMgQ(con);
             ccCleanUpMGCtx(con);
           }
           RETVALUE(ROK);
         }     
         ccReconfigureCCNPostLiSub(con, TRUE); /*This will derive the CCN*/
         CCDP(AIN_DBG_LEVEL_1, "%s: set icIpParam & ogIpParam locBearerIpPort to 0\n",
                          __FUNCTION__);
         CC_SET_ZERO_BEARER_IP_PORT(&con->icIpParam.locBearerIpPort); /* FID 14341.0 */
         CC_SET_ZERO_BEARER_IP_PORT(&con->ogIpParam.locBearerIpPort); /* FID 14341.0 */

         ccCleanMgCtxFromBcm(&(con->icBcm));
         ccCleanMgCtxFromBcm(&(con->ogBcm));
         if (con->ccmCb.ccn == CCN_1)
         {
           ccInitAdj(BtOAdjBcm, &con->icAdjBcm, &con->icAdjIpParam, con, con->icBcm.mgSpId);
           ccInitAdj(BtTAdjBcm, &con->ogAdjBcm, &con->ogAdjIpParam, con, con->ogBcm.mgSpId);
         } 
         ccProcessPostAuthorizeTermination(con);

         RETVALUE(ROK);
      }
      /* Else for all other cases like CCN 3,4 or CCN5 + mg is not Y MG
         we let it fail as the normal call would also fail */
      /* - FID 15083.0 */

      /* BUG#84296 Fix the O_No_Answe TMR core issue */
      if(CC_IS_ICA_CALL(con))
      {
        ccStopConTmr(con, AIN_O_NO_ANS_TMR);
        ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
      }

      con->failCndVal  = ccGetMegacoFailCnd(con);
      /* FID 14457.0 + */
      /* If call is HPC call and MG Advanced Condition Met and either there is single MG */
      /* on the MG list used or no MG lists are provisioned or not using any MG list(s)  */
      /* and HPC-SYS MG retries is not zero and the call has not reached the maximum of  */
      /* MG retries yet, do the clean up and take a timer out, send backwards indication */
      /* of excessive delay, then retry the same MG when the timer expires.              */
      if (IS_THIS_CALL_SPECIAL_CALL(con) && 
          (!CC_IS_MAX_HPC_MG_RETRIES(con)) && 
          (CC_IS_MG_ADVANCE_COND_MET(con->failCndVal)) &&
          (
           (!CC_IS_ICMG_LIST_POPULATED(con)&&!CC_IS_OGMG_LIST_POPULATED(con)) ||
            (!CC_IS_EGRESS_MGLIST_USED(con)&&!CC_IS_INGRESS_MGLIST_USED(con)) ||
            (CC_IS_EGRESS_MGLIST_USED(con)&&(CC_NUM_MGW_ON_OGMG_LIST(con)<=1)) ||
            (CC_IS_INGRESS_MGLIST_USED(con)&&(CC_NUM_MGW_ON_ICMG_LIST(con)<=1))
          ) 
         )
      {
        /* FID 14457.0 Retry the same MG for HPC call MG */
        CCDP(AIN_DBG_LEVEL_0, "%s: HPC call retry single MG %d time(s)\n", 
                              __FUNCTION__, con->ccmCb.hpcMgRetries+1);
        if (con->ccmCb.hpcMgRetries == 0) /* Only send excessive delay for the first retry */
          ccSendBackwardMessageForCallQueued(con);
          
        /* If there is context on the single MG (including MG list with a single MG), clean up before wait */
        if (CC_IS_CONTEXT_PRESENT(con))
        {
          CCDP(AIN_DBG_LEVEL_0, "%s: Clean up MG context before MG retry\n", __FUNCTION__);
          if (!CC_IS_CALL_MULTI_MG(con) || CC_OPERATING_INGRESS_MG(con)) 
          {
            ccQSubBasedOnCcn(con);
            /* The above function calls ccUpdateMgQForSubRsc(), in some failure case */
            /* will set remoteSdpSentOnIcBCM in correctly, also fail to recover the  */
            /* incoming SDP (icIpParam.rmtDesc), check the flag, if set clear and do */
            /* recovery here.  */
            if (IS_SDPSENTONICBCM(con))
            {
               CCDP(AIN_DBG_LEVEL_0, "Reset remoteSdpSentOnIcBCM and recover rmtDesc\n");
               RESET_SDPSENTONICBCM(con);
  
               if (ccIsIPResource(&(con->icBcm)) &&
                   (con->icIpParam.rmtDesc == NULL) &&
                   (con->ccHeldRemSdpTillAns != NULL))
               {
                 cmGetCleanSdp(ccInit.region, ccInit.pool, &(con->icIpParam.rmtDesc));
                 cmCpyAndFreeSdp(ccInit.region, ccInit.pool, con->icIpParam.rmtDesc,
                                                             &(con->ccHeldRemSdpTillAns));
               }
            }
          }
          else /* Operating on Egress MG, clean up OG side */
          {
              ccQueueSubOnOGCleanUp(con);
          }

          ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
          con->relPend = OUTRELHPCMGRETRY;
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORDP);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret != ROK)
          {
            CCLOGERR("Error: MGI failed:icSu:%ld, ogSu:%ld, suCtxId:%ld,"
                          " icTransId:%ld\n", con->icSuConnId, con->ogSuConnId,
                           con->mgBlock->mgCtx->suCtxId, con->icBcm.svcHeader.transId);
            ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
            con->direction = OUTTOINC;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
            cleanUpMgQ(con);
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          }
          RETVALUE(ret);
        }

        /* Bug 88263 No context to clean up, may need to recvoer rmtDesc */
        if (ccIsIPResource(&(con->icBcm)) &&
            (con->icIpParam.rmtDesc == NULL) &&
            (con->ccHeldRemSdpTillAns != NULL))
        {
          cmGetCleanSdp(ccInit.region, ccInit.pool, &(con->icIpParam.rmtDesc));
          cmCpyAndFreeSdp(ccInit.region, ccInit.pool, con->icIpParam.rmtDesc,
                                                      &(con->ccHeldRemSdpTillAns));
          CCDP(AIN_DBG_LEVEL_0, "Failed w/o context, recover rmt SDP from ccHeldRemSdpTillAns\n");
        }

        if (con->ogRscVal) 
        {
          /* No Context to clean up, Clean up ogRsc before waiting for MG retry */
          CCDP(AIN_DBG_LEVEL_0, "No Context to clean up, Clean up ogRsc before waiting for retry\n");
              
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
        }

        con->lastState = con->state;
        ccStartConTmr(CC_TMR_HPC_MG_RETRY, con, (PTR)&ccCp);
        CC_STATE_CHANGE(con, CCS_AWTHPCMGRETRYTIMEREXPRIY);
        RETVALUE(ROK);
      }
      /* ELSE: If the call is NOT HPC CALL, or MG Advance is ON, list has more than 1  */
      /* MG, do the normal processing. This includes FID 14457.0 new functionaly of MG */
      /* Advance with Ingress MG list, and functionalities of MG Advance of Egress MG  */
      /* list, and failure processing (exhausted MG list, enough retries.              */
      else
      { 
        if ((!CC_IS_CALL_MULTI_MG(con) || CC_OPERATING_INGRESS_MG(con)) && 
            (CC_IS_ICMG_LIST_POPULATED(con)) &&
            (CC_IS_ICMG_ADVANCE(con)) &&
            (!CC_IS_MAX_ICMG_REROUTE(con)) &&
            (CC_IS_MG_ADVANCE_COND_MET(con->failCndVal)) 
           )
        {
          if (CC_IS_MGW_AVAIL_ICMG_LIST(con))
          {
              /* reroute to the next in the Ingress MG list */
            CCDP(AIN_DBG_LEVEL_0, "%s: MGWAdvance to the next MG in the Ingress MG"
                                    " list\n", __FUNCTION__);
            if (IS_THIS_CALL_SPECIAL_CALL(con))
                ccSendBackwardMessageForCallQueued(con);

            /* If there is context on the single MG or Ingress MG of Multi MG call, clean up */
            if (CC_IS_CONTEXT_PRESENT(con))
            {
              CCDP(AIN_DBG_LEVEL_0, "%s: Clean up MG context before MGWAdvance with Ingress MG" 
                                    " list\n", __FUNCTION__);
               ccQSubBasedOnCcn(con);
               /* The above function calls ccUpdateMgQForSubRsc(), in some failure case */
               /* will set remoteSdpSentOnIcBCM in correctly, also fail to recover the  */
               /* incoming SDP (icIpParam.rmtDesc), check the flag, if set clear and do */
               /* recovery here.  */
               if (IS_SDPSENTONICBCM(con))
               {
                 CCDP(AIN_DBG_LEVEL_0, "Reset remoteSdpSentOnIcBCM and recover rmtDesc\n");

                 RESET_SDPSENTONICBCM(con);

                 if (ccIsIPResource(&(con->icBcm)) &&
                     (con->icIpParam.rmtDesc == NULL) &&
                     (con->ccHeldRemSdpTillAns != NULL))
                 {
                   cmGetCleanSdp(ccInit.region, ccInit.pool, &(con->icIpParam.rmtDesc));
                   cmCpyAndFreeSdp(ccInit.region, ccInit.pool, con->icIpParam.rmtDesc,
                                                             &(con->ccHeldRemSdpTillAns));
                 }
               }

               ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
               con->relPend = OUTRELRSPANDROUTEFORICMGADVANCE;

               CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORDP);
               con->mgBlock->con = con;
               ret = ccSendMgiQueue(0, con->mgBlock);
               if (ret != ROK)
               {
                 CCLOGERR("Error: MGI failed:icSu:%ld, ogSu:%ld, suCtxId:%ld,"
                          " icTransId:%ld\n", con->icSuConnId, con->ogSuConnId,
                           con->mgBlock->mgCtx->suCtxId, con->icBcm.svcHeader.transId);
                 ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
                 con->direction = OUTTOINC;
                 if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
                 ccDeallocateResource(con, CC_OUTGOING);
                 con->ogRscVal = FALSE;
                 cleanUpMgQ(con);
                 ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
               }
               RETVALUE(ret);
            }

            if (con->ogRscVal) 
            {
              /* No Context to clean up, Clean up ogRsc before ReRoute */
              CCDP(AIN_DBG_LEVEL_0, "No Context to clean up, Clean up ogRsc before ReRoute\n");
              con->direction = OUTTOINC;
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
              ccDeallocateResource(con, CC_OUTGOING);

              con->ogRscVal = FALSE;
            }

            ccReRouteCall(con, CC_INGRESS_MG);
            RETVALUE(ROK);
          }
          else
          {
              CCDP(AIN_DBG_LEVEL_0, "MGW List exhausted for Ingress MG list\n");
              con->failCndVal = FC_MG_RLIST_EXHAUST;
          }
        }  /* End of MG Advance for Ingress MG List */
        else

      /* FID 14457.0 - */
/* + FID 14732.0 */
        if (!(CC_INGRESS_INTER_CCS_CALL(con)) &&
            (CC_IS_EGRESS_MGLIST_USED(con)) &&  /* FID 15261.0 */
            (CC_IS_MG_ADVANCE(con)) &&
            (CC_IS_MG_ADVANCE_COND_MET(con->failCndVal)) &&
            (!CC_IS_MAX_MG_REROUTE(con)) &&
            (icRealIcProtType != CC_CS_TG))
        {
          /* Explanation of IF condition above
             1. Egress CCS passes failure condition and ingress does the reroute
             2. ReRoute attempt is done only if MG advance is on for that route
                and MG advance condition is met  else we will go to treatment.
             3. We use the treatment as per megaco failure if Max MG Reroute
                is reached when MG advance feature is on.
             4. For cas of isdn we dont support the MGWlist, so all these
                calls are not tried for the multiple MGW list (There is code
                in ccRegisterInterCCS* function that routes incoming CS and IN
                calls to the same MG for outgoing SIP or SIPT
           */
          if (CC_IS_MGW_AVAIL_MG_LIST(con))
          {
              /* reroute to the next in the MG list */
              CCDP(AIN_DBG_LEVEL_0, "%s: MGWAdvance to the next MG in the MG"
                                    " list\n", __FUNCTION__);
            if (IS_THIS_CALL_SPECIAL_CALL(con))
                ccSendBackwardMessageForCallQueued(con);

              ccReRouteCall(con, CC_EGRESS_MG);
              RETVALUE(ROK);
          }
          else
          {
              CCDP(AIN_DBG_LEVEL_0, "MGW List exhausted for this route"
                                    " playing treatment\n");
              con->failCndVal = FC_MG_RLIST_EXHAUST;
          }
        }  /* End of MG Advance for Egress MG List processing */
      }
      
      CCDP(AIN_DBG_LEVEL_1, "Stop early ACM timer and dequeue the event if buffered\n");
      ccStopConTmr(con, CC_TMR_EARLYACM);
      ccDeleteBufferedEvent(con, con->icSuConnId, CCE_EARLYACMTMREXP);

      /* Check to see if this is RemoteCallTransfer CCID (13) */
      /* If so, treat this as diconnect on leg-2 */
      if((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup))
      {
        ccSendODisconnect(&con->icBcm, 2);
        RETVALUE(ROK);
      }

      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccStopConTmr(con, TMR_SETUP);

        ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
        }
        else
        {
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
          con->mgBlock->con = con;
          con->relPend = NORELANDINFAILCOND;
          RETVALUE(ROK);
        }
      }

      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
      if(con->failCndVal != FC_NOT_APPLICABLE)
      {
        ccProcessFailCnd(con, con->failCndVal, TRUE);
        RETVALUE(ROK);
      }
      /* This is an internal switch error, what tone should be played */
      ccPlayToneOrRelease(con, CCTMPFAIL);
      RETVALUE(RFAILED);
   }

   RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S28
 *
 *      Desc:  Connection state function
 *             event - SETUP expiry
 *             state - AWTOGSWTCFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S28
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    /* Wait for switch confirmation to clear the call */
    ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
               LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    con->relPend = ICRELONLY;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);
    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE30SXX
 *
 *      Desc:  Connection state function
 *             event - Buffer (of Queued events) Timer Expiry.
 *             state - 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE30SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE30SXX:%ld,%ld,%ld\n", con->icSuConnId,
                        con->ogSuConnId, (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
#ifdef ZC

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
    cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_KILL_CALL;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer(); 
  }
#endif
  ccKillCallOnThisCon(con);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE25S30
 *
 *      Desc:  Connection state function
 *             event - 
 *             state - 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/

PRIVATE S16 ccConE25S30
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if(con->ogRscVal)
  ccDeallocateResource(con, CC_OUTGOING);

  CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
  ccDeallocateResource(con, CC_INCOMING);
  RETVALUE(ROK);
}
   

/*
*
*      Fun:   ccConE31S04
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - AWTRSCALOCCFM
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S04
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  TRC3(ccConE31S04)

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);
#ifdef CC_CALEA
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }
#endif

  ccStopConTmr(con, TMR_INTERDGT);
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Delete the mgi-context from the con */
  ccCleanUpMGCtx(con);

  CC_STATE_CHANGE(con, CCS_AWTRSCCFM_TOCLR);

#endif /* PENDING */
  RETVALUE(ROK);
} /* ccConE31S04 */


/*
*
*      Fun:   ccConE31S10
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - ANSWERED
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE31S10:%ld,%ld,%ld\n", con->icSuConnId,
                        con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
#ifdef ZC
  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
    cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_KILL_CALL;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
  }
#endif
  ccKillCallOnThisCon(con);
#endif /* PENDING */
  RETVALUE(ROK);
} /* ccConE31S10 */


/*
*
*      Fun:   ccConE31S09
*
*      Desc:  Connection state function
*             event - SFT release indication
*             state - CCS_AWTBUSYREL_IC
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  MgitInd        *mgitInd     = NULLP;
  S16             ret         = RFAILED;
  ODisconnect_t   oDisconnect;
  SvcHeader_t     header;
  U8              index          = 0;
#ifdef ZC                
  ZcUpdParam upd;
#endif /* ZC */
  Bool            notIndFlag     = FALSE;

  CCDP(AIN_DBG_LEVEL_1, "ccConE31S09:%ld,%ld,%ld\n", con->icSuConnId,
                         con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  mgitInd     = (MgitInd *) event;

  if (mgitInd->type == MGIT_ANN_COMPLETE_IND)
  {
    if ((con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ||
        (con->icBcm.nel[EReqODisconnect] == NEL_NOTIFY))
    {
      if (con->icBcm.svcHeader.transId)
      {
        cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
        cmMemset((U8 *)&oDisconnect, 0, sizeof(ODisconnect_t));
        /* Store legId */
        if (con->icBcm.cc)
        {
          if (con->icBcm.cc->ccId >= CiThreePartySetup)
            con->ainInfo.legId = 2;
          else
            con->ainInfo.legId = 1;
        }
        else
          con->ainInfo.legId = 1;

        /* Bug# 18104 */
        ccUpdateccId(&(con->icBcm.cc->ccId), con->ainInfo.legId);

        CCDP(AIN_DBG_LEVEL_2, "LegId disconnected:%d\n",
                              con->ainInfo.legId);
        ccFillSvcHeader(&header, &(con->icBcm), MSG_O_Disconnect);
        CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

        notIndFlag = (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ?
                      FALSE: TRUE;

        ccFillODisconnectParam(&oDisconnect, &(con->icBcm), notIndFlag);
        CCDP(AIN_DBG_LEVEL_0," Filled O_Disconnect, TransID=%ld\n",
             header.spTransId);

        /* Bug# 11386 */
        if (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST)
        {
           /* Cleaning up the NEL as per R5-241 GR1298 */
           for (index = 0; index < EReqMax; index++)
           {
               con->icBcm.nel[index] = NEL_UNARMED;
           }

           /* Send the msg as it is not needed to be buffered */
           con->lastState = con->state;
           CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE9);
           ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                              CCS_CANNOTPROCESSEVENTS);
           CcUiFctODisconnect(&oDisconnect, &header);
           RETVALUE(ROK);
        }
        else
        {
           CCDP(AIN_DBG_LEVEL_0, "Disconnect Notification:%d\n",
                con->icBcm.nel[EReqODisconnect]);
           CcUiFctODisconnect(&oDisconnect, &header);
        }
      }
      else
      {
        CCLOGERR("Error: transId is zero:%ld,%ld\n", con->icSuConnId,
                                                   con->ogSuConnId);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "Cleaning up the call anyways:%ld,%ld\n",
                            con->icSuConnId, con->ogSuConnId);
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccStopConTmr(con, AIN_O_NO_ANS_TMR);
        ccStopConTmr(con, AIN_T_NO_ANS_TMR);
        /* STOP the AWAIT ANSWER Timer if running
         *
         * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
         */
        ccStopConTmr(con, CC_TMR_AWAITANS); 
        ccStopConTmr(con, TMR_SETUP);
        ccStopConTmr(con, TMR_RELEASE);
        ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
        ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
        upd.icSuConnId = con->icSuConnId;
        zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif

        ccQSubBasedOnCcn(con);  /* FID 15261.0 */

        if ((con->icRscVal) && (con->ogRscVal))
        {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
        }
        else if (con->icRscVal)
        {
          con->relPend = ICRELONLY;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }
        else if (con->ogRscVal)
        {
          con->relPend = OGRELONLY;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }
        else
        {
          con->lastState = 0;
          con->relPend = NORELANDNORELRSP;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }

        con->mgBlock->con = con;
        ret = ccSendMgiQueue(0, con->mgBlock);
        if (ret == ROK)
          RETVALUE(ROK);
        CCDP(AIN_DBG_LEVEL_4, "ERROR, reached end of if statement\n");
      }

      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);

      ccStopConTmr(con, AIN_O_NO_ANS_TMR);
      ccStopConTmr(con, AIN_T_NO_ANS_TMR);
      /* STOP the AWAIT ANSWER Timer if running
       *
       * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
       */
      ccStopConTmr(con, CC_TMR_AWAITANS); 
      ccStopConTmr(con, TMR_SETUP);
      ccStopConTmr(con, TMR_RELEASE);
      ccStopConTmr(con, CC_TMR_SUSP);
      ccStopConTmr(con, CC_TMR_TMDREL);
      ccStopConTmr(con, TMR_BUSY_TONE);
      ccStopConTmr(con, TMR_RECONNECT);
      ccStopConTmr(con, CC_TMR_CALLDTL_STATS);
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
      ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif

      if ((con->icRscVal) && (con->ogRscVal))
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCCALLCLR, NULL);
      }
      else if (con->icRscVal)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
      }
      else if (con->ogRscVal)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCCALLCLR, NULL);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
      RETVALUE(ROK);
    }
  }
  else if (mgitInd->type == MGIT_SVC_CHANGE_IND)
  {
    CCDP(AIN_DBG_LEVEL_1, "ccConE31S10:%ld,%ld,%ld\n", con->icSuConnId,
                          con->ogSuConnId, 
                          (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
    /* Replication is not done, as this happens before we replicate
     * the CS2 to the standby, the relcon's and the other, disc leg,
     * and merge calls will take care of this */
    ccKillCallOnThisCon(con);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Invalid mgitInd->type:%d, %ld, %ld\n", mgitInd->type,
                                    con->icSuConnId, con->ogSuConnId);
    RETVALUE(RFAILED);
  }
#endif /* PENDING */

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  RETVALUE(ROK);
} /* ccConE31S10 */

/*
*
*      Fun:   ccConE31SFICRSP
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - Awaiting some FIC response.
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31SFICRSP
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  MgitInd        *mgitInd     = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE31SFICRSP:%ld,%ld,%ld\n", con->icSuConnId,
                         con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
  mgitInd     = (MgitInd *) event;

  if (mgitInd->type == MGIT_SVC_CHANGE_IND)
  {
    CC_STATE_CHANGE(con, CCS_AWT_FIC_RSP_TO_KILL);
    RETVALUE(ROK);
  }
  else if (mgitInd->type == MGIT_ANN_COMPLETE_IND)
  {
    ABORT_DEBUG;
    CCLOGERR("Error: Unexpected message, %ld, %ld, %d\n",
             con->icSuConnId, con->ogSuConnId, con->state);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Error: Unexpected type , %ld, %ld, %d, %d\n",
             con->icSuConnId, con->ogSuConnId, con->state, mgitInd->type);
    RETVALUE(ROK);
  }
#endif /* PENDING */
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE31S41
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - CCS_AWTRSPFORDPE11 - Awaiting O-MidCall.
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S41
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  MgitInd        *mgitInd     = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE31S41:%ld,%ld,%ld\n", con->icSuConnId,
                         con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
  mgitInd     = (MgitInd *) event;

  if (mgitInd->type == MGIT_SVC_CHANGE_IND)
  {
    CC_STATE_CHANGE(con, CCS_AWT_FIC_RSP_TO_KILL);
    RETVALUE(ROK);
  }
  else if (mgitInd->type == MGIT_ANN_COMPLETE_IND)
  {
    ccBufferEventToQueue(con, bcm, event, CCE_MGCTSVCCHGIND, sizeof(MgitInd), 0,
                         NULLP, 0);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Error: Unexpected type , %ld, %ld, %d, %d\n",
             con->icSuConnId, con->ogSuConnId, con->state, mgitInd->type);
    RETVALUE(ROK);
  }
#endif /* PENDING */
  RETVALUE(ROK);
}



/*
*
*      Fun:   ccConE31S2X
*
*      Desc:  Connection state function
*             event - SFT release indication           
*             state - 
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S2X
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  TRC3(ccConE31S2X)

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

  /* Stop timer, Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

#ifdef CC_CALEA
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }
#endif
  ccStopConTmr(con, TMR_INTERDGT);
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
   
  /* Delete the mgi-context from the con */
  ccCleanUpMGCtx(con);

  if(con->ogRscVal == TRUE)
  {
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
  }

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL, NULL);

#endif /* PENDING */
  RETVALUE(ROK);
}  /* ccConE31S2X */


/*
*
*      Fun:   ccConE31S20
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - CCS_AWTSWTCFM_TOCLR
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S20
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  CCLOGERR("ccConE31S20: Got MGI Indication. Not waiting for MgiTxnCfm:%lx\n",
           con->icSuConnId);

#ifdef CC_CALEA
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }
#endif
  switch(con->relPend)
  {
        case ICRELONLY:
          if(con->ogRscVal == TRUE)
            ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;

          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          break;

        case OGRELONLY:
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          break;

        case INRELRSPANDOUTREL:
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_INCOMING);
#else
          ccDeallocateResource(con, CC_INCOMING);
#endif
          con->icRscVal = FALSE;
          break;

        case OUTRELRSPANDINREL:

          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
          ccDeallocateResource(con, CC_OUTGOING);
#endif
          con->ogRscVal = FALSE;
          break;

        case BOTHREL:
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
          break;

        case OUTRELRSPANDNOREL:
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
          break;

        case INRELRSPANDNOREL :
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          /* outgoing resource is to be released here */
          /* This happens if outGoing SS7 call gets released in state-28 */
          /* Its better that we check the state of the ogRscVal */
          if(con->ogRscVal == TRUE)
           ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;

          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
          break;

        case INRELRSPANDOUTRELRSP:

          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          if( con->direction == INCTOOUT)
            con->direction = OUTTOINC;
          else
            con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
          break;

        default :
          CCLOGERR( "ERROR : not supporting this relPend==%d\n",
              con->relPend);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL,NULL);

          if(con->ogRscVal == TRUE)
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCTMPFAIL,NULL);
          }
          break;
  }

#endif /* PENDING */
  RETVALUE(ROK);
} /* ccConE31S20 */


/*
 *
 *      Fun:   ccConE31S3X
 *
 *      Desc:  Connection state function
 *             event - SFT event indication           
 *             state - 
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S3X
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
  TRC3(ccConE31S3X)

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  /* Stop timer, Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);
#ifdef CC_CALEA
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }
#endif

  ccStopConTmr(con, TMR_INTERDGT);
  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
   
  /* Delete the mgi-context from the con */
  ccCleanUpMGCtx(con);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId, 
                con->icProtType, CCTMPFAIL, NULL);

  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL, NULL);

#endif /* PENDING */
  RETVALUE(ROK);
}
  

/*
*
*      Fun:   ccConE31S5X
*
*      Desc:  Connection state function
*             event - SFT event indication           
*             state - 
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S5X
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
  TRC3(ccConE31S5X)

#ifndef TELICA_MGI_MEGACO    
    /* Send Sft Release Repsonse */
    (Void)CcLiSftRelRsp(&con->sfSapCb->pst, con->sfSapCb->spId,
                        con->icSuConnId, (SwtchIdxTkn *)event);
#endif /* TELICA_MGI_MEGACO */  
  ccStopConTmr(con, CC_TMR_CALLDTL);
  con->relPend = INITRELPEND;
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

#endif /* PENDING */
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE31S52
*
*      Desc:  Connection state function
*             event - SFT event indication
*             state - 
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE31S52
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  /* stop the timer */
  ccStopConTmr(con, CC_TMR_SUSP);

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  CCDP(AIN_DBG_LEVEL_3, "ccConE31S52: call is released. MGI wants to do so\n");
#ifdef CC_CALEA
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con);
  }
#endif

  /* Delete the mgi-context from the con */
  ccCleanUpMGCtx(con);

  /* Release the call */
  ccStopConTmr(con, CC_TMR_CALLDTL);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

#ifdef ZC
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL, NULL);

  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                con->ogProtType, CCTMPFAIL, NULL);

#endif /* PENDING */
  RETVALUE(ROK);
} /* ccConE31S52 */


/*
 *
 *      Fun:   ccConE31S6X
 *
 *      Desc:  Connection state function
 *             event - SFT event indication           
 *             state - 
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/

PRIVATE S16 ccConE31S6X
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* PENDING */

  TRC3(ccConE31S4X)

    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifndef TELICA_MGI_MEGACO    
  /* Send Sft Release Repsonse */
  (Void)CcLiSftRelRsp(&con->sfSapCb->pst, con->sfSapCb->spId,
                      con->icSuConnId, (SwtchIdxTkn *)event);
#endif /* TELICA_MGI_MEGACO */
  /* Stop timer, Send release to outgoing side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_DEALOC_IND, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
   
  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId, 
                con->ogProtType, CCTMPFAIL, NULL);
 

#endif /* PENDING */
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S31
 *
 *      Desc:  Connection state function
 *             event - RELEASE timer expired
 *             state - Waiting for delete from the Active side in case of FT/HA environment
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
        File:  cc_bdy2.c
 *
 */

PRIVATE S16 ccConE15S31
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  TRC3(ccConE15S31)

   if (zcCb.protState == ACTIVE)
   {
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

     /* bug:21795 : special treatment for CAS removed */
     if(con->icRscVal && con->ogRscVal)
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
       ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                   con->icProtType, CCTMPFAIL, NULL);
       ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                 con->ogProtType, CCTMPFAIL, NULL);
     }
     else if(con->icRscVal)
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                   con->icProtType, CCTMPFAIL, NULL);
     }
     else if(con->ogRscVal)
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
       ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                 con->ogProtType, CCTMPFAIL, NULL);
     }
     else
     {
       CC_STATE_CHANGE(con, CCS_IDLE);
       ccRelCon(con);
       RETVALUE(ROK);
     }
   }
   else /* We are still standby */
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  RETVALUE(ROK);

} /* End of ccConE15S31() */



 
 
/*
*
*      Fun:   ccConE04S32
*
*      Desc:  Connection state function
*             event - Cct Release Indication 
*             state - CCS-LOCALLYANSWERED
*
*             This function procesess the Release Indication received
*             when the Call Control State Machine is in the LOCALLY ANSWERED
*             state. This is the case when the switch termninates a call.
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S32
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16        ret       = RFAILED;
  Bool       mgiSent   = FALSE;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE04S32:%ld,%ld,%ld\n", con->icSuConnId,
                        con->ogSuConnId, 
                        (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));

  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  ccStopConTmr(con, CC_TMR_TST_LN_DSC);
  ccRmvCon100Tmr(con, CC_TST_100_SLNC_TMR);
  ccRmvCon100Tmr(con, CC_TST_102_SLNC1_TMR);
  ccRmvCon100Tmr(con, CC_TST_102_SLNC2_TMR);
#ifdef ZC
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif    
  con->icEvnt = (CcAllSdus *) event;

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* FID 1915  Cleanup for a Test Line call */
    if (con->tstLnCb != NULLP)
    {
      CCDP(AIN_DBG_LEVEL_1, "ccConE04S32:Administer testLineType:%d\n", 
                             con->tstLnCb->testLineType);
      SPutSBuf(ccInit.region, ccInit.pool, con->tstLnCb,
               (Size) sizeof(CcTstLnCb_t));
    } /* End if Test line */
if (con->callDtlInfo.cm.timevalStart.event)
{
        struct tm     res;
       U32   elapsed;    /* seconds from call connect till NOW */
        oal_gmtime_r (&res, &con->callDtlInfo.cm.timevalStart.tv_sec);
CCDP(AIN_DBG_LEVEL_1,"ccConE04S32:callDtlInfo.timevalStart.event=%d %04d %02d %02d %02d:%02d:%02d.%d UTC\n",
            con->callDtlInfo.cm.timevalStart.event,
            res.tm_year + 1900, res.tm_mon + 1, res.tm_mday,
            res.tm_hour, res.tm_min, res.tm_sec,
            con->callDtlInfo.cm.timevalStart.tenths);

    /* calculate current elapsed time.  This will be about zero for a
       new call, but will be non-zero when a standby syncs to an active */
    /* subtract connect time from current time to get current elapsed */
    SGetSysTime (&elapsed);
    if (con->callDtlInfo.cm.tckOgConCfmRcvd.pres == PRSNT_NODEF) 
    {
        elapsed = (elapsed - con->callDtlInfo.cm.tckOgConCfmRcvd.val) / 10;
    } 
    else if (con->callDtlInfo.cm.tckIcConRspSent.pres == PRSNT_NODEF) 
    {
        elapsed = (elapsed - con->callDtlInfo.cm.tckIcConRspSent.val) / 10;
    } 
   else 
   {
       CCDP(AIN_DBG_LEVEL_1,"ccConE04S32 elapsed time = %ld\n",elapsed); 
    }
       CCDP(AIN_DBG_LEVEL_1,"ccConE04S32 elapsed time = %ld\n",elapsed); 

}


    ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
    con->relPend = INRELRSPANDNOREL;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
    con->mgBlock->con = con; 
    ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    if (ret == ROK)
      mgiSent = TRUE;
    else
    {
      CCLOGERR("Error: ccSendMgiQueue failed:suCtxId = %ld, icSu:%ld\n",
               con->mgBlock->mgCtx->suCtxId, con->icSuConnId);
      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);
    }
  }
  if (!mgiSent)
  {
    ccSendReleaseRsp(con);
    CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
#ifdef GUARD_TIMER /* aambika - Bugzilla 3187 - Guard Timer */
    ccGuardOrDeallocResource(con, CC_INCOMING);
#else
    ccDeallocateResource(con, CC_INCOMING);
#endif
  }
  RETVALUE(ROK);
}


/* Start AIS TOPS */
/* Route Info: Cause value and Telica defined Ident */

PUBLIC S16 ccChangeRouteDigits ( U16 protocol_type, CcRouteInfo *routeInfo, S16  cause_val, U16 coding_standard)
{
  LngAddrs iBuf;
  ShrtAddrs bcdBuf;
  U32 i;

  TRC3(ccChangeRouteDigits)
    //KMM        CCLOGERR( "ccChangeRouteDigits ()\n");
  
    iBuf.length = sprintf (iBuf.strg, "%d", cause_val);

  /* Routing digits for cause value should be three digits */
  if (iBuf.length == 1)
    {
      iBuf.length = 3;
      iBuf.strg[2] = iBuf.strg[0];
      iBuf.strg[0] = '0';
      iBuf.strg[1] = '0';

    }
  else if (iBuf.length == 2)
    {
      iBuf.length = 3;
      iBuf.strg[2] = iBuf.strg[1];
      iBuf.strg[1] = iBuf.strg[0];
      iBuf.strg[0] = '0';
    }

  routeInfo->nmbDigits = iBuf.length;

        
  /* Convert from IA5 to BCD and copy in route event */
  //    for (i=0; i < event->cdPtyNmb.nmbDigits.len; i++)
  //      iBuf.strg[i] = event->cdPtyNmb.nmbDigits.val[i];
  //    iBuf.length = event->cdPtyNmb.nmbDigits.len;
      
  cmAscHexAdrToBcd(&iBuf, &bcdBuf);
      
  for (i=0; i<bcdBuf.length; i++)
    routeInfo->addr.strg[i] = bcdBuf.strg[i];
  
  routeInfo->addr.length = iBuf.length;
  /* Swap the route digits as per the E.164 representation */
  ccSwapDigits(&(routeInfo->addr));
      
  routeInfo->addrInd = CC_CDPTY;
  routeInfo->numPlan = CC_ISDNNUM;
  if( protocol_type == CC_RELPROTO_ISDN && coding_standard == CSTD_CCITT)
    {
      CCLOGERR("inter CC_REL_INCCITT\n");
      routeInfo->ident = CC_REL_INCCITT;
    }        
  else if( protocol_type == CC_RELPROTO_ISUP && coding_standard == CSTD_CCITT)
    {
      CCLOGERR("inter CC_REL_INCCITT\n");
      routeInfo->ident = CC_REL_ISCCITT;
    }
  else if( protocol_type == CC_RELPROTO_ISDN && coding_standard == CSTD_NAT)
    {
      routeInfo->ident = CC_REL_INNAT;
    }
  else if( protocol_type == CC_RELPROTO_ISUP && coding_standard == CSTD_NAT)
    {
      routeInfo->ident = CC_REL_ISNAT;
    }
  /* Added the CAS check as a part of the bug#12690 */ 
  else if ((protocol_type == CC_RELPROTO_CAS) && 
           (coding_standard == CSTD_CCITT)) 
    {
      routeInfo->ident = CC_REL_INCCITT;
    }
  else if ((protocol_type == CC_RELPROTO_CAS) && 
           (coding_standard == CSTD_NAT)) 
    {
      routeInfo->ident = CC_REL_INNAT;
    }
    
  RETVALUE(ROK);
}


PUBLIC S16 ccChangeCalledDigits ( CcConCb      *con,   /* connection */
                                  CcAllSdus    *event, /* Connection Event */
                                  S16          msgID,
                                  U16           send_called_number)
{
  ProtType protType;
  TRC3(ccChangeCalledDigits)

  protType = CC_GET_PROTOCOL(con->icProtType);
  switch (protType)
    {
    case CC_SI:
    case CC_EXT_BICC:
      ccChangeNBCalledDigits(&event->m.ccConEvnt.m.siConEvnt.cdPtyNum, msgID, send_called_number);
      break;

    case CC_IN:
      ccChangeINCalledDigits(con, &event->m.ccConEvnt.m.inConEvnt.cdPtyNmb, msgID, send_called_number);
      break;


    case CC_CS_LN:
    case CC_CS_TG:
    case CC_GR303:
      ccChangeINCalledDigits(con, &event->m.ccAddrCfmEvnt.m.casCctEvnt.cdPtyNmb, msgID, send_called_number);
      break;

    case CC_SIP:
      ccChangeNBCalledDigits(&event->m.ccConEvnt.m.sipConEvnt.cdPtyNum, msgID, send_called_number);
      break;

    case CC_MGCP_LN:
    case CC_MGCP_TG:
        ccChangeINCalledDigits(con, &event->m.ccAddrCfmEvnt.m.mgcpCctEvnt.cdPtyNmb, msgID, send_called_number);
        break;

    }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccChangeNBCalledDigits
*
*      Desc:  Add the route Digits to the NB CC connection event
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_isup.c
*
*/
PUBLIC S16 ccChangeNBCalledDigits
(
 SiCdPtyNum *cdPtyNum,
 S16          msgID,
 U16 send_called_number
)
{
  LngAddrs iBuf;
  ShrtAddrs bcdBuf;  
  U32 i;
  if ( msgID != -1) // ANN ID need to pass in outgoing message */
    iBuf.length = sprintf (iBuf.strg, "%d", msgID);
  else
    iBuf.length=0;


  
  cdPtyNum->addrSig.pres = PRSNT_NODEF;

  if (msgID != -1 && send_called_number == 0)
    { /* Only ANN need to pass in outgoing Called Party Number */
      /* Convert from IA5 to BCD and copy in route event */
      cmAscHexAdrToBcd(&iBuf, &bcdBuf);
      /* Swap the route digits as per the E.164 representation */
      ccSwapDigits((Addrs *)&(bcdBuf));

      for (i=0; i<bcdBuf.length; i++)
        cdPtyNum->addrSig.val[i] = bcdBuf.strg[i];
 
      if (iBuf.length % 2 == 0)
        {
          cdPtyNum->oddEven.pres = PRSNT_NODEF;
          cdPtyNum->oddEven.val = 0;
          cdPtyNum->addrSig.len = iBuf.length/2;
        }
      else
        {
          cdPtyNum->oddEven.pres = PRSNT_NODEF;
          cdPtyNum->oddEven.val = 1;
          cdPtyNum->addrSig.len = iBuf.length/2 + 1;
          cdPtyNum->addrSig.val[cdPtyNum->addrSig.len - 1] &= 0x0f;
        }
    }
  else if (msgID != -1)
    { 
      /* Both ANN and Incoming Called party Number Passed in Outgoing 
       * Called Party Number */
      if(send_called_number == 7 && cdPtyNum->addrSig.len==5)
        {
          for(i=0; i < 3; i++)
            {
              cdPtyNum->addrSig.val[i] = 
                ((((cdPtyNum->addrSig.val[i+1]) & 0xf0) >> 4) |
                 (((cdPtyNum->addrSig.val[i+2]) & 0x0f) << 4)
                 );
            }
          cdPtyNum->addrSig.val[i] = 
            (cdPtyNum->addrSig.val[i+1] & 0xf0) >> 4;

          cdPtyNum->oddEven.val = NMB_ODD;
          cdPtyNum->addrSig.len=4;
                
            
           
        }

      if(! (iBuf.length & 0x01)) /* Prefix is even */
        {
          U8 bcdLength = iBuf.length >> 1;
          for (i = cdPtyNum->addrSig.len; i>0; i--)
            {
              cdPtyNum->addrSig.val[i+bcdLength-1] =
                cdPtyNum->addrSig.val[i-1];
            }
          /* Add the digits now */

          for (i = 0; i <  bcdLength; i++)
            {
               U8 digit1, digit2;

               CM_ASCII_TO_BCD(iBuf.strg[2*i], digit1);
               CM_ASCII_TO_BCD(iBuf.strg[2*i+1], digit2);

              cdPtyNum->addrSig.val[i] = (digit2 << 4) | digit1;
            }

          cdPtyNum->addrSig.len += bcdLength;

        }
      else if (cdPtyNum->oddEven.val == NMB_ODD)
        {
          U8 bcdLength = iBuf.length >> 1;
          U8 digit0;

          /* odd -> even */
          cdPtyNum->oddEven.val = NMB_EVEN;
          for (i = cdPtyNum->addrSig.len; i>1; i--)
            {
              cdPtyNum->addrSig.val[i+bcdLength-1] =
                ((cdPtyNum->addrSig.val[i-1] & 0x0f) << 4) |
                ((cdPtyNum->addrSig.val[i-2] & 0xf0) >> 4);
            }

          CM_ASCII_TO_BCD(iBuf.strg[bcdLength*2], digit0);

          cdPtyNum->addrSig.val[bcdLength] =
             ((cdPtyNum->addrSig.val[0] & 0x0f) << 4) | digit0;

          for (i = 0; i < bcdLength; i++)
            {
             U8 digit1, digit2;
             
             CM_ASCII_TO_BCD(iBuf.strg[2*i], digit1);
             CM_ASCII_TO_BCD(iBuf.strg[2*i+1], digit2);

              cdPtyNum->addrSig.val[i] = (digit2 << 4) | digit1;
            }
          cdPtyNum->addrSig.len += bcdLength;
        }
      else
        {
          U8 bcdLength = (iBuf.length >> 1) + 1;
          U8 digit0;

          CCDP(AIN_DBG_LEVEL_2, "EVEN=>ODD\n");

          /* even -> odd */
          cdPtyNum->oddEven.val = NMB_ODD;

          for (i = 0; i < bcdLength; i++)
            cdPtyNum->addrSig.val[(cdPtyNum->addrSig.len) + i] = 0;

          for (i = cdPtyNum->addrSig.len; i>0; i--)
            {

              cdPtyNum->addrSig.val[i+bcdLength-1] =
                ((cdPtyNum->addrSig.val[i-1] & 0xf0) >> 4) |
                ((cdPtyNum->addrSig.val[i] & 0x0f) << 4);
            }
          bcdLength--;

          CM_ASCII_TO_BCD(iBuf.strg[bcdLength*2], digit0);

          cdPtyNum->addrSig.val[bcdLength] =
             ((cdPtyNum->addrSig.val[0] & 0x0f) << 4) | digit0;
            
          for (i = 0; i < bcdLength; i++)
            {
               U8 digit1, digit2;

               CM_ASCII_TO_BCD(iBuf.strg[2*i], digit1);
               CM_ASCII_TO_BCD(iBuf.strg[2*i+1], digit2);

               cdPtyNum->addrSig.val[i] = (digit2 << 4) | digit1;
            }

          cdPtyNum->addrSig.len += bcdLength + 1;
        }

    }
  else
    { /* nothing to do: pass same called party number as received */
    }

  RETVALUE(ROK);
}


/*
*
*      Fun:   ccChangeINCalledDigits
*
*      Desc:  Add the route Digits to the IN CC connection event
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_isdn.c
*
*/
PUBLIC S16 ccChangeINCalledDigits ( CcConCb      *con, 
                                    CdPtyNmb     *cdPtyNmb,
                                    S16          msgID,
                                    U16           send_called_number)
{
  LngAddrs iBuf;
  U32 i;

  TRC3(ccChangeINCalledDigits)

  if (msgID != -1 && send_called_number == 0)
  {   
    CCLOGERR( "enter msgId != 0 and send_called_number =0\n");
    cdPtyNmb->nmbDigits.len = sprintf (cdPtyNmb->nmbDigits.val,
        "%d", msgID);
  }
  else if (msgID != -1)
  {
      CCDP(AIN_DBG_LEVEL_2, "enter msgId != 0 and send_called_number =1\n");
      iBuf.length = sprintf (iBuf.strg, "%d", msgID);
      CCDP(AIN_DBG_LEVEL_2, "Length Prefix =%d\n", iBuf.length);
      if (send_called_number == 7 && cdPtyNmb->nmbDigits.len == 10)
      {
          cdPtyNmb->nmbDigits.len = 7;
          cdPtyNmb->typeNmb0.val = TON_SUB;
          for(i=0; i < 7; i++)
            cdPtyNmb->nmbDigits.val[i] = 
              cdPtyNmb->nmbDigits.val[i+3];
      }
      for (i=cdPtyNmb->nmbDigits.len; i; i--)
      {
          cdPtyNmb->nmbDigits.val[i-1+iBuf.length] = 
            cdPtyNmb->nmbDigits.val[i-1];
      }
      /* Add the prefix digits now */
      for (i=0; i < iBuf.length; i++)
        {
          cdPtyNmb->nmbDigits.val[i] = iBuf.strg[i];
        }

      cdPtyNmb->nmbDigits.len += iBuf.length;
   
      CCDP(AIN_DBG_LEVEL_2, "Length=%d\n", cdPtyNmb->nmbDigits.len);
  }
  else
  { 
    /* Nothing to do : pass only received called party number */
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE04S33
*
*      Desc:  Connection state function
*             event - CCE_RELIND
*             state - CCS_AWTSWTCFMFORSVC
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S33
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S33 : %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE11S33
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFMFORSVC
*      This function is implement to offload some functionality from AWTSWTCFM.
*      For few services GCC would wait in this state for a resposne from 
*      MGI.
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S33
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *othercon       = NULLP;
  MgctTxnCfm       *txnCfm         = NULLP;
  S16               ret            = RFAILED;
  msgValBcmTypeEnum bcmType        = BtMax; /* Controller in othercon */
  msgValCcIDEnum    prev_ccId      = CiInvalid;
  Bool              mgiSent        = FALSE;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CC_CALEA
  U8 alertingType = CltMax;
  S16 caleaRet = RFAILED;
#endif

#ifdef CC_BUFFER_EVENT
  U8                relDisBool     = RFAILED;
  U8                evntType       = 0;
  ProtType          conIcProtType  = 0;
  ProtType          conOgProtType  = 0;
#endif /* CC_BUFFER_EVENT */

  txnCfm   = (MgctTxnCfm*) event;
  ret = ccHandleMgResponse(con, txnCfm);          
  if (ret != ROK)
  {
    CCLOGERR( "ccHandleResponse Failed:%ld\n", con->icSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);

  }
#ifdef CALEA_3WC
  /* Process any CALEA release when waiting in CCS_AWTSWTCFMFORSVC */ 
    /* Case when Calea subReq are sent along with Tapped Sub's Signal_DATA request */
    if (con->mgiPendRelRsp)
    {
       CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S33\n");
       ccProcessCaleaMgiSubRsp(con, FALSE);
       con->mgiPendRelRsp = 0;
    }
    if (con->mgiPendAddRsp)
    {
       CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S33\n");
       ccProcessCaleaMgiAddRsp(con, FALSE);
       con->mgiPendAddRsp = 0;
    }
    if (con->mgiPendRelReq)
    {
       ccProcessPendingCaleaMgiRelReq(con);
       con->mgiPendRelReq = 0;
       /* Send the Mg Queue. */
       /* Stay in the same state */
       con->mgBlock->con = con;
       ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
       if (ret != ROK)
       {
         CCLOGERR("Error: ccSendMgiQueue failed icSu 0x%lx\n",
                  con->icSuConnId);
         cleanUpMgQ(con);
         ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       }
       RETVALUE(ROK);
    }
#endif

  if ((con->lastState == CCS_AWTRSPFORDPE9)  ||
      (con->lastState == CCS_AWTRSPFORDPE28) ||
      (con->lastState == CCS_ANSWERED))
  {
    CCDP(AIN_DBG_LEVEL_0, "ccConE11S33:CWT case:reconnect or a CT case\n");
    if (con->reconnectBcm == OBCM)
    {
      if (con->icBcm.cc->legId01 == &(con->icBcm))
      {
        /* con is CS 2 and othercon is CS 1 */
        othercon      = con->icBcm.cc->legId02->con;
        bcmType       = con->icBcm.cc->legId02->bcmType;
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
      ccPostEventToSelf (con);
#endif /* 1 */ 
      }
      else if (con->icBcm.cc->legId02 == &(con->icBcm))
      {
        /* con is CS 1 and othercon is CS 2 */
        othercon = con->icBcm.cc->legId01->con;
        bcmType = con->icBcm.cc->legId01->bcmType;
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(con->icBcm.cc->legId01);
      ccPostEventToSelf (con);
#endif /* 1 */ 
      }
      else
      {
        CCLOGERR( "Unexpected condition:%ld\n", con->icSuConnId);
        RETVALUE(ROK);
      }
      prev_ccId = con->icBcm.cc->ccId;
      con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->icBcm));

      othercon->icEvnt     = othercon->ccEvntHold;
      othercon->direction  = INCTOOUT;
      othercon->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

      CCDP(AIN_DBG_LEVEL_0, "Re-Connect to icSu=%ld\n", othercon->icSuConnId);

      ccPostEventToSelf (othercon);
      CC_STATE_CHANGE(othercon, CCS_AWTANS);
      ccStartConTmr(TMR_RECONNECT, othercon, (PTR)&ccCp.genCfg);

      othercon->reconnectBcm = OBCM; /* Does not matter if O/T as we just
                                        use it when we get a response */
      /* Find out where the controller is in the othercon IC/OG? */
      if (bcmType == BtOBcm)
      {
        /* Re-assign the Call Config */
        othercon->icBcm.cc->ccId    = CiStable2Party;
        othercon->icBcm.cc->legId01 = &(othercon->icBcm);
        othercon->icBcm.cc->legId1  = &(othercon->ogBcm);
        othercon->icBcm.cc->legId02 = NULLP;
        othercon->icBcm.cc->legId2  = NULLP;

        ccReconnectBearer(&(othercon->icBcm), &(othercon->ogBcm), NULLP, NULLP,
                          othercon->state);
#ifdef CALEA_3WC
        if ((othercon->icBcm.nel[EReqNetworkSignal] == NEL_NOTIFY) &&
            (othercon->icBcm.svcHeader.transId != 0))
        {
           alertingType = ccSetAlertingType(con);
           ccSendNetworkSignalMsg(othercon, FC_SIG_ALERTING, alertingType,0,0,
                                  CC_INCOMING);
        }
        else
        {
           CCDP(AIN_DBG_LEVEL_1,"NetworkSignal Notifn. is not set for OBCM\n");
        }
#endif
      }
      else /* It has to be BtTBcm */
      {
        /* Re-assign the Call Config */
        othercon->ogBcm.cc->ccId    = CiStable2Party;
        othercon->ogBcm.cc->legId01 = &(othercon->ogBcm);
        othercon->ogBcm.cc->legId1  = &(othercon->icBcm);
        othercon->ogBcm.cc->legId02 = NULLP;
        othercon->ogBcm.cc->legId2  = NULLP;

        /* Bug#15674, rkhan */
        ccUpdSts(con->icSapCb,con->ogSapCb);

        /* FID 14457.0 + */
        if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
        {
          ccUpdGetsSts(con->ogProtType, CC_OUTGOING);
        } /* FID 14457.0 - */

        ccReconnectBearer(&(othercon->ogBcm), &(othercon->icBcm), NULLP, NULLP,
                          othercon->state);
#ifdef CALEA_3WC
        if ((othercon->ogBcm.nel[EReqNetworkSignal] == NEL_NOTIFY) &&
            (othercon->ogBcm.svcHeader.transId != 0))
        {
           alertingType = ccSetAlertingType(con);
           ccSendNetworkSignalMsg(othercon, 0,0,FC_SIG_ALERTING, alertingType,
                                  CC_OUTGOING);
        }
        else
        {
           CCDP(AIN_DBG_LEVEL_1,"NetworkSignal Notifn. is not set for TBCM\n");
        }
#endif
      }
      if ((prev_ccId == CiThreePartySetup) ||
          ((prev_ccId == CiPartyOnHold) &&
           (con->ogBcm.bcmType == BtMax)))
      {
        CCDP(AIN_DBG_LEVEL_0, "Reconnect Done in ccId:%d, %ld\n",
                              prev_ccId, con->icSuConnId);
        /* As there is no LegId2, we can just clean up CS2 con */
        ccRelCon(con);
        RETVALUE(ROK);
      }
      
      ret = ccProcessDisconnectOnSpecificBCM (&(con->ogBcm));
#ifdef CC_CALEA
      /* we must not send the DisconnectNofn for the CaleaLegs of 
       * controller as they will be moved into CS1, but the surrogate 
       * LEAs must be released*/ 
      if (con->surrogate != NULLP) 
         ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
      if (ret == ROK)
      {
        /* This is when the BCM is also involved in a MParty Call */
        /* The related action will be taken in the response function */
        CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the TBCM of"
                              " the connection\n");
        RETVALUE(ROK);
      }
#ifdef CC_CALEA
      /* The passive leg is not involved in MParty Call */
      caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                                 event);
      if (caleaRet != ROK)
      {
         CCDP(AIN_DBG_LEVEL_4,
         "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
      } 
#endif
      /* ELSE do normal Release handling */
      ccStopConTmr(con, CC_TMR_CALLDTL);
      if (con->keepGCCCallInfo == FALSE)
      {
      con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
      }
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      con->tempHolderForReleaseCause = CCCALLCLR;
      
      if (con->ogRscVal)
      {
        relDisBool = ccCheckRelOrOnHookInBuffer(&(con->ogBcm), &evntType);
        if (relDisBool == ROK)
        {
          conOgProtType = CC_GET_PROTOCOL(con->ogProtType);
          if ((conOgProtType == CC_BI) || (conOgProtType == CC_SI) ||
              (conOgProtType == CC_IN) || (conOgProtType == CC_SIP))
            con->relPend                   = OUTRELRSPANDNOREL;
          else /* Bug# 17883 */
            con->relPend                   = OGRELONLY;

          ccDeleteBufferedEvent(con, con->ogSuConnId, evntType);
        }
        else
          con->relPend                   = OGRELONLY;
        con->tempHolderForReleaseCause = CCCALLCLR;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      }
      else
      {
        con->relPend                   = NORELANDNORELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
      }
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR( "MGI Operation failed:%ld\n", con->mgBlock->mgCtx->suCtxId);
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        mgiSent = TRUE;
      
      if (!mgiSent)
      {
        ccSendReleasesOnBothSidesWithSwitching(con, CCNORMUNSPEC);
      }
      else
      {
#ifdef ZC
        upd.icSuConnId = con->icSuConnId;
        zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif
      }
      RETVALUE(ROK);
    }
    else if (con->reconnectBcm == TBCM)
    {
      if (con->ogBcm.cc->legId01 == &(con->ogBcm))
      {
        /* con is CS 2 and othercon is CS 1 */
        othercon      = con->ogBcm.cc->legId02->con;
        bcmType       = con->ogBcm.cc->legId02->bcmType;
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
      ccPostEventToSelf (con);
#endif /* 1 */ 
      }
      else if (con->ogBcm.cc->legId02 == &(con->ogBcm))
      {
        /* con is CS 1 and othercon is CS 2 */
        othercon      = con->ogBcm.cc->legId01->con;
        bcmType       = con->ogBcm.cc->legId01->bcmType;
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(con->ogBcm.cc->legId01);
      ccPostEventToSelf (con);
#endif /* 1 */ 
      }
      else
      {
        CCLOGERR( "Unexpected condition:%ld\n", con->icSuConnId);
        RETVALUE(ROK);
      }
      con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->ogBcm));

      othercon->icEvnt     = othercon->ccEvntHold;
      othercon->direction  = INCTOOUT;
      othercon->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

      CCDP(AIN_DBG_LEVEL_0, "Re-Connect to icSu=%ld\n", othercon->icSuConnId);

      ccPostEventToSelf (othercon);
      CC_STATE_CHANGE(othercon, CCS_AWTANS);
      ccStartConTmr(TMR_RECONNECT, othercon, (PTR)&ccCp.genCfg);

      othercon->reconnectBcm = TBCM; /* Does not matter if O/T as we just
                                        use it when we get a response */
      /* Find out where the controller is in the othercon IC/OG? */
      if (bcmType == BtOBcm)
      {
        /* Re-assign the Call Config */
        othercon->icBcm.cc->ccId    = CiStable2Party;
        othercon->icBcm.cc->legId01 = &(othercon->icBcm);
        othercon->icBcm.cc->legId1  = &(othercon->ogBcm);
        othercon->icBcm.cc->legId02 = NULLP;
        othercon->icBcm.cc->legId2  = NULLP;

        ccReconnectBearer(&(othercon->icBcm), &(othercon->ogBcm), NULLP, NULLP,
                          othercon->state);
#ifdef CC_CALEA
        if ((othercon->icBcm.nel[EReqNetworkSignal] == NEL_NOTIFY) &&
            (othercon->icBcm.svcHeader.transId != 0))
        {
           alertingType = ccSetAlertingType(con);
           ccSendNetworkSignalMsg(othercon, FC_SIG_ALERTING, alertingType,0,0,
                                  CC_INCOMING);
        }
        else
        {
           CCDP(AIN_DBG_LEVEL_1,"NetworkSignal Notifn. is not set for OBCM\n");
        }
#endif

      }
      else /* It has to be BtTBcm */
      {
        /* Re-assign the Call Config */
        othercon->ogBcm.cc->ccId    = CiStable2Party;
        othercon->ogBcm.cc->legId01 = &(othercon->ogBcm);
        othercon->ogBcm.cc->legId1  = &(othercon->icBcm);
        othercon->ogBcm.cc->legId02 = NULLP;
        othercon->ogBcm.cc->legId2  = NULLP;

        /* Bug#15674, rkhan */
        ccUpdSts(con->icSapCb,con->ogSapCb);

        /* FID 14457.0 + */
        if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
        {
          ccUpdGetsSts(con->ogProtType, CC_OUTGOING);
        } /* FID 14457.0 - */

        ccReconnectBearer(&(othercon->ogBcm), &(othercon->icBcm), NULLP, NULLP,
                          othercon->state);
#ifdef CC_CALEA
        if ((othercon->ogBcm.nel[EReqNetworkSignal] == NEL_NOTIFY) &&
            (othercon->ogBcm.svcHeader.transId != 0))
        {
           alertingType = ccSetAlertingType(con);
           ccSendNetworkSignalMsg(othercon, 0,0,FC_SIG_ALERTING, alertingType,
                                  CC_OUTGOING);
        }
        else
        {
           CCDP(AIN_DBG_LEVEL_1,"NetworkSignal Notifn. is not set for TBCM\n");
        }
#endif

      }

      ret = ccProcessDisconnectOnSpecificBCM (&(con->icBcm));
      if (ret == ROK)
      {
        /* This is when the BCM is also involved in a MParty Call */
        /* The related action will be taken in the response function */
        CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the OBCM of the"
                              " connection\n");
        RETVALUE(ROK);
      }
      /* Passive leg is not in MPartyCall */
#ifdef CC_CALEA
      caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->icBcm), 
                                                                 event);
      if (caleaRet != ROK)
      {
         CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs FAILED\n");
      } 
#endif
      /* ELSE do normal Release handling */
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      con->tempHolderForReleaseCause = CCCALLCLR;
      
      if (con->icRscVal)
      {
#ifdef CC_BUFFER_EVENT
        relDisBool = ccCheckRelOrOnHookInBuffer(&(con->icBcm), &evntType);
        if (relDisBool == ROK)
        {
          conIcProtType = CC_GET_PROTOCOL(con->icProtType);
          if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->icBcm, conIcProtType))
            con->relPend                   = INRELRSPANDNOREL;
          else
            con->relPend                   = ICRELONLY;

          ccDeleteBufferedEvent(con, con->icSuConnId, evntType);
        }
        else
          con->relPend                   = ICRELONLY;
#endif /* CC_BUFFER_EVENT */
        con->tempHolderForReleaseCause = CCCALLCLR;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      }
      else
      {
        con->relPend                   = NORELANDNORELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
      }
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR( "MGI Operation failed:%ld\n", con->mgBlock->mgCtx->suCtxId);
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        mgiSent = TRUE;
      
      if (!mgiSent)
      {
        ccSendReleasesOnBothSidesWithSwitching(con, CCNORMUNSPEC);
      }
      else
      {
#ifdef ZC
        upd.icSuConnId = con->icSuConnId;
        zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif
      }
      RETVALUE(ROK);
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "CT FEATURE: %ld, %ld, %d\n", con->icSuConnId,
                             con->ogSuConnId, con->reconnectBcm);
      if (con->keepGCCCallInfo == FALSE)
      {
      con->callDtlInfo.cm.callState = LCC_CDR_ANSWERED;
      }
      con->tmdRelApplied = CC_CHECK_TMD_RELEASE;
      CC_STATE_CHANGE(con, CCS_ANSWERED);
      RETVALUE(ROK);
    }
  }
  else if (con->lastState == CCS_AWTRSPFORDPE11)
  {
    CCDP(AIN_DBG_LEVEL_0, "ccConE11S33:CTX case:Move Leg case\n");

    if (con->ogBcm.pic == PicTActive)
    {
      CC_STATE_CHANGE(con, CCS_ANSWERED);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTANS);
    }

    RETVALUE(ROK);
  }
  else if (con->lastState == CCS_AWTRSPFORDPE27)
  {
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
    CCDP(AIN_DBG_LEVEL_0, "ccConE11S33:CWT case:Move Leg case\n");
    ccHandleMGIResponseForMoveLeg(&(con->ogBcm));
    RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0, "Not Supported\n");
    CC_STATE_CHANGE(con, con->lastState);
    RETVALUE(ROK);
  }
}


/*
*
*      Fun:   ccConE11S66
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFMCONFTONE
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: This is used for Playing tone for calls which have callOnHold.
*             As there is a possiblility of a conference , GCC needs to
*             play the annoucement throught MGI.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S66
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  MgctTxnCfm       *txnCfm         = NULLP;
  S16               ret            = RFAILED;
  CcConCb          *CSID1con       = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S66:\n");
  txnCfm   = (MgctTxnCfm*) event;
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  ret = ccHandleMgResponse(con, txnCfm);          
  if (ret != ROK)
  {
    CCLOGERR( "ccHandleResponse Failed:%ld\n", con->icSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);

  }

  if (ccIsIPSubscriber(&(con->icBcm)))
  {
    MgcpCctEvnt_t     *mgcp       = NULLP;
    CcAllSdus          ogEvnt;
  
    mgcp = &(ogEvnt.m.ccCnStEvnt.m.mgcpCctEvnt);
    INITEVENT(mgcp, sizeof(MgcpCctEvnt_t));
    mgcp->evntType = CC_CCT_EVNT_TYPE_CNSTREQ;
    mgcp->mode.pres = PRSNT_NODEF;
    mgcp->mode.val = MGCT_MODE_SENDRECV;

    ccFillProtSdp(ccInit.region, ccInit.pool, &con->icBcm,
                  &mgcp->sdp);
    ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCMGCP_ET_MODIFY_CONNECTION,
                  &(ogEvnt.m.ccCnStEvnt), NULLP);

  }

  CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);
  ccStopConTmr(con, TMR_SETUP);
#ifdef CC_BUFFER_EVENT
  if ( ccCheckForCallOnHold(&(con->icBcm)) == ROK )
  {
    CSID1con = con->icBcm.cc->legId1->con;
    if (CSID1con)
      ccPostEventToSelf (CSID1con);
  }
  ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE11S67
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFMFORSPLIT3WC
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: 
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S67
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                        mgret          = RFAILED;
  S16                        ret            = RFAILED;
  msgValCcIDEnum             prev_ccId      = CiInvalid;
  msgValBcmTypeEnum          bcmType        = BtMax;
  AinBCM_t                  *legId1         = NULLP;
  AinBCM_t                  *legId2         = NULLP;
  AinBCM_t                  *legId01        = NULLP;
  AinBCM_t                  *legId02        = NULLP;
  MgctTxnCfm                *txnCfm         = NULLP;
  CcConCb                   *CSID1con       = NULLP;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED;
#endif
#ifdef CC_BUFFER_EVENT
  U8                relDisBool     = RFAILED;
  U8                evntType       = 0;
  Bool              releaseNeeded  = FALSE;
#endif /* CC_BUFFER_EVENT */

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S67:%ld\n", con->icSuConnId);

#ifdef ZC
  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam)); 
#endif /* ZC */

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR("ERROR: cc is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  legId1    = con->icBcm.cc->legId1;
  legId2    = con->icBcm.cc->legId2;
  legId02   = con->icBcm.cc->legId02;
  legId01   = con->icBcm.cc->legId01;
  prev_ccId = con->icBcm.cc->ccId;

  if ((legId1 == NULLP) || (legId2 == NULLP) || (legId02 == NULLP) ||
      (legId01 == NULLP))
  {
    CCLOGERR("ERROR: legId is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  /*CID 15585*/
  bcmType   = legId02->bcmType;
  CSID1con = legId1->con;

  txnCfm   = (MgctTxnCfm*) event;
  mgret = ccHandleMgResponse(con, txnCfm);

  /* Bug 71118 remove source here since this logic caused ccHandleCleanUpConCb()
   * can't runtime update standby CCS CcConCb with CC_DISCONNECT.
   */
  /* Bug71748 move back bug71118's codes and send CC_DISCONNECT to standby */
  if (mgret!= ROK)
  {
#ifdef ZC
     if (CC_IS_OBCM_PIC_ACTIVE(con))
     {
      upd.featMsg.ccAinUpdType = CC_DISCONNECT;
      upd.featMsg.suConnId     = con->icSuConnId;
      upd.featMsg.DlegId       = 0;
      upd.featMsg.nel          = con->icBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
     }
#endif /* ZC */
    legId01->cc->ccId    = CiStable2Party;
    legId01->cc->legId1  = legId2;
    legId01->cc->legId2  = NULLP;
    legId01->cc->legId02 = NULLP;
    legId02->cc          = NULLP;
  }
  if (mgret == RFAILED)
  {
    CCLOGERR( "ERROR: Response Handling FAILED\n");
    if ((prev_ccId == CiTransfer) || (prev_ccId == CiRemoteTransferSetup))
    {
      if (CC_IS_CALL_MULTI_MG(con))
         ccDeleteLegId1FromCon2MgCtx(legId1, con->icAdjBcm); /*bug 90781*/
      else
         ccDeleteLegId1FromCon2MgCtx(legId1, legId2); /*bug 90369*/
    }
    cleanUpMgQ(CSID1con);
    ccHandleCleanUpConCb(CSID1con, TRUE, CCTMPFAIL);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  else if (mgret == RNOCONF)
  {
#if 1 /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
    CCDP(AIN_DBG_LEVEL_2, "Killing first half of the Conf\n");
    ccHandleCleanUpConCb(CSID1con, TRUE, CCTMPFAIL);

    ret = ccProcessDisconnectOnSpecificBCM (&(con->ogBcm));
#ifdef CALEA_3WC
    /* we must not send the DisconnectNofn for the CaleaLegs of 
     * controller as they will be moved into CS1, but the surrogate 
     * LEAs must be released*/
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif

    if (ret == ROK)
    {
      /* If event is armed , we would process this disconnect and
       * the con will be cleaned up in that function */
      RETVALUE(ROK);
    }
    else
    {
#ifdef CALEA_3WC
      /* The passive leg is not involved in MParty Call */
      caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                                 event);
      if (caleaRet != ROK)
      {
         CCDP(AIN_DBG_LEVEL_4,
         "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs"
         " FAILED\n");
      }
#endif

/************************CLEAN UP THE CS2 CALL******************************/
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif
      if ((con->icRscVal) && (con->ogRscVal))
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCTMPFAIL, NULL);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCTMPFAIL, NULL);
      }
      else if (con->icRscVal)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCTMPFAIL, NULL);
      }
      else if (con->ogRscVal)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCTMPFAIL, NULL);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
      RETVALUE(ROK);
    }
  }
  else /* It should be ROK */
  {
    if (con->lastState == CCS_AWTRSPFORDPE11)
    {
      /******************Split due to a disconnect leg******************/
#ifdef ZC
      /* Do the replication stuff */
      /**************************REPLICATION****************************/
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));
        upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_DISCONNECTLEG_WITH_SPLIT;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
      /**********************ACT ON DISCONNECT LEG *********************/
      ccToggleCC6CtrlHashList(&con->icBcm);
      if (bcmType == BtOBcm)
      {
    /************************CHANGE OWNER OF RESOURCE ******************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld,%ld\n",
                    CSID1con->icSuConnId, con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }
      }
      else
      {
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld,%ld\n",
                     CSID1con->ogSuConnId, con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }
      }
      /***ReConnect to CAS-SP with appropriate CONNECTION direction**/
      if (!ccIsIPSubscriber(&(CSID1con->ogBcm)) && (bcmType == BtTBcm))
      {
        ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId,
                      &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                      CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                      CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG,
                      NULLP, NULLP);
      }

#if 1 /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
      /**************Call Configuration*******************/
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId2  = NULLP;
      con->icBcm.cc          = NULLP;

      /**********************PROPAGATE DISCONNECT TO OG*****************/
      ret = RFAILED;
      if (con->ogBcm.bcmType == BtTBcm)
      { 
        ret = ccProcessDisconnectOnSpecificBCM(&(con->ogBcm));
#ifdef CALEA_3WC
        /* we must not send the DisconnectNofn for the CaleaLegs of 
         * controller as they will be moved into CS1, but the surrogate 
         * LEAs must be released*/ 
        if (con->surrogate != NULLP)
           ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
      }
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "Detected Disconnect on OG:%ld,%ld,%ld\n",
                              con->icSuConnId, con->ogSuConnId,
                              con->ogBcm.svcHeader.transId);
        RETVALUE(ROK);
      }
      else
      {
#ifdef CALEA_3WC
         /* The passive leg is not involved in MParty Call */
         caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                               event);
         if (caleaRet != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
                 "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
#endif

#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));
          upd.icSuConnId = con->icSuConnId;
          zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif
        /********************CHECK BUFFER FOR REL AND ON-HOOK*************/
#ifdef CC_BUFFER_EVENT
        relDisBool = ccCheckRelOrOnHookInBuffer(&(con->ogBcm), &evntType);
        if (relDisBool == ROK)
        {
          ccDeleteBufferedEvent(con, con->ogSuConnId, evntType);
          if (ccFindIfReleaseOrRelRspNeeded(&(con->ogBcm)) == ROK)
            releaseNeeded = TRUE;
        }
#endif /* CC_BUFFER_EVENT */
        /*************************CLEAN UP CS2****************************/
        ret = RFAILED;
        if (CC_IS_CONTEXT_PRESENT(con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
          ccStopConTmr(con, CC_TMR_CALLDTL);
          ccStopConTmr(con, AIN_O_NO_ANS_TMR);
          ccStopConTmr(con, AIN_T_NO_ANS_TMR);
          /* STOP the AWAIT ANSWER Timer if running
           *
           * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
           */
          ccStopConTmr(con, CC_TMR_AWAITANS); 
          ccStopConTmr(con, TMR_BUSY_TONE);
          ccStopConTmr(con, TMR_RECONNECT);
          ccStopConTmr(con, TMR_RELEASE);
          ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
          ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          con->lastState = con->state;
          if (con->ogRscVal)
          {
#ifdef CC_BUFFER_EVENT
            if ((relDisBool == ROK) && (releaseNeeded == FALSE))
            {
              con->tempHolderForReleaseCause = CCCALLCLR;
              con->relPend = OUTRELRSPANDNOREL;
              CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
            }
            else
            {
              con->tempHolderForReleaseCause =
                                          CS_RELREQ_EVENT_ALLOW_REORIGINATION;
              CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
              con->relPend = OGRELONLY;
            }
#endif /* CC_BUFFER_EVENT */
          }
          else
          {
            CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
            con->relPend = NORELANDNORELRSP;
          }
          ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
          if (ret == ROK)
          {
            CCDP(AIN_DBG_LEVEL_0, "MGI Operation Success:%ld,%ld,%ld\n",
                 con->icSuConnId, con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
            /* We dont need a MGI context if the remaining call CS2 is
             * and On-net call */ 
            ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                           CSID1con->state, FALSE);
            RETVALUE(ROK);
          }
          else
          {
            cleanUpMgQ(con);
            CCLOGERR("ERROR:MGI Operation FAILED:%ld,%ld,%ld\n", con->icSuConnId,
                              con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
          }
        }
        if (ret != ROK) 
        {
          if (con->ogRscVal)
          {
#ifdef CC_BUFFER_EVENT
          if ((relDisBool == ROK) && (releaseNeeded == FALSE))
          {
            con->direction = OUTTOINC;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(con, CC_OUTGOING);
          }
          else
          {
            ccStopConTmr(con, TMR_SETUP);
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
            ccSendRelease( con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                           con->ogProtType, CS_RELREQ_EVENT_ALLOW_REORIGINATION,
                           NULLP );
          }
#endif
          }
          else
          {
            ccRelCon(con);
          }
          /* We dont need a MGI context if the remaining call CS2 is
           * and On-net call */ 
          ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                         CSID1con->state, FALSE);
          RETVALUE(ROK);
        }
        CCLOGERR("ERROR: Control should never reach here:%ld,%ld,%ld\n",
                         con->icSuConnId, con->ogSuConnId,
                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
        RETVALUE(ROK);
      }
    }
    else
    {
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));
        upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_WITH_SPLIT;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (legId1->mgCtx ? legId1->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (legId2->mgCtx ? legId2->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */

      if (con->icBcm.cc->ccId == CiTransfer)
         ccDisconnectCallInCC11(con, TRUE, event);
      else
         ccDisconnectCallInCC10(con, TRUE, event);
      RETVALUE(ROK);
    }
  }
}


/*
*
*      Fun:   ccConE11S69
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFMFORMERGEINCC4
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes:
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S69
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                        mgret          = RFAILED;
  S16                        ret            = RFAILED;
  msgValBcmTypeEnum          bcmType        = BtMax;
  AinBCM_t                  *legId1         = NULLP;
  AinBCM_t                  *legId2         = NULLP;
  AinBCM_t                  *legId01        = NULLP;
  AinBCM_t                  *legId02        = NULLP;
  MgctTxnCfm                *txnCfm         = NULLP;
  CcConCb                   *CSID1con       = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S69:%ld\n", con->icSuConnId);
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR("ERROR: cc is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  legId1    = con->icBcm.cc->legId1;
  legId2    = con->icBcm.cc->legId2;
  legId02   = con->icBcm.cc->legId02;
  legId01   = con->icBcm.cc->legId01;

  if ((legId1 == NULLP) || (legId2 == NULLP) || (legId02 == NULLP) ||
      (legId01 == NULLP))
  {
    CCLOGERR("ERROR: legId is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  /*CID 15587*/
  bcmType   = legId02->bcmType;
  CSID1con = legId1->con;

  txnCfm   = (MgctTxnCfm*) event;
  mgret = ccHandleMgResponse(con, txnCfm);
  if (mgret != ROK)
  {
    CCLOGERR("ERROR: MGI Response failed:%d, icSu:%ld, ogSu:%ld\n", mgret,
             con->icSuConnId, con->ogSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  if ((legId02->con) && (legId02->con->mgBlock))
    legId02->con->mgBlock->con = legId02->con;

  if (bcmType == BtOBcm)
  {
    ccToggleCC6CtrlHashList(&con->icBcm);
/*********CHANGE OWNER OF RESOURCE AND UPDATE CallConfiguration***************/
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                             RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->icRscVal = TRUE;
    }

    CSID1con->icBcm.cc->ccId    = CiStable2Party;
    CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
    CSID1con->icBcm.cc->legId02 = NULLP;
    CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
    CSID1con->icBcm.cc->legId2  = NULLP;
    con->icBcm.cc = NULLP;
    CC_CLEAN_FIC_TXN(&(con->icBcm));
    if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
      ccSendCnStReq(CSID1con, CSID1con->icSapCb->suId,
                    &CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                    CSID1con->icSpConnId, CSID1con->icSuConnId,
                    CSID1con->icProtType, CS_CONN_STATUS_RECONNECT_IC,
                    NULLP, NULLP);
  }
  else
  {
    ccToggleCC6CtrlHashList(&con->icBcm);
/*********CHANGE OWNER OF RESOURCE AND UPDATE CallConfiguration***************/
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                           RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                CSID1con->ogSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->ogRscVal = TRUE;
    }

    CSID1con->ogBcm.cc->ccId    = CiStable2Party;
    CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
    CSID1con->ogBcm.cc->legId02 = NULLP;
    CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
    CSID1con->ogBcm.cc->legId2  = NULLP;
    con->icBcm.cc = NULLP;
    CC_CLEAN_FIC_TXN(&(con->icBcm));

    if (!ccIsIPSubscriber(&(CSID1con->ogBcm)))
      ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId,
                    &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                    CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                    CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG,
                    NULLP, NULLP);
  }
  CC_STATE_CHANGE(CSID1con, CCS_ANSWERED);
#ifdef CC_BUFFER_EVENT
  /* Move Buffered events from CS2 to CS1 */
  ccMoveBufferedEvents(con, CSID1con);
#endif /* CC_BUFFER_EVENT */
/*############################################################################*/
      if (CC_IS_CCID_CC10_AND_ABOVE(legId1))
        ccCreateOnSwitchBearer((legId02), NULLP, NULLP, NULLP,
                               CSID1con->state, FALSE);
      else
      ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                     CSID1con->state, FALSE);
/*############################################################################*/
    CC_STATE_CHANGE(con, CCS_IDLE);
    ccRelCon(con);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE11S70
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFM_MERGEINCC6IC
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes:
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S70
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                        mgret          = RFAILED;
  S16                        ret            = RFAILED;
  msgValBcmTypeEnum          bcmType        = BtMax;
  AinBCM_t                  *legId1         = NULLP;
  AinBCM_t                  *legId2         = NULLP;
  AinBCM_t                  *legId01        = NULLP;
  AinBCM_t                  *legId02        = NULLP;
  MgctTxnCfm                *txnCfm         = NULLP;
  CcConCb                   *CSID1con       = NULLP;
  ProtType                   icProtType     = 0;
  ProtType                   ogProtType     = 0;
  State                      tempState      = CCS_IDLE;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S70:%ld\n", con->icSuConnId);
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR("ERROR: cc is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  legId1    = con->icBcm.cc->legId1;
  legId2    = con->icBcm.cc->legId2;
  legId02   = con->icBcm.cc->legId02;
  legId01   = con->icBcm.cc->legId01;

  if ((legId1 == NULLP) || (legId2 == NULLP) || (legId02 == NULLP) ||
      (legId01 == NULLP))
  {
    CCLOGERR("ERROR: legId is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  bcmType   = legId02->bcmType;
  CSID1con  = legId02->con;
  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));

  txnCfm   = (MgctTxnCfm*) event;
  mgret = ccHandleMgResponse(con, txnCfm);

  /* FID 15261.0 + */
  if (CC_IS_CALL_MULTI_MG(con))
  {
    if (con->ccmCb.mgPend)
      con->ccmCb.mgPend--;

    if (mgret != ROK)
    {
      con->ccmCb.flags |= CC_MG_SUB_ERROR;
    }

    if (con->ccmCb.mgPend)
    {
      RETVALUE(ROK);
    }
  }
  /* FID 15261.0 - */

  if ((mgret != ROK) || (con->ccmCb.flags & CC_MG_SUB_ERROR))
  {
    CCLOGERR("ERROR: MGI Response failed:%d, icSu:%ld, ogSu:%ld\n", mgret,
             con->icSuConnId, con->ogSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));

  if (con->icBcm.cc->ccId == CiRemoteTransferSetup)
  {
    ccProcessMCForRemTrfStp(&con->icBcm);
    RETVALUE(ROK);
  }

  if (con->ainInfo.legId == 2)
  {
#ifdef ZC
    if (CC_IS_OBCM_PIC_ACTIVE(con))
    {
      upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
      upd.featMsg.DlegId       = 2;
      upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->icBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
    ccToggleCC6CtrlHashList(&con->icBcm);
/******************************************************************************/
    if (bcmType == BtOBcm)
    {
/***************************BCM OPERATION*********************************/
      CSID1con->icBcm.cc->ccId    = CiStable2Party;
      CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
      CSID1con->icBcm.cc->legId02 = NULLP;
      CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
      CSID1con->icBcm.cc->legId2  = NULLP;
      con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->icBcm));
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(con, CSID1con);
      /* There may be a event sitting on CSID1con Event Buffer */
      ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      tempState = CSID1con->state;
      CC_STATE_CHANGE(CSID1con, CCS_CANNOTPROCESSEVENTS);

      ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (ret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
      }
      else
      {
        con->icRscVal      = FALSE;
        CSID1con->icRscVal = TRUE;
      }
      CC_STATE_CHANGE(CSID1con, tempState);
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
      if (con->ogRscVal)
      {
        ogProtType = CC_GET_PROTOCOL(con->ogProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->ogBcm, ogProtType))
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCCALLCLR, NULL);
        }
        else
        {
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_OUTGOING);
        }
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
    }
    else
    {
/***************************BCM OPERATION*********************************/
      CSID1con->ogBcm.cc->ccId    = CiStable2Party;
      CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
      CSID1con->ogBcm.cc->legId02 = NULLP;
      CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
      CSID1con->ogBcm.cc->legId2  = NULLP;
      con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->icBcm));
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(con, CSID1con);
      /* There may be a event sitting on CSID1con Event Buffer */
      ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      tempState = CSID1con->state;
      CC_STATE_CHANGE(CSID1con, CCS_CANNOTPROCESSEVENTS);

      ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (ret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
      }
      else
      {
        con->icRscVal      = FALSE;
        CSID1con->ogRscVal = TRUE;
      }
      CC_STATE_CHANGE(CSID1con, tempState);

      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      if (con->ogRscVal)
      {
        ogProtType = CC_GET_PROTOCOL(con->ogProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->ogBcm, ogProtType))
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, CCCALLCLR, NULL);
        }
        else
        {
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_OUTGOING);
        }
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
    }
/*###########################################################################*/
    CC_BREAK_IF_DISC_BUFFERED(CSID1con);
    if (CC_IS_CCID_CC10_AND_ABOVE(legId1))
      ccCreateOnSwitchBearer((legId02), NULLP, NULLP, NULLP,
                               CSID1con->state, FALSE);
    else
      ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                     CSID1con->state, FALSE);
/*###########################################################################*/
  }
  else /* It has to be legId 1 as we have already checked it */
  {
    if (bcmType == BtOBcm)
    {
#ifdef ZC
      upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
      upd.featMsg.DlegId       = 1;
      upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->icBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
      ccToggleCC9CtrlHashList(&CSID1con->icBcm);
/***************************BCM OPERATION*********************************/
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = &(con->icBcm);
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId1  = &(con->ogBcm);
      con->icBcm.cc->legId2  = NULLP;
      CSID1con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));

      con->lastState = con->state;
      CC_STATE_CHANGE(con, CCS_ANSWERED);
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      ret = ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (ret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->icSuConnId);
      }
      else
      {
        CSID1con->icRscVal = FALSE;
        con->icRscVal      = TRUE;
      }
#ifdef CC_BUFFER_EVENT
      /* There may be a event sitting on con Event Buffer */
      ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      if (CSID1con->ogRscVal)
      {
        ogProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->ogBcm, ogProtType))
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
          ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                        CSID1con->ogSuConnId, CSID1con->ogProtType,
                        CCCALLCLR, NULL);
        }
        else
        {
          CSID1con->direction = OUTTOINC;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(CSID1con, CC_OUTGOING);
        }
      }
      else
      {
        CC_STATE_CHANGE(CSID1con,  CCS_IDLE);
        ccRelCon(CSID1con);
      }
    }
    else
    {
#ifdef ZC
      upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
      upd.featMsg.DlegId       = 1;
      upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->icBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
      ccToggleCC9CtrlHashList(&CSID1con->ogBcm);
/***************************BCM OPERATION*********************************/
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = &(con->icBcm);
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId1  = &(con->ogBcm);
      con->icBcm.cc->legId2  = NULLP;
      CSID1con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      ret = ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (ret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->icSuConnId);
      }
      else
      {
        CSID1con->ogRscVal = FALSE;
        con->icRscVal      = TRUE;
      }
      con->lastState = con->state;
      CC_STATE_CHANGE(con, CCS_ANSWERED);
#ifdef CC_BUFFER_EVENT
      /* There may be a event sitting on con Event Buffer */
      ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      if (CSID1con->icRscVal)
      {
        icProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->icBcm, icProtType))
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
          ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                        CSID1con->icSuConnId, CSID1con->icProtType,
                        CCCALLCLR, NULL);
        }
        else
        {
          CSID1con->direction = INCTOOUT;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(CSID1con, CC_INCOMING);
        }
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_IDLE);
        ccRelCon(CSID1con);
      }
    }
/*###########################################################################*/
    CC_BREAK_IF_DISC_BUFFERED(con);
    if (CC_IS_CCID_CC10_AND_ABOVE(legId2))
      ccCreateOnSwitchBearer((legId01), NULLP, NULLP, NULLP,
                             con->state, FALSE);
    else
      ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                     con->state, FALSE);
/*###########################################################################*/
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE11S71
*
*      Desc:  Connection state function
*             event - Switch Connect Confirm.
*             state - CCS_AWTSWTCFM_MERGEINCC6OG
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes:
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S71
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                        mgret          = RFAILED;
  S16                        rmret          = RFAILED;
  ProtType                   icProtType     = 0;
  ProtType                   ogProtType     = 0;
  msgValBcmTypeEnum          bcmType        = BtMax;
  AinBCM_t                  *legId1         = NULLP;
  AinBCM_t                  *legId2         = NULLP;
  AinBCM_t                  *legId01        = NULLP;
  AinBCM_t                  *legId02        = NULLP;
  MgctTxnCfm                *txnCfm         = NULLP;
  CcConCb                   *CSID1con       = NULLP;
  CcMidCallReqEvnt           midCallReq;
  Bool                       answerFlag     = FALSE;
  State                      tempState      = CCS_IDLE;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S71:%ld\n", con->icSuConnId);
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
  if (con->ogBcm.cc == NULLP)
  {
    CCLOGERR("ERROR: cc is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  legId1    = con->ogBcm.cc->legId1;
  legId2    = con->ogBcm.cc->legId2;
  legId02   = con->ogBcm.cc->legId02;
  legId01   = con->ogBcm.cc->legId01;

  if ((legId1 == NULLP) || (legId2 == NULLP) || (legId02 == NULLP) ||
      (legId01 == NULLP))
  {
    CCLOGERR("ERROR: legId is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  bcmType   = legId02->bcmType;
  CSID1con  = legId02->con;

  txnCfm   = (MgctTxnCfm*) event;
  mgret = ccHandleMgResponse(con, txnCfm);
  if (mgret != ROK)
  {
    CCLOGERR("ERROR: MGI Response failed:%d, icSu:%ld, ogSu:%ld\n", mgret,
             con->icSuConnId, con->ogSuConnId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  if (con->ainInfo.legId == 2)
  {
#ifdef ZC
    if (CC_IS_OBCM_PIC_ACTIVE(con))
    {
      upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
      upd.featMsg.DlegId       = 2;
      upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->ogBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
    ccToggleCC6CtrlHashList(&(con->ogBcm));
/*************************************************************************/
    if (bcmType == BtOBcm)
    {
/***************************BCM OPERATION*********************************/
      CSID1con->icBcm.cc->ccId    = CiStable2Party;
      CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
      CSID1con->icBcm.cc->legId02 = NULLP;
      CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
      CSID1con->icBcm.cc->legId2  = NULLP;
      con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->ogBcm));
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(con, CSID1con);
      /* There may be a event sitting on con Event Buffer */
      ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      tempState = CSID1con->state;
      CC_STATE_CHANGE(CSID1con, CCS_CANNOTPROCESSEVENTS);
      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
      }
      else
      {
        con->ogRscVal      = FALSE;
        CSID1con->icRscVal = TRUE;
      }
      CC_STATE_CHANGE(CSID1con, tempState);

      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      if (con->icRscVal)
      {
        icProtType = CC_GET_PROTOCOL(con->icProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->icBcm, icProtType))
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCALLCLR, NULL);
        }
        else
        {
          con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
        }
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
      CC_BREAK_IF_DISC_BUFFERED(CSID1con);
      if (CC_IS_CCID_CC10_AND_ABOVE(&(CSID1con->ogBcm)))
        ccCreateOnSwitchBearer(&(CSID1con->icBcm), NULLP, NULLP, NULLP,
                               CSID1con->state, FALSE);
      else
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
    }
    else
    {
/***************************BCM OPERATION*********************************/
      CSID1con->ogBcm.cc->ccId    = CiStable2Party;
      CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
      CSID1con->ogBcm.cc->legId02 = NULLP;
      CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
      CSID1con->ogBcm.cc->legId2  = NULLP;

      con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->ogBcm));
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(con, CSID1con);
      /* There may be a event sitting on con Event Buffer */
      ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
      tempState = CSID1con->state;
      CC_STATE_CHANGE(CSID1con, CCS_CANNOTPROCESSEVENTS);

      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
      }
      else
      {
        con->ogRscVal      = FALSE;
        CSID1con->ogRscVal = TRUE;
      }
      CC_STATE_CHANGE(CSID1con, tempState);
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      if (con->icRscVal)
      {
        icProtType = CC_GET_PROTOCOL(con->icProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->icBcm, icProtType))
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCALLCLR, NULL);
        }
        else
        {
          con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_INCOMING);
        }
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
      CC_BREAK_IF_DISC_BUFFERED(CSID1con);
      if (CC_IS_CCID_CC10_AND_ABOVE(&(CSID1con->icBcm)))
        ccCreateOnSwitchBearer(&(CSID1con->ogBcm), NULLP, NULLP, NULLP,
                               CSID1con->state, FALSE);
      else
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
    }
  }
  else /* It has to be legId 1 as we have already checked it */
  {
    ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);
    if (bcmType == BtOBcm)
    {
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId;
                                       /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
        upd.featMsg.DlegId       = 1;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0); 
        upd.featMsg.nel          = con->ogBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
      else
      {
        upd.featMsg.suConnId     = CSID1con->icSuConnId;
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_MERGE_CALL_PRE_ANSWER;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();

        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          CcLiCctMidCallReq(&CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                            CSID1con->icSpConnId, CSID1con->icSuConnId,
                            CSID1con->icProtType, &midCallReq);
      }
#endif /* ZC */
      /* IF CONTROLLER IS OBCM IN CS 1 */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->icBcm));
/***************************BCM OPERATION*********************************/
      con->ogBcm.cc->ccId    = CiStable2Party;
      con->ogBcm.cc->legId01 = &(con->ogBcm);
      con->ogBcm.cc->legId02 = NULLP;
      con->ogBcm.cc->legId1  = &(con->icBcm);
      con->ogBcm.cc->legId2  = NULLP;

      CSID1con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));

/***************************CHANGE RESOURCE OWNER*************************/
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->ogSuConnId);
      }
      else
      {
        CSID1con->icRscVal = FALSE;
        con->ogRscVal      = TRUE;
      }
      /* change the state to ANSWERED, as we sent a Disconnect from this
       * connection this was the held call */

      if (con->icBcm.pic == PicOActive)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      /* Stop billing timer */
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      if (CSID1con->ogRscVal)
      {
        ogProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->ogBcm, ogProtType))
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
          ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                        CSID1con->ogSuConnId, CSID1con->ogProtType,
                        CCCALLCLR, NULL);
        }
        else
        {
          CSID1con->direction = OUTTOINC;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(CSID1con, CC_OUTGOING);
        }
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_IDLE);
        ccRelCon(CSID1con);
      }
      CC_BREAK_IF_DISC_BUFFERED(con);
      if (con->icBcm.pic == PicOAlerting)
      {
        answerFlag = TRUE;
        CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      else
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      if (CC_IS_CCID_CC10_AND_ABOVE(&(con->icBcm)))
        ccCreateOnSwitchBearer(&(con->ogBcm), NULLP, NULLP, NULLP, con->state,
                               answerFlag); 
      else
        ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP, con->state,
                       answerFlag);
    }
    else
    {
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId;
                                     /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
        upd.featMsg.DlegId       = 1;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->ogBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
      else
      {
        upd.featMsg.suConnId     = CSID1con->ogSuConnId;
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_MERGE_CALL_PRE_ANSWER;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();

        if (!ccIsIPSubscriber(&(CSID1con->ogBcm)))
          CcLiCctMidCallReq(&CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                            CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                            CSID1con->ogProtType, &midCallReq);
      }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->ogBcm));
/***************************BCM OPERATION*********************************/
      con->ogBcm.cc->ccId    = CiStable2Party;
      con->ogBcm.cc->legId01 = &(con->ogBcm);
      con->ogBcm.cc->legId02 = NULLP;
      con->ogBcm.cc->legId1  = &(con->icBcm);
      con->ogBcm.cc->legId2  = NULLP;

      CSID1con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
/***************************CHANGE RESOURCE OWNER*************************/
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->ogSuConnId);
      }
      else
      {
        CSID1con->ogRscVal = FALSE;
        con->ogRscVal      = TRUE;
      }
      /* change the state to ANSWERED, as we sent a Disconnect from this
       * connection this was the held call */

      if (con->icBcm.pic == PicOActive)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
#ifdef CC_BUFFER_EVENT
      /* Move Buffered events from CS1 to CS2 */
      ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      /* Stop billing timer */
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      if (CSID1con->icRscVal)
      {
        icProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
        if (!CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->icBcm, icProtType))
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
          ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                        CSID1con->icSuConnId, CSID1con->icProtType,
                        CCCALLCLR, NULL);
        }
        else
        {
          CSID1con->direction = INCTOOUT;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(CSID1con, CC_INCOMING);
        }
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_IDLE);
        ccRelCon(CSID1con);
      }
/*###########################################################################*/
      CC_BREAK_IF_DISC_BUFFERED(con);
      /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
       * in CS1 */
      if (con->icBcm.pic == PicOAlerting)
      {
        answerFlag = TRUE;
        CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      else
        CC_STATE_CHANGE(con, CCS_ANSWERED);

      if (CC_IS_CCID_CC10_AND_ABOVE(&(con->icBcm)))
        ccCreateOnSwitchBearer(&(con->ogBcm), NULLP, NULLP, NULLP, con->state,
                               answerFlag);
      else
        ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP, con->state,
                       answerFlag);
    }
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE14S33
*
*      Desc:  Connection state function
*             event - CCE_SETUPTMREXP
*             state - CCS_AWTSWTCFMFORSVC
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE14S33
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCLOGERR("ccConE14S33: %ld, setup timer expiry\n", con->icSuConnId);
  ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S01
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND
 *             state - CCS_AWTROUTERSC
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S01
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16   ret   = RFAILED;

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {   
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }   
    else if (ret == RFAILED)
    {   
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }   
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
    /* CALL release before the Tapped subject goes to ANSWERED state */
    if (con->icProtType != CC_LOCAL_SWT_PROT)
    {
       /* Make sure ur in Tapped Con */
       ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
       if (ret != ROK)
       {
          CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
       }
    }
#endif
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    con->relPend = ICRELONLY;
    CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
  }
  else
  {
    CCLOGERR(
      "ccConE03S01(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S04
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND 
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S04
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16  ret = RFAILED;

  /* Feature 1839 - compatibility */
  /*
   * Process event CC_ET_COMPAT_ACK while
   * 1. The current compat process state is COMPAT_SENDTO_ISUP, and
   * 2. The compatibility is supported by current variant
   */
  if(con->icEvntType == CC_ET_COMPAT_ACK && con->compatSt == COMPAT_SENDTO_ISUP &&
       CC_IS_COMPAT_SUPPORTED(con->icIntfcCb, con->icProtType))
  {
     if(event == NULLP)
     {
        CCDP(AIN_DBG_LEVEL_0,"ccConE03S04: CC_ET_COMPAT_ACK event == NULLP\n");
        RETVALUE(ROK);
     }

     ccProcessCompatACK(con, (CcCnStEvnt*)event);

     /* Go on the normal call process */
     return(ROK);
  }
  /* end of compatibility */

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    { 
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    } 
    else if (ret == RFAILED)
    { 
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    } 
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (con->icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    /* Wait for  resource confirmation to clear the call */
    con->relPend = ICRELONLY;
    CC_STATE_CHANGE(con, CCS_AWTALOCCFM_TOCLR);
    RETVALUE(ROK);
  }
  else
  {
     /* Bug: 31931 - Buffer E03 in this case  - Required for
      * Transiting Unrecognised message in International
      * RV Suresh, 5.0, International 
      */
    ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE03S04 */



/*
 *
 *      Fun:   ccConE03S17
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND
 *                   - AWTRELCFM_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S17
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* 24279, 24624: Extract the SDP if rcvd from layer-3 */
  ccExtractSdpFromCnStInd(con, event);

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */


  CCLOGERR("ccConE03S17(): Not Handling the evnt."
        "stae = %d, ProtocolType = %d/%d, direction = %d, evnType =%d\n",
        con->state, con->icProtType, con->ogProtType, con->direction,
        con->icEvntType);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S18
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND
 *                   - AWTRELCFM_OG
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S18
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->lastState == CCS_AWTRSPFORDPE32)
  {
    /* GCC is in a process of Forwarding the call */
    DP("Buffered an Event :%ld, %d\n", con->icSuConnId, con->icEvntType);
    ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                         NULLP, 0);
    RETVALUE(ROK);
  }

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */

  /* 24279, 24624: Extract the SDP if rcvd from layer-3 */
  ccExtractSdpFromCnStInd(con, event);

  CCLOGERR("ccConE03S18(): unExpected evnt in state"
          "= %d, ProtocolType = %d/%d, direction = %d, evnType =%d\n",
          con->state, con->icProtType, con->ogProtType, con->direction,
          con->icEvntType);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S19
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND
 *                   - AWTRELCFM_BOTH
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S19
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* 24279, 24624: Extract the SDP if rcvd from layer-3 */
  ccExtractSdpFromCnStInd(con, event);

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */

  if( ((con->direction == OUTTOINC) && /* bug 58297 */
      (con->ogProtType != CC_CS_LN) &&
      (con->ogProtType != CC_CS_TG) &&
      (con->ogProtType != CC_GR303) ) ||
     ((con->direction == INCTOOUT) &&
      (con->icProtType != CC_CS_TG) &&
      (con->icProtType != CC_CS_LN) &&
      (con->icProtType != CC_GR303)) )
  {   
      CCLOGERR(
        "ccConE03S19(): Not Handling the evnt."
        "stae = %d, ProtocolType = %d/%d, direction = %d, evnType =%d\n",
        con->state, con->icProtType, con->ogProtType, con->direction,
        con->icEvntType);
  } 

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S28
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND 
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S28
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16  ret = RFAILED;

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    { 
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    } 
    else if (ret == RFAILED)
    { 
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if ODisc event is armed\n");
    } 
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "ODisconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (con->icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    /* Wait for  SFT confirm to clear the call */
    con->relPend = ICRELONLY;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_TOCLR);

    RETVALUE(ROK);
  }
  else
  {
     /* BUG: 56327 - buffering this message again to be handled in another state */
     ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                          NULLP, 0);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE03S28 */


/*
 *
 *      Fun:   ccConE03S32
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND 
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S32
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16         ret        = RFAILED;
  Bool        mgiSent    = FALSE;
  ProtType    icProtType = 0;
#ifdef ZC
  ZcUpdParam  upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE03S32: %ld\n", con->icSuConnId);

  if(con->direction == OUTTOINC)
  {
    CCLOGERR("Error: Invalid direction :%d, icSu:%ld\n", con->direction,
             con->icSuConnId);
    RETVALUE(ROK);
  }

#ifdef ZC
  cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
#endif /* ZC */
  icProtType = CC_GET_PROTOCOL(con->icProtType);

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);  
  }
  else if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ccStopConTmr(con, CC_TMR_TST_LN_DSC);
    ccRmvCon100Tmr(con, CC_TST_100_SLNC_TMR);
    ccRmvCon100Tmr(con, CC_TST_102_SLNC1_TMR);
    ccRmvCon100Tmr(con, CC_TST_102_SLNC2_TMR);
    ccStopConTmr(con, CC_TMR_CALLDTL);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

#ifdef ZC
     upd.icSuConnId = con->icSuConnId;
     zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
     zcUpdPeer();
#endif
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    if (con->mgBlock->mgCtx && con->mgBlock->mgCtx->suCtxId)
    {
       /* FID 1915  Cleanup for a Test Line call */
      if (con->tstLnCb != NULLP)
      {
        CCDP(AIN_DBG_LEVEL_1, "ccConE03S32:Administer testLineType:%d\n", 
                               con->tstLnCb->testLineType);
        SPutSBuf(ccInit.region, ccInit.pool, con->tstLnCb,
                 (Size) sizeof(CcTstLnCb_t));
      } /* End if Test line */

      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      con->relPend = ICRELONLY;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret == ROK)
        mgiSent = TRUE;
      else
      {
        CCLOGERR("Error: ccSendMgiQueue failed:suCtxId = %ld, icSu:%ld\n",
                 con->mgBlock->mgCtx->suCtxId, con->icSuConnId);
        cleanUpMgQ(con);
        ccCleanUpMGCtx (con);
      }
    }
    if (!mgiSent)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCCALLCLR, NULL);
    }
    RETVALUE(ROK);
  }
  else if (((icProtType == CC_BICC) || (icProtType == CC_SIPT)) && (con->icEvntType == CC_ET_CONNECTED))
  {
    CCDP(AIN_DBG_LEVEL_0, "Dropping the message for eventType:%d\n",
         con->icEvntType);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR(
      "ccConE03S32(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }
} /* ccConE03S32 */


/*
 *
 *      Fun:   ccConE03S33
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND 
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S33
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    CCDP(AIN_DBG_LEVEL_0, "Ignoring Flash till we get a Rsp from MGI\n");
    RETVALUE(ROK);
  }

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Received a on hook while waiting for MGI response */
    /* Lets ignore it for now. */
    RETVALUE(ROK);
  }
  else
  {
    RETVALUE(ROK);
  }

} /* ccConE03S33 */


/*
 *
 *      Fun:   ccConE03S34
 *
 *      Desc:  Connection state function
 *             event - CCE_CNST_IND 
 *             state - 
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S34
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16         ret           = RFAILED;
#ifdef CC_CALEA
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
#endif

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
    CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
    RETVALUE(ROK);
  }
  else if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId < CiThreePartySetup)
      {
        CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
        RETVALUE(ROK);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
      RETVALUE(ROK);
    }
    con->lastState = con->state;
    ret = ccProcessMidCallEvent(con);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent success, event detected:%ld\n",
                            con->icSuConnId);
      RETVALUE(ROK);       
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed:%ld\n",
                             con->icSuConnId);
    }
    /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
    CCDP(AIN_DBG_LEVEL_0, "Hook Flash event is not armed:%ld\n",con->icSuConnId);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("ccConE03S34(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE03S34 */


/*
 *
 *      Fun:   ccConE03S35
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND 
 *             state: 35 - CCS_AWT_MID_CALL_CFM (CAS / CCCS)
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S35
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16               ret           = RFAILED;
  SvcHeader_t       header;
  ResourceClear_t   resourceClear;
  AinBCM_t         *pBcm          = NULLP;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if ((!con->ainInfo.disconnectLegFlag) &&
        (con->anncBlock.anncType!= CC_PERMSIGTREATANNC))
    {
      if (con->anncBlock.stateForAnnc != CCS_AWTRSPFORDPE20)
        pBcm = &(con->icBcm);
      else
        pBcm = &(con->ogBcm);

      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&resourceClear, 0, sizeof(ResourceClear_t));

      /* Fill ClearCause with ClcUserAbandon */
      con->ainInfo.ClearCause = ClcUserAbandon;

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_Resource_Clear);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the Resource Clear structure */
      ccFillResourceClearParam(&resourceClear, pBcm);
      CCDP(AIN_DBG_LEVEL_0," Filled ResourceClear\n");

      /* Send the ResourceClear message to the FIC */
      CCDP(AIN_DBG_LEVEL_0,"Sending ResourceClear, TransID=%ld\n",
           header.spTransId);
      CcUiFctResourceClear(&resourceClear, &header);
    }

    /***************PROCESS DISCONNECT*****************************/
    ret = ccProcessDisconnectEvent(con, event);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    else if (ret == ROKDRSIG)
    {
      /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
         CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O_Disconnect event is not Armed\n");

    ret = RFAILED;
    /* Release the call incase of CAS */
    ccStopConTmr(con, CC_TMR_CALLDTL);
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);

    /* Initiate De-switching */
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      /* Blow off the switching and Release the Call */
      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      if (ret == ROK)
      {
        /* No need to save the last State */
        if(con->ogRscVal == TRUE)
        {
          con->relPend = BOTHREL;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
        }
        else
        {
          con->relPend = ICRELONLY;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(0, con->mgBlock);
      }
      if (ret != ROK)
      {
        CCLOGERR( "ERROR occured \n");
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
      }
      else
        RETVALUE(ROK);
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0,  "No Switching Context Found\n");
    }

    /* Anyway Go ahead and clean up the call we we reach here */
    if(con->ogRscVal == TRUE)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    }

    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
    if(con->ogRscVal == TRUE)
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, CCCALLCLR, NULL);

    RETVALUE(ROK);
  }
  else if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId < CiThreePartySetup)
      {
        CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
        RETVALUE(ROK);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
      RETVALUE(ROK);
    }
    con->lastState = con->state;
    ret = ccProcessMidCallEvent(con);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent success, event detected:%ld\n",
                            con->icSuConnId);
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed:%ld\n",
                             con->icSuConnId);
    }
    /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
    CCDP(AIN_DBG_LEVEL_0,"Hook Flash event is not armed:%ld\n",con->icSuConnId);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("ccConE03S35(): unExpected evnt in state = %d, ProtocolType = %d,"
             " direction = %d, evnType =%d\n", con->state, con->icProtType,
             con->direction, con->icEvntType);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S36
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND
 *             state: 36 - CCS_AWTRSPFORDPE1
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S36
(      
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /*******************************************************
    NOTE: Need to check whether T_Disconnect or O_Disconnect
          are armed and then suitably send the FIC 
          messages to FIC on receiving the Response from
          FIC for the OriginationAttempt sent earlier.
          Also we need to invoke the CAS RelReq
    ********************************************************/

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    con->relPend = ICRELONLY; 
    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
  }
  else
  {
      CCDP(AIN_DBG_LEVEL_2,
          "ccConE03S36(): unExpected evnt in state = %d,"
          "ProtocolType = %d, direction = %d, evnType =%d\n",
          con->state, con->icProtType, con->direction, con->icEvntType);
  }
  RETVALUE(ROK);

} /* End of ccConE03S36 */


/*
 *
 *      Fun:   ccConE03S37
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND
 *             state: 37 - CCS_AWTRSPFORDPE3
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S37
(      
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    ProtType icProtType     = CC_GET_PROTOCOL(con->icProtType); /* Bug: 88025 */
    ProtType ogProtType     = CC_GET_PROTOCOL(con->ogProtType); /* Bug: 88025 */
    S16      ret            = ROK; /* Bug: 88025 */

    /* FID 14234.0 */
    if(con->icEvntType == CC_ET_APPTRAN)
    {
        con->icEvnt = (CcAllSdus *)event;

        if(ccProcessOApm(&(con->icBcm)) == ROK)
        {
            CCDP(AIN_DBG_LEVEL_0,"ccProcessOApm success,requested event detected.\n");
            CCDP(AIN_DBG_LEVEL_2, "ccConE03S37: CarrConnTime on virtual call\n");
            ccFgdBilling(con);
            RETVALUE(ROK);
        }
    }
 
    /* BUG: 88025 & 88230 + */ 
    if (ccIsPrackRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
    {
         /* FID 14732 */
         ccExtractSipwMBufFromCnStInd(con, event);

         /* Extract the SDP if rcvd from layer-3 */
         /* euysal - 05/31/2006 - BUG:46983 Need to check the retvalue */
         ret = ccExtractSdpFromCnStInd(con, event);
         if (ret != ROK)
         {
           CCLOGERR("Error: SDP parsing failed - %d\n", ret);
           con->failCndVal = FC_PROTERR;

           if (CC_IS_CONTEXT_PRESENT(con))
           {
             ccQSubBasedOnCcn(con);  /* FID 15261.0 */

             ret = ccSendMgiQueue(0, con->mgBlock);
             if (ret != ROK)
             {
               CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
               cleanUpMgQ(con);
               ccCleanUpMGCtx(con);
             }
             else
             {
               CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
               con->mgBlock->con = con;
               con->relPend = ONLYINFAILCND;
               RETVALUE(ROK);
             }
           }

           ccProcessFailCnd(con, con->failCndVal, TRUE);
           RETVALUE(ROK);
         }

         ret = ccProcessPrackOrAck (con, icProtType, ogProtType, (CcAllSdus*)event);
         if (ret == ROKIGNORE)
         {
            RETVALUE (ROK);
         }
         else
         {
            CCLOGERR("%s: ERROR: Unexpected return value from ccProcessPrackOrAck()\n", __FUNCTION__);
            ABORT_DEBUG;
            RETVALUE (ROK);
         }
    }
    /* BUG: 88025 & 88230 - */ 

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
   {       
     /* Remove this Code after FSM buffering works */
     CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

     ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
     cleanUpMgQ(con);
     ccCleanUpMGCtx (con);
     ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
     RETVALUE(ROK);
   }

   if(con->direction == OUTTOINC)
     RETVALUE(ROK);


  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /*******************************************************
    NOTE: Need to check whether T_Disconnect or O_Disconnect
          are armed and then suitably send the FIC 
          messages to FIC on receiving the Response from
          FIC for the InfoCollected sent earlier.
          Also we need to invoke the CAS RelReq
    ********************************************************/
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    con->relPend = ICRELONLY; 
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
  }
  else
  {
     /* Bug: 31931 - Buffer E03 in this case  - Required for
      * Transiting Unrecognised message in International
      * RV Suresh, 5.0, International 
      */
      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  }
  RETVALUE(ROK);

} /* End of ccConE03S37 */



/*
 *
 *      Fun:   ccConE03S39
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND 
 *             state: 39 - CCS_AWTRSPFORDPE20
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S39
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
   {       
     /* Remove this Code after FSM buffering works */
     CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

     ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
     cleanUpMgQ(con);
     ccCleanUpMGCtx (con);
     ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
     RETVALUE(ROK);
   }

   if(con->direction == OUTTOINC)
     RETVALUE(ROK);


  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    /*******************************************************
    NOTE: Need to check whether T_Disconnect or O_Disconnect
          are armed and then suitably send the FIC 
          messages to FIC on receiving the Response from
          FIC for the TerminationAttempt sent earlier.
          Also we need to invoke the CAS RelReq
    ********************************************************/
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    con->relPend = ICRELONLY; 
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
  }
  else
  {
     /* Bug: 31931 - Buffer E03 in this case  - Required for
      * Transiting Unrecognised message in International
      * RV Suresh, 5.0, International 
      */
      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  }
  RETVALUE(ROK);

} /* End of ccConE03S39 */

/*
 *
 *      Fun:   ccConE03S48
 *
 *      Desc:  Connection state function
 *             event - CnStIndication
 *             state - CCS_AWTREATTEMPT 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S48 
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16      ret              = RFAILED;
  CcConCb *conWaitingForRsc = NULLP;


  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
#ifdef CC_CALEA
      /* CALL release before the Tapped subject goes to ANSWERED state */
      if (con->icProtType != CC_LOCAL_SWT_PROT)
      {
         /* Make sure ur in Tapped Con */
         ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
         if (ret != ROK)
         {
            CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
         }
      }
#endif

    /* Change the ownership of the CC_OUTGOING Rsc to Connection
     * (con->icSuConnIdOfIntGlare) waiting for this resource */

    ret = cmHashListFind(&ccSuInstTbl,
                          (U8 *)&(con->icSuConnIdOfIntGlare),
                          (U16)sizeof(UConnId), 0, (PTR *)&conWaitingForRsc);
    if((ret != ROK) ||
       ((ret == ROK) && (conWaitingForRsc->state != CCS_AWTROUTERSC) &&
        (conWaitingForRsc->state != CCS_AWTALOCCFM_TOCLR)))
    {
         CCLOGERR("ERROR: internal GLARE handling : "
             " problem with oldCon notfound %lx\n", con->icSuConnIdOfIntGlare);
         ccStopConTmr(con, TMR_SETUP);
         ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
 
         ccDeallocateResource(con, CC_OUTGOING);
         con->ogRscVal = FALSE;

         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL,NULL);
         RETVALUE(ROK);
    }

       /* Send a trigger to ConWaitingForRsc */
    ccAllocateResource(conWaitingForRsc,
                       (CcConEvnt *)conWaitingForRsc->ccEvntHold,
                       CC_INCOMING,
                       RMT_ALOC_CHOWN);

    con->ogRscVal = FALSE;

    /* send Release to CAS */
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
             con->icProtType, CCCALLCLR, NULL);

    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR(
      "ccConE03S48(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* ccConE03S48 */


/*
 *
 *      Fun:   ccConE04S48
 *
 *      Desc:  Connection state function
 *             event - Release indication
 *             state - CCS_AWTREATTEMPT 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S48
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb *conWaitingForRsc   = NULLP;
  S16      ret                = RFAILED;

  if (con->direction == INCTOOUT)
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    else if (ret == ROKDRSIG)
    {
       /* NOTE: ROKDRSIG is used to indicate that the O/T Disconnect
               notification is sent  and continue with release*/
       CCDP(AIN_DBG_LEVEL_3,"(O/T) Disc Notification is armed\n");
    }
    else
       /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
       CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

    /* Change the ownership of the CC_OUTGOING Rsc to Connection
     * (con->icSuConnIdOfIntGlare) waiting for this resource */

    ret = cmHashListFind(&ccSuInstTbl,
                          (U8 *)&(con->icSuConnIdOfIntGlare),
                          (U16)sizeof(UConnId), 0, (PTR *)&conWaitingForRsc);
    if((ret != ROK) ||
       ((ret == ROK) && (conWaitingForRsc->state != CCS_AWTROUTERSC) &&
        (conWaitingForRsc->state != CCS_AWTALOCCFM_TOCLR)))
    {
         CCLOGERR("ERROR: internal GLARE handling : "
             " problem with oldCon notfound %lx\n", con->icSuConnIdOfIntGlare);
         ccStopConTmr(con, TMR_SETUP);
         ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

         ccDeallocateResource(con, CC_OUTGOING);
         con->ogRscVal = FALSE;

         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL,NULL);
         RETVALUE(ROK);
    }

       /* Send a trigger to ConWaitingForRsc */
    ccAllocateResource(conWaitingForRsc,
                       (CcConEvnt *)conWaitingForRsc->ccEvntHold,
                       CC_INCOMING,
                       RMT_ALOC_CHOWN);

    con->ogRscVal = FALSE;

    CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

    con->direction = INCTOOUT;
    if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_INCOMING);
#else
    ccDeallocateResource(con, CC_INCOMING);
#endif
    RETVALUE(ROK);     
  }     
  else /* This is an unexpected RelInd */
  {
    DP("ERROR:E%02dS%02d:OUTTOINC su:0x%08X, icsp:0x%08X icProt:%d, "
       " ogsp:0x%08X ogProt=%d\n",
       con->evntType, con->state, (unsigned int)con->icSuConnId,
       (unsigned int)con->icSpConnId, con->icProtType,
       (unsigned int)con->ogSpConnId, con->ogProtType);
    con->ogSpConnId = 0; /* Reset this value */
  }

  RETVALUE(ROK);
} /* ccConE04S48 */


/*
 *
 *      Fun:   ccConE07S48
 *
 *      Desc:  Connection state function
 *             event - Re-attmept indication
 *             state - CCS_AWTREATTEMPT 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE07S48
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb            *conWaitingForRsc = NULLP;
  RtRteCfmEvnt1      *routeEvnt        = NULLP;
  S16                 ret              = RFAILED;

  SGetSBuf(ccInit.region, ccInit.pool, (Data **) &routeEvnt, (Size) sizeof(RtRteCfmEvnt1));
  cmMemset((U8 *)routeEvnt, 0, sizeof(RtRteCfmEvnt1));
  if (con->direction == OUTTOINC)
  {
       /* Change the ownership of the CC_OUTGOING Rsc to Connection
        * (con->icSuConnIdOfIntGlare) waiting for this resource */

       ret = cmHashListFind(&ccSuInstTbl,
                            (U8 *)&(con->icSuConnIdOfIntGlare),
                            (U16)sizeof(UConnId), 0, (PTR *)&conWaitingForRsc);
       if((ret != ROK) ||
          ((ret == ROK) && (conWaitingForRsc->state != CCS_AWTROUTERSC) &&
           (conWaitingForRsc->state != CCS_AWTALOCCFM_TOCLR)))
       {
         CCLOGERR("ERROR: internal GLARE handling : "
             " problem with oldCon notfound %lx\n", con->icSuConnIdOfIntGlare);
         ccStopConTmr(con, TMR_SETUP);
         ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

         ccDeallocateResource(con, CC_OUTGOING);
         con->ogRscVal = FALSE;

         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL,NULL);
         SPutSBuf(ccInit.region, ccInit.pool, routeEvnt, (Size) sizeof(RtRteCfmEvnt1));
         RETVALUE(ROK);
       }

       /* Send a trigger to ConWaitingForRsc */
       ccAllocateResource(conWaitingForRsc,
                          (CcConEvnt *)conWaitingForRsc->ccEvntHold,
                          CC_INCOMING,
                          RMT_ALOC_CHOWN);

       con->ogRscVal = FALSE;
       if((con->ogSapCb) && (con->ogSapCb->nmbActvConn > 0))
         con->ogSapCb->nmbActvConn--;
       else
         CCLOGERR("ERROR in %s: con->ogSapCb->nmbActvConn=%d\n", __FUNCTION__,
             (con->ogSapCb)?con->ogSapCb->nmbActvConn:0);
       if((con->ogIntfcCb) && (con->ogIntfcCb->nmbActvConn > 0))
         con->ogIntfcCb->nmbActvConn--;
       else
         CCLOGERR("ERROR in %s: con->ogIntfcCb->nmbActvConn=%d\n", __FUNCTION__,
             (con->ogIntfcCb)?con->ogIntfcCb->nmbActvConn:0);
       con->ogRscSta = RMT_RES_INVALID;
       cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);

       /* Send a fresh ccAllocateResource request for this call to
        * re-route the call on a different circuit */
       routeEvnt->numOfOgInterfaces = 1;
       routeEvnt->currentInterface = 0;
       routeEvnt->ogInterface[0].intfType = CC_SI_INTFC;
       routeEvnt->ogInterface[0].t.tgrpDesc.tgrpId =
                                    con->ogRsc.intfc.t.tgrpDesc.tgrpId;
       routeEvnt->ogInterface[0].t.tgrpDesc.dpc =
                                    con->ogRsc.intfc.t.tgrpDesc.dpc;
       routeEvnt->ogPrtclType[0] = con->ogProtType;
#if 0
       routeEvnt->rtDgtsStrpInfo[0].numdgts = 0;
       routeEvnt->rtDgtsStrpInfo[0].ident = 0xFF;
       routeEvnt->rtDgtsPrefixInfo[0].ident = 0xFF;
#endif
       CC_STATE_CHANGE(con, CCS_AWTRSCALLOCCFM_GLARE);

       ccAllocateResourceArray(con, (CcConEvnt *)con->ccEvntHold,
                               CC_OUTGOING, RMT_DONTCARE,
                               routeEvnt->ogInterface,
                               routeEvnt->ogPrtclType,
                               routeEvnt->numOfOgInterfaces);
       SPutSBuf(ccInit.region, ccInit.pool, routeEvnt,
                (Size) sizeof(RtRteCfmEvnt1));
      RETVALUE(ROK);
  }
  else
  {
    DP("Unexpected:E%02dS%02d:INCTOOUT su:0x%08X, icsp:0x%08X icProt:%d, "
       " ogsp:0x%08X ogProt=%d\n",
       con->evntType, con->state, (unsigned int)con->icSuConnId,
       (unsigned int)con->icSpConnId, con->icProtType,
       (unsigned int)con->ogSpConnId, con->ogProtType);
  }
 
  SPutSBuf(ccInit.region, ccInit.pool, routeEvnt, (Size) sizeof(RtRteCfmEvnt1));
  RETVALUE(ROK);
} /* ccConE07S48 */


/*
 *
 *      Fun:   ccConE14S48
 *
 *      Desc:  Connection state function
 *             event - SETUP timer expiry
 *             state - CCS_AWTREATTEMPT 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S48
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb     *conWaitingForRsc = NULLP;
  S16          ret              = RFAILED;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Change the ownership of the CC_OUTGOING Rsc to Connection
   * (con->icSuConnIdOfIntGlare) waiting for this resource */

  ret = cmHashListFind(&ccSuInstTbl,
                       (U8 *)&(con->icSuConnIdOfIntGlare),
                       (U16)sizeof(UConnId), 0, (PTR *)&conWaitingForRsc);
  if((ret != ROK) ||
       ((ret == ROK) && (conWaitingForRsc->state != CCS_AWTROUTERSC) &&
        (conWaitingForRsc->state != CCS_AWTALOCCFM_TOCLR)))
  {
        CCLOGERR("ERROR: internal GLARE handling : "
            " problem with oldCon notfound %lx\n", con->icSuConnIdOfIntGlare);
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

        ccDeallocateResource(con, CC_OUTGOING);
        con->ogRscVal = FALSE;

        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCTMPFAIL,NULL);
        RETVALUE(ROK);
  }

      /* Send a trigger to ConWaitingForRsc */
  ccAllocateResource(conWaitingForRsc,
                     (CcConEvnt *)conWaitingForRsc->ccEvntHold,
                     CC_INCOMING,
                     RMT_ALOC_CHOWN);

  con->ogRscVal = FALSE;

  /* send Release to incoming side */
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
           con->icProtType, CCCALLCLR, NULL);

  RETVALUE(ROK);
} /* ccConE14S48 */

/*
 *
 *      Fun:   ccConE14S66
 *
 *      Desc:  Connection state function
 *             event - SETUP timer expiry
 *             state - CCS_AWTSWTCFMCONFTONE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S66
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCLOGERR("Error: Setup timer expiry:%ld, %ld\n", con->icSuConnId,
                   con->ogSuConnId);
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  cleanUpMgQ(con);
  ccCleanUpMGCtx (con);
  ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE57S00
 *
 *      Desc:  Connection state function
 *             event - CCE_CREATECALL (Create Call From FIC)
 *             state - CCS_IDLE
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE57S00
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                ret            = RFAILED;
  SvcHeader_t       *ccSvcHeader    = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE57S00:\n");

  ccSvcHeader = (SvcHeader_t *) event;

  if (ccSvcHeader->lastTransactionFlag == TRUE)
  {
    CCLOGERR("Error: lastTransaction is TRUE for CreateCall");
    ccDeleteBcm(&(con->ogBcm));
    ccRelCon(con);
    RETVALUE(ROK);
  }

  /* Also Intialize the ccEvntHold */
  /* Initialize the icBcm field in the CcConCb */
  ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->icBcm.cc),
                 (Size) sizeof(AinCallConfig_t));
  if (ret != ROK)
  {
     ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
     ccRelCon(con);
     RETVALUE(RFAILED);
  }
  cmMemset((U8 *) (con->icBcm.cc), 0, sizeof(AinCallConfig_t));

  /* FIC allocates the transId  */
  con->icBcm.svcHeader.transId = ccGetNewtransId();
  CCDP(AIN_DBG_LEVEL_0," TransId= %ld\n", con->icBcm.svcHeader.transId);

  /* FillBCMInfo       */
  ret = ccFillBCMInfo(con, &(con->icBcm), con->icBcm.svcHeader.transId,
                      CiOriginatingSetup, PicONull, BtOBcm,
                      DP_ORIGINATION_ATTEMPT);
  /* Update AinCallConfig */
  con->icBcm.cc->legId01 = & (con->icBcm);

  /* Insert in icBCM Hash table */
  ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(con->icBcm),
                        (U8 *)&(con->icBcm.svcHeader.transId),
                        (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCLOGERR(" ccicBCMInsTbl Insertion failed:%ld\n", con->icSuConnId);
    ccRelCon(con);
    RETVALUE(RFAILED);
  }
  CC_STATE_CHANGE(con, CCS_AWTRSCCFMNOTIFY);
  ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING, RMT_DONTCARE);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S51
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND 
 *             state: 51 - CCS_AWTBUSYREL_IC  (CAS / CCCS)
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S51
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16         ret           = RFAILED;
  ProtType protType;
#ifdef CC_CALEA
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
#endif 
  protType = ((con->direction == INCTOOUT) ? con->icProtType : con->ogProtType);

  CCDP(AIN_DBG_LEVEL_1, "ccConE03S51\n");

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
   {       
     /* Remove this Code after FSM buffering works */
     CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

     cleanUpMgQ(con);
     ccCleanUpMGCtx (con);
     ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
     RETVALUE(ROK);
   }

  if(con->direction == OUTTOINC)
    RETVALUE(ROK);

  if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
    if (con->surrogate != NULLP)
      ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
    if (ret == ROK)
    {     
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
    CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    /* Stop the ToneTimer, infact it is the SETUP timer  */
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

#ifdef CC_CALEA
    /* CALL release before the Tapped subject goes to ANSWERED state */
    if (icProtType != CC_LOCAL_SWT_PROT)
    {
       /* Make sure ur in Tapped Con */
       ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
       if (ret != ROK)
       {
          CCDP(AIN_DBG_LEVEL_4,
          "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
       }
    }
#endif

    if(con->icProtType == CC_MGCP_LN || con->icProtType == CC_MGCP_TG)
    {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULLP);
        RETVALUE(ROK);
    }

    ret = RFAILED;
    if (CC_IS_CONTEXT_PRESENT(con))
    {

      /* Send the Mg Queue. */
      con->relPend = ICRELONLY;
      con->direction = INCTOOUT;

      ccQSubBasedOnCcn(con);  /* FID 15261.0 */

      /* Zzzz Oh! the possibilities :o) : If subscriber hangs up frustrated with ROH tone */
      if (con->mgPlayingTone && (con->mgToneType == MGCT_SIG_ID_CG_WT) && (con->icProtType == CC_CS_LN))
      {
        con->mgPlayingTone = FALSE;
        con->tempHolderForReleaseCause = CCCALLCLR;
      }

      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
    }
    if (ret != ROK)
    {
      CCDP(AIN_DBG_LEVEL_0, "ccUpdateMgQForSubRsc not sent:icSu:%ld, ctxId:%ld,"
           "ret:%d\n", con->icSuConnId, (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), ret);

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
      /* we may be waiting for OG to confirm the release; Don't want to miss
       * that */
      if(con->ogRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      }

      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL,NULL);
      RETVALUE(RFAILED);
    }
    RETVALUE(ROK);
  }
  else if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId < CiThreePartySetup)
      {
        CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
        RETVALUE(ROK);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
      RETVALUE(ROK);
    }
    con->lastState = con->state;
    ret = ccProcessMidCallEvent(con);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent success, event detected:%ld\n",
                            con->icSuConnId);
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed:%ld\n",
                             con->icSuConnId);
    }
    /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
    CCDP(AIN_DBG_LEVEL_0, "Hook Flash event is not armed:%ld\n",con->icSuConnId);
    RETVALUE(ROK);
  }
  else if((protType == CC_CS_LN) && (CHK_4_ALS70_MG) &&
         (con->icEvntType == CS_CONN_STATUS_G_SC_BT_CT_TO))
  {
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    cleanUpMgQ(con);
    ccCleanUpMGCtx(con);
    /* we may be waiting for OG to confirm the release; Don't want to miss
     * that */
    if(con->ogRscVal == TRUE)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    }
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR(
      "ccConE03S51(): unExpected evnt in state = %d," 
      "ProtocolType = %d, direction = %d, evnType =%d\n",
      con->state, con->icProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE14S51
 *
 *      Desc:  Connection state function
 *             event: 14 - SETUP timer expiry (busyTone)
 *             state: 51 - AWT_BUSY_REL_IC
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S51
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  ODisconnect_t   oDisconnect;
  SvcHeader_t     header;
  U8              index          = 0;
  Bool            notIndFlag     = FALSE;

  TRC3(ccConE14S51)

  if (con->icBcm.cc != NULLP)
  {
    if ((con->icBcm.cc->ccId >= CiThreePartySetup) &&
        (con->icBcm.cc->ccId <= CiRemoteTransferSetup))
    {
       /* Bug# 18044 and bug# 18131*/
       if (con->mgPlayingTone)
       {
          /* Bug# 18104 */
          if (con->mgToneType == MGCT_SIG_ID_CG_WT)
          {
             CCDP(AIN_DBG_LEVEL_2,"ccConE14S51:3 Party call, ROH timer expiry\n");
             RETVALUE(ccFollowSilenceAfterROH(con));
          }

          CCDP(AIN_DBG_LEVEL_0,
               "Busy Timer Expiry in MultiParty call \n");
          if ((con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ||
              (con->icBcm.nel[EReqODisconnect] == NEL_NOTIFY))
          {
            if (con->icBcm.svcHeader.transId)
            {
              cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
              cmMemset((U8 *)&oDisconnect, 0, sizeof(ODisconnect_t));
              /* Store legId */
              if (con->icBcm.cc)
              {
                if (con->icBcm.cc->ccId >= CiThreePartySetup)
                  con->ainInfo.legId = 2;
                else
                  con->ainInfo.legId = 1;
              }
              else
                con->ainInfo.legId = 1;
              ccProcessDisconnectNotfnForSurrogateLegs(con, event);
              /* Bug# 18104 */
              ccUpdateccId(&(con->icBcm.cc->ccId), con->ainInfo.legId);

              CCDP(AIN_DBG_LEVEL_2, "LegId disconnected:%d\n",
                              con->ainInfo.legId);
              ccFillSvcHeader(&header, &(con->icBcm), MSG_O_Disconnect);
              CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

              notIndFlag = (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST) ?
                            FALSE: TRUE;

              ccFillODisconnectParam(&oDisconnect, &(con->icBcm), notIndFlag);
              CCDP(AIN_DBG_LEVEL_0," Filled O_Disconnect, TransID=%ld\n",
                   header.spTransId);

              /* Bug# 11386 */
              if (con->icBcm.nel[EReqODisconnect] == NEL_REQUEST)
              {
                 /* Cleaning up the NEL as per R5-241 GR1298 */
                 for (index = 0; index < EReqMax; index++)
                 {
                     con->icBcm.nel[index] = NEL_UNARMED;
                 }

                 /* Send the msg as it is not needed to be buffered */
                 con->lastState = con->state;
                 CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE9);
                 ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                                    CCS_CANNOTPROCESSEVENTS);
                 CcUiFctODisconnect(&oDisconnect, &header);
                 RETVALUE(ROK);
              }
              else
              {
                 CCDP(AIN_DBG_LEVEL_0, "Disconnect Notification:%d\n",
                      con->icBcm.nel[EReqODisconnect]);
                 CcUiFctODisconnect(&oDisconnect, &header);
              }
            }
            else
            {
              CCLOGERR("Error: transId is zero:%ld,%ld\n", con->icSuConnId,
                                                      con->ogSuConnId);
            }
          }
          else
             CCLOGERR("BusyTimer expired and ODisconnect event is not armed\n");
       }

      /* As this is resource has another resource on hold
       * lets continue to give him the tone */
        RETVALUE(ROK);
      }
      else
      {
        con->ainInfo.legId = 1;
        ccProcessDisconnectNotfnForSurrogateLegs(con, event); 
      } 
    /* else just fall through */
  }
  else
  {
    /* For Two Party Call Forwarding case, send ODisconnect for surrogate legs */ 
    con->ainInfo.legId = 1; 
    ccProcessDisconnectNotfnForSurrogateLegs(con, event);
  }
  /* else just fall through */
  /* no timer is running! no need to stop setup timer */
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  if(con->icProtType == CC_MGCP_LN || con->icProtType == CC_MGCP_TG)
  {
      if (con->mgPlayingTone && (con->mgToneType == MGCT_SIG_ID_CG_WT))
      {
         CCDP(AIN_DBG_LEVEL_2,"ccConE14S51:2 Party MGCP call, ROH timer expiry\n");
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
         RETVALUE(RFAILED);
      }
      else
      {
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCCALLCLR, NULLP);
         RETVALUE(ROK);
      }
  }
  if ((con->icProtType == CC_CS_LN) && (CHK_4_ALS70_MG))
  {
         CCDP(AIN_DBG_LEVEL_2,"ccConE14S51:ALS70 call, tone timer expiry\n");
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
         RETVALUE(RFAILED);
  }

  if (CC_IS_CONTEXT_PRESENT(con)) /* BUG91183 */
    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

  /* Send the Mg Queue. */
  con->relPend = ICRELONLY;
  con->direction = INCTOOUT;
  /* Bug: 27339 - update release cause */
  con->tempHolderForReleaseCause = ccGetRelCauseValueForTimeOut(con->icProtType);
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
  con->mgBlock->con = con;
  ret = ccSendMgiQueue(0, con->mgBlock);
  if (ret != ROK)
  {
      CCLOGERR( "ccUpdateMgQForSubRsc or SendMgiQ. failed \n");
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
      /* we may be waiting for OG to confirm the release; Don't want to miss
       * that */
      if(con->ogRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      }
#if 1 /*GCC_ANNOUNCEMENT*/
      if (con->mgPlayingTone && (con->mgToneType == MGCT_SIG_ID_CG_WT))
      {
         CCDP(AIN_DBG_LEVEL_2,"ccConE14S51:2 Party call, ROH timer expiry\n");
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
         RETVALUE(RFAILED);
      }
#endif /*GCC_ANNOUNCEMENT*/

      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCTMPFAIL,NULL);
      RETVALUE(RFAILED);
  }
  RETVALUE(ROK);
} /* ccConE03S51 */



/*
 *
 *      Fun:   ccConE03S52
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND
 *             state: 52 - CCS_AWT_RESUME (CAS / CCCS)
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S52
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16         ret           = RFAILED;
#ifdef ZC
    ZcUpdParam upd;
#endif /* ZC */
    ProtType icProtType;
    ProtType ogProtType;
    ProtType protType;
    CcCnStEvnt ogEvnt;
    Buffer   *uBuf=NULLP;

    ProtType ingressCCSIcProtType = 0;
    CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCSIcProtType);

    icProtType = CC_GET_PROTOCOL(con->icProtType);
    ogProtType = CC_GET_PROTOCOL(con->ogProtType);
    cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));

    /* BUG 78085 init the pointer in con before call inter-working function. */
    con->ogEvnt = (CcAllSdus *)&ogEvnt;
    con->icEvnt = (CcAllSdus *)event;

    if (con->direction == INCTOOUT)
    {
        protType = icProtType;
    }
    else
    {
        protType = ogProtType;
    }

  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
    {       
        /* Remove this Code after FSM buffering works */
        CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

       ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
        cleanUpMgQ(con);
        ccCleanUpMGCtx (con);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(ROK);
    }

    /* Bug: 32512, RV Suresh 5.0, International  
     *
     * SUSPEND and RESUME can be initiated by the calling party also in ISUP for USER initiated SUSPEND
     */

    if( ( (con->direction == INCTOOUT) &&
          (con->icProtType != CC_CS_TG) &&
          (con->icProtType != CC_CS_LN) &&
          (con->icProtType != CC_MGCP_LN) &&
          (con->icProtType != CC_GR303) &&
          ((icProtType != CC_SI) || (con->icEvntType != CC_ET_RESME)) ) ||
        ( (con->direction == OUTTOINC) &&
          (con->ogProtType != CC_CS_TG) &&
          (con->ogProtType != CC_CS_LN) &&
          (con->ogProtType != CC_MGCP_LN) &&
          (con->ogProtType != CC_GR303) &&
          ((ogProtType != CC_SI) || (con->icEvntType != CC_ET_RESME)) ) )
    {

       /* Handle  HOLD/XFER for SIP/BICC calls */
       /* Note: MGCP will not send HOLD/QUERY/XFER to GCC */

       /* Dual Call Hold handle SIP XFER (and hold) */
       if (ccIsXferRcvd(CC_GET_PROTOCOL(con->icProtType),
           CC_GET_PROTOCOL(con->ogProtType), con->icEvntType, con->direction))
       {

          /* Extract the SDP if rcvd from layer-3 */
          ccExtractSdpFromCnStInd(con, event);

          /* FID 14732 */
          ccExtractSipwMBufFromCnStInd(con, event);
          /* FID 14732 */

          /* Dual Call Hold -- XFER will be handling seperately */
          ret = ccHandleXfer(con, icProtType, ogProtType, con->direction, event);

          /* FID-2593: Transcoding + */
          if (ret == ROKIGNORE)
          {
             RETVALUE (ROK);
          }
          /* FID-2593: Transcoding - */

          if(ret == ROKPENDING) /* Save the event for later */
          {
             /* we will interwork the event after MGI's response */
             ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                  sizeof(CcCnStEvnt));
             RETVALUE(ROK);
          }


          ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
          if (ret == CCIGNOREMAPPING)
          {
              ccDropUBuf(&con->uBuf);
              RETVALUE(ROK);
          }
          else if (ret != ROK)
          {
             ccStopConTmr(con, CC_TMR_CALLDTL);
             ccStopConTmr(con, TMR_SETUP);
             ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

             /* Release all connections */
             ccDropUBuf(&con->uBuf);
             if (CC_IS_CONTEXT_PRESENT(con))
             {
                /* Blow off the switching and Release the Call */
                ccQSubBasedOnCcn(con);  /* FID 15261.0 */

                ccStopConTmr(con, CC_TMR_CALLDTL);
                ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

                con->lastState = con->state;
                con->relPend = BOTHREL;

                CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
#ifdef ZC      
                upd.icSuConnId = con->icSuConnId;
                zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
                zcUpdPeer();
#endif  
                con->mgBlock->con = con;
                ret = ccSendMgiQueue(0, con->mgBlock);
                if (ret != ROK)
                {
                   CCLOGERR( "ccUpdateMgQForSubRsc() failed \n");
                   cleanUpMgQ(con);
                   ccCleanUpMGCtx(con);
                }
                else
                {
                   RETVALUE(ROK);
                }
             }
             else
             {
                 CCLOGERR( "ERROR: No Switching Context Found\n");
                 ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
                 RETVALUE(ROK);
             }
          }
          /* Done with SIP XFER (and hold) Processing */
          RETVALUE(ROK);
       }
       /* Russia ISUP will transit Ringing message */
       else if((CC_IS_PROT_TYPE_RUSSIA(con->icProtType) || CC_IS_PROT_TYPE_RUSSIA(con->ogProtType)) && 
                (con->icEvntType == CC_ET_RNG))
       {
          CCDP(AIN_DBG_LEVEL_0, "Mapping Ringing msg for Russia ISUP:icProtType:%d, ogProtType:%d, Evnt:%d\n",
               con->icProtType, con->ogProtType, con->icEvntType);

          ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
          if (ret == CCIGNOREMAPPING)
          {
              CCDP(AIN_DBG_LEVEL_0, "Mapping failure for Ringing message\n");
              ccDropUBuf(&con->uBuf);
              RETVALUE(CCIGNOREMAPPING);

          }

          uBuf = con->uBuf;
          con->uBuf = NULLP;

          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                  con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
          }

          RETVALUE(ROK);
       }
       /* CCITT 88 ISUP will transit DRS message */
       else if((CC_IS_PROT_TYPE_ITU88(con->icProtType) || CC_IS_PROT_TYPE_ITU88(con->ogProtType)) && 
                (con->icEvntType == CC_ET_DRS))
       {
          CCDP(AIN_DBG_LEVEL_0, "Mapping Delayed Release msg for CCITT 88 ISUP:icProtType:%d, ogProtType:%d, Evnt:%d\n",
               con->icProtType, con->ogProtType, con->icEvntType);

          ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
          if (ret == CCIGNOREMAPPING)
          {
              CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping for DRS message\n");
              ccDropUBuf(&con->uBuf);
              RETVALUE(CCIGNOREMAPPING);

          }

          uBuf = con->uBuf;
          con->uBuf = NULLP;

          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                  con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
          }

          RETVALUE(ROK);
       }
       /* BUG 85582 ++ */ 
       else if (con->icEvntType == CC_ET_SUSP)
       {
          CCDP(AIN_DBG_LEVEL_0, "Mapping SUS msg for ISUP inter-ccs call:icProtType:%d, ogProtType:%d, Evnt:%d\n",
               con->icProtType, con->ogProtType, con->icEvntType);

          ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
          if (ret == CCIGNOREMAPPING)
          {
              CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping for SUS message\n");
              ccDropUBuf(&con->uBuf);
              RETVALUE(CCIGNOREMAPPING);

          }

          uBuf = con->uBuf;
          con->uBuf = NULLP;

          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                  con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
          }

          RETVALUE(ROK);
       }
       else if (ingressCCSIcProtType == CC_SI && con->icEvntType == CC_ET_RESME)
       {
          CCDP(AIN_DBG_LEVEL_0, "Mapping RES msg for ISUP inter-ccs call:icProtType:%d, ogProtType:%d, Evnt:%d\n",
               con->icProtType, con->ogProtType, con->icEvntType);

          ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
          if (ret == CCIGNOREMAPPING)
          {
              CCDP(AIN_DBG_LEVEL_0, "Ignored Mapping for RES message\n");
              ccDropUBuf(&con->uBuf);
              RETVALUE(CCIGNOREMAPPING);

          }

          uBuf = con->uBuf;
          con->uBuf = NULLP;

          if (con->direction == INCTOOUT)
          {
              ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                  con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
          }
          else
          {
              ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
          }

          RETVALUE(ROK);
       }
       /* BUG 85582 -- */
       /* FID16465.0 */
       else if (ccIsDtmfInfoRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType), con->icEvntType,
                             con->direction))
       {
         ccSendDtmfInfoRsp(con, con->direction, SIP_503_SERVICE_UNA);
         RETVALUE(ROK);
       }
       else  /* Unexpected event  */
       {
          CCLOGERR(
               "ccConE03S52(): unExpected evnt in state = %d, \
               ProtocolType = %d/%d, direction = %d, evnType =%d\n",
               con->state, con->icProtType, con->ogProtType, con->direction,
               con->icEvntType);
          RETVALUE(ROK);
       }
    }

    /* Ignore redundant ON_HOOK */
    if ((con->suspendDirection == con->direction) &&
        (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction)))
    {
        return(ROK);
    }
   
    if((con->suspendDirection == con->direction) &&
       ((protType == CC_SI) || (con->icEvntType == CS_CONN_STATUS_OFF_HOOK)))
    {
        /* resume the call */

        /* bug#18732, rkhan, Previous release should not be considered
         * reinitialise the value */
        con->callDtlInfo.cm.relCause.causeVal.val = AM_CV_TMPFAIL;
#if 0  /* Bug 50629 */
        con->callDtlInfo.cm.relOrign = LCC_RELORGN_INTERNAL;
#else
        con->callDtlInfo.cm.relOrign = LCC_RELORGN_INVALID;
#endif
        con->callDtlInfo.cm.tckRelIndRcvd.pres = NOTPRSNT;

        /* stop the timer and change the state */
        CC_STATE_CHANGE(con, CCS_ANSWERED);
        /* euysal - 05/25/2005 - ACC Support */
        CC_UPDATE_PIC(&con->ogBcm, PicTActive);
        CC_UPDATE_PIC(&con->icBcm, PicOActive);
        
        ccResumeCall(con, event);
   
        con->timingInd2 = ON;

        RETVALUE(ROK);
    }

    if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
    {
        S16 tmdRel = 0;
        /* Bug# 17130 : Stop the Suspend Timer*/
        ccStopConTmr(con, CC_TMR_SUSP);
        /* end of Bug# 17130 */
        ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
        if (con->surrogate != NULLP)
           ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
        if (ret == ROK)
        {
            CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
            RETVALUE(ROK);
        }
        else if (ret == RFAILED)
        {
            CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
        }
        /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
        CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

        /* Release the call */
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
#ifdef ZC      
        upd.icSuConnId = con->icSuConnId;
        zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif  

#ifdef CC_CALEA
        if (con->icProtType != CC_LOCAL_SWT_PROT)
        {
            /* Make sure ur in Tapped Con */
            ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
            if (ret != ROK)
            {
                CCDP(AIN_DBG_LEVEL_4,
                     "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
            }
        }
#endif

        /* Release the Switching */
        if (CC_IS_CONTEXT_PRESENT(con))
        {
            /* Blow off the switching and Release the Call */
            ccQSubBasedOnCcn(con);  /* FID 15261.0 */

            con->lastState = con->state;
            con->relPend = BOTHREL;
            CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
            con->mgBlock->con = con;
            ret = ccSendMgiQueue(0, con->mgBlock);
            if (ret != ROK)
            {
                cleanUpMgQ(con);
                CCLOGERR( "ERROR occured \n");
                ret = RFAILED;
            }
            else
                RETVALUE(ROK);
        }
        else
        {
            CCLOGERR( "ERROR: No Switching Context Found\n");
        }
        if (ret != ROK)
        {
            cleanUpMgQ(con);
            ccCleanUpMGCtx(con);
            /* Anyway Go ahead and Clean the Call */
            tmdRel = ccIsTmdRelRequired(con);
            switch(tmdRel)
            {
            case CC_IC_TMD_RELEASE:
                ccApplyTmdRelease(con, &con->icRsc);
                con->tmdRelApplied = CC_IC_TMD_RELEASE;
                CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

                if(con->ogRscVal == TRUE)
                    ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                                  con->ogSuConnId, con->ogProtType,
                                  CCCALLCLR, NULL);
                break;

            case CC_OG_TMD_RELEASE:
                ccApplyTmdRelease(con, &con->ogRsc);
                con->tmdRelApplied = CC_OG_TMD_RELEASE;
                CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

                if(con->icRscVal == TRUE)
                    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                                  con->icProtType, CCCALLCLR, NULL);
                break;

            default :
            {
                CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCCALLCLR, NULL);
                if(con->ogRscVal == TRUE)
                    ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                                  con->ogSuConnId, con->ogProtType,
                                  CCCALLCLR, NULL);
            }
            break;
            }
            RETVALUE(ROK);
        }
    }
    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE03S53
 *
 *      Desc:  Connection state function
 *             event: 03 - CCE_CNST_IND 
 *             state: 53 - CCS_AWT_TMDRELEXP (CAS / CCCS)
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S53
(       
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->icEvntType == CS_CONN_STATUS_FORCED_ON_HOOK)
  {       
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if( ( (con->direction == INCTOOUT) &&
        (con->icProtType != CC_CS_TG) &&
        (con->icProtType != CC_CS_LN) &&
        (con->icProtType != CC_MGCP_LN) &&
        (con->icProtType != CC_GR303) ) ||
      ( (con->direction == OUTTOINC) &&
        (con->ogProtType != CC_CS_TG) &&
        (con->ogProtType != CC_CS_LN) &&
        (con->ogProtType != CC_MGCP_LN) &&
        (con->ogProtType != CC_GR303) ) )
  {
      CCLOGERR(
         "ccConE03S53(): unExpected evnt in state = %d," 
         "ProtocolType = %d/%d, direction = %d, evnType =%d\n",
         con->state, con->icProtType, con->ogProtType, con->direction,
         con->icEvntType);
      RETVALUE(ROK);
  }

  if((con->tmdRelApplied == CC_OG_TMD_RELEASE) && (con->direction == INCTOOUT))
    RETVALUE(ROK);
     
  if((con->tmdRelApplied == CC_IC_TMD_RELEASE) && (con->direction == OUTTOINC))
    RETVALUE(ROK);
     
  if((con->direction == OUTTOINC) &&
     (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction)))
  {
    /* stop the timer and send relReq */
    ccRemoveTmdRelease(con, &con->ogRsc);
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);

    if(con->icRscVal == TRUE)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
    }

    if(con->ogRscVal == TRUE)
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, CCCALLCLR, NULL);

    RETVALUE(ROK);
  }

  if((con->direction == INCTOOUT) &&
     (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction)))
  {
    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    /* stop the timer and send relReq */
    ccRemoveTmdRelease(con, &con->icRsc);

    if(con->ogRscVal == TRUE)
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
    }
    else
    {
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    }

    if(con->icRscVal == TRUE)
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCCALLCLR, NULL);

    RETVALUE(ROK);
  }

  RETVALUE(ROK);
} /* end ccConE03S53 */

/* CPDI release happens when relaseing timer started */
/*
 *
 *      Fun:   ccConE04S53
 *
 *      Desc:  Connection state function
 *             event: 04  - CCE_RELIND
 *             status: 53 - CCS_AWT_TMDRELEXP
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S53
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    Bool exceptionalCase = FALSE;
    
    CCDP(AIN_DBG_LEVEL_0, "ccConE04S53(): got RelInd in state = %d, ProtocolType = %d/%d,"
        "direction = %d\n", con->state, con->icProtType, con->ogProtType, con->direction);

    /* stop calls if it's from incoming */
        if (con->direction == INCTOOUT)
        {
            switch (con->tmdRelApplied)
            {
            case CC_OG_TMD_RELEASE:
                /* Send Resource Dealocation for incoming interface */
                ccDeallocateResource(con, CC_INCOMING);
                con->icRscVal = FALSE;
                break;
            case CC_IC_TMD_RELEASE:
            case CC_IC_TMD_RELEASE_CPDI:
                /* stop the timer and send relReq */
                ccRemoveTmdRelease(con, &con->icRsc);
                
                /* Send Resource Dealocation for incoming interface */
                if(con->ogRscVal == TRUE)
                {
                    CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                }
                else
                {
                    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
                }
                
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCCALLCLR, NULL);
                break;
            default:
                exceptionalCase = TRUE;
               
                /* if nothing to release, then let it be */
                break;
            }
        }
        else if (con->direction == OUTTOINC)
        {
            switch (con->tmdRelApplied)
            {
            case CC_IC_TMD_RELEASE:
            case CC_IC_TMD_RELEASE_CPDI:
                /* Send Resource Dealocation for outgoing interface */
                ccDeallocateResource(con, CC_OUTGOING);
                con->ogRscVal = FALSE;
                /* the resources will be released after receiving rel cfm  */
                /* from both sides */
                break;
            case CC_OG_TMD_RELEASE:
                /* Send Resource Dealocation for incoming interface */
                if(con->icRscVal == TRUE)
                {
                    CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                }
                else
                {
                    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
                }
                
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                              con->ogProtType, CCCALLCLR, NULL);  

                break;
            default:
                exceptionalCase = TRUE;
                break;
            }
        }
        
        if (exceptionalCase)
        {
            CCLOGERR("ERROR: unmatched tmdRelType %d\n", con->tmdRelApplied);
            
            if ((con->icRscVal == TRUE) && (con->ogRscVal == TRUE))
            {
                CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCCALLCLR, NULL);
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                              con->ogProtType, CCCALLCLR, NULL);
            }
            else if (con->ogRscVal == TRUE)
            {
                CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                              con->ogProtType, CCCALLCLR, NULL);
            }
            else if (con->icRscVal == TRUE)
            {
                CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCCALLCLR, NULL);
            }
        }
        
  RETVALUE(ROK);
} /* end ccConE04S53 */




/*
 *
 *      Fun:   ccConE05S53
 *
 *      Desc:  Connection state function
 *             event: 05  - CCE_RELCFM
 *             status: 53 - CCS_AWT_TMDRELEXP
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S53
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if ((con->direction == INCTOOUT) &&
      (con->tmdRelApplied == CC_OG_TMD_RELEASE) )
  {
    /* Send Resource Dealocation for incoming interface */
    ccDeallocateResource(con, CC_INCOMING);
    con->icRscVal = FALSE;
  }
  else if ((con->direction == OUTTOINC) &&
               (con->tmdRelApplied == CC_IC_TMD_RELEASE))
  {
    /* Send Resource Dealocation for outgoing interface */
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
  }
  RETVALUE(ROK);
} /* end ccConE05S53 */



/*
 *
 *      Fun:   ccConE05S59
 *
 *      Desc:  Connection state function
 *             event - Connection Release confirmation
 *             state - AWTRELCFM__KEEP_CON
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE05S59
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb     *CS1con   = NULLP;
  CcConCb     *CS2con   = NULLP;
  AinBCM_t    *pBcm     = NULLP;
  AinBCM_t    *legId02  = NULLP;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE05S59: %ld\n", con->icSuConnId);

  /* De-allocate the Resource and stay in the same state
   * So that we dont deallocate the CcConCb and complete the Call Transfer
   * procedure */

  if (con->direction == INCTOOUT)
  {
    CCDP(AIN_DBG_LEVEL_0, "CT case: %d, %ld\n", con->direction, con->icSuConnId);
    pBcm = &(con->icBcm);
  }
  else if (con->direction == OUTTOINC)
  {
    CCDP(AIN_DBG_LEVEL_0, "CT case: %d, %ld\n", con->direction, con->icSuConnId);
    pBcm = &(con->ogBcm);
  }
  else
  {
    CCLOGERR("ERROR: Invalid direction: %d, %ld\n", con->direction, con->icSuConnId);
    RETVALUE(ROK);
  }

  if (pBcm->cc)
  {
    if ((pBcm->cc->legId02 == NULLP) || (pBcm->cc->legId01 == NULLP))
    {
      CCLOGERR("Error: legId02/01 is NULLP: %ld\n", con->icSuConnId);
      RETVALUE(RFAILED);
    }
    CS1con         = pBcm->cc->legId02->con;
    CS2con         = pBcm->cc->legId01->con;
  }

  if (con->direction == INCTOOUT)
  {
    con->icBcm.keepTransactionOpen = TRUE;
    ccDeallocateResource(con, CC_INCOMING);
    con->icRscVal = FALSE;
    con->icBcm.keepTransactionOpen = FALSE;

    /* Detach the con from the SP. */
    cmHashListDelete(&con->icSapCb->spInstTbl, (PTR)con);
    con->icSapCb->nmbActvConn--;
    con->icSpConnId = 0;
    con->icSapCb = NULLP;

    /* Re- arrange the call Configuration and assoicate both mgBlocks for
     * Call Transfer */

    if ((pBcm->cc) && (pBcm->cc->legId01 == &(con->icBcm)))
    {
      /* OBCM/TBCM CT in CC6 */
      CCDP(AIN_DBG_LEVEL_0, "O or TBCM CT in CC6: %ld\n", con->icSuConnId);

      /* Bug# 19408 */ 
      if (con->icBcm.pic == PicOActive)
      {
         CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
      else if (con->icBcm.pic == PicOAlerting)
      {
         CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      else
      { 
         CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);
      } 

      if (con->icBcm.cc->ccId  == CiStableMParty)
      {
         /* Transition of subject from C10 to C11 */ 
#ifdef ZC
         if (CC_IS_OBCM_PIC_ACTIVE(con))
         {
            cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
            upd.featMsg.suConnId     = con->icSuConnId;
            upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
            upd.featMsg.DlegId       = 0;
            upd.featMsg.suCtxId1     = (CS1con->mgBlock->mgCtx ? CS1con->mgBlock->mgCtx->suCtxId : 0);
            upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
            upd.featMsg.nel          = con->icBcm.nel;
            zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
            zcUpdPeer();
         }
#endif
         con->icBcm.cc->ccId = CiTransfer;
       
         RETVALUE(ROK);
      }
      else
      {
         legId02 = con->icBcm.cc->legId02;
         ccChangeCallStateOfAssociatedCalls(legId02, CCS_CANNOTPROCESSEVENTS);
         ccCreateOnSwitchBearer(&(CS1con->icBcm), &(CS1con->ogBcm),
                                ccProcessCallCC6ToCC11, (PTR) con,
                                CS1con->state, FALSE);
         RETVALUE(ROK);
      }
    }
    else
       CCLOGERR("ERROR !! INVALID BCM \n");
  }
  else
  {
    CCLOGERR("ERROR: Invalid direction: %d, %ld\n", con->direction, con->icSuConnId);
    RETVALUE(ROK);
  }
  RETVALUE(ROK); 
}


/*
 *
 *      Fun:   ccConE14S34
 *
 *      Desc:  Connection state function
 *             event - SETUP Timer Expired
 *             state - CCS_AWT_ADDR_CFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE14S34
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  Bool      multiPartyCall   = FALSE;
  CCLOGERR("ccConE14S34 SetUp Timer Expired: 0x%lx, state = %d\n", con->icSuConnId,
           con->lastState);
  /* Stop timer, Send release to incoming side, Generate Alarm? */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);
  if (con->icBcm.cc)
  {
    if ((con->icBcm.cc->ccId >= CiThreePartySetup) &&
          (con->icBcm.cc->ccId <= CiRemoteTransferSetup))
      multiPartyCall = TRUE;
  }
  if (multiPartyCall)
  {
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  else
  {
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL,NULL);
    RETVALUE(ROK);
  }
}


/*
 *
 *      Fun:   ccConE15S47
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - CCS_AWTRSPFORDPEXY_TOCLR
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S47
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* Stop timer, Send release to incoming side, Generate Alarm? */
  CCLOGERR("ERROR: Release tmr expired waiting for FIC in state-%d\n",
            con->state);

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

  /* Bug# 19048 */
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {
     ccReleaseCaleaLegs(con); 
  }

  ccCloseOBcmTransaction(con);
  ccCloseTBcmTransaction(con);

#if 1
  if(con->ogRscVal == TRUE)
  {
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
  }

  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL,NULL);
#else /* 1 */
  ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
#endif /* 1 */

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S51
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - CCS_AWTBUSYREL_IC
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S51
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE15S51: %ld\n", con->icSuConnId);
  CCLOGERR("We already have the setup timer running: %ld\n", con->icSuConnId);

  /* stop the release timer, as we already have a busy tone timer running */
  ccStopConTmr(con, TMR_RELEASE);

  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE35S09
 *
 *      Desc:  Connection state function
 *             event - CCE_ADDR_CFM
 *             state - CCS_AWTANS
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE35S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   CcAddrCfmEvnt *addrCfmEvnt = (CcAddrCfmEvnt *)event;
   Buffer *uBuf = NULLP;
   S16 ret = RFAILED;
   CcConEvnt ogEvnt;
   CasCctEvent_t *cs = NULL;    /* incoming connection event */ 

   /* bug 91532 */
   cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

   /* Feature 1789 - German ISUP */
   /* stop the Toiw2 Timer if running */
   ccStopConTmr(con, CC_TMR_TOIW2);

   cs = &(addrCfmEvnt->m.casCctEvnt);

   if (con->icProtType == CC_CS_TG)
   {
      if((cs->cdPtyNmb.nmbDigits.len <= 0) && (cs->cutThru.pres != PRSNT_NODEF))
      {
         /* 
          * Release both the legs of the call. At this point we have received CRA on
          * the outgoing ISUP leg
          */
         CCLOGERR("Error:cdPtyNmb Length(%d) not Valid, icSpConnId=%lx\n",
                   cs->cdPtyNmb.nmbDigits.len, con->icSpConnId);
         ccStopConTmr(con, TMR_SETUP);
         ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
         ccFreeTheRscFromCon(con, OUTTOINC);
         ccProcessFailCnd(con, FC_CASTG_ZERO_DIGITS_RX, TRUE);
         RETVALUE(ROK);
      }
      /*
       * Over write the previous AddrCfm event. This is the latest and greatest
       * Addr Cfm that has Called party number to be filled in the outgoing IAM
       */
      if(con->ccEvntHold != NULLP)
         cmMemcpy((U8 *)con->ccEvntHold, (U8 *)addrCfmEvnt, sizeof(CcAddrCfmEvnt));

      /* bug:21879 - no cdPty at AT ... BEGIN */
      /* do the same stuff done at e35s34 (awt-addrCfm, get addrCfm) */
      /* don't call ccSetAddrCfmForRt(con); it zeroes tns */
      /* ccBill... calls ccExtractCalledNum which updates callDtl with cdPty */
      ccBillUpdCdPtyNum (__FILE__, __LINE__, con);
      
      /* Now set the con->callDtlInfo.un.telicaCDR_extention.icIncPrefix.
         Doing this in cc_cas.c::ccExtractCSRouteInfo() - because that's where
         we decide if we're an AT and trust whatever CS parsed for ozz, xxxx */
      /* bug:21879 - no cdPty at AT ... END */

      con->icEvnt = con->ccEvntHold;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      con->direction = INCTOOUT;

      /* Map ADDRCFM to IAM */
      ret = ccMapEvent(con, CCE_ADDRCFM, 0);

      if (ret != ROK)
      {
         CCLOGERR( "Mapping failed: %ld\n", con->icSuConnId);
         if (con->ogRscVal)
         {
            ccDeallocateResource(con, CC_OUTGOING);
            con->ogRscVal = FALSE;
         }
         ccDropUBuf(&con->uBuf);
#ifdef CC_CALEA
         if (con->icProtType == CC_LOCAL_SWT_PROT)
         {
            if (ret == CCIGNOREMAPPING)
               CCLOGERR(" CALEA Call with only o/g SS7 is supported\n"); 
            /* For CALEA call */
            ccRelCon(con);
            RETVALUE(RFAILED);
         } 
#endif
         ccPlayToneOrRelease(con, CCTMPFAIL);
         RETVALUE(RFAILED);
      }
      uBuf = con->uBuf;
      con->uBuf = NULLP;
      if (ccInit.acnt == TRUE)
      {
         con->callDtlInfo.cm.tckOgConReqSent.pres = PRSNT_NODEF;
         (Void) SGetSysTime(&con->callDtlInfo.cm.tckOgConReqSent.val);
      }

      /* Increment the call attempt statistics */
      if (con->ogIntfcCb)
         con->ogIntfcCb->sts.numOgCallAttempt++;

      cmHashListInsert(&con->ogSapCb->ogConsInstTbl, (PTR)con,
            (U8 *)&con->ogSuConnId, (U16)sizeof(UConnId));

      /* Update the ogSpConnId: We know that, ogSpConnId is same
         as og resource chan (Ds0) */
      if((con->ogProtType == CC_CS_TG) || (con->ogProtType == CC_CS_LN))
         con->ogSpConnId = 0;
      else if (con->ogProtType == CC_GR303)
         CC_SET_G3CONNID(con->ogSpConnId, con->ogRsc.intfc.t.intfcId, con->ogRsc.t.gr3Rsc.crv);

      /* CHECK FOR TNOANSWER EVENT */
      if (con->ogBcm.nel[EReqTNoAnswer] == NEL_REQUEST)
      {
         CCDP(AIN_DBG_LEVEL_0,"ccConE35S09: T_No_Answer event is ARMED\n");
         if (con->ainInfo.TnoAnswerTimer.pres)
         {
            /* Assign the timer value with the one that was received
             * in ReqRepBCMEvnt 
             */
            ccCp.genCfg.tmr.tAinTNoAns.val = con->ainInfo.TnoAnswerTimer.val;
         }
         ccStartConTmr(AIN_T_NO_ANS_TMR, con, (PTR)&ccCp.genCfg);
      }

      UPDATE_OPIC(con, PicSendCall);
      if (con->icBcm.cc != NULLP)
      {
         if (con->icBcm.cc->ccId == CiThreePartySetup)
            con->icBcm.cc->ccId = CiPartyOnHold;
      }

      ccCleanAnsFraudCall(con);
      processAnsSupervisionFraudPrflId(con);
      CCDP(AIN_DBG_LEVEL_2, "Sending ConReq\n");

      /* 57460 */
      ccUpdInterCcsTermPbxSubId(con);

#ifdef SAVE_PRFLID
      ccSaveProfileId(con); 
#endif
      ccProcessOCallSent(&con->icBcm);

      /* PreAnswer Timer is only started for CRBT Call */
      ccStartConTmr(CC_TMR_PREANM, con, (PTR)&ccCp.genCfg);

      CcLiCctConReq (&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSuConnId,
                     &con->ogRsc, con->ogProtType, &ogEvnt, uBuf, con);

      /* FID 15174.0 */
      if (((!CC_INGRESS_INTER_CCS_CALL(con) && CC_EGRESS_INTER_CCS_CALL(con)) ||
           (!CC_INGRESS_INTER_CCS_CALL(con)  && !CC_EGRESS_INTER_CCS_CALL(con))) &&
          (con->EarlyACMSt != EARLY_ACM_HAS_BEEN_SENT) &&
          (CC_IS_ICOVERLAP_SENDACM(con)) &&
          (CC_IS_OGOVERLAP_DISABLED(con)))
      {
          ccStopConTmr(con, CC_TMR_EARLYACM);
          /* Directly call the early acm expire to send early acm */
          ccTmrEarlyACMExp(con);
          /* BUG 67115 */
          if (con->state == CCS_AWTMGCTCFMFOREARLYACM)
          {
              RETVALUE(ROK);
          }
      }

   } /* end if con->icProtType == CC_CS_TG */
   else
   {
      CCLOGERR("ccConE35S09():Non-CAS Protocol (%d) sends addrCfm \n",
                con->icProtType);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
   }
   RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE35S34
 *
 *      Desc:  Connection state function
 *             event - CCE_ADDR_CFM
 *             state - CCS_AWT_ADDR_CFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE35S34
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcAddrCfmEvnt *addrCfmEvnt = (CcAddrCfmEvnt *)&con->ccEvntHold->m.ccAddrCfmEvnt;
  msgValCcIDEnum  temp_ccId   = CiInvalid;
  U8 key = 0;
  InfoCollected_t infoCollected;
  SvcHeader_t     header;
  ProtType        icProtType  = CC_GET_PROTOCOL(con->icProtType);
  U8              index       = 0;
  CdPtyNmb        *cdPtyNmb = NULLP;
  CasCctEvent_t *cs = NULLP;

  ccUpdateBcm(con, PicCollectInformation, con->icBcm.cc->ccId, BtOBcm);

  if ((icProtType == CC_CS_LN) || (icProtType == CC_GR303))
  {
    if (addrCfmEvnt->m.casCctEvnt.addrCfmResult.pres) 
    {
       if(addrCfmEvnt->m.casCctEvnt.addrCfmResult.val == CS_RESULT_SUCCESS)
       {
         CCDP(AIN_DBG_LEVEL_0, "Success OutCome:%ld\n", con->icSuConnId);
         ccSendSuccessOutCome(&con->icBcm);
       }
       else if ((addrCfmEvnt->m.casCctEvnt.addrCfmResult.val == CS_RESULT_CCRM_OOR) ||
                (addrCfmEvnt->m.casCctEvnt.addrCfmResult.val == CS_RESULT_CCRM_FAILED))
       {
         for (index = 0; index < EReqMax; index++)
           con->icBcm.nel[index] = NEL_UNARMED;
         CC_STATE_CHANGE(con, CCS_AWTRSPFAILOUT);
         ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                            CCS_CANNOTPROCESSEVENTS);
         ccSendFailureOutCome(&con->icBcm);
         RETVALUE(ROK);
       }
    }
  }

  if(con->icProtType == CC_MGCP_LN || con->icProtType == CC_MGCP_TG)
    ccExtractProtSdp(ccInit.region, ccInit.pool, con,
              &(((CcAddrCfmEvnt *)event)->m.mgcpCctEvnt.sdp));

  if((con->icProtType == CC_CS_LN) || (con->icProtType == CC_CS_TG) ||
      (con->icProtType == CC_GR303) || (con->icProtType == CC_MGCP_LN) ||
      (con->icProtType == CC_MGCP_TG))
    {
        if(con->icProtType == CC_MGCP_LN || con->icProtType == CC_MGCP_TG)
            cdPtyNmb = &(addrCfmEvnt->m.mgcpCctEvnt.cdPtyNmb);
        else
        {
            cs = &(addrCfmEvnt->m.casCctEvnt);
            cdPtyNmb = &(cs->cdPtyNmb);
        }

        if(cdPtyNmb->nmbDigits.len <= 0)
        {
            /* Release the call - This could be a timeOut or some other 
             * problem at IOM / CCRM */
            if(((con->icProtType == CC_CS_TG) && (cs->cutThru.pres != PRSNT_NODEF)) || con->icProtType == CC_MGCP_TG)
            {
              /* bug#16405, rkhan, changed to debug level 2 */
              CCDP(AIN_DBG_LEVEL_2, "Error:cdPtyNmb Length(%d) not Valid, icSpConnId=%lx\n",
                         cdPtyNmb->nmbDigits.len, con->icSpConnId);

              ccStopConTmr(con, TMR_SETUP);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con, con->icSapCb, con->icSpConnId,con->icSuConnId,
                            con->icProtType,  CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
              RETVALUE(RFAILED);
            }
            else
            {
              /* bug#16405, rkhan, changed to debug level 2 */
              CCDP(AIN_DBG_LEVEL_2, "Error:cdPtyNmb Length(%d) not Valid, icSpConnId=%lx\n",
                       cdPtyNmb->nmbDigits.len, con->icSpConnId);
            }
        }

        ccSetAddrCfmForRt(con);

        ccBillUpdCdPtyNum (__FILE__, __LINE__, con);

        /* NOTE: Need to copy CdPrtyNmb into CollectAddrInfo at his point */
        if (ccCopyCdPty2ClAddr(con) !=ROK)
        {
          CCDP(AIN_DBG_LEVEL_2," Populating the Called Party Address failed\n");
          ccCp.sts.fRoutUnavail++;
          ccPlayToneOrRelease(con, CCTMPFAIL);
          RETVALUE(RFAILED);
        }

        /* Initializing the message buffers */
        cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
        cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

        /* Update icBcm parameters */
        /* Number of parametes to this procedure will increase */
        if (con->icBcm.cc)
           temp_ccId = con->icBcm.cc->ccId;
        else
           temp_ccId = CiOriginatingSetup;

        ccUpdateBcm(con, PicCollectInformation, temp_ccId,
                    BtOBcm);

        /* Cleaning up the NEL as per R5-241 GR1298 */
        for (key = 0; key < EReqMax; key++)
        {
            con->icBcm.nel[key] = NEL_UNARMED;
        }
        /* Fill in parameters in the Service Header Structure */
        ccFillSvcHeader(&header, &(con->icBcm), MSG_Info_Collected);
        CCDP(AIN_DBG_LEVEL_2," Filled SvcHeader\n");

        /* Fill in parameters in the Info Collected Structure */
        ccFillInfoColltdParam(&infoCollected, &(con->icBcm));
        CCDP(AIN_DBG_LEVEL_2," Filled InfoCollected\n");

        CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);
        ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
        /* Send the Info Collected message to the FIC */
        CCDP(AIN_DBG_LEVEL_3," Sending InfoCollected, TransID=%ld\n",
             header.spTransId);
        CcUiFctInfoCollected(&infoCollected, &header);

            /* bug:40864 only for cas, call here - otherwise, in e09s01 */
        ccChkCallTrc(con, CALLINC, 0);
    }
    else
    {
        CCLOGERR("ccConE35S34():Non-CAS/MGCP Protocol (%d) sends addrCfm \n",
                 con->icProtType);
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        ccCp.sts.fRoutUnavail++;
        ccSendRelease(con, con->icSapCb, con->icSpConnId,con->icSuConnId,
                      con->icProtType,  CCTMPFAIL, NULL);
        RETVALUE(RFAILED);
    }
    RETVALUE(ROK);
} /* ccConE35S34 */


/*
 *
 *      Fun:   ccConE36S35
 *
 *             event - CCE_MID_CALL_CFM 
 *             state - CCS_AWT_MID_CALL_CFM
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE36S35
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                  ret                 = RFAILED;
  CcMidCallCfmEvnt    *ccMidCallCfmEvnt    = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE36S35 0x%lx\n", con->icSuConnId);

  ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);

  if ((con == NULLP) || (event == NULLP))
  {
    CCLOGERR("Error: null pointers con 0x%lx, event 0x%lx\n", (U32)con, event);
    RETVALUE(ROK);
  }
  ccMidCallCfmEvnt = (CcMidCallCfmEvnt *) event;

  ret = ccHandleMidCallCfmForAnnoucement(con, ccMidCallCfmEvnt);
  if (ret != ROK)
  {
    CCLOGERR("Error: ccHandleMidCallCfmForAnnoucement failed 0x%lx\n",
             con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  else
  {
    ret = ccPostAnnoucementProcessing(con);
    if (ret != ROK)
    {
      CCLOGERR("Error: ccPostAnnoucementProcessing failed icSu = 0x%lx\n",
               con->icSuConnId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    }
    RETVALUE(ROK);
  }
} /* ccConE36S35 */


/*
*
*      Fun:   ccConE39S36
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE1
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: This function is called only in case of CAS Lines only.
*             Received a Continue message for the Origination
*             Attempt message sent to the FIC.
*             This procedure sends a SFT request for the incoming Leg.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S36
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcAddrReqEvnt ccAddrReqEvnt;
  SvcHeader_t       *oaSvcHeader    = NULLP;
  Continue_t        *pContinue      = NULLP;
#ifdef CALEA_3WC
  U8               OsignalId = SigToneDialTone; 
#endif

#if 1 /* Bug#: 17932 */
   ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
  oaSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2; 
  if (pContinue->errorCode != FC_NOT_APPLICABLE)
  {
    CCLOGERR("ERROR FROM FIC = %ld\n", pContinue->errorCode);
#ifdef CC_CALEA 
    if (con->icProtType != CC_LOCAL_SWT_PROT)
    {
       if (con->icBcm.nel[EReqNetworkSignal] == NEL_NOTIFY)
       {
          /* This needed for sending NetworkSignal after playing Error Tone/Annoucement */
          con->icBcm.keepTransactionOpen = TRUE;
       }
   }
   else
      ccUpdateCloseCause(con, CC_BOTH, CscInternalFailure);
#endif

#if 0 /*Bug:38483 -- Just send Exception */
    ccCloseOBcmTransaction(con);
#endif

    /* Update termInd with exception for Termination Notification msg */
    con->ainInfo.termInd = EXCEPTION_IND;

    if (con->ainInfo.ControllingLegTreatment == CltSilence)
    {
      CCDP(AIN_DBG_LEVEL_0, "Received CltSilence with Ctrltreat for icSu:%ld,"
           " ogSu:%ld, icTransId:%ld\n", con->icSuConnId, con->ogSuConnId,
           con->icBcm.svcHeader.transId);
      CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);
      ccStopConTmr(con, TMR_SETUP);
      RETVALUE(ROK);
    }
/* #if 0  16298 : untill the code in FIC is ready */
    else if(pContinue->errorCode == FC_SUBIF_NOT_PROV)
    {
        ccPlayTone(con, MGCT_PACKAGE_ID_CG, MGCT_ITEM_ID_CG_MAX);
        RETVALUE(RFAILED);
    }
/* #endif 16298 : untill the code in FIC is ready */
    ccProcessFailCnd(con, pContinue->errorCode, TRUE);
    RETVALUE(ROK);
  }

  if (oaSvcHeader->lastTransactionFlag == TRUE)
  {
    ccDeleteBcm(&(con->icBcm));
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

/*********************Drop down and proceed with the Call*********************/

  if((con->icProtType == CC_CS_LN) || (con->icProtType == CC_CS_TG) ||
     (con->icProtType == CC_GR303) || (con->icProtType == CC_MGCP_LN) ||
     (con->icProtType == CC_MGCP_TG))
  {

    CC_STATE_CHANGE(con, CCS_AWT_ADDR_CFM);
    ccSetDefaultAddrReq(con->icProtType, &ccAddrReqEvnt);
    /* Set the ccAddrReqEvnt with SPEED DIAL feature Info received from FIC */
#if 0
    ccAddrReqEvnt.m.casCctEvnt.digitMapName.pres =  PRSNT_NODEF;
    ccAddrReqEvnt.m.casCctEvnt.digitMapName.val  =  MGCT_DIGIT_MAP_DEFAULT;
#endif /* 0 */
    /* Bug# 17046 */
    if (ccIsIPSubscriber(&(con->icBcm)))
      ccUpdateAddrReqForDMAPofIPSubscriber(con, &ccAddrReqEvnt);
#if 0
    ccUpdateAddrReq(con, &ccAddrReqEvnt);
    ccUpdateAddrReqForDialTone(con, &ccAddrReqEvnt, &OsignalId);
#endif /* 0 */

    /* For gr303, lgcl ds1, sig prfl id and ds0 resource must be passed */
    if (con->icProtType == CC_GR303)
    {
       ccAddrReqEvnt.m.casCctEvnt.g3Info.lgcl_ds1 = con->icRsc.t.gr3Rsc.lgcl_ds1;
       ccAddrReqEvnt.m.casCctEvnt.g3Info.sig_prfl_id = con->icRsc.t.gr3Rsc.sig_prfl_id;
       ccAddrReqEvnt.m.casCctEvnt.g3Info.ds0Rsc = con->icRsc.t.gr3Rsc.ds0Rsc;
    }

    CcLiCctAddrReq(&con->icSapCb->pst, con->icSapCb->spId,
                    con->icSpConnId, con->icSuConnId, con->icProtType,
                   &ccAddrReqEvnt);
#ifdef CC_CALEA
    /* Sending Dial Tone N/w Signal to FIC */
    /* Bug# 17046 */
    ccSendNetworkSignalMsg(con, FC_SIG_TONE, OsignalId, 0, 0, 
                           CC_INCOMING);
#endif
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR( "Invalid Call Flow\n");
    RETVALUE(RFAILED);
  }
}


/*
*
*      Fun:   ccConE39S37
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE3
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S37
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* Same code as E37S37 (Analyze Route in DPE3)
     Must do a little different , viz. checking error codes */
  SvcHeader_t       *icSvcHeader           = NULLP;
  Bool               noCloseMsgAndCloseTx  = FALSE;
  CcConCb           *othercon              = NULLP;
  S16            ret = RFAILED;
  Continue_t        *pContinue             = NULLP;

  TRC3(ccConE39S37)
  CCDP(AIN_DBG_LEVEL_1, "ccConE39S37: %ld\n", con->icSuConnId);

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  icSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2;

  CCDP(AIN_DBG_LEVEL_1, "%s: errorCode=%ld, cacFailInfo.pres=%d\n",
       __FUNCTION__, pContinue->errorCode, pContinue->cacFailInfo.pres);
  /*FID 16206 +*/
  if(con->dummyCallInfo)
  {
     ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
     RETVALUE(ROK);
  }
  /*FID 16206 -*/

  /* FID16970.0 */
  if(con->ccbsIsdnCallInfo && pContinue->errorCode != FC_NOT_APPLICABLE)
  {
     TknU8 causeVal;
     TknU8 errType;

     causeVal.pres = PRSNT_NODEF;
     if(pContinue->errorCode == FC_NOROUTDST)
        causeVal.val = CCNORTTODEST;
     else
        causeVal.val = CCNORMUNSPEC;
     errType.pres = PRSNT_NODEF;
     errType.val = LGTERMDENIAL;

     CCLOGERR("ccConE39S37: CCBS can not proceed\n");

     CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
     ccbsIsdnSendRelReq(con, causeVal, errType);

     RETVALUE(ROK);
  }

  if (con->icBcm.cc != NULLP)
  {
    if (con->icBcm.cc->ccId  == CiForward)
      othercon = con->icBcm.cc->legId1->con;
    else if (con->icBcm.cc->ccId == CiThreePartySetup)
      noCloseMsgAndCloseTx   = TRUE;
  }

  /* FID 15174.0 */
  CCDP(AIN_DBG_LEVEL_1, "%s: icProtType=%d, minDigits=%d\n", __FUNCTION__, 
       con->icProtType, con->minDigits);
  ccStopConTmr(con, CC_TMR_EARLYACM);
  if(pContinue->errorCode == FC_NOROUTDST)
  {
    switch (CC_GET_PROTOCOL(con->icProtType))
    {
    case CC_SI:
    case CC_EXT_BICC:
        if(CC_IS_SI_BICC_ICOVERLAP(con))
        {
            ccStopConTmr(con, CC_TMR_MINDIGIT);
            if(con->minDigits > 0)
            {
                CC_STARTTMR_MINDIGIT(con);
            }
        }
        break;
    case CC_SIPT:
        if(CC_IS_SIPT_ICOVERLAP(con))
        {
            if(con->minDigits > 0)
            {
                pContinue->errorCode = FC_INVNMBFORM;
            }
        }
        break;
    case CC_SIP:
        if(CC_IS_SIP_ICOVERLAP(con))
        {
            if(con->minDigits > 0)
            {
                pContinue->errorCode = FC_INVNMBFORM;
            }
        }
        break;
    default:
        break;
    }
  }
  else if(pContinue->errorCode == FC_OVERLAPTOENBLOC_REQ) /*FID 16696.0 */
  {
       CC_SET_CALL_FLAG(con->overlapToEnblocFlag,CC_OVERLAPTOENBLOC_REQ_RECVED);
	   
       if(!CC_IS_CALL_FLAG_SET(con->overlapToEnblocFlag, CC_OVERLAPTOENBLOC_STARTED))
       {
          if(ccOverlapToEnbloc(con)== TRUE)
          {
             RETVALUE(ROK);
          }
          else
          {
             if (con->STDigitRecd == TRUE)
             {
                 ccStopConTmr(con, CC_TMR_EARLYACM);
                 ccSendOrSkipInfoCollected(con);
                 RETVALUE(ROK);
             } 
             else
             {    
                 /*Should not happen as FIC/RS need overlap to enbloc conversion to continue*/ 
                 pContinue->errorCode = FC_INVNMBFORM;
             }    
          }
       }
       else
       {
             /*Should not happen as FIC/RS need overlap to enbloc conversion to continue*/ 
             pContinue->errorCode = FC_INVNMBFORM;
       }
  }
  
  if(pContinue->errorCode != FC_NOT_APPLICABLE)
  {
    CCLOGERR("ERROR FROM FIC = %ld\n", pContinue->errorCode);

    /* FID: 14457.0 + */
    if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)) &&
        (pContinue->errorCode == FC_HPC_QUEUE_TIMEOUT))
    {
      ccCp.getsSts.queuedTimeoutTx++;
    } /* FID 14457.0 - */

    if (othercon)
    {
      /* It was in a process of Call Forward Processing */
      CCDP(AIN_DBG_LEVEL_0, "Release during CF* processing\n");

      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = &con->icBcm;
      con->icBcm.cc->legId1  = &con->ogBcm;
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId2  = NULLP;

      /* Bug# 25673 */
      if (othercon->ogBcm.cc)
      {
        othercon->ogBcm.svcHeader.transId = 0;
        othercon->ogBcm.cc = NULLP;
      }
      ccRelCon(con);
      CCDP(AIN_DBG_LEVEL_0, "Deallocated the new Connection\n");
      con = othercon;
    }
    if (con->icProtType != CC_LOCAL_SWT_PROT)
    {
       ccReleaseCaleaLegs(con);
       if (con->icBcm.nel[EReqNetworkSignal] == NEL_NOTIFY)
       {
          /* This needed for sending NetworkSignal after playing Error Tone/Annoucement */ 
          con->icBcm.keepTransactionOpen = TRUE;
       }
    }
    else
    {
       ccUpdateCloseCause(con, CC_BOTH, CscInternalFailure);
       ccRemoveCaleaAssnWithTappedBcm(con);
    }

#if 0 /*Bug 38483 --  Just send Exception*/
    if (noCloseMsgAndCloseTx == FALSE)
      ccCloseOBcmTransaction(con);
#endif

    /* Update termInd with exception for Termination Notification msg */
    con->ainInfo.termInd = EXCEPTION_IND;

    if((pContinue->errorCode == FC_INVNMBFORM) && (con->ccEvntHold != NULLP))
    {
      con->anncBlock.anncType = CC_PERMSIGTREATANNC;
      if((con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303))
      {
	CcCnStEvnt  ogEvnt;
	
	cmMemset((U8*) &ogEvnt, 0, sizeof(CcCnStEvnt));
	
        con->ogEvntType = CS_CONN_STATUS_PERM_SIG_TREATMENT;
        CC_STATE_CHANGE(con, CCS_AWT_PERMSIG_TREATMENT_CFM);
        ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                      con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                      con->icProtType, con->ogEvntType, &ogEvnt, NULLP);
        RETVALUE(ROK);
      }
      else if(con->icProtType == CC_MGCP_LN)
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->icBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP, 
                                     (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, con);
        ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                           CCS_CANNOTPROCESSEVENTS);
        CC_STATE_CHANGE(con, CCS_AWTMGCTCFMFORMODIFY0);
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("Error: Switching processing failed 0x%lx\n",
                   con->icSuConnId);
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        }
        RETVALUE(ROK);
      }
      else
      {
      /* Bug: 32702 - FC_INVNMBFORM can happen in case of SIP or ISUP also
       */
        ccProcessFailCnd (con, pContinue->errorCode, TRUE);
      
        RETVALUE(ROK);
      }
    }
    else
    {
      if ((pContinue->errorCode == FC_REJECT_SES_CAC)&&
          (pContinue->cacFailInfo.pres))
      {
        con->callDtlInfo.cm.CACCause.cacTypeDir.pres = PRSNT_NODEF;
        con->callDtlInfo.cm.CACCause.cacTypeDir.val = pContinue->cacFailInfo.cacTypeDir;
        CCDP(AIN_DBG_LEVEL_0,"%s: cacTypeDir=%d\n", 
             __FUNCTION__, pContinue->cacFailInfo.cacTypeDir);

        con->callDtlInfo.cm.CACCause.CACProfileName = pContinue->cacFailInfo.cacPrflName;

        if (pContinue->cacFailInfo.cacPrflName.pres)
        {
          CCDP(AIN_DBG_LEVEL_0,"%s: cacPrflName=%s\n", __FUNCTION__, 
               pContinue->cacFailInfo.cacPrflName.val);
        }

      }

      /* FID 14234.0 */
      if( (con->icRscVal == FALSE) && !con->assocBlock)
      {
        /* BUG:85584 Fix the ICA firt CDPN to be announcement */
        if(CC_IS_ICA_CALL(con) && (pContinue->errorCode == FC_STR_REJECT))
        {
          ccUpdateCloseCause(con, CC_BOTH, CscInternalFailure);
        }

        /* FID15310.1 Apply failCnd only for the ICA second half call */
        if (CC_IS_ICA_CALL(con) && con->icBcm.cc && 
             con->icBcm.cc->legId02 && con->icBcm.cc->legId2 &&
             (con->icBcm.cc->legId2 == &con->ogBcm))
        {
          CCDP(AIN_DBG_LEVEL_0,"%s: ICA SCP->SRP call, need to apply the failcnd\n",
              __FUNCTION__);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
          RETVALUE (ROK);
        }
      }
    }
  }

  /* BUG 82235 If this is failure during reroute call after go 
   * to router again, subtract MG context.
   */
  if((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) && CC_IS_CONTEXT_PRESENT(con))
  {
      ccQSubBasedOnCcn(con); 

      con->relPend = NORELANDINFAILCOND;
      con->failCndVal = pContinue->errorCode;
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(0, con->mgBlock);
      if (ret != ROK)
      {
          CCLOGERR( "Error: ccSendMgiQueue failed\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
          ccProcessFailCnd (con, pContinue->errorCode, TRUE);
      }
      else
      {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
      }
      RETVALUE(ROK);
  }
  else if(pContinue->errorCode != FC_NOT_APPLICABLE)
  {
     ccProcessFailCnd (con, pContinue->errorCode, TRUE);
     RETVALUE(ROK);
  }

  if (icSvcHeader->lastTransactionFlag == TRUE)
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId != CiForward)
        ccDeleteBcm(&(con->icBcm));
    }
    else
      ccDeleteBcm(&(con->icBcm));

    /* FIC cannot close the transaction on Info Collected response,
       if It closes it its an error */
    CCLOGERR("FIC sent a last Transaction TRUE for Info Collected: %ld\n",
              con->icSuConnId);
  }

#if 0 /* gb- turned-off untill continue-no-error is required */  
  tmpcon = ccPostCallForwardProcessingAPI(con);
  if (tmpcon != NULLP)
  {
    CCDP(AIN_DBG_LEVEL_4,"Updating con after ccPostCallForwardProcessingAPI\n");
    con = tmpcon;
  }
#if 1
  if (con->lastState == CCS_AWTRSPFORDPEXY_TOCLR)
     {
    CCDP(AIN_DBG_LEVEL_3, "Race Condition: Onhook or release came in:%d,%d\n",
                           con->icSuConnId, con->ogSuConnId);
    CC_STATE_CHANGE(con, con->lastState);
    ccConE38S47(con, event, bcm, event2);
    RETVALUE(ROK);
     }
#endif /* 1 */

  /* TELICA - Bugzilla-3723 - taraveti */
  if((icProtType == CC_SI) || (icProtType == CC_BICC) || (icProtType == CC_SIPT))
  {
      /* When con ind is received on ic side, we updated the lnp_status if 
       * it has already been dipped. Now we update the lnp_status only if 
       * number is not already dipped */
      if (con->lnp_status == LNP_NA)
      {
        TknU8 *transCallNInd = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.\
                                fwdCallInd.transCallNInd;

        if ((transCallNInd->pres) && (transCallNInd->val))
  {
          /* telica-bug 13609-support multiple GAPs */
          con->lnp_status = LNP_TRANS_HERE;

          /* check all GAPs for a ported number parameter */
          for (i = 0; i < MF_MAX_GAP; i++)
          {
            genAddr = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.genAddr[i];
            if ((genAddr->eh.pres) && genAddr->typeOfAddr.val == PORTNUM)
            {
              con->lnp_status = LNP_PORTD_HERE;
              break;
             }
          }
        }
   }
      break;
   }
#endif /* gb- pending */  

  CCLOGERR("****** Alert: CONTINUE-NO- ERROR is not expected*****\n");
  CCLOGERR("****** icSuConnId=%lx\n *** \n", con->icSuConnId);

  CC_TRACE_DUMP(con);
  ccProcessFailCnd(con, FC_INTERNAL, TRUE);

   RETVALUE(ROK);
} /* end ccConE39S37 */


/*
*
*      Fun:   ccConE37S37
*
*      Desc:  Connection state function
*             event - CCE_ANALYZE_ROUTE
*             state - CCS_AWTRSPFORDPE3
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE37S37
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  Bool               noCloseMsgAndCloseTx  = FALSE;
  SvcHeader_t       *icSvcHeader           = NULLP;
  CcConCb           *othercon              = NULLP;
  AnalyzeRoute_t    *pAnalyzeRoute         = NULLP;
  CcConCb           *tmpcon                = NULLP;
  ProtType          icProtType = CC_GET_PROTOCOL(con->icProtType);
  SiGenAddr         *genAddr               = NULLP;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  CCDP(AIN_DBG_LEVEL_1, "ccConE37S37: 0x%lx\n", con->icSuConnId);

  pAnalyzeRoute = (AnalyzeRoute_t *) event2;
  icSvcHeader = (SvcHeader_t *) event;

  /* CPDI need restore ConInd event before mapping AR routing info into it */
  ccRestoreEvntHold(con);
  ccExtractAnalyzeRteParam(pAnalyzeRoute, bcm);
  ccExtractSvcHeader(icSvcHeader, bcm, MSG_Analyze_Route);
  /* aliu002 add this for performance enhancement */
  if ((con->ainInfo.MdpTrunkGroup.eh.pres == PRSNT_NODEF) &&  (con->routeEvnt == NULLP ||(con->routeEvnt->numOfOgInterfaces == 0)))
  ccPopulateRtListFromMdpTgInfo(con);
  /* FID 14457.0 Clear mark of call queued for delay  */
  CC_CLR_CALL_FLAG(con->flag, CC_FLAG_CALLQUEUED_DELAY); 
  CC_CLR_CALL_FLAG(con->flag, CC_FLAG_CALLQUEUED); 

  if (con->icBcm.cc != NULLP)
  {
    if (con->icBcm.cc->ccId  == CiForward)
      othercon = con->icBcm.cc->legId1->con;
    else if (con->icBcm.cc->ccId == CiThreePartySetup)
      noCloseMsgAndCloseTx   = TRUE;
  }

  if (icSvcHeader->lastTransactionFlag == TRUE)
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId != CiForward)
        ccDeleteBcm(&(con->icBcm));
    }
    else
      ccDeleteBcm(&(con->icBcm));

    CCDP(AIN_DBG_LEVEL_0, "FIC sent a last Transaction TRUE"
        " for Info Collected: %ld\n", con->icSuConnId);
  }

  tmpcon = ccPostCallForwardProcessingAPI(con);
  if (tmpcon != NULLP)
  {
    CCDP(AIN_DBG_LEVEL_4,"Updating con after ccPostCallForwardProcessingAPI\n");
    con = tmpcon;
  }

  if (con->lastState == CCS_AWTRSPFORDPEXY_TOCLR)
  {
    CCDP(AIN_DBG_LEVEL_3, "Race Condition: Onhook or release came in:%ld,%ld\n",
                           con->icSuConnId, con->ogSuConnId);
    CC_STATE_CHANGE(con, con->lastState);
    ccConE38S47(con, event, bcm, event2);
    RETVALUE(ROK);
  }

  /* TELICA - Bugzilla-3723 - taraveti */
  if((icProtType == CC_SI) || (icProtType == CC_EXT_BICC) || (icProtType == CC_BICC) || (icProtType == CC_SIPT))
  {
      /* When con ind is received on ic side, we updated the lnp_status if 
       * it has already been dipped. Now we update the lnp_status only if 
       * number is not already dipped */
      if (con->lnp_status == LNP_NA)
      {
        TknU8 *transCallNInd = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.\
                                fwdCallInd.transCallNInd;

        if ((transCallNInd->pres) && (transCallNInd->val))
        {
          S16 i;
          /* telica-bug 13609-support multiple GAPs */
          con->lnp_status = LNP_TRANS_HERE;

          /* check all GAPs for a ported number parameter */
          for (i = 0; i < MF_MAX_GAP; i++)
          {
            genAddr = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.genAddr[i];
            if ((genAddr->eh.pres) && genAddr->typeOfAddr.val == PORTNUM)
            {
              con->lnp_status = LNP_PORTD_HERE;
              break;
            }
          }
        }
      }
  }

  /* TELICA-BUG:12976-mqin */
  /* bug:40864 - for cas ccChkCallTrc is called in e35s34(addrCfm), for others its
     called in e09s01.
     ccChkCallTrc(con, CALLINC, 0); */

#if 1 /* TELICA-BUG:15265-mqin */
  if ((con->icProtType >= CC_IN) && (con->icProtType <= CC_INITU))
  {
     if (pAnalyzeRoute->status.pres == PRSNT_NODEF &&
         pAnalyzeRoute->status.val == FC_NA_EXTRA_DGTS)
     {
        /* send STATUS message to calling party */
        ccSendINStatusReq(con, AM_CV_EXEDIGITRECV);
     }
  }
#endif /* BUG:15265 */


  if (ccIsRscRspReqd(con))
  {
    CcLiCctRscRsp(&con->icSapCb->pst, con->icSapCb->spId,
                  con->icSpConnId, con->icSuConnId, &con->icRsc,
                  con->STDigitRecd);
  }

  /* Check and Send NOTIFY to refering call */
  ccSendInitialNotify(con);

  UPDATE_OPIC(con, PicAnalyzeInformation); /* 52682 */

  if(ROK == ccCheckForInterfaces(con))
    ccRouteCall(con, FALSE);
   else
   {
      /*FID 16206 +*/
      if(con->dummyCallInfo)
      {
           ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
           RETVALUE(ROK);
      }
      /*FID 16206 -*/

      /* FID 14716 +*/
      if(CC_GR_OVRFLW_PRES(con) &&
         CC_IS_CALL_FLAG_SET(con->flag, CC_FLAG_GROVRFLW_SKIP))
      {
          ccProcessFailCnd(con, FC_RESUNAVAIL, TRUE);
          RETVALUE(ROK);
      }   
      /* FID 14716 -*/

    CC_TRACE_DUMP(con);
    ccProcessFailCnd(con, FC_INTERNAL, TRUE);
   }

  RETVALUE(ROK);
} /* end ccConE37S37 */

/*
*
*      Fun:   ccConE37S36
*
*      Desc:  Connection state function
*             event - CCE_ANALYZE_ROUTE
*             state - CCS_AWTRSPFORDPE1
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE37S36
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  AnalyzeRoute_t      *pAnalyzeRoute = NULLP;
  SvcHeader_t         *icSvcHeader    = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE37S36:%ld\n", con->icSuConnId);

  pAnalyzeRoute = (AnalyzeRoute_t *) event2;
  icSvcHeader = (SvcHeader_t *) event;

  /* CPDI need restore ConInd event before mapping AR routing info into it */
  ccRestoreEvntHold(con);
  ccExtractAnalyzeRteParam(pAnalyzeRoute, bcm);
  ccExtractSvcHeader(icSvcHeader, bcm, MSG_Analyze_Route);

  /* need to copy the Called Party Number into CollectedAddressInfo */
  if ((con->icProtType == CC_CS_LN) || (con->icProtType == CC_GR303) ||
      (con->icProtType == CC_MGCP_LN))
  {
     if (ccCopyCdPty2ClAddr(con) !=ROK)
     {
        CCDP(AIN_DBG_LEVEL_2," Populating the Called Party Address failed\n");
        ccCp.sts.fRoutUnavail++;
        ccPlayToneOrRelease(con, CCTMPFAIL);
        RETVALUE(RFAILED);
     } 
  } 

  if (icSvcHeader->lastTransactionFlag == TRUE)
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId != CiForward)
        ccDeleteBcm(&(con->icBcm));
    }
    else
      ccDeleteBcm(&(con->icBcm));

    /* FIC cannot close the transaction on Info Collected response,
       if It closes it its an error */
    CCLOGERR("FIC sent a last Transaction TRUE for Info Collected: %ld\n",
              con->icSuConnId);
  }

  /* bug:40864 - for cas ccChkCallTrc is called in e35s34(addrCfm), for others its
     called in e09s01.
  ccChkCallTrc(con, CALLINC, 0); */

  if(ROK == ccCheckForInterfaces(con))
    ccRouteCall(con, FALSE);
  else
  {
    CC_TRACE_DUMP(con);
    ccProcessFailCnd(con, FC_INTERNAL, TRUE);
  }

  RETVALUE(ROK);
} /* end ccConE37S36 */


/*
*
*      Fun:   ccConE38S47
*
*      Desc:  Connection state function
*             event - E37, E38, E39 and E41
*             state - CCS_AWTRSPFORDPEXY_TOCLR
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE38S47
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16       tmpret      = RFAILED;
  ProtType  icProtType  = CC_GET_PROTOCOL(con->icProtType);
  S16       ret         = ROK;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) && 
      (con->icBcm.SndNotInd != SND_NOTIF_MAX)) 
  /* Case where caller abandoned after Switch Call Related Message
   * was sent before the Send_Notification message is received .
   * R5-[636] GR 1298 */  
  {
     ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     ret = ccSendTerminationNot(&con->icBcm);
     if (ret != ROK)
     {
        CCDP(AIN_DBG_LEVEL_2,"Failed to send TermNotif after NEL event\n");
     }
  } else if ((con->ogBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
             (con->ogBcm.SndNotInd != SND_NOTIF_MAX))
  /* Case where caller abandoned after Switch Call Related Message
   * was sent before the Send_Notification message is received .
   * R5-[636] GR 1298 */
  {
     ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     ret = ccSendTerminationNot(&con->ogBcm);
     if (ret != ROK)
     {
        CCDP(AIN_DBG_LEVEL_2,"Failed to send TermNotif after NEL event\n");
     }
  }


  switch (con->relPend)
  {
      case ICRELONLY:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
#ifdef CC_CALEA
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
           /* Make sure ur in Tapped Con */
           ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
           if (ret != ROK)
           { 
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
           }
         }
#endif 
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
         break;

      case INRELRSPANDNOREL:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

         CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
         ccDeallocateResource(con, CC_INCOMING);
         RETVALUE(ROK);
         break;

      default:
         CCDP(AIN_DBG_LEVEL_2,"ccConE38S47: Unexpected con->relPend=%d\n",
              con->relPend);

         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
#if 1
         ccPlayToneOrRelease(con, CCTMPFAIL);
#else /* 1 */
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
#ifdef CC_CALEA
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
           /* Make sure ur in Tapped Con */
           ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
           if (ret != ROK)
           { 
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
           }
         }
#endif 
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
#endif /* 1 */
         break;
  }
  RETVALUE(ROK);
} /* ccConE38S47 */


/*
*
*      Fun:   ccConE37S47
*
*      Desc:  Connection state function
*             event - Analyze Route.
*             state - CCS_AWTRSPFORDPEXY_TOCLR
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE37S47
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                tmpret                = RFAILED;
  ProtType           icProtType            = CC_GET_PROTOCOL(con->icProtType);
  S16                ret                   = ROK;
  SvcHeader_t       *arSvcHeader           = NULLP;
  AnalyzeRoute_t    *pAnalyzeRoute         = NULLP;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  pAnalyzeRoute = (AnalyzeRoute_t *) event2;
  arSvcHeader   = (SvcHeader_t *) event;
  /* CPDI need restore ConInd event before mapping AR routing info into it */
  ccRestoreEvntHold(con);
  ccExtractAnalyzeRteParam(pAnalyzeRoute, bcm);
  ccExtractSvcHeader(arSvcHeader, bcm, MSG_Analyze_Route);
  ccCleanAnsFraudCall(con);

  if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) && 
      (con->icBcm.SndNotInd != SND_NOTIF_MAX)) 
  /* Case where caller abandoned after Switch Call Related Message
   * was sent before the Send_Notification message is received .
   * R5-[636] GR 1298 */  
  {
     ccUpdateBusyCauseForTermNot(con, con->icProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     ret = ccSendTerminationNot(&con->icBcm);
     if (ret != ROK)
     {
        CCDP(AIN_DBG_LEVEL_2,"Failed to send TermNotif after NEL event\n");
     }
  } else if ((con->ogBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
             (con->ogBcm.SndNotInd != SND_NOTIF_MAX))
  /* Case where caller abandoned after Switch Call Related Message
   * was sent before the Send_Notification message is received .
   * R5-[636] GR 1298 */
  {
     ccUpdateBusyCauseForTermNot(con, con->ogProtType, ILOC_USER, CSTD_CCITT,
                                 CCCALRABANDON);
     ret = ccSendTerminationNot(&con->ogBcm);
     if (ret != ROK)
     {
        CCDP(AIN_DBG_LEVEL_2,"Failed to send TermNotif after NEL event\n");
     }
  }


  switch (con->relPend)
  {
      case ICRELONLY:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
#ifdef CC_CALEA
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
           /* Make sure ur in Tapped Con */
           ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
           if (ret != ROK)
           { 
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
           }
         }
#endif 
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
         break;

      case OUTRELRSPANDNOREL:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

         CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
         ccDeallocateResource(con, CC_INCOMING);
         RETVALUE(ROK);
         break;

      case INRELRSPANDNOREL:
         /* INRELRSPANDNOREL handling missing. Added for Bug:31216, RV Suresh */
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

         CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
         ccDeallocateResource(con, CC_INCOMING);
         RETVALUE(ROK);
         break;
      
      default:
         CCDP(AIN_DBG_LEVEL_2,"ccConE38S47: Unexpected con->relPend=%d\n",
              con->relPend);

         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
#if 1
         ccPlayToneOrRelease(con, CCTMPFAIL);
#else /* 1 */
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
#ifdef CC_CALEA
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
           /* Make sure ur in Tapped Con */
           ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
           if (ret != ROK)
           { 
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
           }
         }
#endif 
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
#endif /* 1 */
         break;
  }
  RETVALUE(ROK);
} /* ccConE37S47 */


/*
*
*      Fun:   ccConE39S39
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE20
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  Continue_t        *pContinue      = NULLP;
  CcAllSdus               ogEvnt;
  S16                      ret      = RFAILED;
  
  CCDP(AIN_DBG_LEVEL_1, "ccConE39S39\n");

  pContinue   = (Continue_t *) event2;
  if (pContinue->errorCode != FC_NOT_APPLICABLE)
  {
    CCLOGERR("ERROR FROM FIC = %ld\n", pContinue->errorCode);
#ifdef CC_CALEA 
    if (con->icProtType != CC_LOCAL_SWT_PROT)
    {
       ccReleaseCaleaLegs(con);
       if (con->ogBcm.nel[EReqNetworkSignal] == NEL_NOTIFY)
       {
          /* This needed for sending NetworkSignal after playing Error Tone/Annoucement */
          con->ogBcm.keepTransactionOpen = TRUE;
       }

    }
    else if (con->icProtType == CC_LOCAL_SWT_PROT)
    {
       ccUpdateCloseCause(con, CC_BOTH, CscInternalFailure);
       ccRemoveCaleaAssnWithTappedBcm(con);
    }
#endif

     ccStopConTmr(con, AIN_O_NO_ANS_TMR);
     ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);

     if(con->ogRscVal == TRUE)
     {
       ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;
     }
     ccCloseTBcmTransaction(con);

#ifdef SND_NOT_IND
     /* Update termInd with exception for Termination Notification msg */
     con->ainInfo.termInd = EXCEPTION_IND;
#endif

     /* 
      * bug: 57719
      * if inter-ccs call, the fail condition value should be sent to ingress
      * ccs, then use ccProcessFailCnd to release the call in ingress ccs.
      */
     if (CC_INGRESS_INTER_CCS_CALL(con))
     {
          if (CC_IS_CONTEXT_PRESENT(con))
          {
              /* Blow off the switching and Release the Call */
              ccQSubBasedOnCcn(con);  /* FID 15261.0 */
     
              con->relPend = ICRELONLY;
              con->failCndVal = pContinue->errorCode;
              CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
              con->mgBlock->con = con;
              ret = ccSendMgiQueue(0, con->mgBlock);
              if (ret != ROK)
              {
                  /* Anyway go ahead and send a release to the other side */
                  CCLOGERR( "Error: ccSendMgiQueue failed\n");
                  cleanUpMgQ(con);
                  ccCleanUpMGCtx(con);
              }
              else
                  RETVALUE(ROK);
          }
          else
          {
              ccStopConTmr(con, TMR_SETUP); 
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              con->direction = OUTTOINC;
              con->ogEvnt = &ogEvnt;
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccBuildInterCcsReleaseForFailCnd(con, pContinue->errorCode, (PTR) con->ogEvnt);
              ccSendReleaseReq(con);
              RETVALUE(ROK);
          }
     }

     ccProcessFailCnd(con, pContinue->errorCode, TRUE);
     RETVALUE(ROK);
  }

  ccConE38S39(con, event, bcm, event2);
  RETVALUE(ROK);
}



/* 
*  
*      Fun:   ccConE39S42
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE27
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S42
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t    *tmSvcHeader    = NULLP;
#ifdef ZC
  ZcUpdParam upd; 
#endif /* ZC */
  Continue_t        *pContinue   = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE39S42: %ld\n", con->icSuConnId);
  tmSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2;

  if (pContinue->errorCode != FC_NOT_APPLICABLE)
    CCLOGERR("ERROR:rcvd from FIC: %ld\n", pContinue->errorCode);

  if (CC_IS_TBCM_PIC_ACTIVE(con))
  {
#ifdef ZC
    cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->ogSuConnId;
    upd.featMsg.ccAinUpdType = CC_UPDATE_BCM;
    upd.featMsg.nel          = con->ogBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
  }

  /* Lets ignore the flash and fall back to the last state */
  CC_STATE_CHANGE(con, con->lastState);
  RETVALUE(ROK);
}

/* 
*  
*      Fun:   ccConE47S37
*
*      Desc:  Connection state function
*             event - CCE_SEND_TO_RESOURCE
*             state - CCS_AWTRSPFORDPE3
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE47S37
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   Bool               noCloseMsgAndCloseTx  = FALSE;
   S16                ret                   = RFAILED;
   SvcHeader_t       *icSvcHeader           = NULLP;
   CcConCb           *cs1Con                = NULLP;
   SendToResource_t  *pSTR                  = NULLP;

   CCDP(AIN_DBG_LEVEL_1, "ccConE47S37: Rec SendToResource in AWTRSPFORDPE3\n");

   /*Bug90642 Disable Media Agnostic before playing announcement*/ 
   if (con->ccmCb.ccn == CCN_1)
   {
      ccDisableMediaAgnostic(con, CC_INGRESS_MG);
      ccDisableMediaAgnostic(con, CC_EGRESS_MG);
   }
   else if (con->ccmCb.ccn == CCN_0)
   {
      ccDisableMediaAgnostic(con, CC_INGRESS_MG);
   } 

   /*Bug92368 move the fix to ccSendToResource to cover more more scenarios*/
   #if 0 
   /*BUG#90458*/
   if(con->icHeldIpVersion==INVALID_IPV && con->direction==INCTOOUT)
   {
     con->icHeldIpVersion = CC_GCC_IPV(con->icIpParam.locBearerIpPort.ip.ipVersion);
     CCDP(AIN_DBG_LEVEL_0,"%s(): Set icHeldIpVersion = %d\n", __FUNCTION__, con->icHeldIpVersion);
   }
   #endif

   /* Bug 90466 + */
   ccFreeAdj(con);
   ccFreeLi(con);

   con->ccmCb.ogAdjRealmId = 0;
   con->ccmCb.icLiAdjRealmId = 0;
   con->ccmCb.ogLiAdjRealmId = 0;
   con->ccmCb.ccn = CCN_0;
   /* Bug 90466 - */
   
   /* BUG:93368 clean up the ogOffAns to be NULL just as what we did in
    * ccClenUpOGForReRoute since for annc the ogLeg is null */
   CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
       CC_OFFANS_STATE_NULL,
       CC_OFFANS_GET_SUBSTATE(con),
       CC_OFFANS_METHOD_USED(con));

   pSTR = (SendToResource_t*)event2; /* bug 76675 */

   ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

   icSvcHeader = (SvcHeader_t *) event;
  /*FID 16206 +*/
  if(con->dummyCallInfo)
  {
     ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
     RETVALUE(ROK);
  }
  /*FID 16206 -*/

   if (con->icBcm.cc != NULLP)
      if (con->icBcm.cc->ccId == CiThreePartySetup)
         noCloseMsgAndCloseTx   = TRUE;

   if (icSvcHeader->lastTransactionFlag == TRUE)
      ccDeleteBcm(&(con->icBcm));

   /* Added for Bug# 15384 */
   if (con->icBcm.cc != NULLP)
   {
      if (con->icBcm.cc->ccId == CiForward)
      {
         /* For Call Forwarding number, send to resource message must not
          * be received */
         CCDP(AIN_DBG_LEVEL_0,
              "Send To Resource is not valid for Forwarding Party\n");
         if (con->icBcm.cc->legId02 != NULLP)
         {
            cs1Con = con->icBcm.cc->legId02->con;
            con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
            con->icBcm.cc->legId02 = NULLP;
            con->icBcm.cc          = NULLP;
            ccRelCon(con);
            /* Play Busy Tone for the Originating Party */
            if (cs1Con != NULLP)
               ccProcessFailCnd(cs1Con, FC_INTERNAL, TRUE);
         }
         else
         {
           CCLOGERR("con->icBcm.cc->legId02 is NULLP\n");
           ccRelCon(con);
         }
         RETVALUE(ROK);
      }
      else if (con->icBcm.cc->ccId == CiRemoteTransferSetup)
      {
        /* FID15310.1 ++ */
        if ( CC_IS_ICA_CALL(con) && 
             (con->icBcm.cc->legId01 == &(con->icBcm)) && 
             (con->icBcm.cc->legId1))
        {
          CCDP(AIN_DBG_LEVEL_0,"ICA calls need to play annoucement for A party!\n");
          ret = ccSendToResourceForIcaCall(con);
          if (ret != ROK)
          {
            CCLOGERR("Error: ccSendToResourceForIcaCall failed:icSu:%ld, ogSu:%ld, icTrsId:%ld\n",
                con->icSuConnId, con->ogSuConnId, (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          }
          RETVALUE(ROK);
        }/* FID15310.1 -- */
        else
        {
          ccProcessFailCnd(con, FC_INTERNAL, TRUE);
          RETVALUE(ROK);
        }
      }
   }

   if (pSTR->cacFailInfo.pres)
   {
     con->callDtlInfo.cm.CACCause.cacTypeDir.pres = PRSNT_NODEF;
     con->callDtlInfo.cm.CACCause.cacTypeDir.val = pSTR->cacFailInfo.cacTypeDir;
     CCDP(AIN_DBG_LEVEL_0,"%s: cacTypeDir=%d\n", 
          __FUNCTION__, pSTR->cacFailInfo.cacTypeDir);

     con->callDtlInfo.cm.CACCause.CACProfileName = pSTR->cacFailInfo.cacPrflName;
     if (pSTR->cacFailInfo.cacPrflName.pres)
     {
       CCDP(AIN_DBG_LEVEL_0,"%s: cacPrflName=%s\n", 
            __FUNCTION__, pSTR->cacFailInfo.cacPrflName.val);
     }

   }

   con->lastState = con->state;
   con->anncBlock.stateForAnnc = con->state;
   ret = ccSendToResource(&(con->icBcm));
   if (ret != ROK)
   {
     CCLOGERR("Error: ccSendToResource failed:icSu:%ld, ogSu:%ld, icTrsId:%ld\n",
              con->icSuConnId, con->ogSuConnId, (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
     ccHandleCleanUpConCb(con, TRUE, AM_CV_TMPFAIL);
   }
   RETVALUE(ROK);
} /* End of ccConE47S37 */



/*
*
*      Fun:   ccConE38S39
*
*      Desc:  Connection state function
*             event - CCE_AUTHORIZE_TERMINATE
*             state - CCS_AWTRSPFORDPE20
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PUBLIC S16 ccConE38S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t            *taSvcHeader    = NULLP;

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  taSvcHeader = (SvcHeader_t *) event;
 
  if (taSvcHeader->lastTransactionFlag == TRUE)
    ccDeleteBcm(&(con->ogBcm));

  ccProcessAuthorizeTermination(con);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE41S39
*
*      Desc:  Connection state function
*             event - CCE_FORWARD_CALL
*             state - CCS_AWTRSPFORDPE20
*      Comments have been added w.r.t      A-B-C call. (B CF to C)
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE41S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                  ret           = RFAILED;
  SvcHeader_t       *taSvcHeader    = NULLP;


  CCDP(AIN_DBG_LEVEL_1, "ccConE41S39: %ld \n", con->icSuConnId);
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  taSvcHeader = (SvcHeader_t *) event;

  if (taSvcHeader->lastTransactionFlag == TRUE)
    ccDeleteBcm(&(con->ogBcm));

  /* Drop down and go ahead with Forward Call */

  ret = ccForwardCallAPI(con);
  if (ret == RFAILED)
  {
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULL);
  }
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE47S39
*
*      Desc:  Connection state function
*             event - CCE_SEND_TO_RESOURCE
*             state - CS_AWTRSPFORDPE20
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE47S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   SvcHeader_t       *taSvcHeader           = NULLP;
   S16                ret                   = RFAILED;

   CCDP(AIN_DBG_LEVEL_1, "ccConE47S39: Rec SendToResource in AWTRSPFORDPE20\n");

   taSvcHeader = (SvcHeader_t *) event;

   if (taSvcHeader->lastTransactionFlag == TRUE)
      ccDeleteBcm(&(con->ogBcm));

   con->lastState = con->state;
   con->anncBlock.stateForAnnc = con->state;
   ret = ccSendToResource(&(con->icBcm));
   if (ret != ROK)
   {
     CCLOGERR("Error: ccSendToResource failed:icSu:%ld, ogSu:%ld,"
              "icTrsId:%ld\n", con->icSuConnId, con->ogSuConnId,
              (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
     ccHandleCleanUpConCb(con, TRUE, AM_CV_TMPFAIL);
   }
   RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE39S40
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE30
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S40
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t       *tbSvcHeader    = NULLP;
  S16               ret             = RFAILED;
  U8                index           = 0;
  Continue_t        *pContinue      = NULLP;

  /* We come here only when there is an error */
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  ccPostEventToSelf (con);
  CCDP(AIN_DBG_LEVEL_1, "ccConE39S40:%ld\n", con->icSuConnId);
  tbSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2;

  if (pContinue->errorCode != FC_NOT_APPLICABLE)
    CCLOGERR("ERROR: rcv error %ld, %ld\n", pContinue->errorCode,
                                               con->icSuConnId);

  /* For ACB, check if OCalledPartyBusy is armed */
  ret = ccProcessOCalledPartyBusy(&(con->icBcm));
  if (ret == ROK)
  {
     CCDP(AIN_DBG_LEVEL_0, "Detected OCdPrtyBusy:%ld\n", con->icSuConnId);
     RETVALUE(ROK);
  }
  else
  {

     if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) ||
         (con->ogBcm.SndNotInd != SND_NOTIF_NOT_PRSNT))
        ccUpdateBusyCauseForTermNot(con, con->icProtType,
                                    ILOC_PUBNETRUS, CSTD_CCITT,
                                    CCUSRBSY);

     /* Bug# 10613: Close TBCM */
     if (con->ogBcm.svcHeader.transId != 0)
     {
        for (index = 0; index < EReqMax; index++)
        {
            con->ogBcm.nel[index] = NEL_UNARMED;
        }
        ccCloseTBcmTransaction(con);
     }

     if((con->ogRscSta == RMT_RES_ALOC_BUSY) &&
        ((ccIsLEGSubscriber(&con->ogBcm)) ||
        (CC_GET_PROTOCOL(con->ogProtType) == CC_IN)))
     {
        ccProcessFailCnd(con, FC_USRBUSY, TRUE);
     }
     else
     {
        ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);
     }
     RETVALUE(ROK);
  }

  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE39S41
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE11
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S41
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t    *omSvcHeader    = NULLP;
#ifdef ZC
  ZcUpdParam upd; 
#endif /* ZC */
  Continue_t        *pContinue      = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE39S41: %ld\n", con->icSuConnId);
  omSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2;

  if (pContinue->errorCode != FC_NOT_APPLICABLE)
    CCLOGERR("ERROR:rcvd from FIC: %ld\n", pContinue->errorCode);

  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
#ifdef ZC
    cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.ccAinUpdType = CC_UPDATE_BCM;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
  }
  /* Lets ignore the flash and fall back to the last state */
  CC_STATE_CHANGE(con, con->lastState);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE41S40
*
*      Desc:  Connection state function
*             event - CCE_FORWARD_CALL
*             state - CCS_AWTRSPFORDPE30
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE41S40
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  S16                  ret           = RFAILED;
  SvcHeader_t             *tbSvcHeader     = NULLP;
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  ccPostEventToSelf (con);
  CCDP(AIN_DBG_LEVEL_1, "ccConE41S40: %ld\n", con->icSuConnId);
  tbSvcHeader = (SvcHeader_t *) event;

  if (tbSvcHeader->lastTransactionFlag == TRUE)
  {
    /* Will not be deleting the BCM, as it will screw up the ForwardCall,
       Inform FIC about this error */
    CCLOGERR("ERROR: rcvd lastTxnFlag = TRUE\n");
  }

  ret = ccForwardCallAPI(con);
  if (ret == RFAILED)
  {
    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULL);
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE44S40
*
*      Desc:  Connection state function
*             event - CCE_OFFER_CALL
*             state - CCS_AWTRSPFORDPE30
*             Comments are as per the Following scenario
*             A and B in Two Party Call.
*             C calls B/ C calls A
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE44S40
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                      ret             = RFAILED;
  UConnId                  busySuConnId    = 0;
  CcConCb                 *CSID1con        = NULLP;
  CcCnStEvnt               tempEvent;
  Buffer                  *uBuf            = NULLP;
  msgValBcmTypeEnum        bcmType         = BtMax;
  CcMidCallReqEvnt         midCallReq;
  CcCnStEvnt               ogEvnt;
  SvcHeader_t             *tbSvcHeader;
#ifdef CC_CALEA
  Bool reqSFMAdd = FALSE;
  MgctCmdType cmdType = MGCT_CMD_ADD;
#endif
  U8                       tempEvntType    = 0;
  U8                       index           = 0;
  MgcpCctEvnt_t            *mgcp = &(ogEvnt.m.mgcpCctEvnt);

  CCDP(AIN_DBG_LEVEL_1, "ccConE44S40: %ld\n", con->icSuConnId);
  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));

#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
  ccPostEventToSelf (con);

  tbSvcHeader = (SvcHeader_t *) event;

  if (tbSvcHeader->lastTransactionFlag == TRUE)
  {
    /* Will not be deleting the BCM, as it will screw up the CWT,
       Inform FIC about this error */
    CCLOGERR("ERROR: rcvd lastTxnFlag = TRUE\n");
  }

  cmMemset((U8 *)&tempEvent, 0, sizeof(CcCnStEvnt));
  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));

  busySuConnId = con->busySuConnId;
  /* Find the connection block with which this resource is busy */
  ret = cmHashListFind (&ccSuInstTbl, (U8 *)&busySuConnId, (U16)sizeof(UConnId),
                         (U16)0, (PTR *) &CSID1con);
  if (ret != ROK)
  {
    ret = cmHashListFind(&ccSuOgInstTbl, (U8 *)&busySuConnId,
                         (U16)sizeof(UConnId), (U16)0, (PTR *) &CSID1con);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0, "CWT Subscriber in TBCM,%ld\n",CSID1con->ogSuConnId);
      bcmType        = BtTBcm;
    }
    else  /* ERROR Case */
    {
      /* Did not find the busySuConnId in both the hash List,
       * Play a busy tone */
      CCLOGERR( "Error: Cb for Resource not found,%ld\n", con->ogSuConnId);
      ccPlayToneOrRelease(con, CCUSRBSY);
      RETVALUE(ROK);
    }
  }
  else  /* We found it in ccSuInstTbl */
  {
    CCDP(AIN_DBG_LEVEL_0, "CWT Subscriber in OBCM,%ld\n", CSID1con->icSuConnId);
    bcmType = BtOBcm;
  }

  if (CSID1con->state != CCS_ANSWERED)
  {
    if (con->ogBcm.svcHeader.transId != 0)
    {
      for (index = 0; index < EReqMax; index++)
      {
        con->ogBcm.nel[index] = NEL_UNARMED;
      }
      ccCloseTBcmTransaction(con);
    }
    ccProcessFailCnd(con, FC_NOCKTAVAIL, TRUE);

      /* BUG:29717-mqin */
    ccCp.sts.fResUnavail++;
    
    RETVALUE(ROK);
  }

  /* We reach here, after we find find the associated CS1. */

  /* Map and send a Status indication to incoming */
  con->icEvnt = (CcAllSdus *)&tempEvent;
  con->ogEvnt = (CcAllSdus *)&ogEvnt;

  tempEvntType    = con->icEvntType;
  con->direction = OUTTOINC;
  if(con->ogProtType == CC_MGCP_LN)
    con->icEvntType = CCMGCP_ET_ALERTING;
  else
    con->icEvntType = CS_CONN_STATUS_ALERTING;

  ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
  if (ret == RFAILED) 
  {
    ccPlayToneOrRelease(con, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  if (ret == ROK)
  {
    uBuf = con->uBuf;
    con->uBuf = NULLP;
    ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                  con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                  con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
  }
  /* Bug# 20640 */
  if (ccInit.acnt == TRUE)
  {
     con->callDtlInfo.cm.tckOgConReqSent.pres = PRSNT_NODEF;
     (Void) SGetSysTime(&con->callDtlInfo.cm.tckOgConReqSent.val);
  }

  con->mgPlayingTone = TRUE;
  con->mgToneType = MGCT_SIG_ID_CG_RT;
  if (con->icBcm.pic < PicOAlerting)
    ccProcessOTermSeized(&(con->icBcm));

  UPDATE_OPIC(con, PicOAlerting);
  if (con->icBcm.cc != NULLP)
  {
    if (con->icBcm.cc->ccId == CiThreePartySetup)
      con->icBcm.cc->ccId = CiPartyOnHold;
  }

  if(ccIsIPSubscriber(&(con->ogBcm)))
  {
    /* prepare MgcpEvnt for MDCX with : CallWaitTone, CallerId, CallerName */

    /* initialize the MGCP event */
    INITEVENT(mgcp, sizeof(MgcpCctEvnt_t));
    ccMgcpFillSignal(mgcp, MGCP_LINE_CALL_WAIT1);
    mgcp->evntType = CC_CCT_EVNT_TYPE_CNSTREQ;
    if ((ccRetCNDStatus(con) == ROK))
    {
      CCDP(AIN_DBG_LEVEL_0, "ccRetCNDStatus ok and %d\n",
                            con->ainInfo.cgPtyNmb.eh.pres);
      /* calling party number */
      mgcp->cgPtyNmb.eh.pres = PRSNT_NODEF;
      ccSetDfltCsCgPtyNmb(&(mgcp->cgPtyNmb));
      if (con->ainInfo.cgPtyNmb.eh.pres)
      {
        cmMemcpy((U8 *)&(mgcp->cgPtyNmb), (U8 *)&(con->ainInfo.cgPtyNmb),
          sizeof(CgPtyNmb));
        CCDP(AIN_DBG_LEVEL_0,"mgcp->cgPtyNmb: %s\n",
            mgcp->cgPtyNmb.nmbDigits.val);
      }
      else
      {
       ccSetDfltCsCgPtyNmb(&(mgcp->cgPtyNmb));
       CCLOGERR("*****:CWT-TONE:CND is SET but No CG PTY NUMB ***\n");
      }
    }
    if ((con->genName.eh.pres) && (con->ainInfo.CNAMAllowed))
    {
      CCDP(AIN_DBG_LEVEL_0, "Name present for Reconnect:\n");
      cmMemcpy((U8 *)&(mgcp->genName), (U8 *)&(con->genName),
        sizeof(SiGenName));
    }
  }
  else
  {
    cmMemset((U8 *)&midCallReq, 0, sizeof(CcMidCallReqEvnt));
    ccBuildMidCalReqForCWTToneAndCallerId(con, &midCallReq);
  }

  if (bcmType == BtOBcm)
  {
    if (CSID1con->icBcm.cc == NULLP)
    {
      /* Do not deallocate the new ogBcm cc */
      CCDP(AIN_DBG_LEVEL_0, "CWT in in OBCM CS1\n");
      CSID1con->icBcm.cc     = con->ogBcm.cc;
    }
    else
    {
      /* Deallocate, as we already have one CC already. */
      ccDropOgBcmMember(con);
      con->ogBcm.cc = CSID1con->icBcm.cc;
    }

    /* Associate the CS1 and CS2 in CSA1 */
    con->ogBcm.cc->ccId    = CiCallWaiting;
    con->ogBcm.cc->legId01 = &(con->ogBcm);
    con->ogBcm.cc->legId02 = &(CSID1con->icBcm);
    con->ogBcm.cc->legId1  = &(CSID1con->ogBcm);
    con->ogBcm.cc->legId2  = &(con->icBcm);
    if(con->ogProtType == CC_MGCP_LN)
    {
      ccSendCnStReq(CSID1con, CSID1con->icSapCb->suId, &CSID1con->icSapCb->pst,
                    CSID1con->icSapCb->spId, CSID1con->icSpConnId,
                    CSID1con->icSuConnId, CSID1con->icProtType,
                    CCMGCP_ET_MODIFY_CONNECTION, &ogEvnt, NULLP);
    }
    else
    {
      /* Play CWT tone to IC, (Controller) */
      CcLiCctMidCallReq(&CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                        CSID1con->icSpConnId, CSID1con->icSuConnId,
                        CSID1con->icProtType, &midCallReq);
      /* GCC does not expect a response, lets proceed with the Call */
    }
#ifdef CC_CALEA
  /* Sending CallWaiting Alerting in N/W signal to FIC */
  ccSendNetworkSignalMsg(CSID1con, FC_SIG_ALERTING, 
                         SigAlertingCallWaitingPattern1, 0, 0,
                         CC_INCOMING);
#endif
  }
  else /* It is BtTBcm */
  {
    /* Bug# 20222 */
    if (CSID1con->ogBcm.cc == NULLP)
    {
       /* Do not deallocate the new ogBcm cc */
       CCDP(AIN_DBG_LEVEL_0, "CWT in TBCM of CS1\n");
       CSID1con->ogBcm.cc     = con->ogBcm.cc;
    }
    else
    {
       /* Deallocate the original cc memory */
       ccDropOgBcmMember(con);
       con->ogBcm.cc          = CSID1con->ogBcm.cc;
    }

    /* Associate the CS1 and CS2 in CSA1 */
    con->ogBcm.cc->ccId    = CiCallWaiting;
    con->ogBcm.cc->legId01 = &(con->ogBcm);
    con->ogBcm.cc->legId02 = &(CSID1con->ogBcm);
    con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
    con->ogBcm.cc->legId2  = &(con->icBcm);

    if(con->ogProtType == CC_MGCP_LN)
    {
      ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId, &CSID1con->ogSapCb->pst,
                    CSID1con->ogSapCb->spId, CSID1con->ogSpConnId,
                    CSID1con->ogSuConnId, CSID1con->ogProtType,
                    CCMGCP_ET_MODIFY_CONNECTION, &ogEvnt, NULLP);
    }
    else
    {
      /* Play CWT tone to IC, (Controller) */
      CcLiCctMidCallReq(&CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                        CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                        CSID1con->ogProtType, &midCallReq);
    }
    /* GCC does not expect a response, lets proceed with the Call */
#ifdef CC_CALEA
  /* Sending CallWaiting Alerting in N/W signal to FIC */
  ccSendNetworkSignalMsg(CSID1con, 0,0, FC_SIG_ALERTING, 
                         SigAlertingCallWaitingPattern1, CC_OUTGOING);
#endif
    /* GCC does not expect a response, lets proceed with the Call */
  }

  /* restore the 'con->icEvntType' back to original value */
  con->icEvntType = tempEvntType;
    
  if (!ccIsIPResource(&(con->icBcm)))
  {
#ifdef CC_CALEA
    ccAdjustNoOfCaleaLegs(con, &reqSFMAdd);
#endif
    if (reqSFMAdd)
    {
       CCDP(AIN_DBG_LEVEL_0,"Sending MGCT_CMD_ADD to MGI\n");
       cmdType = MGCT_CMD_ADD; 
    }
    else
    {
      if(ccCheckForCallOnHold (&(con->icBcm)) == ROK) 
        cmdType = MGCT_CMD_ADD;
      else 
        cmdType = MGCT_CMD_ADD;
    }
    /* Add IC in Ring Signal */
    ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_CG,
                                 MGCT_SIG_ID_CG_RT, cmdType,
                                 &(con->icBcm), NULLP, NULLP,
                                 NULLP, NULLP, NULLP, 
                                 (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                 MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
    /* Need to adjust the no of CAlea Legs w.r.t to the controller, any
     * excess LEA legs attached to con->icBcm in CS2 will be released */
    if (con->icBcm.cc != NULLP)
    {
      if (((con->icProtType == CC_CS_LN)||(con->icProtType == CC_GR303)) &&
          (isCaleaLegPresent(&(con->icBcm))))
        ccAddCaleaToMgQ(&(con->icBcm), MGCT_ITEM_ID_CG_MAX, con);
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0,"con->icBcm.cc is NULLP\n");
    }
#endif
    con->lastState = con->state;
    CC_STATE_CHANGE(con, CCS_AWTSWTCFM); /* Do we want to go in this state */
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                       CCS_CANNOTPROCESSEVENTS);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    if (ret != ROK)
    {
      cleanUpMgQ(con);
      CCLOGERR( "Error: Failed to play Ring back on %ld\n", con->icSuConnId);
      /* Still go ahead, the Originator will not hear a Ring back */
    }
    else
    {
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                           CCS_CANNOTPROCESSEVENTS);
    }
  }
  else
  {
    ccProcessTNoAnswer(&(con->ogBcm));
    CC_STATE_CHANGE(con, CCS_AWTANS);
  }
#ifdef CC_CALEA
  /* Send RingBack N/w Signal to the incoming */
  ccSendNetworkSignalMsg(con, FC_SIG_TONE, SigToneRingbackTone, 0, 0,
                         CC_INCOMING);
#endif
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE45S41
*
*      Desc:  Connection state function
*             event - CCE_ORIGINATE_CALL
*             state - CCS_AWTRSPFORDPE11
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE45S41
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb             *newcon         = NULLP;
  S16                  ret            = RFAILED;
  PTR                  dupEntry       = NULLP;   /* For checking duplicate item */
  UConnId              tempSuConnId   = 0;
  SvcHeader_t         *omSvcHeader    = NULLP;
  Bool                 mgiSent        = FALSE;
  U16                  index        = 0;
  SvcHeader_t          header;
  OriginationAttempt_t originationAttempt;
  U8 leaIndex = 0;

  CCDP(AIN_DBG_LEVEL_1, "ccConE45S41: %ld\n", con->icSuConnId);
  omSvcHeader = (SvcHeader_t *) event;

  if (omSvcHeader->lastTransactionFlag == TRUE)
  {
    /* We are going to use the same transId for the newcon */
    /* Ignore and go ahead */
    CCLOGERR("ERROR: rcvd lastTxnFlag = TRUE\n");
  }

  /* Allocate a connection block */
  if ((ret = ccInitCon(&newcon)) != ROK)
  {
    CCLOGERR( "InitCon Failed for Originate Call\n");
    RETVALUE(ROK);
  }
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  if (!(ccIsSwitchingLocallyDone(&con->ogBcm) ||
        ccIsSwitchingLocallyDone(&con->icBcm)))
    ccMakeLegInactive(&(con->ogBcm));

  /* Move CS1 IC to CS2 IC */
  ret = cmHashListDelete(&ccSuInstTbl, (PTR)con);
  tempSuConnId         = con->icSuConnId;
  con->icSuConnId      = ccGetNewSuConnId();
  newcon->origIcSuConnId  = con->icSuConnId;

  ret = cmHashListInsert(&ccSuInstTbl, (PTR)con, (U8 *)&con->icSuConnId,
                         (U16)sizeof(UConnId));
  newcon->icSuConnId   = tempSuConnId;

  newcon->ogSuConnId   = ccGetNewSuConnId();
  newcon->origOgSuConnId = newcon->ogSuConnId;

  newcon->icProtType = con->icProtType;
  newcon->icSapCb    = con->icSapCb;
  newcon->uBuf       = con->uBuf;
  newcon->direction  = INCTOOUT;

  newcon->icRscVal    = TRUE;
  newcon->icRsc       = con->icRsc;
  /* A shortcut to indicate that the Rsc is absent, must be in another CS
     of the CSA */
  con->icRscVal       = FALSE;

  /* Copy CallId from con->icBcm */
  ccCopyTknStrVar(&(newcon->callDtlInfo.un.icSipId),&(con->callDtlInfo.un.icSipId));

  /* FID14485 the sip call-id GCC generated is within 32(CC_SIP_ID_LENGTH_OLD) bytes presently, 
   * if the call-id GCC generated is longer than 32  bytes,should change to CC_SIP_ID_LENGTH(128)
   * or more.
   */
   /* Generate new ogCallId */
  ret = ccGetNewVarSipCallId (&(newcon->callDtlInfo.un.ogSipId),
        CC_SIP_ID_LENGTH, newcon->ogSuConnId,TRUE);
  if(ret != ROK) 
     CCDP(AIN_DBG_LEVEL_0,"Error in getting new sip call-id!");

  CCDP(AIN_DBG_LEVEL_0, "%ld, %ld, %ld, %ld\n", con->icSuConnId, con->ogSuConnId,
                         newcon->icSuConnId, newcon->ogSuConnId);

  if ((ret = ccAssignSaps(newcon, &(newcon->icRsc.intfc))) != ROK)
  {
    CCLOGERR( "ccAssignSaps Failed\n");
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  if (con->ogProfile != NULLP)
     cmMemcpy((U8 *) newcon->icProfile, (U8 *) con->icProfile,
                                            sizeof(CcProfile));
  ret = SGetSBuf(ccInit.region, ccInit.pool,
                 (Data **) &newcon->ccEvntHold, (Size) sizeof(CcAllSdus));
  if (ret != ROK)
  {
    CCLOGERR( "SGetSBuf Failed for ccEvntHold\n");
    ccRelCon(newcon);
    RETVALUE(ROK);
  }
  cmMemset((U8 *) (newcon->ccEvntHold), 0, sizeof(CcAllSdus));
  ccSetEvntHoldsEvntHeldType(newcon, CC_GET_PROTOCOL(newcon->icProtType));


  /* Need to Insert newcon in various HashList's */

  /* Find the icSuConnId in the ccSuOgInstTbl */
  ret = cmHashListFind(&ccSuOgInstTbl, (U8 *)&newcon->icSuConnId,
                      (U16)sizeof(UConnId), 0, &dupEntry);
  if (ret != ROK)
    ret = cmHashListInsert(&ccSuInstTbl, (PTR)newcon, (U8 *)&newcon->icSuConnId,
                           (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCLOGERR("cmHashListInsert failed for ccSuInst icSuConnId=%ld\n",
                          newcon->icSuConnId);
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  /* Find the ogSuConnId in the ccSuInstTbl */
  ret = cmHashListFind(&ccSuInstTbl, (U8 *)&newcon->ogSuConnId,
                      (U16)sizeof(UConnId), 0, &dupEntry);
  if (ret != ROK)
     ret = cmHashListInsert(&ccSuOgInstTbl, (PTR)newcon,
                            (U8 *)&newcon->ogSuConnId, (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCLOGERR("cmHashListInsert failed ccSuOgInst ogSuConnId=%ld\n",
                          newcon->ogSuConnId);
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  /* Move the Hash entry of the sapCb */
  ret = cmHashListDelete(&con->icSapCb->spInstTbl, (PTR)con);
  newcon->icSpConnId = con->icSpConnId;
  con->icSpConnId    = 0;
  ret = cmHashListInsert(&newcon->icSapCb->spInstTbl, (PTR) newcon,
                         (U8 *)&newcon->icSpConnId, (U16) sizeof(UConnId));
  
  if (ccInit.acnt == TRUE)
  {
#if 1 /* change from local time to UTC in billing */
    SwTimevalGet (&newcon->callDtlInfo.cm.timevalStart,
		  SW_TIMEVAL_IcConIndRcvd, NULL);
#else
    (Void) SGetDateTime(&newcon->callDtlInfo.cm.tmIcConIndRcvd);
#endif
    newcon->callDtlInfo.cm.tckIcConIndRcvd.pres = PRSNT_NODEF;
    (Void) SGetSysTime(&newcon->callDtlInfo.cm.tckIcConIndRcvd.val);
  }

  /* Change owner of the Controlling Resource */
  newcon->icRscVal = FALSE;
  ccAllocateResource(newcon, (CcConEvnt *)event, CC_INCOMING, RMT_ALOC_CHOWN);
  newcon->icRscVal = TRUE;

  /* Build the Call Config in the BCM. */
  newcon->icBcm.svcHeader.transId  = ccGetNewtransId();

  /* Both the BCM have a common CC area */
  newcon->icBcm.cc = con->icBcm.cc;

  /* FillBCMInfo for OBCM */
  ret = ccFillBCMInfo(newcon, &(newcon->icBcm), newcon->icBcm.svcHeader.transId,
                      CiThreePartySetup, PicCollectInformation, BtOBcm,
                      DP_INFO_COLLECTED);
  /* Insert in icBCM Hash table */
  ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(newcon->icBcm),
                        (U8 *)&(newcon->icBcm.svcHeader.transId),
                        (U16)sizeof(UConnId));

  CCDP(AIN_DBG_LEVEL_0,  "Inserted in ccicBCMInsTbl\n");

  newcon->icBcm.cc->legId01 = &(newcon->icBcm);
  newcon->icBcm.cc->legId02 = &(con->icBcm);
  newcon->icBcm.cc->legId1  = &(con->ogBcm);
  newcon->icBcm.cc->legId2  = &(newcon->ogBcm);

  /* bug# 18012 */
  ccStartConTmr(TMR_SETUP, newcon, (PTR)&ccCp.genCfg);
  ccCp.sts.totalCalls++;

  /* Send Sub req to MGI in CSID 1     */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
#ifdef CC_CALEA
    ccAddSubCaleaRscReqIntoMgQ(&(con->icBcm), FALSE, FALSE);
    ccAssociateSubAndCaleaLegs(&(con->icBcm), &(newcon->icBcm));
#endif

    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    con->lastState = con->state;
    CC_STATE_CHANGE(newcon, CCS_CANNOTPROCESSEVENTS);
    CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORHOLD);
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      CCLOGERR( "Error: ccSendMgiQueue failed:%ld,%ld,%ld\n",
                con->icSuConnId, con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
      cleanUpMgQ(con);
    }
    else
      mgiSent = TRUE;
  }
  if (!mgiSent)
  {
    CCDP(AIN_DBG_LEVEL_0, "ON-NET call suCtxId = %ld\n",
         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
    CCDP( AIN_DBG_LEVEL_0, "Call On-hold case:1ic:%ld,1og:%ld,2ic%ld,2og%ld\n",
          con->icSuConnId, con->ogSuConnId, newcon->icSuConnId,
          newcon->ogSuConnId );
    CC_STATE_CHANGE(con, CCS_ANSWERED);
#ifdef CC_CALEA
    /* Set the noOfCalea count in the newcon */
    for (leaIndex = 0; leaIndex < MAX_CALEALEGS_PER_SUB; leaIndex++)
    { 
      if (newcon->icBcm.cc->caleaLegId[leaIndex] != NULLP)
        newcon->ainInfo.noOfCaleaLegs++;
    }
    CCDP(AIN_DBG_LEVEL_0,"CS2 of CT call has %d noOfCaleaLegs so far\n",
         newcon->ainInfo.noOfCaleaLegs);
#endif

    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&originationAttempt, 0, sizeof(OriginationAttempt_t));

    /* Update icBcm parameters */
    ccUpdateBcm(newcon, PicONull, CiThreePartySetup, BtOBcm);

    /* Update for RecallDialTone */
    newcon->ainInfo.ControllingLegTreatment = CltRecallDialToneOn;

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
      newcon->icBcm.nel[index] = NEL_UNARMED;
    ccFillSvcHeader(&header, &(newcon->icBcm), MSG_Origination_Attempt);

    ccFillOrigAttemptParam(&originationAttempt, &(newcon->icBcm), FALSE);

    CC_STATE_CHANGE(newcon, CCS_AWTRSPFORDPE1);

    CCDP(AIN_DBG_LEVEL_0," Sending OriginationAttempt\n");
    CcUiFctOriginationAttempt(&originationAttempt, &header);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE43S42
*
*      Desc:  Connection state function
*             event - CCE_MOVE_LEG
*             state - CCS_AWTRSPFORDPE27
*             This function is called when GCC receives a response
*             to the TMidCall which was sent to FIC.
*
*             Following things are done in this function.
*             1. Find CS1
*             2. Delete SP and SU from CS1 and move to CS2 or vice versa.
*             3. Change Resource Owner and CCID.
*             4. Stay in ANSWERED state.
*             5. Queue and Send MGI requests.
*             6. Map and send Connect Response.
*      
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE43S42
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *CSID1con       = NULLP;
  msgValBcmTypeEnum bcmType        = BtMax;
  CcMgCmdQ_t       *mgCmdQ         = NULLP;
  CcMgCmdQ_t       *prevCmdQ       = NULLP;
  S16               ret            = RFAILED;
  S16               rmret          = RFAILED;
  SvcHeader_t      *tmSvcHeader    = NULLP;
  Bool              ccMgiProcessed = FALSE;
  Bool              mgiSent        = FALSE;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CC_CALEA
  CcSurrogate *pSurrogate = NULLP;
#endif

  CCDP(AIN_DBG_LEVEL_1, "ccConE43S42:%ld\n", con->icSuConnId);

  tmSvcHeader = (SvcHeader_t *) event;

  if (tmSvcHeader->lastTransactionFlag == TRUE)
  {
    /* This could screw up things, lets ignore */
    CCLOGERR("ERROR: Rcvd txnflg = TRUE :%ld,%ld,%ld,%ld\n", con->icSuConnId,
             con->ogSuConnId, con->icBcm.svcHeader.transId,
             con->ogBcm.svcHeader.transId );
  }

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  CSID1con = con->ogBcm.cc->legId1->con;

  if (con->ogBcm.cc->legId02 == &(CSID1con->icBcm))
    bcmType = BtOBcm;
  else if (con->ogBcm.cc->legId02 == &(CSID1con->ogBcm))
    bcmType = BtTBcm;
  else
  {
    /* Error Case, lets ignore the error and fall back to lastState */
    CC_STATE_CHANGE(con, con->lastState);
    RETVALUE(ROK);
  }

  CCDP(AIN_DBG_LEVEL_0, "%ld, %ld, %ld, %ld\n",
                       CSID1con->icSuConnId, CSID1con->ogSuConnId,
                       con->icSuConnId, con->ogSuConnId);
  if (con->icBcm.pic == PicOAlerting)
  {
    ccCleanAnsFraudCall(con); 
    if (con->ainInfo.scrFraudPrflId)
    {
      if (con->fraudPrflbmap & SET_SCR_ZERODUR_CDR_FLAG)
      {
        ccGenZeroDurFraudCDR(con);
      }
      ccStartFraudTmr(SCR_FRAUD_TMR, con);
    }
  }
 
  if (bcmType == BtOBcm)
  {
    CCDP(AIN_DBG_LEVEL_0, "The Originator is the Controller\n");
    if ((con->ogBcm.cc->ccId  == CiPartyOnHold)||
        (con->ogBcm.cc->ccId  == CiPartyOnHoldComplement))
    /* CC6 */ /* CS2 to CS1 */
    {
/************************SWITCHING REQUEST FOR MOVE LEG *****************/
      ccMoveLegWrtSwitching(&(con->ogBcm), &(CSID1con->icBcm), CCSOURCE,
                            &ccMgiProcessed);
      if (!ccMgiProcessed)
      {
        CCDP(AIN_DBG_LEVEL_0, "ccMgiProcessed:%ld,%ld,%d,%d\n", con->icSuConnId,
                              con->ogSuConnId, ccMgiProcessed, con->icBcm.pic);
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(CSID1con->icBcm));
#endif
        ccUpdateMgQForSubRsc( &(con->ogBcm), con->mgBlock->mgCtx->suCtxId, con);
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->icBcm), NULLP,
                                     NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        /* Adding the CAleaLegs to the originating controller in CS1 */
        ccAddCaleaToMgQ(&(CSID1con->icBcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
#endif
      }
      /* Need to combine the mgCmdQ of CSID1con and con (CS 2) */
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      /* When mgCmdQ for CS 2 is deallocated, mgCmdQ of CS 1 will have junk */
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;

      /* Send the Txn Req */
      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        con->lastState  = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n",
                   (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
#ifdef ZC
      upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MOVE_LEG;
      upd.featMsg.DlegId       = 0;
      upd.featMsg.suCtxId1     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->ogBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC6CtrlHashList(&(con->ogBcm));
/*****************CHANGE OWNER OF RESOURCE AND UPDATE CCID*******************/
      /* Change owner of the Controlling Resource */
      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               CSID1con->icSuConnId);
      }
      else
      {
        CSID1con->icRscVal = TRUE;
        con->ogRscVal      = FALSE;
      }
      con->ogBcm.cc->ccId  = CiCallWaitingComplement;
/*****************************FOR ALL PACKET LEGS***************************/
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* All Packet A, B and C */
        if (!ccIsSwitchingLocallyDone(&(con->icBcm)))
          ccMakeLegInactive(&(con->icBcm));
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
/*############################################################################*/
        /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
         * in CS1 */
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
/*############################################################################*/
      }
      RETVALUE(ROK);
    }
    else /* Need to move controller from CS1 to CS2 */
    {
/************************SWITCHING REQUEST FOR MOVE LEG *****************/
      ccMoveLegWrtSwitching(&(CSID1con->icBcm), &(con->ogBcm), CCDESTINATION,
                            &ccMgiProcessed);
      if (!ccMgiProcessed)
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(CSID1con->icBcm), FALSE, FALSE);
        ccAssociateSubAndCaleaLegs(&(CSID1con->icBcm), &(con->ogBcm));
#endif
        ccUpdateMgQForSubRsc( &(CSID1con->icBcm),
                              (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0), CSID1con);
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                         &(con->ogBcm), NULLP,
                                         NULLP, NULLP, NULLP, NULLP,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, 
                                         con);
#ifdef CC_CALEA
        /* Add the CaleaLegs to the Originating Controller in CS2 */
        ccAddCaleaToMgQ(&(con->ogBcm), MGCT_ITEM_ID_CG_MAX, con);
        if (con->surrogate != NULLP)
        {
          pSurrogate = con->surrogate;
          while (pSurrogate != NULLP)
          {
             ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX, con);
             pSurrogate = pSurrogate->next;
          }
        }
#endif
      }
      if (con->icBcm.pic == PicOAlerting)
      {
        if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty))
          ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        else if (!(ccIsIPResource(&(con->icBcm))))
        {
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_MODIFY,
                                       &(con->icBcm), NULLP,
                                       NULLP, NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, 
                                       con);
        }
      }
      /* Need to combine the mgCmdQ of CSID1con (CS1) and con (CS 2) */
      mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
      {
        prevCmdQ->next = con->mgBlock->mgCtx->mgCmdQ;
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      }
      else
        mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;

      /* Send the Txn Req */
      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        /* We need a new State */
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
        con->lastState  = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n",
                    con->mgBlock->mgCtx->suCtxId);
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Cntl leg connId*/
        upd.featMsg.ccAinUpdType = CC_MOVE_LEG;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->ogBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->icBcm));
/*****************CHANGE OWNER OF RESOURCE AND UPDATE CCID*******************/
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               con->ogSuConnId);
      }
      else
      {
        con->ogRscVal      = TRUE;
        CSID1con->icRscVal = FALSE;
      }
      con->ogBcm.cc->ccId  = CiPartyOnHold;
/*****************************FOR ALL PACKET LEGS***************************/
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* All Packet A, B and C */
        if (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm)))
          ccMakeLegInactive(&(CSID1con->ogBcm));

        if (con->icBcm.pic == PicOActive)
        {
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_ANSWERED);
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, FALSE);
        }
        else
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, TRUE);
      }
      RETVALUE(ROK);
    }
  }
  else /* it should be BtTBcm */
  {
    CCDP(AIN_DBG_LEVEL_0, "The Terminator is the Controller\n");
    if ((con->ogBcm.cc->ccId  == CiPartyOnHold)||
        (con->ogBcm.cc->ccId  == CiPartyOnHoldComplement))
    {
/************************SWITCHING REQUEST FOR MOVE LEG *****************/
      ccMoveLegWrtSwitching(&(con->ogBcm), &(CSID1con->ogBcm), CCSOURCE,
                            &ccMgiProcessed);
      if (!ccMgiProcessed)
      {
        CCDP(AIN_DBG_LEVEL_0, "ccMgiProcessed:%ld,%ld,%d,%d\n", con->icSuConnId,
                              con->ogSuConnId, ccMgiProcessed, con->icBcm.pic);
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(CSID1con->ogBcm));
#endif
        ccUpdateMgQForSubRsc( &(con->ogBcm), con->mgBlock->mgCtx->suCtxId, con);

        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->ogBcm), NULLP,
                                     NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(CSID1con->ogBcm), MGCT_ITEM_ID_CG_MAX, CSID1con);

        /* Add the Surrogate LEAs in CS1 to the Terminating Controller */
        if (CSID1con->surrogate != NULLP)
        {
          pSurrogate = CSID1con->surrogate;
          while (pSurrogate != NULLP)
          {
            ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
            pSurrogate = pSurrogate->next;
          }
        }
#endif
      }
      /* Need to combine the mgCmdQ of CSID1con and con (CS 2) */
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      /* When mgCmdQ for CS 2 is deallocated, mgCmdQ of CS 1 will have junk */
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;

      /* Send the Txn Req */
      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        /* We need a new State */
        con->lastState  = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        con->mgBlock->con = con;
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
#ifdef ZC
      upd.featMsg.suConnId     = con->ogSuConnId;
                                        /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_MOVE_LEG;
      upd.featMsg.DlegId       = 0;
      upd.featMsg.suCtxId1     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.suCtxId2     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
      upd.featMsg.nel          = con->ogBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC6CtrlHashList(&(con->ogBcm));
/*****************CHANGE OWNER OF RESOURCE AND UPDATE CCID*******************/
      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               CSID1con->icSuConnId);
      }
      else
      {
        CSID1con->ogRscVal = TRUE;
        con->ogRscVal      = FALSE;
      }
      con->ogBcm.cc->ccId  = CiCallWaitingComplement;
/*****************************FOR ALL PACKET LEGS***************************/
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* All Packet A, B and C */
        if (!ccIsSwitchingLocallyDone(&(con->icBcm)))
          ccMakeLegInactive(&(con->icBcm));
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
/*############################################################################*/
        /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
         * in CS1 */
        /* ccBuildSwitchingInTalkingState(CSID1con); */
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
/*############################################################################*/
      }
      RETVALUE(ROK);
    }
    else /* Need to move controller from CS1 to CS2 */
    {
/************************SWITCHING REQUEST FOR MOVE LEG *****************/
      ccMoveLegWrtSwitching(&(CSID1con->ogBcm), &(con->ogBcm),  CCDESTINATION,
                            &ccMgiProcessed);
      if (!ccMgiProcessed)
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(CSID1con->ogBcm) ,TRUE, FALSE);
        ccAssociateSubAndCaleaLegs(&(CSID1con->ogBcm), &(con->ogBcm));
#endif
        ccUpdateMgQForSubRsc( &(CSID1con->ogBcm),
                             CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->ogBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP, 
                                     (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(con->ogBcm), MGCT_ITEM_ID_CG_MAX, con);
        if (con->surrogate != NULLP)
        {
           pSurrogate = con->surrogate;
           while (pSurrogate != NULLP)
           {
               CCDP(AIN_DBG_LEVEL_0,
                    "Adding Any Calea Leg's attached to Surrogate=%ld",
               pSurrogate->bcm.svcHeader.transId);
               ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX, con);
               pSurrogate = pSurrogate->next;
           }
        }
#endif
      }
      if (con->icBcm.pic == PicOAlerting)
      {
        if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty))
          ccUpdateMgQForSubAnnRsc(con->mgBlock->mgCtx->suCtxId, con);
        else if (!(ccIsIPResource(&(con->icBcm))))
        {
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_MODIFY,
                                       &(con->icBcm), NULLP, NULLP,
                                       NULLP, NULLP, NULLP,
                                       con->mgBlock->mgCtx->suCtxId,
                                       MGCT_CONTEXT_CHOOSE, 
                                       con);
        }
      }
      /* Need to combine the mgCmdQ of CSID1con (CS1) and con (CS 2) */
      mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
      {
        prevCmdQ->next = con->mgBlock->mgCtx->mgCmdQ;
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      }
      else
        mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;

      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId; /* Cntrl leg connId */
        upd.featMsg.ccAinUpdType = CC_MOVE_LEG;
        upd.featMsg.DlegId       = 0;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->ogBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->ogBcm));
/*****************CHANGE OWNER OF RESOURCE AND UPDATE CCID*******************/
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               con->ogSuConnId);
      }
      else
      {
        con->ogRscVal      = TRUE;
        CSID1con->ogRscVal = FALSE;
      }
      con->ogBcm.cc->ccId  = CiPartyOnHold;
/*****************************FOR ALL PACKET LEGS***************************/
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* All Packet A, B and C */
        if (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm)))
          ccMakeLegInactive(&(CSID1con->ogBcm));

        if (con->icBcm.pic == PicOActive)
        {
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_ANSWERED);
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, FALSE);
        }
        else
        {
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, TRUE);
        }
/*############################################################################*/
      /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
       * in CS1 */
       /* ccBuildSwitchingInTalkingState(CSID1con); */
/*############################################################################*/
      }
      RETVALUE(ROK);
    }
  }
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE45S42
*
*      Desc:  Connection state function
*             event - CCE_ORIGINATE_CALL
*             state - CCS_AWTRSPFORDPE27
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE45S42
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb        *newcon         = NULLP;
  S16             ret            = RFAILED;
  PTR             dupEntry       = NULLP;   /* For checking duplicate item */
  UConnId         tempSuConnId   = 0;
  SvcHeader_t    *tmSvcHeader    = NULLP;
  Bool                 mgiSent        = FALSE;
  U16                  index        = 0;
  SvcHeader_t          header;
  OriginationAttempt_t originationAttempt;
  U8  leaIndex = 0;

  /* Allocate a connection block */
  if ((ret = ccInitCon(&newcon)) != ROK)
  {
    CCLOGERR( "InitCon Failed for Originate Call\n");
    RETVALUE(ROK);
  }

  CCDP(AIN_DBG_LEVEL_1, "ccConE45S42: %ld\n", con->icSuConnId);
  tmSvcHeader = (SvcHeader_t *) event;

  if (tmSvcHeader->lastTransactionFlag == TRUE)
  {
    /* We are going to use the same transId for the newcon */
    /* Ignore and go ahead */
    CCLOGERR("ERROR: rcvd lastTxnFlag = TRUE\n");
  }
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */

  if (!(ccIsSwitchingLocallyDone(&con->ogBcm) ||
        ccIsSwitchingLocallyDone(&con->icBcm)))
    ccMakeLegInactive(&(con->icBcm));

  /* Move CS1 OG to CS2 IC */
  ret = cmHashListDelete(&ccSuOgInstTbl, (PTR)con);
  tempSuConnId         = con->ogSuConnId;
  con->ogSuConnId      = ccGetNewSuConnId();
  newcon->origIcSuConnId = con->ogSuConnId;

  ret = cmHashListInsert(&ccSuOgInstTbl, (PTR)con, (U8 *)&con->ogSuConnId,
                         (U16)sizeof(UConnId));
  newcon->icSuConnId   = tempSuConnId;

  newcon->ogSuConnId   = ccGetNewSuConnId();
  newcon->origOgSuConnId = newcon->ogSuConnId;

  /* Move the Hash entry of the sapCb */

  newcon->icProtType = con->ogProtType;
  newcon->icSapCb    = con->ogSapCb;
  newcon->uBuf       = con->uBuf;
  newcon->direction  = INCTOOUT;

  newcon->icRscVal    = TRUE;
  newcon->icRsc       = con->ogRsc;
  /* A shortcut to indicate that the Rsc is absent, must be in another CS
     of the CSA */
  con->ogRscVal       = FALSE;

  /* Copy CallId from con->ogBcm */
  ccCopyTknStrVar(&newcon->callDtlInfo.un.ogSipId,&con->callDtlInfo.un.ogSipId);


  /* FID14485 the sip call-id GCC generated is within 32(CC_SIP_ID_LENGTH_OLD) bytes presently, 
   * if the call-id GCC generated is longer than 32  bytes,should change to CC_SIP_ID_LENGTH(128)
   * or more.
   */
  /* Generate new icCallId */
  ret = ccGetNewVarSipCallId (&(newcon->callDtlInfo.un.icSipId),
        CC_SIP_ID_LENGTH, newcon->icSuConnId,FALSE);
  if(ret != ROK) 
     CCDP(AIN_DBG_LEVEL_3,"Error in getting new sip call-id!!!");


  if ((ret = ccAssignSaps(newcon, &(newcon->icRsc.intfc))) != ROK)
  {
    CCLOGERR( "ccAssignSaps Failed\n");
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  if (con->ogProfile != NULLP)
     cmMemcpy((U8 *) newcon->icProfile, (U8 *) con->ogProfile,
                                            sizeof(CcProfile));
  ret = SGetSBuf(ccInit.region, ccInit.pool,
                 (Data **) &newcon->ccEvntHold, (Size) sizeof(CcAllSdus));
  if (ret != ROK)
  {
    CCLOGERR( "SGetSBuf Failed for ccEvntHold\n");
    ccRelCon(newcon);
    RETVALUE(ROK);
  }
  cmMemset((U8 *) (newcon->ccEvntHold), 0, sizeof(CcAllSdus));
  /* Bug# 29457 */
  ccSetEvntHoldsEvntHeldType(newcon, CC_GET_PROTOCOL(newcon->icProtType));

  /* Need to Insert newcon in various HashList's */

  /* Find the icSuConnId in the ccSuOgInstTbl */
  ret = cmHashListFind(&ccSuOgInstTbl, (U8 *)&newcon->icSuConnId,
                      (U16)sizeof(UConnId), 0, &dupEntry);
  if (ret != ROK)
    ret = cmHashListInsert(&ccSuInstTbl, (PTR)newcon, (U8 *)&newcon->icSuConnId,
                           (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCLOGERR("cmHashListInsert failed for ccSuInst icSuConnId=%ld\n",
                          newcon->icSuConnId);
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  /* Find the ogSuConnId in the ccSuInstTbl */
  ret = cmHashListFind(&ccSuInstTbl, (U8 *)&newcon->ogSuConnId,
                      (U16)sizeof(UConnId), 0, &dupEntry);
  if (ret != ROK)
     ret = cmHashListInsert(&ccSuOgInstTbl, (PTR)newcon,
                            (U8 *)&newcon->ogSuConnId, (U16)sizeof(UConnId));
  if (ret != ROK)
  {
    CCLOGERR("cmHashListInsert failed ccSuOgInst ogSuConnId=%ld\n",
                          newcon->ogSuConnId);
    ccRelCon(newcon);
    RETVALUE(ROK);
  }

  ret = cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);
  newcon->icSpConnId = con->ogSpConnId;
  con->ogSpConnId    = 0;
  ret = cmHashListInsert(&newcon->icSapCb->spInstTbl, (PTR) newcon,
                         (U8 *)&newcon->icSpConnId, (U16) sizeof(UConnId));

  if (ccInit.acnt == TRUE)
  {
#if 1 /* change from local time to UTC in billing */
    SwTimevalGet (&newcon->callDtlInfo.cm.timevalStart,
		  SW_TIMEVAL_IcConIndRcvd, NULL);
#else
    (Void) SGetDateTime(&newcon->callDtlInfo.cm.tmIcConIndRcvd);
#endif
    newcon->callDtlInfo.cm.tckIcConIndRcvd.pres = PRSNT_NODEF;
    (Void) SGetSysTime(&newcon->callDtlInfo.cm.tckIcConIndRcvd.val);
  }

  /* Change owner of the Controlling Resource */
  newcon->icRscVal = FALSE;
  ccAllocateResource(newcon, (CcConEvnt *)event, CC_INCOMING, RMT_ALOC_CHOWN);
  newcon->icRscVal = TRUE;

  /* Build the Call Config in the BCM. */
  newcon->icBcm.svcHeader.transId  = ccGetNewtransId();

  /* Both the BCM have a common CC area */
  newcon->icBcm.cc = con->ogBcm.cc;

  /* FillBCMInfo for OBCM */
  ret = ccFillBCMInfo(newcon, &(newcon->icBcm), newcon->icBcm.svcHeader.transId,
                      CiThreePartySetup, PicCollectInformation, BtOBcm,
                      DP_INFO_COLLECTED);
  /* Insert in icBCM Hash table */
  ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(newcon->icBcm),
                        (U8 *)&(newcon->icBcm.svcHeader.transId),
                        (U16)sizeof(UConnId));

  CCDP(AIN_DBG_LEVEL_0,  "Inserted in ccicBCMInsTbl\n");


  newcon->icBcm.cc->legId01 = &(newcon->icBcm);
  newcon->icBcm.cc->legId02 = &(con->ogBcm);
  newcon->icBcm.cc->legId1  = &(con->icBcm);
  newcon->icBcm.cc->legId2  = &(newcon->ogBcm);

  /* bug# 18012 */
  ccStartConTmr(TMR_SETUP, newcon, (PTR)&ccCp.genCfg);
  ccCp.sts.totalCalls++;

  /* Send Sub req to MGI in CSID 1     */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
#ifdef CC_CALEA
    ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
    ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(newcon->icBcm));
#endif

    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    con->lastState = con->state;
    CC_STATE_CHANGE(newcon, CCS_CANNOTPROCESSEVENTS);
    CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORHOLD);
    ccChangeCallStateOfAssociatedCalls(&(con->ogBcm), CCS_CANNOTPROCESSEVENTS);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
    if (ret != ROK)
    {
      CCLOGERR("Error: MGI Failed:%ld\n", con->mgBlock->mgCtx->suCtxId);
      cleanUpMgQ(con);
    }
    else
      mgiSent = TRUE;
  }
  if (!mgiSent)
  {
    CCDP(AIN_DBG_LEVEL_0, "ON-NET call suCtxId = %ld\n",
         con->mgBlock->mgCtx->suCtxId);
    CCDP( AIN_DBG_LEVEL_0, "Call On-hold case:1ic:%ld,1og:%ld,2ic%ld,2og%ld\n",
          con->icSuConnId, con->ogSuConnId, newcon->icSuConnId,
          newcon->ogSuConnId );
    CC_STATE_CHANGE(con, CCS_ANSWERED);
#ifdef CC_CALEA
    /* Set the noOfCalea count in the newcon */
    for (leaIndex = 0; leaIndex < MAX_CALEALEGS_PER_SUB; leaIndex++)
    {
      if (newcon->icBcm.cc->caleaLegId[leaIndex] != NULLP)
        newcon->ainInfo.noOfCaleaLegs++;
    }
    CCDP(AIN_DBG_LEVEL_0,"CS2 of CT call has %d noOfCaleaLegs so far\n",
         newcon->ainInfo.noOfCaleaLegs);
#endif

    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&originationAttempt, 0, sizeof(OriginationAttempt_t));

    /* Update icBcm parameters */
    ccUpdateBcm(newcon, PicONull, CiThreePartySetup, BtOBcm);

    /* Update for RecallDialTone */
    newcon->ainInfo.ControllingLegTreatment = CltRecallDialToneOn;

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
      newcon->icBcm.nel[index] = NEL_UNARMED;
    ccFillSvcHeader(&header, &(newcon->icBcm), MSG_Origination_Attempt);

    ccFillOrigAttemptParam(&originationAttempt, &(newcon->icBcm), FALSE);

    CC_STATE_CHANGE(newcon, CCS_AWTRSPFORDPE1);

    CCDP(AIN_DBG_LEVEL_0," Sending OriginationAttempt\n");
    CcUiFctOriginationAttempt(&originationAttempt, &header);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
*      Fun:   ccConE40S41
*
*      Desc:  Connection state function
*             event - CCE_DISCONNECT_LEG
*             state - CCS_AWTRSPFORDPE11
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE40S41
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                  ret          = RFAILED;
  msgValBcmTypeEnum    dBcmType     = BtMax;
  msgValBcmTypeEnum    bcmType      = BtMax;
  SvcHeader_t         *dlSvcHeader  = NULLP;
  AinBCM_t            *legId02      = NULLP;
  AinBCM_t            *legId1       = NULLP;
  CcConCb             *CSID1con     = NULLP;
  CcMgCmdQ_t          *mgCmdQ       = NULLP;
  CcMgCmdQ_t          *prevCmdQ     = NULLP;
  U8                   count        = 0;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED;
#endif

  CCDP(AIN_DBG_LEVEL_1, "ccConE40S41: %ld\n", con->icSuConnId);
  dlSvcHeader = (SvcHeader_t *) event;

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR( "Error *cc is NULLP\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  /* Bug# 20857 */
  ccSetRelIndTicks (con, NULLP); 

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  legId02 = con->icBcm.cc->legId02;
  legId1  = con->icBcm.cc->legId1;
  bcmType = legId02->bcmType;
  CSID1con = con->icBcm.cc->legId1->con;
  dBcmType = BtTBcm;

  count++;
  /* Lets Split Leg First */
  ccSplitMgBlock(legId1, con, con->mgBlock, &count);
  con->mgBlockDirection = LEGID1;
#ifdef CALEA_3WC
  caleaRet = ccAddSubCaleaRscReqIntoMgQ(&(con->icBcm), FALSE, FALSE); 
#endif
  ccUpdateMgQForSubRsc( &(con->icBcm), con->mgBlock->mgCtx->suCtxId, con);
#ifdef CALEA_3WC
  /* Make CAlea Legs of controller in CS2 to point to the controller in 
   * CS1 con */
  ccAssociateSubAndCaleaLegs(&(con->icBcm), legId02);
 
#endif
  ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                               MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                               legId02, NULLP, NULLP,
                               NULLP, NULLP, NULLP,
                               (legId02->con->mgBlock->mgCtx ? legId02->con->mgBlock->mgCtx->suCtxId : 0),
                               MGCT_CONTEXT_CHOOSE, 
                               legId02->con);

#ifdef CALEA_3WC
  /* Add the CAlea Legs of Controller into suCtxId of CS1 */ 
  ccAddCaleaToMgQ(&(con->icBcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
#endif
  /* Need to combine the mgCmdQ of CSID1con and con (CS 2) */
  mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
  while (mgCmdQ != NULLP)
  {
    prevCmdQ = mgCmdQ;
    mgCmdQ = mgCmdQ->next ;
  }
  if (prevCmdQ)
    prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
  else
    con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

  /* When mgCmdQ for CS 2 is deallocated, mgCmdQ of CS 1 will have junk */
  CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;

  con->lastState = con->state;
  CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSPLIT3WC);
  con->mgBlock->con = con;
  ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_2, "MGI Request sent for split:%ld",
                          con->mgBlock->mgCtx->suCtxId);
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  CCLOGERR("Critical Error: Switching failed:%ld, %ld, %ld\n",
            con->icSuConnId, con->ogSuConnId, (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
  cleanUpMgQ(con);
  ABORT_DEBUG;
  CCDP(AIN_DBG_LEVEL_2, "Skipping Split:%ld\n", (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
  /* Switching failed for some reason, still going ahead with Disconnect leg */
#ifdef ZC
  /* Do the replication stuff */
  /**************************REPLICATION****************************/
  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
    upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_DISCONNECTLEG_WITH_SPLIT;
    upd.featMsg.DlegId       = 0;
    upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0); 
    upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
  }
#endif /* ZC */
  /**********************ACT ON DISCONNECT LEG *********************/
  ccToggleCC6CtrlHashList(&con->icBcm);
  if (bcmType == BtOBcm)
  {
/************************CHANGE OWNER OF RESOURCE ******************/
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                             RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld,%ld\n",
                CSID1con->icSuConnId, con->icSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->icRscVal = TRUE;
    }
  }
  else
  {
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                             RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld,%ld\n",
                 CSID1con->ogSuConnId, con->icSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->ogRscVal = TRUE;
    }
  }
  /***ReConnect to CAS-SP with appropriate CONNECTION direction**/
  if (!ccIsIPSubscriber(&(CSID1con->ogBcm)) && (bcmType == BtTBcm))
  {
    ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId,
                  &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                  CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                  CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG,
                  NULLP, NULLP);
  }

  /**************Call Configuration*******************/
  con->icBcm.cc->ccId    = CiStable2Party;
  con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
  con->icBcm.cc->legId02 = NULLP;
  con->icBcm.cc->legId2  = NULLP;
  con->icBcm.cc          = NULLP;

  /**********************PROPAGATE DISCONNECT TO OG*****************/
  ret = RFAILED;
  if (con->ogBcm.bcmType == BtTBcm)
  {
    ret = ccProcessDisconnectOnSpecificBCM(&(con->ogBcm));
#ifdef CALEA_3WC
    /* we must not send the DisconnectNofn for the CaleaLegs of 
     * controller as they will be moved into CS1, but the surrogate 
     * LEAs must be released*/ 
  if (con->surrogate != NULLP)
     ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  }
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0, "Detected Disconnect on OG:%ld,%ld,%ld\n",
                          con->icSuConnId, con->ogSuConnId,
                          con->ogBcm.svcHeader.transId);
    RETVALUE(ROK);
  }
  else
  {
#ifdef CALEA_3WC
    /* The passive leg is not involved in MParty Call */
    caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                               event);
    if (caleaRet != ROK)
    {
       CCDP(AIN_DBG_LEVEL_4,
       "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
    }
#endif
#ifdef ZC
    cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));
    upd.icSuConnId = con->icSuConnId;
    zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif
    /*************************CLEAN UP CS2****************************/
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStopConTmr(con, AIN_O_NO_ANS_TMR);
      ccStopConTmr(con, AIN_T_NO_ANS_TMR);
      /* STOP the AWAIT ANSWER Timer if running
       *
       * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
       */
      ccStopConTmr(con, CC_TMR_AWAITANS); 
      ccStopConTmr(con, TMR_BUSY_TONE);
      ccStopConTmr(con, TMR_RECONNECT);
      ccStopConTmr(con, TMR_RELEASE);
      ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
      ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      con->lastState = con->state;
      if (con->ogRscVal)
      {
        con->tempHolderForReleaseCause =
                                    CS_RELREQ_EVENT_ALLOW_REORIGINATION;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        con->relPend = OGRELONLY;
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        con->relPend = NORELANDNORELRSP;
      }
      RETVALUE(ROK);
    }
    else
    {
      if (con->ogRscVal)
      {
        ccStopConTmr(con, TMR_SETUP);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccSendRelease( con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                       con->ogProtType, CS_RELREQ_EVENT_ALLOW_REORIGINATION,
                       NULLP );
      }
      else
      {
        ccRelCon(con);
        RETVALUE(ROK);
      }
    }
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE40S43
*
*      Desc:  Connection state function
*             event - CCE_DISCONNECT_LEG
*             state - CCS_AWTRSPFORDPE28
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE40S43
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb                 *CSID1con       = NULLP;
  msgValBcmTypeEnum        bcmType        = BtMax; /* passive leg of CS1 */
  S16                      ret            = RFAILED;
  U8                       state          = 0;
  CcMidCallReqEvnt         midCallReq;
  SvcHeader_t             *dlSvcHeader    = NULLP;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE40S43: %ld\n", con->icSuConnId);
  dlSvcHeader = (SvcHeader_t *) event;

  if (con->ogBcm.cc == NULLP)
  {
    CCLOGERR( "Error: cc 0\n");
    CCLOGERR("Critical Error cc NULLP:%ld\n", con->ogBcm.svcHeader.transId);
    RETVALUE(ROK);
  }
  CSID1con = con->ogBcm.cc->legId1->con;
  if (CSID1con == NULLP)
  {
    CCLOGERR("Critical Error CSID1con NULLP:%ld\n",con->ogBcm.svcHeader.transId);
    RETVALUE(RFAILED);
  }

  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccStopConTmr(con, TMR_SETUP);
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  if (con->ainInfo.legId == 1)
  {
    if (con->ogBcm.cc->ccId != CiPartyOnHoldComplement)
    {
      CCDP(AIN_DBG_LEVEL_3, "Unexpected ccId:%d\n", con->ogBcm.cc->ccId);
      RETVALUE(RFAILED);
    }

#ifdef ZC
    upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG;
    upd.featMsg.DlegId       = 1;
    upd.featMsg.nel          = con->ogBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */

    /* The disconnected leg is O or T */
    if (con->ogBcm.cc->legId02 ==  &(CSID1con->icBcm))
    {
      bcmType = BtTBcm;
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */

      /* This is needed, else the cc will be dropped */
      CSID1con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));

      if (con->ogBcm.cc)
      {
        /* update the Call Config of Controller */
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId2  = NULLP;
      }
      CC_STATE_CHANGE(con, con->lastState);

      if (CSID1con->ogRscVal != TRUE)
      {                       
        CCDP(AIN_DBG_LEVEL_1, "Leg 1 in another CSA was cleared from"
                              "this con\n");
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        if (CC_IS_CONTEXT_PRESENT(CSID1con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP,
                               CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
          /* Stop the billing timer */
          ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
          CSID1con->lastState = CCS_ANSWERED;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
          CSID1con->relPend = NORELANDNORELRSP;
          CSID1con->mgBlock->con = CSID1con;
          ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                               CSID1con->mgBlock);
        }
        else
          ret = RFAILED;

        if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", CSID1con->icSuConnId);
          cleanUpMgQ(CSID1con);
          ccRelCon(CSID1con);
          RETVALUE(ROK);
        }
        else
          RETVALUE(ROK);
      }
    }
    else if (con->ogBcm.cc->legId02 == &(CSID1con->ogBcm))
    {
      bcmType = BtOBcm;

#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
      /* This is needed, else the cc will be dropped */
      CSID1con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));

      if (con->ogBcm.cc)
      {
        /* update the Call Config of Controller */
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId2  = NULLP;
      }
      CC_STATE_CHANGE(con, con->lastState);
#ifdef CC_BUFFER_EVENT
    /* There may be a event sitting on con Event Buffer */
    ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */

      if (CSID1con->icRscVal != TRUE)
      {
        CCDP(AIN_DBG_LEVEL_1, "Leg 1 in another CSA was cleared from"
                              "this con\n");
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        if (CC_IS_CONTEXT_PRESENT(CSID1con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP,
                               CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
          /* Stop the billing timer */
          ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
          CSID1con->lastState = CCS_ANSWERED;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
          CSID1con->relPend = NORELANDNORELRSP;
          CSID1con->mgBlock->con = CSID1con;
          ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                               CSID1con->mgBlock);
        }
        else
          ret = RFAILED;

        if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", CSID1con->icSuConnId);
          cleanUpMgQ(CSID1con);
          ccRelCon(CSID1con);
          RETVALUE(ROK);
        }
        else
          RETVALUE(ROK);
      }
    }
    else
    {
      CCLOGERR("Error: Unable to find bcmType: \n");
    }

    ccStopConTmr(CSID1con, TMR_SETUP);
    ccStopConTmr(CSID1con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(CSID1con, AIN_T_NO_ANS_TMR);
    ccDeleteBufferedEvent(CSID1con, CSID1con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(CSID1con, CSID1con->ogSuConnId, CCE_TNOANSEXP);

    /* start a Release procedure for this CS 1 */
    if (CC_IS_CONTEXT_PRESENT(CSID1con))
    {
      /* Blow off the switching context for CSID1con */
      ccUpdateMgQForSubRsc((PTR) NULLP,
                           CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
      /* Stop the billing timer */
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      CSID1con->lastState = CCS_ANSWERED;

      CSID1con->tempHolderForReleaseCause = CCCALLCLR;

      if (bcmType == BtOBcm)
        CSID1con->relPend   = ICRELONLY;
      else /* It should be BtTBcm */
        CSID1con->relPend   = OGRELONLY;

      state = CCS_AWTSWTCFM_SENDONEREL;
      ccModifyRelPendAndState(CSID1con, &(CSID1con->relPend), &state);

      CC_STATE_CHANGE(CSID1con, state);
      CSID1con->mgBlock->con = CSID1con;
      ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                           CSID1con->mgBlock);
    }
    else
      ret = RFAILED;
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other side */
      CCLOGERR("Error: ccSendMgiQueue failed:%ld\n",
                CSID1con->mgBlock->mgCtx->suCtxId);

      /* As the CS 2 would be cleared */
      if (bcmType == BtOBcm)
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
        ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                      CSID1con->icSuConnId, CSID1con->icProtType,
                      CCCALLCLR, NULL);
      }
      else /* It should be BtTBcm */
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
        ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                      CSID1con->ogSuConnId, CSID1con->ogProtType,
                      CCCALLCLR, NULL);
      }
    }
    RETVALUE(ROK);
  }
  else if (con->ainInfo.legId == 2)
  {
    if (con->ogBcm.cc->ccId != CiCallWaiting)
    {
      CCDP(AIN_DBG_LEVEL_3, "Unexpected ccId:%d\n", con->ogBcm.cc->ccId);
      RETVALUE(RFAILED);
    }

    /* We need to turn off the CWT tone as we are going back to a two party Call */
    ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);

    /* Is the Controller O or T of CS 1 */
    if (con->ogBcm.cc->legId02 ==  &(CSID1con->icBcm))
    {
      bcmType = BtOBcm;
      if ((!(ccIsIPSubscriber(&(CSID1con->icBcm)))) &&
          (con->icBcm.pic != PicOActive))
      {
        CcLiCctMidCallReq(&CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                          CSID1con->icSpConnId, CSID1con->icSuConnId, 
                          CSID1con->icProtType, &midCallReq);
      }
      else
      {
        /* Send Cancel CWT tone for IP Subscriber */
      }
    }
    else if (con->ogBcm.cc->legId02 == &(CSID1con->ogBcm))
    {
      bcmType = BtTBcm;
      if ((!(ccIsIPSubscriber(&(CSID1con->ogBcm)))) && 
          (con->icBcm.pic != PicOActive))
      {
        CcLiCctMidCallReq(&CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                          CSID1con->ogSpConnId, CSID1con->ogSuConnId, 
                          CSID1con->ogProtType, &midCallReq);
      }
      else
      {
        /* Send Cancel CWT tone for IP Subscriber */
      }
    }
    else
    {
      CCLOGERR("Error: Unable to find bcmType\n");
      RETVALUE(RFAILED);
    }
#ifdef ZC 
    if (CC_IS_TBCM_PIC_ACTIVE(con))
    {
      upd.featMsg.suConnId     = con->ogSuConnId;
      upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG;
      upd.featMsg.DlegId       = 2;
      upd.featMsg.nel          = con->ogBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
#endif /* ZC */
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
    if (bcmType == BtOBcm)
    {
      CSID1con->icBcm.cc->ccId    = CiStable2Party;
      CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
      CSID1con->icBcm.cc->legId02 = NULLP;
      CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
      CSID1con->icBcm.cc->legId2  = NULLP;
    }
    else /* BtTBcm */
    {
      CSID1con->ogBcm.cc->ccId    = CiStable2Party;
      CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
      CSID1con->ogBcm.cc->legId02 = NULLP;
      CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
      CSID1con->ogBcm.cc->legId2  = NULLP;
    }

    /* This is needed, else the cc will be dropped */
    con->ogBcm.cc = NULLP;
    CC_CLEAN_FIC_TXN(&(con->ogBcm));
#ifdef CC_BUFFER_EVENT
    /* There may be a event sitting on CSID1Con Event Buffer */
    ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */

    if (con->icRscVal != TRUE)
    {
      CCDP(AIN_DBG_LEVEL_1, "Leg 2 in another CSA was cleared from this con\n");
      /* This is needed, else the cc will be dropped */
      con->icBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->icBcm));
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
        /* Stop the billing timer */
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        con->relPend = NORELANDNORELRSP;
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      }
      else
        ret = RFAILED;

      if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", con->icSuConnId);
        cleanUpMgQ(con);
        ccRelCon(con);
        RETVALUE(ROK);
      }
      else
        RETVALUE(ROK);
    }
    ccStopConTmr(con, TMR_SETUP);
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

    /* start a Release procedure for this CS 1 */
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      /* Blow off the switching context for CSID1con */
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      /* Stop the billing timer */
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      con->lastState = CCS_ANSWERED;
      con->relPend   = ICRELONLY;

      state = CCS_AWTSWTCFM_SENDONEREL;
      ccModifyRelPendAndState(con, &(con->relPend), &state);

      CC_STATE_CHANGE(con, state);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    }
    else
      ret = RFAILED;
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other side */
      CCLOGERR("Error: ccSendMgiQueue failed:%ld\n", con->mgBlock->mgCtx->suCtxId);
      cleanUpMgQ(con);

      /* As the CS 2 would be cleared */
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCCALLCLR, NULL);
    }
    RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_3, "This combination not supported LegId=%d\n",
                           con->ainInfo.legId);
    RETVALUE(RFAILED);
  }

}


/*
*
*      Fun:   ccConE42S41
*
*      Desc:  Connection state function
*             event - CCE_MERGE_CALL
*             state - CCS_AWTRSPFORDPE11 (OMIDCALL)
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*     Desc:   This function is not as per GR 1298.
*             But to fullfill the Call Transfer feature requirement, we need to 
*             implement this function.
*
*             When the CSA is in CC4 or CC6 (In CC6, CS2 has not reached
*             Alerting).
*             The CS2 will be cleared and will get back to CS1 and the Call would
*             be in ccId = CiStable2Party
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE42S41
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *CSID1con       = NULLP;
  S16               ret            = RFAILED;
  msgValBcmTypeEnum bcmType        = BtMax; /* Controller in othercon */
  SvcHeader_t      *omSvcHeader    = NULLP;
  CcMgCmdQ_t       *mgCmdQ         = NULLP;
  CcMgCmdQ_t       *prevCmdQ       = NULLP;
  Bool             mgiSent         = FALSE;

#if 1 /* MGCP 3WC */
#ifdef CC_CALEA
  CcSurrogate *pSurrogate = NULLP;
#endif 
#else /* 1 */
#ifdef CC_CALEA
  CcSurrogate *pSurrogate = NULLP;
  S16 caleaRet = RFAILED;
#endif
#endif /* 1 */

  CCDP(AIN_DBG_LEVEL_1, "ccConE42S41:%ld\n", con->icSuConnId);

  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
  omSvcHeader = (SvcHeader_t *) event;

  if (omSvcHeader->lastTransactionFlag == TRUE)
  {
    /* This could screw up things, lets ignore */
    CCLOGERR("ERROR: rcv txnflg = TRUE :%ld\n", con->icSuConnId);
  }

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR("Critical Error:cc NULLP:\n");
    RETVALUE(RFAILED);
  }
  if (con->icBcm.cc->ccId == CiThreePartySetup)
  {
    CSID1con = con->icBcm.cc->legId1->con;
    bcmType  = con->icBcm.cc->legId02->bcmType;

    if (bcmType == BtOBcm)
    {
      if (CC_IS_CONTEXT_PRESENT(con))
      {
#ifdef CALEA_3WC
        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          ccAddSubCaleaRscReqIntoMgQForSpecificCon(&(CSID1con->icBcm), con,
                                                   FALSE);
#endif
        ccUpdateMgQForSubRsc(&(con->icBcm), con->mgBlock->mgCtx->suCtxId, con);
      }
      if ((ccIsSwitchingLocallyDone(&CSID1con->icBcm)) ||
          (ccIsSwitchingLocallyDone(&CSID1con->ogBcm)))
      {
#ifdef CC_CALEA
        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          ccAssociateSubAndCaleaLegs(&(CSID1con->icBcm), &(CSID1con->icBcm));
#endif
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                       &(CSID1con->icBcm),
                                       NULLP, NULLP, NULLP, NULLP, NULLP,
                                       (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, 
                                       CSID1con);
#ifdef CC_CALEA
        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          ccAddCaleaToMgQ(&(CSID1con->icBcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState  = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORMERGEINCC4);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("ERROR: MGI operation failed,%ld\n",
                   con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
        ccToggleCC6CtrlHashList(&con->icBcm);
/*********CHANGE OWNER OF RESOURCE AND UPDATE CallConfiguration***************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }

        CSID1con->icBcm.cc->ccId    = CiStable2Party;
        CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
        CSID1con->icBcm.cc->legId02 = NULLP;
        CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
        CSID1con->icBcm.cc->legId2  = NULLP;
        con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->icBcm));
        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          ccSendCnStReq(CSID1con, CSID1con->icSapCb->suId,
                        &CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                        CSID1con->icSpConnId, CSID1con->icSuConnId,
                        CSID1con->icProtType, CS_CONN_STATUS_RECONNECT_IC,
                        NULLP, NULLP);
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS2 to CS1 */
        ccMoveBufferedEvents(con, CSID1con);
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else if (bcmType == BtTBcm)
    {
      if (CC_IS_CONTEXT_PRESENT(con))
      {
#ifdef CALEA_3WC
        if (!ccIsIPSubscriber(&(CSID1con->ogBcm)))
        ccAddSubCaleaRscReqIntoMgQForSpecificCon(&(CSID1con->ogBcm), con,
                                                 FALSE);
#endif
        ccUpdateMgQForSubRsc(&(con->icBcm), con->mgBlock->mgCtx->suCtxId, con);
      }
      if ((ccIsSwitchingLocallyDone(&CSID1con->icBcm)) ||
          (ccIsSwitchingLocallyDone(&CSID1con->ogBcm)))
      {
#ifdef CC_CALEA
        if (!ccIsIPSubscriber(&(CSID1con->icBcm)))
          ccAssociateSubAndCaleaLegs(&(CSID1con->ogBcm), &(CSID1con->ogBcm));
#endif
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                       &(CSID1con->ogBcm),
                                       NULLP, NULLP, NULLP, NULLP, NULLP,
                                       (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, 
                                       CSID1con);
#ifdef CC_CALEA
        if (!ccIsIPSubscriber(&(CSID1con->ogBcm)))
        {
          ccAddCaleaToMgQ(&(CSID1con->ogBcm),MGCT_ITEM_ID_CG_MAX, CSID1con);
          if (CSID1con->surrogate != NULLP)
          {
            pSurrogate = CSID1con->surrogate;
            while (pSurrogate != NULLP)
            {
              CCDP(AIN_DBG_LEVEL_0,
                   "Adding Any Calea Leg's attached to Surrogate=%ld",
              pSurrogate->bcm.svcHeader.transId);
              ccAddCaleaToMgQ(&(pSurrogate->bcm),MGCT_ITEM_ID_CG_MAX, CSID1con);
              pSurrogate = pSurrogate->next;
             }
          }
        }
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState  = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORMERGEINCC4);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("ERROR: MGI operation failed,%ld\n",
                   con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
        ccToggleCC6CtrlHashList(&con->icBcm);
/*********CHANGE OWNER OF RESOURCE AND UPDATE CallConfiguration***************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                    CSID1con->ogSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }

        CSID1con->ogBcm.cc->ccId    = CiStable2Party;
        CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
        CSID1con->ogBcm.cc->legId02 = NULLP;
        CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId2  = NULLP;
        con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->icBcm));

        if (!ccIsIPSubscriber(&(CSID1con->ogBcm)))
          ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId,
                        &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                        CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                        CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG,
                        NULLP, NULLP);
        CC_STATE_CHANGE(CSID1con, CCS_ANSWERED);
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS2 to CS1 */
        ccMoveBufferedEvents(con, CSID1con);
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("ERROR: Invalid bcmType:%d, icSu:%ld, ogSu:%ld\n",
               bcmType, con->icSuConnId, con->ogSuConnId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
    }
  }
  else if (con->icBcm.cc->ccId == CiPartyOnHold)
  {
    AinBCM_t        *legId02   = NULLP;

    if (con->icBcm.pic == PicOActive)
    {
      CC_STATE_CHANGE(con, CCS_ANSWERED);
    }
    else if (con->icBcm.pic == PicOAlerting)
    {
      CC_STATE_CHANGE(con, CCS_AWTANS);
    }
    else
    { 
      CC_STATE_CHANGE(con, CCS_AWTBUSYREL_IC);
    }

    legId02  = con->icBcm.cc->legId02;
    CSID1con = legId02->con;
    ccChangeCallStateOfAssociatedCalls(legId02, CCS_CANNOTPROCESSEVENTS);
    ccCreateOnSwitchBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), 
                           ccProcessCallCC6ToCC10, (PTR) con, CSID1con->state,
                           FALSE); 
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Unexpected Condition:%d, %ld\n", con->icBcm.cc->ccId,
             con->icSuConnId);
    RETVALUE(RFAILED);
  }
}


/*
*
*      Fun:   ccConE42S43
*
*      Desc:  Connection state function
*             event - CCE_MERGE_CALL
*             state - CCS_AWTRSPFORDPE28
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE42S43
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb                 *CSID1con         = NULLP;
  S16                      rmret            = RFAILED;
  S16                      mgitret          = RFAILED;
  CcMgCmdQ_t              *mgCmdQ           = NULLP;
  CcMgCmdQ_t              *prevCmdQ         = NULLP;
  CcMidCallReqEvnt         midCallReq;
  SvcHeader_t             *mcSvcHeader      = NULLP;
  Bool                     mgiSent          = FALSE;
  ProtType                 icProtType       = 0;
  ProtType                 ogProtType       = 0;
  msgValBcmTypeEnum        bcmType          = BtMax;
  Bool                     answerFlag       = FALSE;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CC_CALEA
  CcSurrogate *pSurrogate = NULLP;
#endif

  CCDP(AIN_DBG_LEVEL_0, "ccConE42S43 %ld:Merge Call Case\n", con->icSuConnId);
  mcSvcHeader = (SvcHeader_t *) event;

  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccStopConTmr(con, TMR_SETUP);
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);


  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  CSID1con = con->ogBcm.cc->legId1->con;
  bcmType  = con->ogBcm.cc->legId02->bcmType;

  if (con->ainInfo.legId == 1)
  {
    if (con->ogBcm.cc->ccId != CiCallWaitingComplement)
    {
      CCDP(AIN_DBG_LEVEL_3, "Unexpected ccId:%d\n", con->ogBcm.cc->ccId);
      RETVALUE(RFAILED);
    }

    /* Also Stop the CWT tone as we are going back to Two Party Call */
    ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);
    ccStopConTmr(con, TMR_SETUP);
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 

    if  (bcmType == BtOBcm)
    {
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(CSID1con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP,
                              CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(con->ogBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(CSID1con->icBcm));
        ccMakeLegInactive(&(CSID1con->ogBcm));
#endif /* 0 */
      }

      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->ogBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP, 
                                     (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(con->ogBcm),MGCT_ITEM_ID_CG_MAX, con);
        if (con->surrogate != NULLP)
        {
          pSurrogate = con->surrogate;
          while (pSurrogate != NULLP)
          {
            ccAddCaleaToMgQ(&(pSurrogate->bcm),MGCT_ITEM_ID_CG_MAX,con);
            pSurrogate = pSurrogate->next;
          }
        }
#endif
      }
      if (con->icBcm.pic == PicOAlerting)
      {
        if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty))
          ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        else if (!(ccIsIPResource(&(con->icBcm))))
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX, MGCT_CMD_MODIFY,
                                       &(con->icBcm), NULLP, NULLP,
                                       NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, con);
      }

      /* Need to combine the mgCmdQ of CSID1con (CS1) and con (CS 2) */
      mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
      {
        prevCmdQ->next = con->mgBlock->mgCtx->mgCmdQ;
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      }
      else
        mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6OG);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        con->mgBlock->con = con;
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
             con->mgBlock->mgCtx->suCtxId);
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("MGI operation Failed, %ld\n", con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->ogSuConnId;
                                         /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 1;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->ogBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
        else
        {
          upd.featMsg.suConnId     = CSID1con->icSuConnId;
          upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_MERGE_CALL_PRE_ANSWER;
          upd.featMsg.DlegId       = 0;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();

          if ((!ccIsIPSubscriber(&(CSID1con->icBcm))) &&
              (con->icBcm.pic != PicOActive))
            CcLiCctMidCallReq(&CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                              CSID1con->icSpConnId, CSID1con->icSuConnId,
                              CSID1con->icProtType, &midCallReq);
        }
#endif /* ZC */
        /* IF CONTROLLER IS OBCM IN CS 1 */
/*************************SU AND SP INSTANCE TABLE ***********************/
        ccToggleCC9CtrlHashList(&(CSID1con->icBcm));
/***************************BCM OPERATION*********************************/
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId2  = NULLP;

        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));

/***************************CHANGE RESOURCE OWNER*************************/
        rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (rmret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->ogSuConnId);
        }
        else
        {
          CSID1con->icRscVal = FALSE;
          con->ogRscVal      = TRUE;
        }
        /* Move Buffered events from CS1 to CS2 */
        if (con->icBcm.pic == PicOActive)
        {
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_ANSWERED);
        }
        ccMoveBufferedEvents(CSID1con, con);
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
        if (CSID1con->ogRscVal)
        {
          ogProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
          if ((ccIsLEGSubscriber(&(CSID1con->ogBcm))) ||
              (ogProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
            ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                          CSID1con->ogSuConnId, CSID1con->ogProtType,
                          CCCALLCLR, NULL);
          }
          else
          {
            CSID1con->direction = OUTTOINC;
            if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
            CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(CSID1con, CC_OUTGOING);
          }
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_IDLE);
          ccRelCon(CSID1con);
        }
/*############################################################################*/
        CC_BREAK_IF_DISC_BUFFERED(con);
        /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
         * in CS1 */
        if (con->icBcm.pic == PicOAlerting)
        {
          answerFlag = TRUE;
          CC_STATE_CHANGE(con, CCS_AWTANS);
        }
        else
          CC_STATE_CHANGE(con, CCS_ANSWERED);

        if (CC_IS_CCID_CC10_AND_ABOVE(&(con->icBcm)))
          ccCreateOnSwitchBearer(&(con->ogBcm), NULLP, NULLP, NULLP, con->state,
                                 answerFlag);
        else
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP, con->state,
                         answerFlag);
/*############################################################################*/
      }
      RETVALUE(ROK);
    }
    else if  (bcmType == BtTBcm)
    {
      /* IF CONTROLLER IS TBCM IN CS 1 */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(CSID1con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP,
                              CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(con->ogBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(CSID1con->icBcm));
        ccMakeLegInactive(&(CSID1con->ogBcm));
#endif /* 0 */
      }
      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->ogBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP,
                                     (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(con->ogBcm),MGCT_ITEM_ID_CG_MAX, con);
        if (con->surrogate != NULLP)
        {
           pSurrogate = con->surrogate;
           while (pSurrogate != NULLP)
           {
              ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX,con);
              pSurrogate = pSurrogate->next;
           }
        }
#endif
      }

      if (con->icBcm.pic == PicOAlerting)
      {
        if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty))
          ccUpdateMgQForSubAnnRsc(con->mgBlock->mgCtx->suCtxId, con);
        else if (!(ccIsIPResource(&(con->icBcm))))
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
                                       MGCT_PACKAGE_ID_MAX,
                                       MGCT_ITEM_ID_CG_MAX,
                                       MGCT_CMD_MODIFY,
                                       &(con->icBcm), NULLP, NULLP,
                                       NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, con);
      }

      /* Need to combine the mgCmdQ of CSID1con (CS1) and con (CS 2) */
      mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
      {
        prevCmdQ->next = con->mgBlock->mgCtx->mgCmdQ;
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      }
      else
        mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6OG);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("ERROR: MGI operation Failed, %ld, %ld, %ld\n",
                   con->mgBlock->mgCtx->suCtxId, con->icSuConnId,
                   con->ogSuConnId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }

      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->ogSuConnId;
                                       /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 1;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->ogBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
        else
        {
          upd.featMsg.suConnId     = CSID1con->ogSuConnId;
          upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_MERGE_CALL_PRE_ANSWER;
          upd.featMsg.DlegId       = 0; 
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
       
          if ((!ccIsIPSubscriber(&(CSID1con->ogBcm))) &&
              (con->icBcm.pic != PicOActive))
            CcLiCctMidCallReq(&CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                              CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                              CSID1con->ogProtType, &midCallReq);
        }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
        ccToggleCC9CtrlHashList(&(CSID1con->ogBcm));
/***************************BCM OPERATION*********************************/
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId2  = NULLP;

        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
/***************************CHANGE RESOURCE OWNER*************************/
        rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (rmret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->ogSuConnId);
        }
        else
        {
          CSID1con->ogRscVal = FALSE;
          con->ogRscVal      = TRUE;
        }
        /* Move Buffered events from CS1 to CS2 */
        if (con->icBcm.pic == PicOActive)
        {
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_ANSWERED);
        }

#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        /* Stop billing timer */
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
        if (CSID1con->icRscVal)
        {
          icProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
          if ((ccIsLEGSubscriber(&(CSID1con->icBcm))) || (icProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
            ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                          CSID1con->icSuConnId, CSID1con->icProtType,
                          CCCALLCLR, NULL);
          }
          else
          {
            CSID1con->direction = INCTOOUT;
            if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
            CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(CSID1con, CC_INCOMING);
          }
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_IDLE);
          ccRelCon(CSID1con);
        }
/*############################################################################*/
        CC_BREAK_IF_DISC_BUFFERED(con);
        /* ROLL THE BALL FOR DOING CODEC NEGOTIATION FOR THE TWO PARTY CALL
         * in CS1 */
        if (con->icBcm.pic == PicOAlerting)
        {
          answerFlag = TRUE;
          CC_STATE_CHANGE(con, CCS_AWTANS);
        }
        else
          CC_STATE_CHANGE(con, CCS_ANSWERED);

        if (CC_IS_CCID_CC10_AND_ABOVE(&(con->icBcm)))
          ccCreateOnSwitchBearer(&(con->ogBcm), NULLP, NULLP, NULLP, con->state,
                                 answerFlag);
        else
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP, con->state,
                         answerFlag);
      }
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR( "Error: Invalid bcmType:%d, %ld, %ld\n", bcmType,
                con->icSuConnId, con->ogSuConnId);
      CC_STATE_CHANGE(con, con->lastState);
    }
    RETVALUE(ROK);
  }
  else if (con->ainInfo.legId == 2)
  {
    if (con->ogBcm.cc->ccId != CiPartyOnHold)
    {
      CCDP(AIN_DBG_LEVEL_3, "Unexpected ccId:%d\n", con->ogBcm.cc->ccId);
      RETVALUE(RFAILED);
    }
    if  (bcmType == BtOBcm)
    {
      /* IF CONTROLLER IS OBCM IN CS 1 */
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(CSID1con->icBcm), &(CSID1con->icBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(con->icBcm));
        ccMakeLegInactive(&(con->ogBcm));
#endif /* 0 */
      }

      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->icBcm),
                                     NULLP, NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(CSID1con->icBcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
#endif
      }

      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6OG);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                              con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("Error: MGI operation Failed, %ld\n",
                   con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 2;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->ogBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
        ccToggleCC6CtrlHashList(&(con->ogBcm));
/***************************BCM OPERATION*********************************/
        CSID1con->icBcm.cc->ccId    = CiStable2Party;
        CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
        CSID1con->icBcm.cc->legId02 = NULLP;
        CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
        CSID1con->icBcm.cc->legId2  = NULLP;
        con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->ogBcm));
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(con, CSID1con);
        /* There may be a event sitting on con Event Buffer */
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
        rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (rmret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
        }
        else
        {
          con->ogRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        if (con->icRscVal)
        {
          icProtType = CC_GET_PROTOCOL(con->icProtType);
          if ((ccIsLEGSubscriber(&(con->icBcm))) || (icProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CCCALLCLR, NULL);
          }
          else
          {
            con->direction = INCTOOUT;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM); 
            ccDeallocateResource(con, CC_INCOMING);
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
        CC_BREAK_IF_DISC_BUFFERED(CSID1con);
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else if  (bcmType == BtTBcm)
    {
      /* IF CONTROLLER IS TBCM IN CS 1 */
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);

#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(CSID1con->ogBcm), &(CSID1con->ogBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(con->icBcm));
        ccMakeLegInactive(&(con->ogBcm));
#endif /* 0 */
      }

      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->ogBcm),
                                     NULLP, NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(CSID1con->ogBcm),MGCT_ITEM_ID_CG_MAX, CSID1con);
        if (CSID1con->surrogate != NULLP)
        {
          pSurrogate = CSID1con->surrogate;
          while (pSurrogate != NULLP)
          {
            ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX, CSID1con);
            pSurrogate = pSurrogate->next;
          }
        }
#endif
      }
      /* Need to combine the mgCmdQ of CSID1con and con (CS 2) */
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6OG);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("Error: MGI operation failed, %ld\n",
                   con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 2;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->ogBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
        ccToggleCC6CtrlHashList(&(con->ogBcm));
/***************************BCM OPERATION*********************************/
        CSID1con->ogBcm.cc->ccId    = CiStable2Party;
        CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
        CSID1con->ogBcm.cc->legId02 = NULLP;
        CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId2  = NULLP;

        con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->ogBcm));
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(con, CSID1con);
        /* There may be a event sitting on con Event Buffer */
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
        rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (rmret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
        }
        else
        {
          con->ogRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        if (con->icRscVal)
        {
          icProtType = CC_GET_PROTOCOL(con->icProtType);
          if ((ccIsLEGSubscriber(&(con->icBcm))) || (icProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CCCALLCLR, NULL);
          }
          else
          {
            con->direction = INCTOOUT;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(con, CC_INCOMING);
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
        CC_BREAK_IF_DISC_BUFFERED(CSID1con);
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR( "Error: Invalid bcmType:%d, %ld, %ld\n", bcmType,
                con->icSuConnId, con->ogSuConnId);
      CC_STATE_CHANGE(con, con->lastState);
    }
    RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_3, "Unexpected Combination:legId = %d\n",
                           con->ainInfo.legId);
    RETVALUE(ROK);
  }
}


/*
*
*      Fun:   ccConE46S43
*
*      Desc:  Connection state function
*             event - CCE_RECONNECT
*             state - CCS_AWTRSPFORDPE28
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE46S43
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *CSID1con       = NULLP;
  S16               ret            = RFAILED;
  S16               rmret          = RFAILED;
  msgValBcmTypeEnum bcmType        = BtMax;
  SvcHeader_t      *reSvcHeader    = NULLP;
  Bool              mgiSent        = FALSE;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CALEA_3WC
  Bool relBcmLeas = FALSE;
#endif
#ifdef CC_CALEA
  S16               caleaRet       = RFAILED;
#endif /* CC_CALEA */

  CCDP(AIN_DBG_LEVEL_1, "ccConE46S43: %ld\n", con->icSuConnId);
  reSvcHeader = (SvcHeader_t *) event;

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  CSID1con = con->ogBcm.cc->legId1->con;
  if (con->ogBcm.cc->legId02 == &(CSID1con->icBcm))
    bcmType = BtOBcm;
  else if (con->ogBcm.cc->legId02 == &(CSID1con->ogBcm))
    bcmType = BtTBcm;
  else
  {
    /* Error Case, lets ignore the error and fall back to lastState */
    CCLOGERR( "CRITICAL ERROR:%ld\n", con->icSuConnId);
    RETVALUE(ROK);
  }

  if(con->ogBcm.cc->ccId == CiPartyOnHold)
  {
#ifdef ZC
    upd.featMsg.suConnId   = con->ogSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_RECONNECT_PRE_ANSWER;
    upd.featMsg.DlegId       = 0;
    upd.featMsg.nel          = con->ogBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
    con->reconnectBcm = TBCM;
/*************************SU AND SP INSTANCE TABLE ***********************/
    ccToggleCC6CtrlHashList(&(con->ogBcm));
/*************************************************************************/
    if  (bcmType == BtOBcm)
    {
/*************************CHANGE OWNER OF RESOURCE ***********************/
      /* Change owner of the Controlling Resource */
      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               CSID1con->icSuConnId);
      }
      else
      {
        CSID1con->icRscVal = TRUE;
        con->ogRscVal      = FALSE;
      }
/************************SWITCHING REQUEST FOR RECONNECT*****************/
      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
        if (!(isThisBcmInMPartyCall(&(con->icBcm))))
           relBcmLeas = TRUE;
        ccReleaseCaleaLegsFromSpecificBcm(&(con->icBcm), relBcmLeas,  TRUE); 
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(CSID1con->icBcm));
#endif
        ccUpdateMgQForSubRsc(&(con->ogBcm), con->mgBlock->mgCtx->suCtxId, con);
      }

      if(con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n",
                   con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else        
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* controller moving from ON-NET to ON-NET 
         * No need to change MGI context.
         * Step 1 : Send Reconnect req to CSID1->icBcm and Wait
         * Step 2 : Disconnect CSID2 or con. don't disconnect con->ogBcm. */

        CC_STATE_CHANGE(CSID1con, CCS_AWTANS);
        ccStartConTmr(TMR_RECONNECT, CSID1con, (PTR)&ccCp.genCfg);
        CSID1con->reconnectBcm = OBCM;
        CSID1con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
/**********************Manage the Call Configuration***************************/
        con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->ogBcm));
        CSID1con->icBcm.cc->ccId      = CiStable2Party;
        CSID1con->icBcm.cc->legId01   = &(CSID1con->icBcm);
        CSID1con->icBcm.cc->legId1    = &(CSID1con->ogBcm);
        CSID1con->icBcm.cc->legId02   = NULLP;
        CSID1con->icBcm.cc->legId2    = NULLP;

        ccReconnectBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                          CSID1con->state);

        ret = ccProcessDisconnectOnSpecificBCM (&(con->icBcm));
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the OBCM of the"
                                " connection\n");
          RETVALUE(ROK);
        }
#ifdef CC_CALEA
        caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(
                                              &(con->icBcm), event);
        if (caleaRet != ROK)
        {
           CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs"
             " FAILED\n");
        }
#endif
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

        if (con->icRscVal)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCALLCLR, NULLP);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
      }
      RETVALUE (ROK);
    }
    else /* It is TBCM */
    {
/*************************CHANGE OWNER OF RESOURCE ***********************/
      /* Change owner of the Controlling Resource */
      rmret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               CSID1con->ogSuConnId);
      }
      else
      {
        CSID1con->ogRscVal = TRUE;
        con->ogRscVal      = FALSE;
      }

/************************SWITCHING REQUEST FOR RECONNECT*****************/
      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
        if (!(isThisBcmInMPartyCall(&(con->icBcm))))
           relBcmLeas = TRUE;
        ccReleaseCaleaLegsFromSpecificBcm(&(con->icBcm), relBcmLeas, TRUE);
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(CSID1con->ogBcm));
#endif
        /* Send a Sub Request for the Controller */
        ccUpdateMgQForSubRsc( &(con->ogBcm),
                              con->mgBlock->mgCtx->suCtxId, con);
      }

      if(con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* controller moving from ON-NET to ON-NET 
         * No need to change MGI context.
         * Step 1 : Send Reconnect req to CSID1->ogBcm and Wait
         * Step 2 : Disconnect CSID2 or con. don't disconnect con->ogBcm. */

        CC_STATE_CHANGE(CSID1con, CCS_AWTANS);
        ccStartConTmr(TMR_RECONNECT, CSID1con, (PTR)&ccCp.genCfg);

        CSID1con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
        CSID1con->reconnectBcm = TBCM;

/**********************Manage the Call Configuration***************************/
        con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->ogBcm));
        CSID1con->ogBcm.cc->ccId      = CiStable2Party;
        CSID1con->ogBcm.cc->legId01   = &(CSID1con->ogBcm);
        CSID1con->ogBcm.cc->legId1    = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId02   = NULLP;
        CSID1con->ogBcm.cc->legId2    = NULLP;

        ccReconnectBearer(&(CSID1con->ogBcm), &(CSID1con->icBcm), NULLP, NULLP,
                          CSID1con->state);
        ret = ccProcessDisconnectOnSpecificBCM (&(con->icBcm));
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the OBCM of the"
                                " connection\n");
          RETVALUE(ROK);
        }
#ifdef CC_CALEA
        caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(
                                              &(con->icBcm), event);
        if (caleaRet != ROK)
        {
           CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs"
             " FAILED\n");
        }
#endif
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

        if (con->icRscVal)
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCCALLCLR, NULLP);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
      }
      RETVALUE (ROK);
    }
  }
  else if (con->ogBcm.cc->ccId == CiCallWaitingComplement)
  {
    /* Stop all timers if they are running at this time */
    ccStopConTmr(con, TMR_SETUP);
/*************************************************************************/
    if  (bcmType == BtOBcm)
    {
      CSID1con->reconnectBcm = OBCM;
#ifdef ZC
      if (CC_IS_TBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId;
        upd.featMsg.nel          = con->ogBcm.nel;
      }
      else
      {
        upd.featMsg.suConnId     = CSID1con->icSuConnId;
        upd.featMsg.nel          = CSID1con->icBcm.nel;
      }
      upd.featMsg.ccAinUpdType = CC_RECONNECT_PRE_ANSWER;
      upd.featMsg.DlegId       = 0;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->icBcm));
/*************************CHANGE OWNER OF RESOURCE ***********************/
      /* Change owner of the Controlling Resource */
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                               RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               con->ogSuConnId);
      }
      else
      {
        con->ogRscVal      = TRUE;
        CSID1con->icRscVal = FALSE;
      }

/************************SWITCHING REQUEST FOR RECONNECT*****************/
      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(CSID1con->icBcm), FALSE, FALSE);
        if (!(isThisBcmInMPartyCall(&(CSID1con->ogBcm))))
           relBcmLeas = TRUE;
        ccReleaseCaleaLegsFromSpecificBcm(&(CSID1con->ogBcm), relBcmLeas, TRUE);
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(con->ogBcm)); 
#endif
        ccUpdateMgQForSubRsc( &(CSID1con->icBcm),
                             CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
      }

      if(CSID1con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {
        CSID1con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFMFORSVC);
        CSID1con->mgBlock->con = CSID1con;
        ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                             CSID1con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n",
                   CSID1con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else        
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* controller moving from ON-NET to ON-NET 
         * No need to change MGI context.
         * Step 1 : Send Reconnect req to con->ogBcm and Wait
         * Step 2 : Disconnect CSID1 or con. don't disconnect con->icBcm. */

        CC_STATE_CHANGE(con, CCS_AWTANS);
        ccStartConTmr(TMR_RECONNECT, con, (PTR)&ccCp.genCfg);
        con->reconnectBcm = TBCM;
        con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

/**********************Manage the Call Configuration***************************/
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId2  = NULLP;

        ccReconnectBearer(&(con->ogBcm), &(con->icBcm), NULLP, NULLP,
                          con->state);

        ret = ccProcessDisconnectOnSpecificBCM (&(CSID1con->ogBcm));
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the TBCM of the"
                                " connection\n");
          RETVALUE(ROK);
        }
#ifdef CC_CALEA
        caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(CSID1con->ogBcm),
                                                                 event);
        if (caleaRet != ROK)
        {
           CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs FAILED\n");
        }
#endif
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);

        if (CSID1con->ogRscVal)
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
          ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                        CSID1con->ogSuConnId, CSID1con->ogProtType,
                        CCCALLCLR, NULLP);
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_IDLE);
          ccRelCon(CSID1con);
        }
      }
      RETVALUE (ROK);
    }
    else /* It should be BtTBcm */
    {
      CSID1con->reconnectBcm = TBCM;
#ifdef ZC
      if (CC_IS_TBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->ogSuConnId; /*ACT Controlling leg connId*/
        upd.featMsg.nel          = con->ogBcm.nel;
      }
      else
      {
        upd.featMsg.suConnId     = CSID1con->ogSuConnId;
        upd.featMsg.nel          = CSID1con->ogBcm.nel;
      }
      upd.featMsg.ccAinUpdType = CC_RECONNECT_PRE_ANSWER;
      upd.featMsg.DlegId       = 0;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */
/*************************SU AND SP INSTANCE TABLE ***********************/
      ccToggleCC9CtrlHashList(&(CSID1con->ogBcm));
/*************************CHANGE OWNER OF RESOURCE ***********************/
      /* Change owner of the Controlling Resource */
      rmret = ccAllocateResource(con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
      if (rmret != ROK)
      {
        CCLOGERR( "Error:ccAllocateResource failed %ld\n",
                               con->ogSuConnId);
      }
      else
      {
        con->ogRscVal      = TRUE;
        CSID1con->ogRscVal = FALSE;
      }
/************************SWITCHING REQUEST FOR RECONNECT*****************/
      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#ifdef CC_CALEA
        ccAddSubCaleaRscReqIntoMgQ(&(CSID1con->ogBcm), TRUE, FALSE);
        if (!(isThisBcmInMPartyCall(&(CSID1con->icBcm))))
           relBcmLeas = TRUE;
        ccReleaseCaleaLegsFromSpecificBcm(&(CSID1con->icBcm), relBcmLeas, TRUE);
        ccAssociateSubAndCaleaLegs(&(con->ogBcm), &(con->ogBcm)); 
#endif
        /* Send a Sub Request for the Controller */
        ccUpdateMgQForSubRsc( &(CSID1con->ogBcm),
                             CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
      }

      if (CSID1con->mgBlock->mgCtx->mgCmdQ != NULLP)
      {

        CSID1con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFMFORSVC);
        CSID1con->mgBlock->con = CSID1con;
        ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                             CSID1con->mgBlock);
        if (ret != ROK)
        {
          CCLOGERR("Error: MGI operation failed:%ld\n",
                    CSID1con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */
        /* controller moving from ON-NET to ON-NET 
         * No need to change MGI context.
         * Step 1 : Send Reconnect req to con->ogBcm and Wait
         * Step 2 : Disconnect CSID1 or con. don't disconnect con->ogBcm. */

        CC_STATE_CHANGE(con, CCS_AWTANS);
        ccStartConTmr(TMR_RECONNECT, con, (PTR)&ccCp.genCfg);
        con->reconnectBcm = TBCM;
        con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

/**********************Manage the Call Configuration***************************/
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        con->ogBcm.cc->ccId    = CiStable2Party;
        con->ogBcm.cc->legId01 = &(con->ogBcm);
        con->ogBcm.cc->legId1  = &(con->icBcm);
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc->legId2  = NULLP;

        ccReconnectBearer(&(con->ogBcm), &(con->icBcm), NULLP, NULLP,
                          con->state);

        ret = ccProcessDisconnectOnSpecificBCM (&(CSID1con->icBcm));
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the OBCM of the"
                                " connection\n");
          RETVALUE(ROK);
        }
#ifdef CC_CALEA
        caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(CSID1con->icBcm),
                                                                 event);
        if (caleaRet != ROK)
        {
           CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs FAILED\n");
        }
#endif
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);

        if (CSID1con->icRscVal)
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
          ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                        CSID1con->icSuConnId, CSID1con->icProtType,
                        CCCALLCLR, NULLP);
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_IDLE);
          ccRelCon(CSID1con);
        }
      }
      RETVALUE (ROK);
    }
  }
  else
  {
    CCLOGERR("Invalid ccId:%d in this STATE\n",con->ogBcm.cc->ccId);
    RETVALUE(ROK);
  }
}


/*
*
*      Fun:   ccConE55S09
*
*      Desc:  Connection state function
*             event - CCE_RECONNECTEXP
*             state - CCS_AWTANS
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE55S09
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{ 
  CCDP(AIN_DBG_LEVEL_1, "ccConE55S09: %ld\n", con->icSuConnId);
  /* Need to Release the Call */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_RECONNECTTMR_EXP, (U8 *) &con->icSuConnId);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* Feature 1789 - German ISUP */
  /* stop the Toiw2 Timer if running */
  ccStopConTmr(con, CC_TMR_TOIW2);

  if (con->icBcm.cc)
  {
    if (con->icBcm.cc->legId2)
    {
      if (con->icBcm.cc->legId01 == &(con->icBcm))
      {
        con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
        con->icBcm.cc->legId2  = NULLP;
        con->icBcm.cc->legId02 = NULLP;
        con->icBcm.cc          = NULLP;
      }
      else if (con->icBcm.cc->legId02 == & (con->icBcm))
      {
        con->icBcm.cc->legId1 = con->icBcm.cc->legId2;
        con->icBcm.cc->legId2  = NULLP;
        con->icBcm.cc->legId02 = NULLP;
        con->icBcm.cc          = NULLP;
      }
    }
  }
  if (con->ogBcm.cc)
  {
    if (con->ogBcm.cc->legId2)
    {
      if (con->ogBcm.cc->legId01 == &(con->ogBcm))
      {
        con->ogBcm.cc->legId01 = con->ogBcm.cc->legId02;
        con->ogBcm.cc->legId2  = NULLP;
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc          = NULLP;
      }
      else if (con->ogBcm.cc->legId02 == & (con->ogBcm))
      {
        con->ogBcm.cc->legId1 = con->ogBcm.cc->legId2;
        con->ogBcm.cc->legId2  = NULLP;
        con->ogBcm.cc->legId02 = NULLP;
        con->ogBcm.cc          = NULLP;
      }
    }
  }
  /* Clean up the call, with the switching */
  ccSendReleasesOnBothSidesWithSwitching(con, CCTMPFAIL);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE52S44
*
*      Desc:  Connection state function
*             event - CCE_DISCONNECT
*             state - CCS_AWTRSPFORDPE9
*             This function would get executed in a number of call scenarios.
*             Some of the call scenarios are listed below.
*             1. This could be a Call Transfer in which the Controller in 
*                CS ID-2 disconnect in CC4 or CC6 before Alerting the LegId2
* 
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE52S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t        *diSvcHeader    = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE52S44: %ld\n", con->icSuConnId);
  diSvcHeader = (SvcHeader_t *) event;

  /* During merging to 3.9+, merge the code code in E52S44 in function
   * ccDisconnectCallForIcBCM, as that is the lastest code for that branch */
  ccDisconnectCallForIcBCM(con, event);
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE52S64
*
*      Desc:  Connection state function
*             event - CCE_DISCONNECT
*             state - CCS_AWTRSPFAILOUT
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: This function assumes that the incoming BCM has sent a Failure
*             outcome and was waiting for a response.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE52S64
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  SvcHeader_t        *diSvcHeader    = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE52S64: %ld\n", con->icSuConnId);
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  diSvcHeader = (SvcHeader_t *) event;

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR( "Error *cc is NULLP\n");
    RETVALUE(RFAILED);
  }
#ifdef CALEA_3WC    
  /* Bug# 18112 */
  if (con->icProtType != CC_LOCAL_SWT_PROT)
  {            
     if (!((con->icBcm.cc != NULLP) &&
        (con->icBcm.cc->ccId >= CiThreePartySetup) &&
        (con->icBcm.cc->ccId <= CiRemoteTransferSetup)))
     {
        ccReleaseCaleaLegs(con);
     }
  }                  
#endif               
  if (con->icBcm.cc->ccId == CiOriginatingSetup)
  {
    if (diSvcHeader->lastTransactionFlag == TRUE)
      ccDeleteBcm(&(con->icBcm));

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULLP);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Not Supported :%d, %ld, %ld\n", con->icBcm.cc->ccId,
                            con->icSuConnId, con->icBcm.svcHeader.transId);
    if (diSvcHeader->lastTransactionFlag == TRUE)
      ccDeleteBcm(&(con->icBcm));

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULLP);
    RETVALUE(ROK);
  }
}


/*
*
*      Fun:   ccConE40S44
*
*      Desc:  Connection state function
*             event - CCE_DISCONNECT_LEG
*             state - CCS_AWTRSPFORDPE9
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE40S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb     *CSID1con            = NULLP;
  S16          ret                 = RFAILED;
  S16          ringRet             = RFAILED;
  MgctCallProgItemId retSignal     = MGCT_ITEM_ID_CG_MAX;
  MgctCallProgItemId signal        = MGCT_ITEM_ID_CG_MAX;
  MgctPackageId      pkgId         = MGCT_PACKAGE_ID_MAX;
  MgctMode           mode          = MGCT_MODE_MAX;
  msgValBcmTypeEnum bcmType        = BtMax;
  AinBCM_t    *legId02             = NULLP;
  U8          state                = 0;
  SvcHeader_t       *dlSvcHeader   = NULLP;
  Bool              releaseNeeded  = FALSE;
  msgValBcmTypeEnum dBcmType       = BtMax;
  AinBCM_t         *dBcm           = NULLP;
  Bool              dRscVal        = FALSE;
  S16               tmpRet         = RFAILED;
  AinBCM_t         *legId2         = NULLP;
  AinBCM_t         *legId1         = NULLP;
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED;
#endif
  AinBCM_t         *pOtherBcm      = NULLP;
  Bool             confRscReq      = FALSE; 


#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */


  CCDP(AIN_DBG_LEVEL_1, "ccConE40S44: %ld\n", con->icSuConnId);
  dlSvcHeader = (SvcHeader_t *) event;

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR( "Error *cc is NULLP\n");
    RETVALUE(RFAILED);
  }
  legId02 = con->icBcm.cc->legId02;

  /* bug 70537 */
  if (legId02 == NULLP && con->icBcm.cc->ccId <= CiStable2Party)
  {
    CCDP(AIN_DBG_LEVEL_1, "ccConE40S44: internal DiscLeg as a result of ETC abandon\n");
    ccConE40S11(con,event,bcm,event2);
    RETVALUE(ROK);
  }

  if(legId02)
    bcmType = legId02->bcmType;

#if 0 /* bug#31662, rkhan */
  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  ccStopConTmr(con, TMR_SETUP);
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
#endif

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));

  if ((con->icBcm.cc->ccId == CiRemoteTransferSetup) &&
      (con->ainInfo.legId == 0))
  {
    CSID1con = con->icBcm.cc->legId1->con;
    con->direction = INCTOOUT;
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_RELIND);
    ccSendReleaseRsp(con);
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
    ccProcessTransfer(con, CSID1con, &(con->icBcm));
    RETVALUE(ROK);
  }
  else if (con->icBcm.cc->ccId == CiStableMParty)
  {
    CSID1con = con->icBcm.cc->legId1->con;
    legId2   = con->icBcm.cc->legId2;
    legId1   = con->icBcm.cc->legId1;
    if (con->ainInfo.legId == 1)
    {
      dBcm = con->icBcm.cc->legId1;

      if (dBcm->bcmType == BtOBcm)
      {
        dRscVal  = CSID1con->icRscVal;
        dBcmType = BtOBcm;
      }
      else if (dBcm->bcmType == BtTBcm)
      {
        dRscVal = CSID1con->ogRscVal;
        dBcmType = BtTBcm;
      }
      else
      {
        CCLOGERR("Error: Invalid bcmType:%d\n", dBcm->bcmType);
        CC_STATE_CHANGE(con, con->lastState);
        RETVALUE(ROK);
      }
      if (dRscVal == FALSE)
      {
        tmpRet = ccRemoveAnncRsc(legId2);
        if (tmpRet == ROK)
        {
          ccUpdateMgQForSubAnnRsc(
                          (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        }
        CCDP(AIN_DBG_LEVEL_2,"PIC=%d,%ld,%ld\n", con->icBcm.pic, con->icSuConnId,
                                               con->ogSuConnId);
        retSignal = ccFindSignalForConfRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
        CCDP(AIN_DBG_LEVEL_0, "signal in conf rsc:%d\n", retSignal);
        if ((retSignal != MGCT_ITEM_ID_CG_MAX) && (tmpRet == ROK))
        {
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_CG,
                                       retSignal, MGCT_CMD_MODIFY,
                                       &(con->icBcm),
                                       NULLP, NULLP, NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, 
                                       con);
          if (con->ogRscVal)
          {
            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
                                         MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX,
                                         MGCT_CMD_ADD,
                                         &(con->ogBcm),
                                         NULLP, NULLP, NULLP, NULLP, NULLP,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, 
                                         con);
#ifdef CALEA_3WC
            ccAddCaleaToMgQ(&(con->ogBcm), MGCT_ITEM_ID_CG_MAX, con);
#endif
          }
        }
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORCC6CC10);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret == ROK)
          RETVALUE(ROK);
        con->state = con->lastState;
        CC_STATE_CHANGE(con, con->lastState);
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

        /**************REPLICATION************************/
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId = con->icSuConnId;
                                              /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
          upd.featMsg.DlegId       = 1;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->icBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif /* ZC */
        /**************Call Configuration*******************/
        con->icBcm.cc->legId02->cc = NULLP;
        CC_CLEAN_FIC_TXN(con->icBcm.cc->legId02);
        con->icBcm.cc->ccId       = CiStable2Party;
        con->icBcm.cc->legId1     = &(con->ogBcm);
        con->icBcm.cc->legId02    = NULLP;
        con->icBcm.cc->legId2     = NULLP;

        /*****************MGBLOCK Assocation*****************/
        GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,NULLP,CSID1con);
        con->mgBlock->con = con;

        /* Allocate the mgBlock */
        ret = SGetSBuf(ccInit.region, ccInit.pool,
                    (Data **) &(CSID1con->mgBlock), (Size) sizeof(CcMgBlock_t));

        cmMemset((U8 *) CSID1con->mgBlock, 0, sizeof(CcMgBlock_t));
        GCC_INC_CONCNT(CSID1con->mgBlock);
        ccRelCon(CSID1con);
        if (!CC_IS_CCID_CC10_AND_ABOVE(legId2))
          ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                         con->state, FALSE);
        RETVALUE(ROK);
      }
      else /* It should be true */
      {
        tmpRet = ccRemoveAnncRsc(legId2);
        if (tmpRet == ROK)
        {
          ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        }
        CCDP(AIN_DBG_LEVEL_2,"PIC=%d,%ld,%ld\n", con->icBcm.pic, con->icSuConnId,
                                               con->ogSuConnId);
        retSignal = ccFindSignalForConfRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
        CCDP(AIN_DBG_LEVEL_0, "signal in conf rsc:%d\n", retSignal);
        if ((retSignal != MGCT_ITEM_ID_CG_MAX) && (tmpRet == ROK))
        {
          ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_CG,
                                       retSignal, MGCT_CMD_MODIFY,
                                       &(con->icBcm), NULLP, NULLP,
                                       NULLP, NULLP, NULLP,
                                       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                       MGCT_CONTEXT_CHOOSE, con);
          if (con->ogRscVal)
          {
            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
                                         MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX,
                                         MGCT_CMD_ADD,
                                         &(con->ogBcm),
                                         NULLP, NULLP, NULLP, NULLP, NULLP,
                                         (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                         MGCT_CONTEXT_CHOOSE, 
                                         con);
#ifdef CALEA_3WC
            ccAddCaleaToMgQ(&(con->ogBcm), MGCT_ITEM_ID_CG_MAX, con);
#endif
          }
        }
#ifdef CALEA_3WC
        /* Remove the LEAs of LegId1 and the Surrogate Leas of CSID1con */ 
        caleaRet = ccAddSubCaleaRscReqIntoMgQ(dBcm, TRUE, FALSE); 
#endif
        /* Send Subscract to MGI */
        ringRet = ccCheckMgContext(dBcm, &pkgId, &signal, &mode);
        if (ringRet != ROKDNA)
          ccUpdateMgQForSubRsc(dBcm, (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0), con);
        if (ret == ROK)
        {
          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORCC6CC10);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        }
        if (ret != ROK)
        {
          CCLOGERR("Error: MGI Operation failed:%ld, %ld\n",
                    con->mgBlock->mgCtx->suCtxId, con->icSuConnId);
          cleanUpMgQ(con);
          if (ccFindIfReleaseOrRelRspNeeded(dBcm) == ROK)
            releaseNeeded = TRUE;
          /**************REPLICATION************************/
#ifdef ZC
          if (CC_IS_OBCM_PIC_ACTIVE(con))
          {
            upd.featMsg.suConnId = con->icSuConnId;
                                                /*ACT Controlling leg connId*/
            upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
            upd.featMsg.DlegId       = 1;
            upd.featMsg.nel          = con->icBcm.nel;
            zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
            zcUpdPeer();
          }
#endif /* ZC */
#if 1 /* Bug#: 17932 */
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
          /**************Call Configuration*******************/
          con->icBcm.cc->legId02->cc = NULLP;
          CC_CLEAN_FIC_TXN(con->icBcm.cc->legId02);
          con->icBcm.cc->ccId    = CiStable2Party;
          con->icBcm.cc->legId1  = &(con->ogBcm);
          con->icBcm.cc->legId02 = NULLP;
          con->icBcm.cc->legId2  = NULLP;

          /*****************MGBLOCK Assocation*****************/
          GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,NULLP,CSID1con);
          con->mgBlock->con = con;

          /* Allocate the mgBlock */
          ret = SGetSBuf(ccInit.region, ccInit.pool,
                    (Data **) &(CSID1con->mgBlock), (Size) sizeof(CcMgBlock_t));

          cmMemset((U8 *) CSID1con->mgBlock, 0, sizeof(CcMgBlock_t));
          GCC_INC_CONCNT(CSID1con->mgBlock);
          ccStopConTmr(CSID1con, TMR_SETUP);
          ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
          if (releaseNeeded)
          {
            if (dBcmType == BtOBcm)
            {
              CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
              ccSendRelease( CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                             CSID1con->icSuConnId, CSID1con->icProtType,
                             CCCALLCLR, NULLP );
            }
            else /* It should be BtTBcm */
            {
              CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
              ccSendRelease( CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                             CSID1con->ogSuConnId, CSID1con->ogProtType,
                             CCCALLCLR, NULLP );
            }
          }
          else
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
            if (dBcmType == BtOBcm)
            {
              CSID1con->direction = INCTOOUT;
              if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
              ccDeallocateResource(CSID1con, CC_INCOMING);
            }
            else
            {
              CSID1con->direction = OUTTOINC;
              if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
              ccDeallocateResource(CSID1con, CC_OUTGOING);
            }
          }
          if (!CC_IS_CCID_CC10_AND_ABOVE(legId2))
            ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                           con->state, FALSE);
          RETVALUE(ROK);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "MGI Operation successful:%ld\n",
                                (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
          RETVALUE(ROK);
        }
      }
    }
    else if (con->ainInfo.legId == 2)
    {
      dBcm     = &(con->ogBcm);
      dRscVal  = con->ogRscVal;
      dBcmType = BtTBcm;
      ret      = RFAILED;

      /* bug#31662, rkhan */
      ccStopConTmr(con, AIN_O_NO_ANS_TMR);
      ccStopConTmr(con, AIN_T_NO_ANS_TMR);
      /* STOP the AWAIT ANSWER Timer if running
       *
       * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
       */
      ccStopConTmr(con, CC_TMR_AWAITANS); 
      ccStopConTmr(con, TMR_SETUP);
      ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
      ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);

      if (legId2->bcmType == BtMax)
      {
        ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        tmpRet = ccRemoveAnncRsc(legId1);
        if (tmpRet == RFAILED)
        {
          ccUpdateMgQForAddAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con, 0, FALSE,
                                  MGCT_ITEM_ID_CG_MAX);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "Silence not needed to reserve Rsc:%ld,%ld\n",
                                con->icSuConnId, con->ogSuConnId);
        }
      }
      else
      {
        tmpRet = ccRemoveAnncRsc(legId1);
        if (tmpRet == ROK)
        {
          ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        }
      }
      /* Send Subscract to MGI */
      if (dRscVal)
      {
        ringRet = ccCheckMgContext(dBcm, &pkgId, &signal, &mode);
        if (ringRet != ROKDNA)
        {
#ifdef CALEA_3WC 
          /* Remove the LEAs of LegId2 and the Surrogate Leas of con */
          caleaRet = ccAddSubCaleaRscReqIntoMgQ(dBcm, TRUE, FALSE);
#endif
          ccUpdateMgQForSubRsc( dBcm,
                                (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
        }
      }
#if 1
#ifdef CALEA_3WC
      caleaRet = ccAddSubCaleaRscReqIntoMgQ(&(con->icBcm), FALSE, FALSE);
      /* make the Leas of Controller to point to the Controller in
       * CSID1con */ 
      if (bcmType == BtOBcm)
      {
         /* Make the CaleaLeg's TappedLeg to point to the controller's old BCM
            , i.e CSID1con->icBcm */
         ccAssociateSubAndCaleaLegs(&(CSID1con->icBcm), &(CSID1con->icBcm));

      }
      else if (bcmType == BtTBcm)
      {
         ccAssociateSubAndCaleaLegs(&(CSID1con->ogBcm), &(CSID1con->ogBcm)); 
      }
#endif
      ccUpdateMgQForSubRsc(&(con->icBcm), (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
      ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                   MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                   legId02, NULLP, NULLP, NULLP, NULLP, NULLP,
                                   (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                   MGCT_CONTEXT_CHOOSE, con);
#ifdef CALEA_3WC
      /* Adding the CAleaLegs to the controller in CS1 */
      ccAddCaleaToMgQ(legId02, MGCT_ITEM_ID_CG_MAX, con);
#endif
#endif /* 1 */
      con->lastState = con->state;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORCC6CC10);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      if (ret != ROK)
      {
        CCLOGERR("Skipping MGI Operation failed:%ld, %ld\n",
                  con->mgBlock->mgCtx->suCtxId, con->icSuConnId);
        cleanUpMgQ(con);
      }
      else
      {
        CCDP(AIN_DBG_LEVEL_0, "MGI operation sucessful:%ld\n",
                              con->icSuConnId);
        RETVALUE(ROK);
      }
      if (dRscVal == TRUE)
      {
        if (ccFindIfReleaseOrRelRspNeeded(dBcm) == ROK)
          releaseNeeded = TRUE;
      }
      /**************REPLICATION************************/
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->icSuConnId;
                                            /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
        upd.featMsg.DlegId       = 2;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
      ccToggleCC6CtrlHashList(&con->icBcm);
      if (legId02->bcmType == BtOBcm)
      {
/***************CHANGE OWNER OF RESOURCE *************************************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }
      }
      else
      {
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }
      }
      if (!ccIsIPSubscriber(legId02))
      {
        /* send ReConnect to CAS-SP with appropriate CONNECTION direction */
        if (legId02->bcmType == BtOBcm)
        {
          ccSendCnStReq(CSID1con, CSID1con->icSapCb->suId,
                        &CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                          CSID1con->icSpConnId, CSID1con->icSuConnId,
                        CSID1con->icProtType, CS_CONN_STATUS_RECONNECT_IC,
                        NULLP, NULLP);
        }
        else /* It should be BtTBcm */
        {
          ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId,
                        &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId,
                          CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                        CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG,
                        NULLP, NULLP);
        }
      }
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
      /**************Call Configuration*******************/
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId2  = NULLP;
      con->icBcm.cc          = NULLP;

      /*****************MGBLOCK Assocation*****************/
      GCC_MNG_MGBLOCK_CNTR(con->mgBlock,NULLP,con);
      CSID1con->mgBlock->con = CSID1con;

      /* Allocate the mgBlock */
      ret = SGetSBuf(ccInit.region, ccInit.pool,
                     (Data **) &(con->mgBlock), (Size) sizeof(CcMgBlock_t));

      cmMemset((U8 *) con->mgBlock, 0, sizeof(CcMgBlock_t));
      GCC_INC_CONCNT(con->mgBlock);
      ccStopConTmr(con, TMR_SETUP);
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      if (dRscVal == TRUE)
      {
        if (releaseNeeded)
        {
            if (dBcmType == BtOBcm)
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccSendRelease( con, con->icSapCb, con->icSpConnId,
                           con->icSuConnId, con->icProtType,
                             CCCALLCLR, NULLP );
          }
          else /* It should be BtTBcm */
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
            ccSendRelease( con, con->ogSapCb, con->ogSpConnId,
                           con->ogSuConnId, con->ogProtType,
                           CCCALLCLR, NULLP );
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          if (dBcmType == BtOBcm)
          {
            con->direction = INCTOOUT;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            ccDeallocateResource(con, CC_INCOMING);
          }
          else
          {
            con->direction = OUTTOINC;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            ccDeallocateResource(con, CC_OUTGOING);
          }
        }
      } /* dRscVal */
      else
      {
        ccRelCon(con);
      }
      /* We dont need a MGI context if the remaining call CS2 is
       * and On-net call */ 
      if (!CC_IS_CCID_CC10_AND_ABOVE(legId1))
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      RETVALUE(ROK);
    }
    else if (con->ainInfo.legId == 0)
    {
      if (isCaleaLegPresent(&(con->icBcm)) ||
          isCaleaLegPresentInSurrogate(con) ||
          isCaleaLegPresent(&(con->ogBcm)) ||
          isCaleaLegPresentInSurrogate(CSID1con) ||
          isConfRscReq(legId1))
      {
         confRscReq = TRUE; 
      }
      if (confRscReq == FALSE)
         ccUpdateMgQForSubAnnRsc((con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con); 
      if (con->icBcm.pic == PicOAlerting)
      {
         if (confRscReq == FALSE)
         {
            pOtherBcm = ccFindOtherBcm(legId1);
            if (pOtherBcm)
            {
#if 0
               ccUpdateMgQForSubRsc( pOtherBcm,
                                     con->mgBlock->mgCtx->suCtxId, con);
               ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
                                            MGCT_PACKAGE_ID_CG,
                                            MGCT_SIG_ID_CG_RT,
                                            MGCT_CMD_ADD,
                                            (PTR) NULLP, pOtherBcm, NULLP,NULLP,
                                            NULLP, NULLP,
                                            con->mgBlock->mgCtx->suCtxId,
                                            MGCT_CONTEXT_CHOOSE, con );
#endif
               /* Need to do for Ephemeral */
               ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
                                            MGCT_PACKAGE_ID_CG,
                                            MGCT_SIG_ID_CG_RT,
                                            MGCT_CMD_MODIFY,
                                            pOtherBcm, NULLP,
                                            NULLP, NULLP, NULLP, NULLP,
                                            (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0),
                                            MGCT_CONTEXT_CHOOSE, con );
            }
         }
      }

      /* Controller releases in conference call */
      ccUpdateMgQForSubRsc( &(con->icBcm), (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con);
      con->lastState = con->state;
      con->relPend = ICRELONLYKEEPCON;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      if (ret != ROK)
      {
        cleanUpMgQ(con);
        CCLOGERR("MGI Operation failed: %ld\n", con->icSuConnId);
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
      }
      RETVALUE(ROK);

    }
    else
    {
      CCLOGERR("Error: legId:%d not supported\n", con->ainInfo.legId);
    }
  }

  if (con->ainInfo.legId == 1)
  {
    CSID1con = con->icBcm.cc->legId1->con;
    if (CSID1con == NULLP)
    {
      CCLOGERR( "Error: CSID1con NULLP\n");
      RETVALUE(RFAILED);
    }
    if (!((con->icBcm.cc->ccId == CiPartyOnHold) ||
        (con->icBcm.cc->ccId == CiPartyOnHoldComplement) ||
        (con->icBcm.cc->ccId == CiThreePartySetup)       ||
        (con->icBcm.cc->ccId == CiThreePartySetupComplement)))
    {
      CCLOGERR("Invalid ccId for disconnectLeg: %d\n", con->icBcm.cc->ccId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      ABORT_DEBUG;
    }
#ifdef ZC
    if (CC_IS_TBCM_PIC_ACTIVE(con))
    {
      upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
      upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG;
      upd.featMsg.DlegId       = 1;
      upd.featMsg.nel          = con->icBcm.nel;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
    else
    {
      if (bcmType == BtOBcm)
        upd.featMsg.suConnId   = CSID1con->ogSuConnId;
      else if (bcmType == BtTBcm)
        upd.featMsg.suConnId   = CSID1con->icSuConnId;
      else
      {
        CCLOGERR("Invalid bcmType: %d\n", bcmType);
        RETVALUE(ROK);
      }
      upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_MERGE_CALL_PRE_ANSWER;
      upd.featMsg.DlegId       = 0;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
    }
#endif /* ZC */
#if 1 /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

    if (con->icBcm.cc)
    {
      /* update the Call Config of B (controller for A (passive)) */
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = &(con->icBcm);
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId1  = &(con->ogBcm);
      con->icBcm.cc->legId2  = NULLP;
    }

    CC_STATE_CHANGE(con, con->lastState);

    if (bcmType == BtTBcm)
    {
      if (CSID1con->icRscVal != TRUE)
      {
        CCDP(AIN_DBG_LEVEL_1, "Leg 1 in another CSA was cleared from this con\n");
        CSID1con->icBcm.cc = NULLP;
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        if (CC_IS_CONTEXT_PRESENT(CSID1con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP,
                               CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
          /* Stop the billing timer */
          ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
          CSID1con->lastState = CCS_ANSWERED;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
          CSID1con->relPend = NORELANDNORELRSP;
          CSID1con->mgBlock->con = CSID1con;
          ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                               CSID1con->mgBlock);
        }
        else
          ret = RFAILED;
  
        if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", CSID1con->icSuConnId);
          cleanUpMgQ(con);
          ccRelCon(CSID1con);
          RETVALUE(ROK);
        }
        else
          RETVALUE(ROK);
      }
    }
    else if (bcmType == BtOBcm)
    {
      if (CSID1con->ogRscVal != TRUE)
      {
        CCDP(AIN_DBG_LEVEL_1, "Leg 1 in another CSA was cleared from this con\n");
        CSID1con->ogBcm.cc = NULLP;
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        if (CC_IS_CONTEXT_PRESENT(CSID1con))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP,
                               CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
          /* Stop the billing timer */
          ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
          ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
          CSID1con->lastState = CCS_ANSWERED;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
          CSID1con->relPend = NORELANDNORELRSP;
          CSID1con->mgBlock->con = CSID1con;
          ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                                 CSID1con->mgBlock);
        }
        else
          ret = RFAILED;

        if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", CSID1con->icSuConnId);
          cleanUpMgQ(CSID1con);
          ccRelCon(CSID1con);
          RETVALUE(ROK);
        }
        else
          RETVALUE(ROK);
      }
    }
    else
    {
      CCLOGERR("Invalid bcmType: %d\n", bcmType);
      RETVALUE(ROK);
    }

    /* otherwise the resource is involved in only this CSA */
    /* Make sure in ccRelCon, we dont blow off the cc  */
  
    /* Verify whether the con pointer entry is deleted from all the
       HashList's */

    /* Stop billing timer */
    ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
    ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);

    /* start a Release procedure for this Connection */
    if (CC_IS_CONTEXT_PRESENT(CSID1con))
    {
      /* Blow off the switching context for CSID1con */
      ccUpdateMgQForSubRsc((PTR) NULLP,
                           CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
      if (bcmType == BtOBcm)
      {
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        CSID1con->relPend  = OGRELONLY;
      }
      else if (bcmType == BtTBcm)
      {
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        CSID1con->relPend  = ICRELONLY;
      }
      else
      {
        CCLOGERR("Invalid bcmType: %d\n", bcmType);
      }
        
      /* As the CS 2 would be cleared */
      CSID1con->lastState = CCS_ANSWERED;
      CSID1con->tempHolderForReleaseCause = CCCALLCLR;

      state = CCS_AWTSWTCFM_SENDONEREL;
      ccModifyRelPendAndState(CSID1con, &(CSID1con->relPend), &state);

      CC_STATE_CHANGE(CSID1con, state);
      CSID1con->mgBlock->con = CSID1con;
      ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId, CSID1con->mgBlock);
      if (ret != ROK)
      {
        /* Anyway go ahead and send a release to the other
           side */
        CCLOGERR("Error: ccSendMgiQueue failed\n");
        cleanUpMgQ(con);

        /* As the CS 2 would be cleared */
        CSID1con->lastState = CCS_ANSWERED;
        if (legId02->bcmType == BtOBcm)
        {
          CSID1con->icBcm.cc = NULLP;
          CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
          ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                        CSID1con->ogSuConnId, CSID1con->ogProtType,
                        CCCALLCLR, NULL);
        }
        else if (legId02->bcmType == BtTBcm)
        {
          CSID1con->ogBcm.cc = NULLP;
          CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
          CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
          CSID1con->relPend  = ICRELONLY;
          ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                        CSID1con->icSuConnId, CSID1con->icProtType,
                        CCCALLCLR, NULL);
        }
        else
        {
          CCLOGERR("Invalid bcmType: %d\n", legId02->bcmType);
        }
        RETVALUE(ROK);
      }
    }
    else
    {
      CCLOGERR( "Error: suCtxId= %ld\n", (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0));
      /* Handle this error case */

      /* As the CS 2 would be cleared */
      CSID1con->lastState = CCS_ANSWERED;
      if (bcmType == BtOBcm)
      {
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
        ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                      CSID1con->ogSuConnId, CSID1con->ogProtType,
                      CCCALLCLR, NULL);
      }
      else if (bcmType == BtTBcm)
      {
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
        CSID1con->relPend  = ICRELONLY;
        ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                      CSID1con->icSuConnId, CSID1con->icProtType,
                      CCCALLCLR, NULL);
      }
      else
      {
        CCLOGERR("Invalid bcmType: %d\n", legId02->bcmType);
      }
      RETVALUE(ROK);
    }
    RETVALUE(ROK);
  }
  else if (con->ainInfo.legId == 2)
  {
    /* bug#31662, rkhan */
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);

    CSID1con = con->icBcm.cc->legId1->con;
    if (CSID1con == NULLP)
    {
      CCLOGERR( "Error: CSID1con NULLP\n");
      RETVALUE(RFAILED);
    }

    if (!((con->icBcm.cc->ccId == CiCallWaiting) ||
        (con->icBcm.cc->ccId == CiCallWaitingComplement)))
    {
      CCDP(AIN_DBG_LEVEL_3, "Unexpected ccId:%d\n", con->ogBcm.cc->ccId);
      RETVALUE(RFAILED);
    }
    /* Is the Controller O or T of CS 1 */
    if (con->icBcm.cc->legId02 ==  &(CSID1con->icBcm))
    {
      bcmType = BtOBcm;
    }
    else if (con->icBcm.cc->legId02 == &(CSID1con->ogBcm))
    {
      bcmType = BtTBcm;
    }
    else
    {
      CCLOGERR("Error: Unable to find bcmType\n");
      RETVALUE(RFAILED);
    }
#ifdef ZC
    cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG;
    upd.featMsg.DlegId       = 2;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
#if 1 /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

    if (bcmType == BtOBcm)
    {
      if (CSID1con->icBcm.cc)
      {
        CSID1con->icBcm.cc->ccId    = CiStable2Party;
        CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
        CSID1con->icBcm.cc->legId02 = NULLP;
        CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
        CSID1con->icBcm.cc->legId2  = NULLP;
      }
    }
    else /* BtTBcm */
    {
      if (CSID1con->ogBcm.cc)
      {
        CSID1con->ogBcm.cc->ccId    = CiStable2Party;
        CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
        CSID1con->ogBcm.cc->legId02 = NULLP;
        CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId2  = NULLP;
      }
    }

    /* This is needed, else the cc will be dropped */
    con->icBcm.cc = NULLP;
    CC_CLEAN_FIC_TXN(&(con->icBcm));
#ifdef CC_BUFFER_EVENT
    ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */

    if (con->ogRscVal != TRUE)
    {
      CCDP(AIN_DBG_LEVEL_1, "Leg 2 in another CSA was cleared from"
                            "this con\n");
      con->ogBcm.cc = NULLP;
      CC_CLEAN_FIC_TXN(&(con->ogBcm));
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
        /* Stop the billing timer */
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        con->relPend = NORELANDNORELRSP;
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      }
      else
        ret = RFAILED;

      if (ret == RFAILED)
      {
        CCDP(AIN_DBG_LEVEL_0, "Cleaning the Con: %ld\n", con->icSuConnId);
        cleanUpMgQ(con);
        ccRelCon(con);
        RETVALUE(ROK);
      }
      else
        RETVALUE(ROK);
    }


    /* start a Release procedure for this CS 2 */
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      /* Blow off the switching context for CSID1con */
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      /* Stop the billing timer */
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      con->lastState = CCS_ANSWERED;
      con->relPend   = OGRELONLY;

      state = CCS_AWTSWTCFM_SENDONEREL;
      ccModifyRelPendAndState(con, &(con->relPend), &state);

      CC_STATE_CHANGE(con, state);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    }
    else
      ret = RFAILED;
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other side */
      CCLOGERR("Error: ccSendMgiQueue failed:%ld\n",con->mgBlock->mgCtx->suCtxId);
      cleanUpMgQ(con);

      /* As the CS 2 would be cleared */
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, CCCALLCLR, NULL);
    }
    RETVALUE(ROK);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_3, "Disconnect on LegId = %d is not supported",
                           con->ainInfo.legId);
    RETVALUE(ROK);
  }
}

/*
*
*      Fun:   ccConE42S44
*
*      Desc:  Connection state function
*             event - CCE_MERGE_CALL
*             state - CCS_AWTRSPFORDPE9
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE42S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *CSID1con         = NULLP;
  S16               ret              = RFAILED;
  S16               mgitret          = RFAILED;
  CcMgCmdQ_t       *mgCmdQ           = NULLP;
  CcMgCmdQ_t       *prevCmdQ         = NULLP;
  MgctPackageId     pkgId            = MGCT_PACKAGE_ID_MAX;
  MgctCallProgItemId signal          = MGCT_ITEM_ID_CG_MAX;
  MgctMode           mode            = MGCT_MODE_MAX;
  AinBCM_t         *legId02          = NULLP;
  msgValBcmTypeEnum bcmType          = BtMax;
  SvcHeader_t      *mcSvcHeader      = NULLP;
  S16               ringRet          = RFAILED;
  Bool              mgiSent          = FALSE;
  ProtType          icProtType       = 0;
  ProtType          ogProtType       = 0;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CC_CALEA
  CcSurrogate *pSurrogate = NULLP;
#endif

  CCDP(AIN_DBG_LEVEL_1, "ccConE42S44 :%ld\n", con->icSuConnId);
  mcSvcHeader = (SvcHeader_t *) event;

  legId02   = con->icBcm.cc->legId02;
  bcmType   = legId02->bcmType;
  CSID1con = con->icBcm.cc->legId1->con;
  CCDP(AIN_DBG_LEVEL_0, "bcmType = %d\n", bcmType);

  if ((bcmType != BtOBcm) &&  (bcmType != BtTBcm))
  {
    CCLOGERR("Invalid bcmType: %d, %ld\n", bcmType, con->icSuConnId);
    RETVALUE(RFAILED);
  }


  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  if (((con->icBcm.cc) && (con->icBcm.cc->ccId == CiRemoteTransferSetup)) &&
      (con->icBcm.pic != PicOActive))
  {
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);

    /* FID 15261.0 + */
    // 90781: if (CC_IS_BCM_IN_CONTEXT(&con->ogBcm))
    {
      if (CC_IS_CALL_MULTI_MG(con))
      {
        con->ccmCb.mgPend = 0;
        if (CC_IS_BCM_IN_CONTEXT(&con->ogBcm))  /* 90781*/
        {
          ccUpdateMgQForSubRsc((PTR) NULLP, con->ogBcm.mgCtx->suCtxId, con);
          if (con->ogBcm.mgCtx->mgCmdQ)
             con->ccmCb.mgPend++;
        }
        else if (CC_IS_BCM_IN_CONTEXT(con->ogAdjBcm))
        {
          ccUpdateMgQForSubRsc((PTR) NULLP, con->ogAdjBcm->mgCtx->suCtxId, con);
          if (con->ogAdjBcm->mgCtx->mgCmdQ)
             con->ccmCb.mgPend++;
        }

        if (CC_IS_BCM_IN_CONTEXT(con->icAdjBcm))    
        {
          ccUpdateMgQForSubRsc(con->icAdjBcm, con->icAdjBcm->mgCtx->suCtxId, con);
          if (con->icAdjBcm->mgCtx->mgCmdQ)
             con->ccmCb.mgPend++;
        }
      }
      else
      { /*CCN_0*/
        if (CC_IS_BCM_IN_CONTEXT(&con->ogBcm))
        {
          ccUpdateMgQForSubRsc(&(con->ogBcm), con->ogBcm.mgCtx->suCtxId, con);
        }
      }

      if (((con->ogBcm.mgCtx)&&(con->ogBcm.mgCtx->mgCmdQ)) ||
          ((CC_IS_CALL_MULTI_MG(con)) && (con->ccmCb.mgPend > 0))) /*90781*/
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6IC);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        mgitret = ccSendMgiQueue(0, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
        }
        else
          mgiSent = TRUE;
      }
    }
    /* FID 15261.0 - */

    if (!mgiSent)
    {
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
      ccProcessMCForRemTrfStp(&con->icBcm);
    }
    RETVALUE(ROK);
  }

  /* This could happen in Call Transfer */
  if (con->ainInfo.legId == 2)
  {
    if (!((con->icBcm.cc->ccId == CiPartyOnHold) ||
        (con->icBcm.cc->ccId ==  CiPartyOnHoldComplement)))
    {
      CCLOGERR("Invalid ccId : %d\n", con->icBcm.cc->ccId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      ABORT_DEBUG;
    }
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);


    if (bcmType == BtOBcm)
    {
      /* IF CONTROLLER IS OBCM IN CS 1 */
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(CSID1con->icBcm), &(CSID1con->icBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(con->icBcm));
        ccMakeLegInactive(&(con->ogBcm));
#endif /* 0 */
      }
      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->icBcm),NULLP,
                                     NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(CSID1con->icBcm),MGCT_ITEM_ID_CG_MAX, CSID1con);
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6IC);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                               con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n",
                                 con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->icSuConnId;
                                       /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 2;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->icBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
        ccToggleCC6CtrlHashList(&con->icBcm);
/***************************BCM OPERATION*********************************/
        CSID1con->icBcm.cc->ccId    = CiStable2Party;
        CSID1con->icBcm.cc->legId01 = &(CSID1con->icBcm);
        CSID1con->icBcm.cc->legId02 = NULLP;
        CSID1con->icBcm.cc->legId1  = &(CSID1con->ogBcm);
        CSID1con->icBcm.cc->legId2  = NULLP;
        con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->icBcm));
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(con, CSID1con);
        /* There may be a event sitting on CSID1con Event Buffer */
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
        if (con->ogRscVal)
        {
          ogProtType = CC_GET_PROTOCOL(con->ogProtType);
          if ((ccIsLEGSubscriber(&(con->ogBcm))) || (ogProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, CCCALLCLR, NULL);
          }
          else
          {
            con->direction = OUTTOINC;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(con, CC_OUTGOING);
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
        CC_BREAK_IF_DISC_BUFFERED(CSID1con);
        if (CC_IS_CCID_CC10_AND_ABOVE(&(CSID1con->ogBcm)))
          ccCreateOnSwitchBearer(&(CSID1con->icBcm), NULLP, NULLP, NULLP, con->state,
                                 FALSE);
        else
          ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                         CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else if (bcmType == BtTBcm)
    {
      /* IF CONTROLLER IS TBCM IN CS 1 */
/*****************CLEAN UP CS2 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(CSID1con->ogBcm), &(CSID1con->ogBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(con->icBcm));
        ccMakeLegInactive(&(con->ogBcm));
#endif /* 0 */
      }
      if ((ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(CSID1con->ogBcm),
                                     NULLP, NULLP, NULLP, NULLP, NULLP,
                                     (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, 
                                     CSID1con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(CSID1con->ogBcm),MGCT_ITEM_ID_CG_MAX,CSID1con);
        if (CSID1con->surrogate != NULLP)
        {
           pSurrogate = CSID1con->surrogate;
           while (pSurrogate != NULLP)
           {
              CCDP(AIN_DBG_LEVEL_0,
                  "Adding Any Calea Leg's attached to Surrogate=%ld",
              pSurrogate->bcm.svcHeader.transId);
              ccAddCaleaToMgQ(&(pSurrogate->bcm), MGCT_ITEM_ID_CG_MAX, 
                                CSID1con);
              pSurrogate = pSurrogate->next;
           }
        }
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6IC);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                              con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR("MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
#ifdef ZC
        if (CC_IS_OBCM_PIC_ACTIVE(con))
        {
          upd.featMsg.suConnId     = con->icSuConnId;
                                     /*ACT Controlling leg connId*/
          upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
          upd.featMsg.DlegId       = 2;
          upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
          upd.featMsg.nel          = con->icBcm.nel;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
        }
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
        ccToggleCC6CtrlHashList(&con->icBcm);
/***************************BCM OPERATION*********************************/
        CSID1con->ogBcm.cc->ccId    = CiStable2Party;
        CSID1con->ogBcm.cc->legId01 = &(CSID1con->ogBcm);
        CSID1con->ogBcm.cc->legId02 = NULLP;
        CSID1con->ogBcm.cc->legId1  = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId2  = NULLP;
        con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(con->icBcm));
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(con, CSID1con);
        /* There may be a event sitting on CSID1con Event Buffer */
        ccPostEventToSelf (CSID1con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
        if (con->ogRscVal)
        {
          ogProtType = CC_GET_PROTOCOL(con->ogProtType);
          if ((ccIsLEGSubscriber(&(con->ogBcm))) || (ogProtType == CC_CS_TG))
          { 
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, CCCALLCLR, NULL);
          }
          else
          {
            con->direction = OUTTOINC;
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
            CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(con, CC_OUTGOING);
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
        CC_BREAK_IF_DISC_BUFFERED(CSID1con);
        if (CC_IS_CCID_CC10_AND_ABOVE(&(CSID1con->icBcm)))
          ccCreateOnSwitchBearer(&(CSID1con->ogBcm), NULLP, NULLP, NULLP, con->state,
                                 FALSE);
        else
          ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                         CSID1con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Invalid bcmType: %d, %ld\n", bcmType, con->icSuConnId);
      RETVALUE(RFAILED);
    }
  }
  else if (con->ainInfo.legId == 1)
  {
    if (!((con->icBcm.cc->ccId == CiCallWaitingComplement) ||
        (con->icBcm.cc->ccId == CiCallWaiting)))
    {
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      ABORT_DEBUG;
      CCLOGERR("Invalid ccId : %d\n", con->icBcm.cc->ccId);
    }
    ccStopConTmr(con, AIN_O_NO_ANS_TMR);
    ccStopConTmr(con, AIN_T_NO_ANS_TMR);
    /* STOP the AWAIT ANSWER Timer if running
     *
     * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
     */
    ccStopConTmr(con, CC_TMR_AWAITANS); 
    ccStopConTmr(con, TMR_SETUP);
    ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
    ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

    if (bcmType == BtOBcm)
    {
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(CSID1con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP,
                              CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
#ifdef CC_CALEA
        ccAssociateSubAndCaleaLegs(&(con->icBcm), &(con->icBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(CSID1con->icBcm));
        ccMakeLegInactive(&(CSID1con->ogBcm));
#endif /* 0 */
      }
      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->icBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP, 
                                     (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), 
                                     MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
        /* Adding the CAleaLegs of the controller in CS2 */
        ccAddCaleaToMgQ(&(con->icBcm), MGCT_ITEM_ID_CG_MAX, con);
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6IC);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                              CSID1con->mgBlock->mgCtx->suCtxId);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
#ifdef ZC
        upd.featMsg.suConnId      = con->icSuConnId;
                                         /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
        upd.featMsg.DlegId       = 1;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif /* ZC */
/****************************SU and SP INSTANCE TABLE *************************/
        ccToggleCC9CtrlHashList(&CSID1con->icBcm);
/***************************BCM OPERATION*********************************/
        con->icBcm.cc->ccId    = CiStable2Party;
        con->icBcm.cc->legId01 = &(con->icBcm);
        con->icBcm.cc->legId02 = NULLP;
        con->icBcm.cc->legId1  = &(con->ogBcm);
        con->icBcm.cc->legId2  = NULLP;
        CSID1con->icBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->icBcm));

        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);

#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
/***************************CHANGE RESOURCE OWNER*************************/
        ret = ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->icSuConnId);
        }
        else
        {
          CSID1con->icRscVal = FALSE;
          con->icRscVal      = TRUE;
        }
#ifdef CC_BUFFER_EVENT
        /* There may be a event sitting on con Event Buffer */
        ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
        if (CSID1con->ogRscVal)
        {
          ogProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
          if ((ccIsLEGSubscriber(&(CSID1con->ogBcm))) || (ogProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
            ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                          CSID1con->ogSuConnId, CSID1con->ogProtType,
                          CCCALLCLR, NULL);
          }
          else
          {
            CSID1con->direction = OUTTOINC;
            if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
            CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(con, CC_INCOMING);
          }
        }
        else
        {
          CC_STATE_CHANGE(CSID1con,  CCS_IDLE);
          ccRelCon(CSID1con);
        }
        CC_BREAK_IF_DISC_BUFFERED(con);
        ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                       con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else if (bcmType == BtTBcm)
    {
      /* IF CONTROLLER IS TBCM IN CS 1 */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
      if (CC_IS_CONTEXT_PRESENT(CSID1con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP,
                              CSID1con->mgBlock->mgCtx->suCtxId, CSID1con);
#ifdef CC_CALEA
        ccReleaseSurrogateCaleaLegs(CSID1con->surrogate);
        ccAssociateSubAndCaleaLegs(&(con->icBcm), &(con->icBcm));
#endif
      }
      else if ((!ccIsSwitchingLocallyDone(&(CSID1con->icBcm))) &&
               (!ccIsSwitchingLocallyDone(&(CSID1con->ogBcm))))
      {
#if 0
        ccMakeLegInactive(&(CSID1con->icBcm));
        ccMakeLegInactive(&(CSID1con->ogBcm));
#endif /* 0 */
      }
      if ((ccIsSwitchingLocallyDone(&(con->icBcm))) ||
          (ccIsSwitchingLocallyDone(&(con->ogBcm))))
      {
        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                     MGCT_ITEM_ID_CG_MAX, MGCT_CMD_ADD,
                                     &(con->icBcm), NULLP, NULLP,
                                     NULLP, NULLP, NULLP,
                                     (con->mgBlock->mgCtx ?  con->mgBlock->mgCtx->suCtxId : 0),
                                     MGCT_CONTEXT_CHOOSE, con);
#ifdef CC_CALEA
        ccAddCaleaToMgQ(&(con->icBcm), MGCT_ITEM_ID_CG_MAX, con);
#endif
      }
      mgCmdQ = con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
        prevCmdQ->next = CSID1con->mgBlock->mgCtx->mgCmdQ;
      else
        con->mgBlock->mgCtx->mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        CCDP(AIN_DBG_LEVEL_0, "ccSendMgiQueue =%ld\n",
                              con->mgBlock->mgCtx->suCtxId);

        con->lastState = CCS_ANSWERED;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_MERGEINCC6IC);
        ccChangeCallStateOfAssociatedCalls(&con->icBcm,
                                           CCS_CANNOTPROCESSEVENTS);
        con->mgBlock->con = con;
        mgitret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (mgitret != ROK)
        {
          CCLOGERR( "MGI operation failed,%ld\n", con->mgBlock->mgCtx->suCtxId);
          ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
#if 1 /* Bug#: 17932 */
        ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
#ifdef ZC
        upd.featMsg.suConnId     = con->icSuConnId;
                                         /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
        upd.featMsg.DlegId       = 1;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif /* ZC */ 
/****************************SU and SP INSTANCE TABLE *************************/
        ccToggleCC9CtrlHashList(&CSID1con->ogBcm);
/***************************BCM OPERATION*********************************/
        con->icBcm.cc->ccId    = CiStable2Party;
        con->icBcm.cc->legId01 = &(con->icBcm);
        con->icBcm.cc->legId02 = NULLP;
        con->icBcm.cc->legId1  = &(con->ogBcm);
        con->icBcm.cc->legId2  = NULLP;
        CSID1con->ogBcm.cc = NULLP;
        CC_CLEAN_FIC_TXN(&(CSID1con->ogBcm));
#ifdef CC_BUFFER_EVENT
        /* Move Buffered events from CS1 to CS2 */
        ccMoveBufferedEvents(CSID1con, con);
#endif /* CC_BUFFER_EVENT */
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
/***************************CHANGE RESOURCE OWNER*************************/
        ret = ccAllocateResource(con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", con->icSuConnId);
        }
        else
        {
          CSID1con->ogRscVal = FALSE;
          con->icRscVal      = TRUE;
        }
#ifdef CC_BUFFER_EVENT
        /* There may be a event sitting on con Event Buffer */
        ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
/*****************CLEAN UP CS1 AND PERFORM SWITCHING**************************/
        ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
        if (CSID1con->icRscVal)
        {
          icProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
          if ((ccIsLEGSubscriber(&(CSID1con->icBcm))) || (icProtType == CC_CS_TG))
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
            ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                          CSID1con->icSuConnId, CSID1con->icProtType,
                          CCCALLCLR, NULL);
          }
          else
          {
            CSID1con->direction = INCTOOUT;
            if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
            CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
            ccDeallocateResource(CSID1con, CC_INCOMING);
          }
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_IDLE);
          ccRelCon(CSID1con);
        }
        CC_BREAK_IF_DISC_BUFFERED(con);
        ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                       con->state, FALSE);
      }
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Invalid bcmType: %d, %ld\n", bcmType, con->icSuConnId);
      RETVALUE(RFAILED);
    }
  }
  else if (con->ainInfo.legId == 0)
  {
    if ((con->icBcm.cc->ccId == CiPartyOnHold) ||
        (con->icBcm.cc->ccId == CiPartyOnHoldComplement))
    {
      ret = RFAILED;
      ringRet = ccCheckMgContext(&(con->icBcm), &pkgId, &signal, &mode);
      if ((pkgId == MGCT_PACKAGE_ID_CG) && (signal == MGCT_SIG_ID_CG_RT))
        signal = MGCT_SIG_ID_CG_RT;
      else
        signal = MGCT_ITEM_ID_CG_MAX;
      ccUpdateMgQForSubRsc(&(con->icBcm), con->mgBlock->mgCtx->suCtxId, con);

      mgCmdQ = CSID1con->mgBlock->mgCtx->mgCmdQ;
      while (mgCmdQ != NULLP)
      {
        prevCmdQ = mgCmdQ;
        mgCmdQ = mgCmdQ->next ;
      }
      if (prevCmdQ)
      {
        prevCmdQ->next            = con->mgBlock->mgCtx->mgCmdQ;
        con->mgBlock->mgCtx->mgCmdQ      = CSID1con->mgBlock->mgCtx->mgCmdQ;
      }
      else
        mgCmdQ                    = con->mgBlock->mgCtx->mgCmdQ;

      CSID1con->mgBlock->mgCtx->mgCmdQ = NULLP;
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->lastState = con->state;
        con->relPend = ICRELONLYKEEPCON;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      }
      if (ret != ROK)
      {
        cleanUpMgQ(con);
        CCDP(AIN_DBG_LEVEL_0, "MGI Operation Performed: %ld, %ld\n",
             con->icSuConnId, con->mgBlock->mgCtx->suCtxId);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
      }
      RETVALUE(ROK);
    }
    else
       CCLOGERR("ERROR!! Invalid ccID = %d\n", con->icBcm.cc->ccId); 
  }
  else
  {
    CCLOGERR("legId = %d is not supported\n", con->ainInfo.legId);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE42S64
*
*      Desc:  Connection state function
*             event - CCE_MERGE_CALL
*             state - CCS_AWTRSPFAILOUT
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE42S64
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  CCDP(AIN_DBG_LEVEL_1, "ccConE42S64:%ld\n", con->icSuConnId);

#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */     
  ccMergeBcmToOriginalConnection(&(con->icBcm));
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE46S44
*
*      Desc:  Connection state function
*             event - CCE_RECONNECT
*             state - CCS_AWTRSPFORDPE9
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE46S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb          *CSID1con       = NULLP;
  CcConCb          *othercon       = NULLP;
  SvcHeader_t      *reSvcHeader    = NULLP;
  msgValBcmTypeEnum bcmType        = BtMax;
  S16               ret            = RFAILED;
  msgValCcIDEnum    prev_ccId      = CiInvalid;
  U8                relDisBool     = RFAILED;
  U8                evntType       = 0;
  ProtType          conOgProtType  = 0;
  Bool              mgiSent        = FALSE;
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CALEA_3WC
  S16               caleaRet       = RFAILED; 
#endif

  CCDP(AIN_DBG_LEVEL_1, "ccConE46S44 : %ld\n", con->icSuConnId);
  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR("Error: cc is nullp:%ld\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  reSvcHeader = (SvcHeader_t *) event;

  CSID1con = con->icBcm.cc->legId02->con;
  bcmType  = con->icBcm.cc->legId02->bcmType;
  if ((bcmType != BtOBcm) && (bcmType != BtTBcm))
  {
    CCLOGERR("Error: bcmType: %d, , %ld\n", bcmType, con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  if ((con->icBcm.cc->ccId != CiThreePartySetup) &&
      (con->icBcm.cc->ccId != CiPartyOnHold))
  {
    CCLOGERR("Error: ccId not supported :%d, %ld\n", con->icBcm.cc->ccId,
                                                    con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  ccStopConTmr(con, AIN_O_NO_ANS_TMR);
  ccStopConTmr(con, AIN_T_NO_ANS_TMR);
  /* STOP the AWAIT ANSWER Timer if running
   *
   * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
   */
  ccStopConTmr(con, CC_TMR_AWAITANS); 
  ccStopConTmr(con, TMR_SETUP);
  ccDeleteBufferedEvent(con, con->icSuConnId, CCE_ONOANSEXP);
  ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

#ifdef ZC
    upd.featMsg.suConnId     = con->icSuConnId; /*ACT Controlling leg connId*/
    upd.featMsg.ccAinUpdType = CC_RECONNECT_PRE_ANSWER;
    upd.featMsg.DlegId       = 0;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */

  prev_ccId         = con->icBcm.cc->ccId;
  con->reconnectBcm = OBCM;
/****************************SU and SP INSTANCE TABLE *************************/
  ccToggleCC6CtrlHashList(&con->icBcm);
/*************************CHANGE OWNER OF RESOURCE ***********************/
  if (bcmType == BtOBcm)
  {
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)NULLP, CC_INCOMING,
                             RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->icRscVal = TRUE;
    }
  }
  else /* It has to be BtTBcm */
  {
    ret = ccAllocateResource(CSID1con, (CcConEvnt *)NULLP, CC_OUTGOING,
                             RMT_ALOC_CHOWN);
    if (ret != ROK)
    {
      CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
    }
    else
    {
      con->icRscVal      = FALSE;
      CSID1con->ogRscVal = TRUE;
    }
  }
/************************SWITCHING REQUEST FOR RECONNECT*****************/
  if (CC_IS_CONTEXT_PRESENT(con))
  {
    if (con->ogRscVal)
    {
#ifdef CALEA_3WC
      ccAddSubCaleaRscReqIntoMgQ(&(con->icBcm), FALSE, FALSE);

#endif
      ccUpdateMgQForSubRsc(&(con->icBcm), con->mgBlock->mgCtx->suCtxId, con);
    }
    else
    {
      if ((con->ogBcm.cc) && ((con->ogBcm.cc->ccId == CiStableMParty) ||
                              (con->ogBcm.cc->ccId == CiTransfer) ||
                              (con->ogBcm.cc->ccId == CiForward) ||
                              (con->ogBcm.cc->ccId == CiRemoteTransferSetup)))
      {
        /* Do Not Sub any legs */
      }
      else
      {
        /* It could be Annc Playing on OutGoing */
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      }
    }
  }
  
  if (con->mgBlock->mgCtx->mgCmdQ)
  {
#ifdef CALEA_3WC
    othercon = con->icBcm.cc->legId1->con; 
    if (bcmType == BtOBcm)
    {
      /* Make the Caleas of the controller in CS2 to point to controller
       * in CS1 */ 
      ccAssociateSubAndCaleaLegs(&(othercon->icBcm), &(othercon->icBcm)); 
    }
    else
    {
      /* Make the Caleas of the controller in CS2 to point to controller
       * in CS1 */
      ccAssociateSubAndCaleaLegs(&(othercon->ogBcm), &(othercon->ogBcm));
    }
#endif
    if (ret == ROK)
    {
      con->lastState = con->state;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFMFORSVC);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    }
    if (ret != ROK)
    {
      CCLOGERR( "MGI Operation Failed %ld\n", con->mgBlock->mgCtx->suCtxId);
      cleanUpMgQ(CSID1con);
      ccCleanUpMGCtx (CSID1con);
      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
    }
    else
      RETVALUE(ROK);
  }
  else
  {
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */ 
    othercon = con->icBcm.cc->legId1->con; 
    con->icBcm.cc->ccId    = CiStable2Party;
    con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
    con->icBcm.cc->legId02 = NULLP;
    con->icBcm.cc->legId2  = NULLP;
    con->icBcm.cc          = NULLP;
    othercon->icEvnt       = NULLP;

    CCDP(AIN_DBG_LEVEL_0, "Re-Connect to icSu=%ld\n", con->icSuConnId);
    CC_STATE_CHANGE(othercon, CCS_AWTANS);
    othercon->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
    ccStartConTmr(TMR_RECONNECT, othercon, (PTR)&ccCp.genCfg);
    othercon->reconnectBcm = OBCM; /* Does not matter if O/T as we just
                                 use it when we get a response */

    if (bcmType == BtOBcm)
    {
#ifdef CALEA_3WC
      /* Make the Caleas of the controller in CS2 to point to controller
       * in CS1 */ 
      ccAssociateSubAndCaleaLegs(&(othercon->icBcm), &(othercon->icBcm)); 
#endif
      ccReconnectBearer(&(othercon->icBcm), &(othercon->ogBcm), NULLP, NULLP,
                          othercon->state);
    }
    else /* It should be BtTBcm */
    {
#ifdef CALEA_3WC
      /* Make the Caleas of the controller in CS2 to point to controller
       * in CS1 */ 
      ccAssociateSubAndCaleaLegs(&(othercon->ogBcm), &(othercon->ogBcm)); 
#endif
      ccReconnectBearer(&(othercon->ogBcm), &(othercon->icBcm), NULLP, NULLP,
                          othercon->state);
    }
    if ((prev_ccId == CiThreePartySetup) ||
        ((prev_ccId == CiPartyOnHold) &&
         (con->ogBcm.bcmType == BtMax)))
    {
      CCDP(AIN_DBG_LEVEL_0, "Reconnect Done in ccId:%d, %ld\n",
                            prev_ccId, con->icSuConnId);
      /* As there is no LegId2, we can just clean up CS2 con */
      ccRelCon(con);
      RETVALUE(ROK);
    }
    else
    {
      ret = ccProcessDisconnectOnSpecificBCM (&(con->ogBcm));
#ifdef CALEA_3WC
      if (con->surrogate != NULLP)
        ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif

      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the TBCM of"
                              " the connection\n");
        RETVALUE(ROK);
      }
#ifdef CALEA_3WC
      /* The passive leg is not involved in MParty Call */
      caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                               event);
      if (caleaRet != ROK)
      {
         CCDP(AIN_DBG_LEVEL_4,
             "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
      }
#endif

      /* Else Fall Down and clean up the call */
      /* ELSE do normal Release handling */
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

      /********** Blow off the switching and Send Release to OG ***********/
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      if (con->mgBlock->mgCtx->mgCmdQ)
      {
        con->tempHolderForReleaseCause = CCCALLCLR;
        if (con->ogRscVal)
        {
          relDisBool = ccCheckRelOrOnHookInBuffer(&(con->ogBcm), &evntType);
          if (relDisBool == ROK)
          {
            conOgProtType = CC_GET_PROTOCOL(con->ogProtType);
            if ((conOgProtType == CC_BI) || (conOgProtType == CC_SI) ||
                (conOgProtType == CC_EXT_BICC) ||
                (conOgProtType == CC_IN) || (conOgProtType == CC_SIP))
              con->relPend                   = OUTRELRSPANDNOREL;

            ccDeleteBufferedEvent(con, con->ogSuConnId, evntType);
          }
          else
            con->relPend                   = OGRELONLY;
          con->tempHolderForReleaseCause = CCCALLCLR;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }
        else
        {
          con->relPend                   = NORELANDNORELRSP;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        }
#ifdef ZC
        upd.icSuConnId = con->icSuConnId;
        zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
#endif
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          cleanUpMgQ(con);
          CCLOGERR( "MGI Operation failed:%ld\n", con->mgBlock->mgCtx->suCtxId);
        }
        else
          mgiSent = TRUE;
      }
      if (!mgiSent)
      {
        if (con->ogRscVal)
        {
          relDisBool = ccCheckRelOrOnHookInBuffer(&(con->ogBcm), &evntType);
          if (relDisBool == ROK)
          {
            conOgProtType = CC_GET_PROTOCOL(con->ogProtType);
            if ((conOgProtType == CC_BI) || (conOgProtType == CC_SI) ||
                (conOgProtType == CC_EXT_BICC) ||
                (conOgProtType == CC_IN) || (conOgProtType == CC_SIP))
            {
              con->direction = INCTOOUT;
              if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
              CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
              ccDeallocateResource(con, CC_OUTGOING);
            }
            ccDeleteBufferedEvent(con, con->ogSuConnId, evntType);
          }
          else
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, CCCALLCLR, NULLP);
          }
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_IDLE);
          ccRelCon(con);
        }
      }
      RETVALUE(ROK);
    }
  }
}


/*
*
*      Fun:   ccConE39S46
*
*      Desc:  Connection state function
*             event - CCE_CONTINUE
*             state - CCS_AWTRSPFORDPE32
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE39S46
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                      ret          = RFAILED;
  CcConCb                 *CS1con       = NULLP;
  SvcHeader_t             *oaSvcHeader    = NULLP;
  CcMidCallReqEvnt         midCallReq;
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED; 
#endif
  Continue_t        *pContinue      = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccConE39S46:%ld\n", con->icSuConnId);

#if 1 /* Bug#: 17932 */
   ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  oaSvcHeader = (SvcHeader_t *) event;
  pContinue   = (Continue_t *) event2;
  /* Lets stay in AWT_ANS and wait for the Setup timer to expire */
  CCLOGERR("Unexpected msg recvd: 39, %ld, %ld\n", con->icSuConnId,
           pContinue->errorCode);

  if (pContinue->errorCode == FC_NOT_APPLICABLE)
  {
    CCDP(AIN_DBG_LEVEL_0, "Received Continue :%ld\n", pContinue->errorCode);
    CC_STATE_CHANGE(con, con->lastState);
    RETVALUE(ROK);
  }

  /* Things to do
  1. Stop the CWT tone.
  2. Clean up association of CWT.
  3. Process as if a Release came from OG */
  if (con->ogBcm.cc == NULLP)
  {
    CCLOGERR("con->ogBcm.cc is NULLP: %ld\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, pContinue->errorCode);
    RETVALUE(ROK);
  }

  if (con->ogBcm.cc->legId02 == NULLP)
  {
    CCLOGERR("con->ogBcm.cc->legId02 is NULLP: %ld\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, pContinue->errorCode);
    RETVALUE(ROK);
  }

  ccStopConTmr(con, TMR_SETUP);
  
  /* Also Stop the CWT tone as we are going back to Two Party Call */
  ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);

  CS1con = con->ogBcm.cc->legId02->con;
  if (con->ogBcm.cc->legId02->bcmType == BtOBcm)
  {
    CcLiCctMidCallReq(&CS1con->icSapCb->pst, CS1con->icSapCb->spId,
                      CS1con->icSpConnId, CS1con->icSuConnId,
                      CS1con->icProtType, &midCallReq);
    CS1con->icBcm.cc->legId01 = &(CS1con->icBcm);
    CS1con->icBcm.cc->legId02 = NULLP;
    CS1con->icBcm.cc->legId2  = NULLP;
    CS1con->icBcm.cc->ccId    = CiStable2Party;
  }
  else if (con->ogBcm.cc->legId02->bcmType == BtTBcm)
  {
    CcLiCctMidCallReq(&CS1con->ogSapCb->pst,CS1con->ogSapCb->spId,
                      CS1con->ogSpConnId, CS1con->ogSuConnId,
                      CS1con->ogProtType, &midCallReq);
    CS1con->ogBcm.cc->legId01 = &(CS1con->ogBcm);
    CS1con->ogBcm.cc->legId02 = NULLP;
    CS1con->ogBcm.cc->legId2  = NULLP;
    CS1con->ogBcm.cc->ccId    = CiStable2Party;
  }
  else
  {
    CCLOGERR("Invalid bcmType: %d\n", con->ogBcm.cc->legId02->bcmType);
    CC_STATE_CHANGE(con, con->lastState);
    RETVALUE(RFAILED);
  }

  con->ogBcm.cc             = NULLP;
  ccCloseTBcmTransaction (con);

  ret = ccProcessDisconnectOnSpecificBCM (&(con->icBcm));
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0, "Disconnect detected on the OBCM of"
                          " the connection\n");
    RETVALUE(ROK);
  }
#ifdef CALEA_3WC
  /* The passive leg is not involved in MParty Call */
  caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->icBcm),
                                                             event);
  if (caleaRet != ROK)
  {
     CCDP(AIN_DBG_LEVEL_4,
          "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
  }
#endif


  if (CC_IS_CONTEXT_PRESENT(con))
  {
    con->relPend   = ICRELONLY;

    ccQSubBasedOnCcn(con);  /* FID 15261.0 */

    CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
    con->mgBlock->con = con;
    ret = ccSendMgiQueue(0, con->mgBlock);
  }
  else
    ret = RFAILED;
  if (ret != ROK)
  {
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    cleanUpMgQ(con);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
  }
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE41S46
*
*      Desc:  Connection state function
*             event - CCE_FORWARD_CALL
*             state - CCS_AWTRSPFORDPE32
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE41S46
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16                 ret        = RFAILED;
   S16                 relDisBool = RFAILED;
   U8                 evntType    = 0;
   CcConCb            *CS1con    = NULLP;
   msgValBcmTypeEnum  bcmType    = BtMax;
   CcMidCallReqEvnt   midCallReq;
   SvcHeader_t       *tnSvcHeader = NULLP;
   AinBCM_t          *pOtherBcm   = NULLP;
   Bool              addRingInconf = FALSE;


  CCDP(AIN_DBG_LEVEL_1, "ccConE41S46 :%ld\n", con->icSuConnId);
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

  tnSvcHeader = (SvcHeader_t *) event;

  ccCleanAnsFraudCall(con);

  if (con->ogBcm.cc)
  {
    if ((con->ogBcm.cc->ccId == CiCallWaiting) ||
        (con->ogBcm.cc->ccId == CiCallWaitingComplement))
    {
      /* Stop the CWT tone from legId02 */
      CS1con  = con->ogBcm.cc->legId02->con;
      bcmType = con->ogBcm.cc->legId02->bcmType;
      ccBuildMidCalReqForMC_CANCEL_ALL(&midCallReq);
      con->ogBcm.cc->ccId    = CiStable2Party;
      con->ogBcm.cc->legId02 = NULLP;
      con->ogBcm.cc->legId2  = NULLP;
      if (bcmType == BtOBcm)
      {
        CCDP(AIN_DBG_LEVEL_0, "STOP CWT TONE\n");
        CcLiCctMidCallReq(&CS1con->icSapCb->pst, CS1con->icSapCb->spId,
                          CS1con->icSpConnId, CS1con->icSuConnId, 
                          CS1con->icProtType, &midCallReq);
        con->ogBcm.cc->legId01 = &(CS1con->icBcm);
        con->ogBcm.cc          = NULLP;
      }
      else if (bcmType == BtTBcm)
      {
        CCDP(AIN_DBG_LEVEL_0, "STOP CWT TONE\n");
        CcLiCctMidCallReq(&CS1con->ogSapCb->pst, CS1con->ogSapCb->spId,
                          CS1con->ogSpConnId, CS1con->ogSuConnId, 
                          CS1con->ogProtType, &midCallReq);
        con->ogBcm.cc->legId01 = &(CS1con->ogBcm);
        con->ogBcm.cc          = NULLP;
      }
      else
      {
        CCLOGERR("Invalid bcmType = %d, for %ld\n", bcmType, CS1con->icSuConnId);
        RETVALUE(RFAILED);
      }
      /* Initialize the ogBcm field in the CcConCb */
      ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->ogBcm.cc),
                     (Size) sizeof(AinCallConfig_t));
      if (ret != ROK)
      {
         ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                    LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
         RETVALUE(RFAILED);
      }
      cmMemset((U8 *) (con->ogBcm.cc), 0, sizeof(AinCallConfig_t));
      con->ogBcm.cc->legId01 = &(con->ogBcm);
      con->ogBcm.cc->legId1  = &(con->icBcm);
      con->ogBcm.cc->ccId    = CiTerminatingSetup;
#ifdef CC_CALEA /* Bug# 16924 */
      /* Pull back the remaining LEAs into the Controller in CS2,
       * This will happen when the TNoAnswer timer expires for a
       * Controller who is having CW also */
      ccAdjustCaleasAmongCons(CS1con, bcmType, con);
#endif 

      /* Bug#30712 */
      relDisBool = ccCheckRelOrOnHookInBuffer(&(con->icBcm), &evntType);
      if ((ccCheckEventInBuffer(&(con->ogBcm), CCE_CONCFM)) ||
          (relDisBool == ROK))
      {
        /* Drop the Forward Call Response and process the Connect Confirm */
        DP("Dropping the Forward Call and processing the ConCfm/Rel message:"
           " icSu = 0x%lx, ogTransId = 0x%lx\n", con->icSuConnId,
           con->ogBcm.svcHeader.transId);
        CC_STATE_CHANGE(con, CCS_AWTANS);
        RETVALUE(ROK);
      }
      /* End of Bug#30712 */

      /* Blow off any MGI switching context on con */
      if (CC_IS_CONTEXT_PRESENT(con))
      {
        ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
        con->lastState = CCS_AWTRSPFORDPE32;
        con->relPend = NORELANDNORELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
        if (ret != ROK)
        {
          cleanUpMgQ(con);
          CCLOGERR( "Error: suCtxId= %ld\n", con->mgBlock->mgCtx->suCtxId);
          /* Handle this error case */
          con->lastState = CCS_AWTRSPFORDPE32;

          /* At this point Call the ForwardCallAPI */
          ret = ccForwardCallAPI(con);
          if (ret == RFAILED)
          {
            ccStopConTmr(con, TMR_SETUP);
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CCCALLCLR, NULL);
          }
          RETVALUE(ROK);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "Success, MGI req sent: %ld\n", 
                con->mgBlock->mgCtx->suCtxId );
          RETVALUE(ROK);
        }
      }
      else
      {
        CCDP(AIN_DBG_LEVEL_0, "icSu:%ld, ogSu:%ld, icPtype:%d, ogPtype:%d\n",
             con->icSuConnId, con->ogSuConnId, con->icProtType, con->ogProtType);

/* bug fix for 20526 */
    /* This is a forward Call scenario */
    ret = ccForwardCallAPI(con);
    if (ret == RFAILED)
    {
        ccProcessFailCnd(con, CCTMPFAIL, TRUE); 
    }
    RETVALUE(ROK);

#if 0
        con->lastState = CCS_AWTRSPFORDPE32;
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCTMPFAIL, NULL);
        RETVALUE(RFAILED);
#endif

      }
    }
    /* Else Drop down it is a normal two party call having CFNA */
  }

  /* Bug#30712 */
  relDisBool = ccCheckRelOrOnHookInBuffer(&(con->icBcm), &evntType);
  if ((ccCheckEventInBuffer(&(con->ogBcm), CCE_CONCFM)) ||
      (relDisBool == ROK))
  {
    /* Drop the Forward Call Response and process the Connect Confirm */
    DP("Dropping the Forward Call and processing the ConCfm/Rel message:"
       " icSu = 0x%lx, ogTransId = 0x%lx\n", con->icSuConnId,
       con->ogBcm.svcHeader.transId);
    CC_STATE_CHANGE(con, CCS_AWTANS);
    RETVALUE(ROK);
  }
  /* End of Bug#30712 */

   /* As Connection Request was sent out , an entry was made in ogConsInstTbl,
      need to delete it. */
   if (con->ogSapCb != NULLP)
   {
      cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);
      con->ogSapCb->nmbActvConn--;
   }

  if (CC_IS_CONTEXT_PRESENT(con))
  {
    /* Do not stop the setup timer, as the call we be attempted 
     * on the Forwarded DN */
    /* Blow off the switching and Release the Call */
    pOtherBcm = ccFindOtherBcm(&(con->icBcm));
    if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiTransfer))
    {
       if (con->icBcm.cc->legId02 != NULLP) 
          CS1con  = con->icBcm.cc->legId02->con; 
       if (isCaleaLegPresent(&(con->icBcm)) ||
           isCaleaLegPresentInSurrogate(con) ||
           isCaleaLegPresent(&(con->ogBcm)) ||
           isCaleaLegPresentInSurrogate(CS1con) ||
           isConfRscReq(con->icBcm.cc->legId1))
       {
          addRingInconf = TRUE;
       } 
       if (addRingInconf)
       {
          ccUpdateMgQForSubAnnRsc(con->mgBlock->mgCtx->suCtxId, con);
          ccUpdateMgQForAddAnnRsc(con->mgBlock->mgCtx->suCtxId, con, 0, FALSE,
                                  MGCT_ITEM_ID_CG_MAX);
       }
       else
       {
          if (pOtherBcm) 
            ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV, MGCT_PACKAGE_ID_MAX,
                                         MGCT_ITEM_ID_CG_MAX, MGCT_CMD_MODIFY,
                                         pOtherBcm, NULLP, NULLP,
                                         NULLP, NULLP, NULLP,
                                         con->mgBlock->mgCtx->suCtxId,
                                         MGCT_CONTEXT_CHOOSE, con);

       }
       UPDATE_OPIC(con, PicSendCall);
       ret = ROK;
    }
    else
    {
       ccUpdateMgQForSubAnnRsc(con->mgBlock->mgCtx->suCtxId, con);
       if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty))
       {
          ccUpdateMgQForAddAnnRsc(con->mgBlock->mgCtx->suCtxId, con, 0, FALSE,
                                  MGCT_ITEM_ID_CG_MAX);
       }
#ifdef CALEA_3WC
       /* Remove the LEA of pOtherBcm from the Context */
       ret = ccAddSubCaleaRscReqIntoMgQ(pOtherBcm, FALSE, FALSE);
#endif
       if (!((con->icBcm.cc) && (con->icBcm.cc->ccId == CiStableMParty)))
       {
         ccUpdateMgQForSubRsc((pOtherBcm), con->mgBlock->mgCtx->suCtxId, con);
       }
    }
    if (ret == ROK)
    {
#ifdef CALEA_3WC
      /* Remove the LEAs of ogBcm and the surrogate */
      ret = ccAddSubCaleaRscReqIntoMgQ(&(con->ogBcm), TRUE, FALSE);
#endif
      ccUpdateMgQForSubRsc(&(con->ogBcm), con->mgBlock->mgCtx->suCtxId, con);
    }
    if (ret == ROK)
    {
      con->lastState = CCS_AWTRSPFORDPE32;
      con->relPend = OGRELONLY;
      con->tempHolderForReleaseCause = CCTMPFAIL;

      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
    }     
    if (ret != ROK)
    {
      /* Anyway go ahead and send a release to the other
         side */
      CCLOGERR( "Error: ccSendMgiQueue failed\n");
      cleanUpMgQ(con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    }
    RETVALUE(RFAILED);
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0, "icSu:%ld, ogSu:%ld, icPtype:%d, ogPtype:%d\n",
         con->icSuConnId, con->ogSuConnId, con->icProtType, con->ogProtType);
    con->lastState = CCS_AWTRSPFORDPE32;
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
    ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, CCTMPFAIL, NULL);
    RETVALUE(RFAILED);
  }

}


/*
*
*      Fun:   ccConE04S36
*
*      Desc:  Connection state function
*             event - Cct Release Indication
*             state - AWTRSPFORDPE1
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S36
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   CCLOGERR("Error: Invalid Call Flow:%ld\n", con->icSuConnId);
   RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE14S36
*
*      Desc:  Connection state function
*             event - SETUP Tmr Expiry
*             state - AWTRSPFORDPE1
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE14S36
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE14S36: %ld\n", con->icSuConnId);
  
  /* Generate alarm */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  ccPlayToneOrRelease(con, CCTMPFAIL);
  RETVALUE(ROK);
} /* ccConE14S36 */


/*
*
*      Fun:   ccConE04S37
*
*      Desc:  Connection state function
*             event - Cct Release Indication
*             state - AWTRSPFORDPE3
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S37
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16            ret = RFAILED;

   /* Store the release event */
   ccStopConTmr(con, TMR_SETUP);
#if 1 /* EARLY_ACM */
   ccStopConTmr(con, CC_TMR_EARLYACM);
#endif
   /* Bug 77061 send RLC immediately to UK ISUP for RBWF when REL is
    * received right after incoming IAM.
    */
    if((con->icProtType == CC_SIUK) && 
       ((con->icBcm.nel[EReqOApm] == NEL_REQUEST)||
        (con->icBcm.nel[EReqOApmCalled] == NEL_REQUEST)))
    {                           
        ccCloseOBcmTransaction(con);
        ccCloseTBcmTransaction(con);

        if (con->noRspReqd == FALSE) 
        {                       
            ccSendReleaseRsp(con);
        }                       
        CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
                                                                          
        if(con->icRscVal == FALSE)
        {
            CC_STATE_CHANGE(con, CCS_IDLE);
            ccRelCon(con);
        }                       
        else 
        {
            ccDeallocateResource(con, CC_INCOMING);
        }
        RETVALUE(ROK);
    }

    /* FID 14457.0 GETS +  */
    if (CC_IS_CALL_FLAG_SET(con->flag,CC_FLAG_CALLQUEUED))
    {
       ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);
       ccStopConTmr(con, CC_TMR_CALLDTL);
       ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

       /* FID 14732 */
       ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
       /* FID 14732 */

       if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
                             sizeof(CcRelEvnt))) != ROK)
       {
           CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
       }
       if (CC_IS_CONTEXT_PRESENT(con))
       {
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */

          con->relPend = INRELRSPANDNOREL;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret == ROK)
             RETVALUE(ROK);
          else
          {
             CCLOGERR("Error: During switching icSu = 0x%lx\n", con->icSuConnId);
             cleanUpMgQ(con);
             ccCleanUpMGCtx (con);
          }
       }

       if (con->noRspReqd == FALSE) 
       {                       
           ccSendReleaseRsp(con);
       }                       
       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
                                                                         
       if(con->icRscVal == FALSE)
       {
           CC_STATE_CHANGE(con, CCS_IDLE);
           ccRelCon(con);
       }                       
       else 
       {
           ccDeallocateResource(con, CC_INCOMING);
       }
       RETVALUE(ROK);
   }
   /* FID 14457.0 GETS - */
   
   ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

   if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
   {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC991, (ErrVal) ret,
                 "ccConE04S37() Failed, ccStoreEvnt failed");
#endif
      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *) event;
      CC_STATE_CHANGE(con, CCS_IDLE);
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      RETVALUE(RFAILED);
   }
   /* Wait for response from FIC for msg sent on DP3    */
   con->relPend = INRELRSPANDNOREL;
   CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
   RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE04S40
*
*      Desc:  Connection state function
*             event - Cct Release Indication
*             state - CCS_AWTRSPFORDPE30
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S40 
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE04S40: icSu = %ld, ogSu = %ld, T.transId = %ld\n",
       con->icSuConnId, con->ogSuConnId, con->ogBcm.svcHeader.transId);
  DP("Buffered an Event :%ld, %d\n", con->icSuConnId, con->icEvntType);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S44
 *
 *      Desc:  Connection state function
 *             event: 04 - Release Indication
 *             state: 44 - CCS_AWTRSPFORDPE9
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S44
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE04S44: %ld\n", con->icSuConnId);
#ifdef CC_BUFFER_EVENT
  CCLOGERR("Buffered an Event :%ld, %d\n", con->icSuConnId,
                                        con->icEvntType);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
#endif /* CC_BUFFER_EVENT */
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S43
 *
 *      Desc:  Connection state function
 *             event: 04 - Release Indication
 *             state: 43 - CCS_AWTRSPFORDPE28
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S43
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S43: %ld\n", con->icSuConnId);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE14S37
*
*      Desc:  Connection state function
*             event - SETUP tmr Expiry
*             state - AWTRSPFORDPE3
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE14S37
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* Generate alarm */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);


#if 1 /* 51792:make sure we execute oDisconnect if this call is multiparty */
  ccProcessFailCnd(con, CCTMPFAIL, TRUE); 
#else
  /* Not waiting for DPE1 anymore. Trying to clear the call */
  ccPlayToneOrRelease(con, CCTMPFAIL);
#endif
  RETVALUE(ROK);
} /* ccConE14S37 */


/*
*
*      Fun:   ccConE04S39
*
*      Desc:  Connection state function
*             event - Cct Release Indication
*             state - AWTRSPFORDPE20
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S39
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16      ret     = RFAILED;

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

   /* Store the release event */
#if 1 /* EARLY_ACM */
   ccStopConTmr(con, CC_TMR_EARLYACM);
#endif
   ccStopConTmr(con, TMR_SETUP);
   ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
   ccUpdateCloseCause(con, CC_BOTH, CscCallerAbandon);

   if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
        sizeof(CcRelEvnt))) != ROK)
   {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC993, (ErrVal) ret,
                 "ccConE04S39() Failed, ccStoreEvnt failed");
#endif
      con->direction = INCTOOUT;
      con->icEvnt = (CcAllSdus *) event;
      CC_STATE_CHANGE(con, CCS_IDLE);
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      RETVALUE(RFAILED);
   }
   /* Wait for response from FIC for msg sent on DP20   */
   con->relPend = INRELRSPANDNOREL;
   CC_STATE_CHANGE(con, CCS_AWTRSPFORDPEXY_TOCLR);
   RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE04S46
*
*      Desc:  Connection state function
*             event - Cct Release Indication
*             state - AWTRSPFORDPE32
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S46
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("Buffered an Event :%ld, %d\n", con->icSuConnId, con->icEvntType);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}



/*
*
*      Fun:   ccConE14S39
*
*      Desc:  Connection state function
*             event - SETUP Tmr Expiry
*             state - AWTRSPFORDPE20
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE14S39
(   
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE14S39: %ld\n", con->icSuConnId);

  /* Generate alarm */
  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
             LCC_CAUSE_SETUPTMR_EXP, (U8 *) &con->icSuConnId);

  /* Not waiting for DPE1 anymore. Trying to clear the call */
  if (con->ogRscVal)
  {   
    ccDeallocateResource(con, CC_OUTGOING);
    con->ogRscVal = FALSE;
  }
  ccPlayToneOrRelease(con, CCTMPFAIL);
  RETVALUE(ROK);
} /* ccConE14S39 */


/*
 *
 *      Fun:   ccConE03S54
 *
 *      Desc:  Connection state function
 *             event - CnStInd
 *             state - CCS_AWTSWTCFM_SENDBOTHREL
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S54
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->icEvntType == CS_CONN_STATUS_FORCED_ON_HOOK)
  {       
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if( (con->direction == INCTOOUT) &&
      (con->icProtType != CC_CS_TG) &&
      (con->icProtType != CC_CS_LN) &&
      (con->icProtType != CC_GR303) )
  {
      CCLOGERR( 
         "ccConE03S54(): unExpected evnt in state = %d," 
         "ProtocolType = %d/%d, direction = %d, evnType =%d\n",
         con->state, con->icProtType, con->ogProtType, con->direction,
         con->icEvntType);
      RETVALUE(ROK);
  }

  /* bug#14799 : Force NO TIMED RELEASE */
  if((con->direction == OUTTOINC) &&
     (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction)))
  {
    /* Make sure TimedRelease/RelReq(PERM_NO_ON_HOOK) is not applied on 
     * this call. All legs are already in ON-HOOK state. */
    con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
  }

  /* 24279 : Extract the SDP if rcvd from layer-3 */
  ccExtractSdpFromCnStInd(con, event);

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */

  if(con->relPend != BOTHREL)
  {
    CCLOGERR(
        "ccConE03S54(): unExpected evnt in state = %d, ProtocolType = %d/%d,"
        "direction = %d, icEvntType==%d,\n", con->state, con->icProtType,
        con->ogProtType, con->direction, con->icEvntType);
    RETVALUE(ROK);
  }

  if(con->icEvntType != CS_CONN_STATUS_ON_HOOK)
  {
    CCLOGERR( "Not handling this event:state = %d," 
         "ProtocolType = %d/%d, direction = %d, evnType =%d\n",
         con->state, con->icProtType, con->ogProtType, con->direction,
         con->icEvntType);
    RETVALUE(ROK);
  }

  /* Only ON-HOOK is expected */

  /* No change in state */
  RETVALUE(ROK);
} /* end ccConE03S54 */


/*
 *
 *      Fun:   ccConE01S55
 *
 *      Desc:  Connection state function
 *             event - ConCfm - ANSWER
 *             state - CCS_AWTSWTCFM_SENDONEREL
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE01S55
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  /* This event should be ignored.
   * However, possible SDP in SIP 200-OK should be freed */

  /* 24446: Extract the SDP if rcvd from layer-3 */
  if (con->direction == OUTTOINC)
  {
      ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

    switch (ogProtType)
    {
       case CC_MGCP_LN:  
       case CC_MGCP_TG:
          ccExtractProtSdp(ccInit.region, ccInit.pool, con,
              &(((CcConEvnt *)event)->m.mgcpCctEvnt.sdp));
          break;

       case CC_SIP:
          ccExtractProtSdp(ccInit.region, ccInit.pool, con,
               &(((CcConEvnt *)event)->m.sipConEvnt.sdp));

          /* FID 14732 */
          ccExtractSipwMBufFromConIndAndConCfm(con, CCE_CONCFM, (PTR) event);
          /* FID 14732 */

          break;
    }
  }

  RETVALUE(ROK);
} /* ccConE01S55 */


/*
 *
 *      Fun:   ccConE03S55
 *
 *      Desc:  Connection state function
 *             event - CnStInd
 *             state - CCS_AWTSWTCFM_SENDONEREL
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S55
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  if (con->icEvntType == CS_CONN_STATUS_FORCED_ON_HOOK)
  {       
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  if( (con->direction == INCTOOUT) &&
      (con->icProtType != CC_CS_TG) &&
      (con->icProtType != CC_CS_LN) &&
      (con->icProtType != CC_GR303) )
  {
      CCLOGERR(
         "ccConE03S55(): unExpected evnt in state = %d," 
         "ProtocolType = %d/%d, direction = %d, evnType =%d\n",
         con->state, con->icProtType, con->ogProtType, con->direction,
         con->icEvntType);
      RETVALUE(ROK);
  }

  /* 24279: Extract the SDP if rcvd from layer-3 */
  ccExtractSdpFromCnStInd(con, event);

  /* FID 14732 */
  ccExtractSipwMBufFromCnStInd(con, event);
  /* FID 14732 */

  if(con->relPend != BOTHREL)
  {
    if(((con->relPend == OUTRELANDINFAILCOND) ||
        (con->relPend == OUTRELRSPANDINFAILCOND) ||
        (con->relPend == OUTRELANDSCRINFAILCOND) || 
        (con->relPend == OUTRELANDANSINFAILCOND) ||
        (con->relPend == OUTRELRSPANDSCRINFAILCOND) ||
        (con->relPend == OUTRELRSPANDANSINFAILCOND) ) &&
        (con->direction == INCTOOUT))
    {
      con->relPend = BOTHREL;
      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
      RETVALUE(ROK);
    }

#ifdef CC_BUFFER_EVENT
    if ((con->relPend == ICRELONLYKEEPCON) ||
        (con->relPend == OGRELONLYKEEPCON) ||
        (con->relPend == OGRELONLY))
    {
      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                           NULLP, 0);
    }
    else
    {
      CCLOGERR(
          "ccConE03S55(): unExpected evnt in state = %d, ProtocolType = %d/%d,"
          "direction = %d, icEvntType==%d,\n", con->state, con->icProtType,
          con->ogProtType, con->direction, con->icEvntType);
    }
    RETVALUE(ROK);
#endif /* CC_BUFFER_EVENT */
  }

  if(con->icEvntType != CS_CONN_STATUS_ON_HOOK)
  {
    CCLOGERR( "Not handling this event:state = %d," 
         "ProtocolType = %d/%d, direction = %d, evnType =%d\n",
         con->state, con->icProtType, con->ogProtType, con->direction,
         con->icEvntType);
    RETVALUE(ROK);
  }

  /* Only ON-HOOK is expected */

  /* No change in state */
  RETVALUE(ROK);
} /* end ccConE03S55 */

/*
 *
 *      Fun:   ccConE03S59
 *
 *      Desc:  Connection state function
 *             event - CnStInd
 *             state - CCS_AWTRELCFM_KEEP_CON
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S59
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CCDP(AIN_DBG_LEVEL_1, "ccConE03S59: %ld\n", con->icSuConnId);
  if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}
/*
*
*      Fun:   ccConE03S72
*
*      Desc:  Connection state function
*             event - CnStInd
*             state - CCS_AWT_PERMSIG_TREATMENT_CFM
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE03S72
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                ret                   = RFAILED;
  ProtType           icProtType            = CC_GET_PROTOCOL(con->icProtType);

  CCDP(AIN_DBG_LEVEL_1, "ccConE03S72: 0x%lx\n", con->icSuConnId);

  if (con->direction != INCTOOUT)
  {
    CCLOGERR("Error: Invalid direction %d, icSu = 0x%ld\n", con->direction,
             con->icSuConnId);
    RETVALUE(ROK);
  }
  else if(con->icEvntType == CS_CONN_STATUS_PERM_SIG_TREATMENT)
  {
    ccPlayInternalAnnoucement(con);
    RETVALUE(ROK);
  }
  else if(ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
         con->direction))
  {
    ret = ccProcessDisconnectEvent(con, event);
    if (con->surrogate != NULLP)
       ccProcessDisconnectNotfnForSurrogateLegs(con, event);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
      RETVALUE(ROK);
    }
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
    }
    CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

    ccStopConTmr(con, TMR_SETUP);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    if (icProtType != CC_LOCAL_SWT_PROT)
    {
      ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
      if (ret != ROK)
      {
        CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
      }
    }
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
    RETVALUE(ROK);
  }
  else if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                                con->direction))
  {
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
  else if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
  {
    if (con->icBcm.cc)
    {
      if (con->icBcm.cc->ccId < CiThreePartySetup)
      {
        CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
        RETVALUE(ROK);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_0, "Ignoring the hook Flash, it may be armed\n");
      RETVALUE(ROK);
    }   
    con->lastState = con->state;
    ret = ccProcessMidCallEvent(con);
    if (ret == ROK)
    {
      CCDP(AIN_DBG_LEVEL_0,"ccProcessMidCallEvent success, event detected:%ld\n",
                            con->icSuConnId);
      RETVALUE(ROK);
    }   
    else if (ret == RFAILED)
    {
      CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed:%ld\n",
                             con->icSuConnId);
    }
    CCDP(AIN_DBG_LEVEL_0, "Hook Flash event is not armed:%ld\n",con->icSuConnId);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Error: Invalid evntType %d, icSu = 0x%ld\n", con->icEvntType,
             con->icSuConnId);
    RETVALUE(ROK);
  }
}


/*
*
*      Fun:   ccConE03S64
*
*      Desc:  Connection state function
*             event - CnStInd
*             state - CCS_AWTRSPFAILOUT
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE03S64
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_BUFFER_EVENT
  CCDP(AIN_DBG_LEVEL_1, "ccConE03S64: %ld\n", con->icSuConnId);
  if (con->icEvntType == CS_CONN_STATUS_FORCED_ON_HOOK)
  {
    /* Remove this Code after FSM buffering works */
    CCDP(AIN_DBG_LEVEL_0, "IOM failover has occured:%ld\n", con->icSuConnId);

    ccUpdateCallDtlInfoRelOrignForOnHook(con->icProtType,con->ogProtType,con, con->direction, con->icEvntType);
    cleanUpMgQ(con);
    ccCleanUpMGCtx (con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }

  ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
#endif /* CC_BUFFER_EVENT */
}


/*
 *
 *      Fun:   ccConE04S59
 *
 *      Desc:  Connection state function
 *             event - Release Indication.
 *             state - CCS_AWTRELCFM_KEEP_CON
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *                                      
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S59
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S59: %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE04S63
*
*      Desc:  Connection state function
*             event - Release Indication.
*             state - CCS_AWTSWTCFMFORCC6CC10
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S63
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S63: %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE04S69
*
*      Desc:  Connection state function
*             event - Release Indication.
*             state - CCS_AWTSWTCFMFORMERGEINCC4
*
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE04S69
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S69: %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S70
 *
 *      Desc:  Connection state function
 *             event - Release Indication.
 *             state - CCS_AWTSWTCFM_MERGEINCC6IC
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S70
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S70: %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S71
 *
 *      Desc:  Connection state function
 *             event - Release Indication.
 *             state - CCS_AWTSWTCFM_MERGEINCC6OG
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S71
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S71: %ld\n", con->icSuConnId);
  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S64
 *
 *      Desc:  Connection state function
 *             event - Release Indication.
 *             state - CCS_AWTRSPFAILOUT
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S64
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE04S64: %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                       NULLP, 0);
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE04S52
 *
 *      Desc:  Connection state function
 *             event -Release indication - 04
 *             state - AWT_RESUME
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S52
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
  /* Received RelInd: Start releasing the call */
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  S16 ret;

  /* Bug 27093: stop suspend timer here */
  ccStopConTmr(con, CC_TMR_SUSP);

  ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
  if (con->surrogate != NULLP)
     ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
    RETVALUE(ROK);
  }
  else if (ret == RFAILED)
  {
    CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
  }
  /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
  CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

#ifdef CC_CALEA
  if (icProtType != CC_LOCAL_SWT_PROT)
  {
     /* Make sure ur in Tapped Con */
     ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
     if (ret != ROK)
     { 
        CCDP(AIN_DBG_LEVEL_4,
           "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
     }
  }
#endif 

  /* We got the ON_HOOK/RelInd during a suspend, release the call */

  /* stop all related timers */
  ccStopConTmr(con, CC_TMR_SUSP);

  ccStopConTmr(con, CC_TMR_CALLDTL);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  /* copy release to evntHold;E11S5X needs this event to send out RelReq/Rsp*/
      
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
      CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
  }
      
#ifdef ZC
  /* REL CON */
  upd.icSuConnId = con->icSuConnId;
  zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
  zcUpdPeer();
#endif

  /* Initiate De-switching */
  if (CC_IS_CONTEXT_PRESENT(con))
  {
     /* Blow off the switching and Release the Call */
     ccQSubBasedOnCcn(con);  /* FID 15261.0 */

     if (ret == ROK)
     {
       con->lastState = con->state;
       if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
       {  
          CCLOGERR( "ERROR: failed to store release event\n");
       }

       if(con->direction == INCTOOUT)
         con->relPend = INRELRSPANDOUTREL;
       else
         con->relPend = OUTRELRSPANDINREL;

       CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
       con->mgBlock->con = con;
       ret = ccSendMgiQueue(0, con->mgBlock);
     }
     if (ret != ROK)
     {
       cleanUpMgQ(con);
       CCLOGERR( "ERROR occured \n");
     }
     else
       RETVALUE(ROK);
  }
  else
  {
#ifdef CALEA_3WC
      if (con->icProtType == CC_LOCAL_SWT_PROT)
      {
         if (con->icBcm.cc != NULLP)
         {
            if (con->icBcm.cc->tappedLegId != NULLP)
            {
               CCDP(AIN_DBG_LEVEL_0,"Deswitching of CALEA  in Tapped con\n");
               ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, event,
                                          CCE_RELIND, sizeof(CcRelEvnt));
               RETVALUE(ROK);
            }
            else
               CCLOGERR( "ERROR: con->icBcm.cc->tappedLegId is NULLP\n");
         }
         else
            CCLOGERR( "ERROR: con->icBcm.cc is NULLP \n");

      }
      else
#endif
         CCLOGERR( "ERROR: No Switching Context Found\n");
  }

  if (con->direction == INCTOOUT)
  {
    /* Deallocate the IC Resources */
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_INCOMING);
#else
    ccDeallocateResource(con, CC_INCOMING);
#endif
    con->icRscVal = FALSE;

    ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                  con->ogSuConnId, con->ogProtType,
                  CCCALLCLR, NULL);
  }
  else if (con->direction == OUTTOINC)
  {
    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
    ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
    ccDeallocateResource(con, CC_OUTGOING);
#endif
    con->ogRscVal = FALSE;

    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
  }

  if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

  RETVALUE(ROK);
} /* end ccConE04S52 */


/*
 *
 *      Fun:   ccConE04S54
 *
 *      Desc:  Connection state function
 *             event -Release indication - 04
 *             state - CCS_AWTSWTCFM_SENDBOTHREL
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S54
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;  /*Bug 76817*/
#if 0 /*bug 33928:taraveti */
  if(con->relPend != BOTHREL)
  {
    CCLOGERR(
        "ccConE04S54(): unExpected evnt in state = %d, ProtocolType = %d/%d,\
        direction = %d\n", con->state, con->icProtType,
        con->ogProtType, con->direction);
    RETVALUE(ROK);
  }
#endif

  if(con->direction == INCTOOUT)
  {
    con->relPend = INRELRSPANDOUTREL;
  }
  else
  {
    con->relPend = OUTRELRSPANDINREL;
  }
  /* Change the state */
  CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
  /*Bug 76817: store the incoming Release event,it will be used in ccConE11S55*/
  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
  {
     CCLOGERR( "ERROR: failed to store release event\n");
  }

  RETVALUE(ROK);
} /* end ccConE04S54 */


/*
 *
 *      Fun:   ccConE04S55
 *
 *      Desc:  Connection state function
 *             event -Release indication - 04
 *             state - CCS_AWTSWTCFM_SENDONEREL
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S55
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  CcConEvnt       ogEvnt;

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

  if(con->direction == INCTOOUT)
  {
    switch(con->relPend)
    {
      case ICRELONLY:
        con->relPend = INRELRSPANDNOREL;
        if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

      case OUTRELRSPANDINREL:
      case OUTRELRSPANDINTONE: /* Bug# 38132 */
        con->relPend = INRELRSPANDOUTRELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

      case OGRELONLY:
        DP("ccConE04S65:%ld,%ld\n", con->icSuConnId, con->ogSuConnId);
        ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,
                             NULLP, 0);
        break;

      case OUTRELANDINFAILCOND :
      case OUTRELANDSCRINFAILCOND :
      case OUTRELANDANSINFAILCOND :
        con->relPend = INRELRSPANDOUTREL;
        if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {  
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        break;

      case OUTRELRSPANDINFAILCOND :
      case OUTRELRSPANDSCRINFAILCOND :
      case OUTRELRSPANDANSINFAILCOND :
        con->relPend = INRELRSPANDOUTRELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {  
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        break;

      default:
        CCLOGERR("ERROR:Unexpected relPend==%d in ccConE04S55\n",
                 con->relPend);
        break;
    }
  }
  else /* OUTTOINC */
  {
    switch(con->relPend)
    {
      case OGRELONLY:
        con->relPend = OUTRELRSPANDNOREL;
        if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

      case INRELRSPANDOUTREL:
        con->relPend = INRELRSPANDOUTRELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;

      case OUTRELANDINFAILCOND :
        con->relPend = OUTRELRSPANDINFAILCOND;
        if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {  
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        break;
      case OUTRELANDSCRINFAILCOND :
        con->relPend = OUTRELRSPANDSCRINFAILCOND;
        if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        break;
      case OUTRELANDANSINFAILCOND :
        con->relPend = OUTRELRSPANDANSINFAILCOND;
        if((ret = ccStoreEvnt(con->evntType, con->icEvntType, con,
                (U8 *)event, sizeof(CcRelEvnt))) != ROK)
        {
          CCLOGERR( "ERROR: failed to store release event\n");
        }
        break;
      /* FID 16706 + */
      case INRELRSPDELAYANDOUTREL:
        CCDP(AIN_DBG_LEVEL_2, "%s(): relPend==INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);
        con->icEvnt = (CcAllSdus *) event;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        ret = ccMapEvent(con, CCE_RELCFM, 0);
        if (ret != ROK)
        {
          con->direction = INCTOOUT; 
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          con->direction = OUTTOINC;
        }
        else
        {
          ccSendReleaseRspReq(con);
        }

#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_INCOMING);
#else
        ccDeallocateResource(con, CC_INCOMING);
#endif
        con->icRscVal = FALSE;

        con->relPend = OUTRELRSPANDNOREL;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
        break;
        
      /* FID 16706 - */
      default:
        CCLOGERR( "ERROR:Unexpected relPend in ccConE04S55\n");
        break;
    }
  }

  /* bug:24909 : to release the call by fore! */
  if((con->mntRelProc == CC_REL_FORCE_LOC) || (con->mntRelProc == CC_REL_FORCE_REM))
  {
    S16 oldValue = 0;
    con->mntRelProc = 0;
    CCLOGERR(" *** Call is being terminated by force on req from Layer-3"
        ": icSu:%lx, ogSuc:%lx, relPend:%d, icPro:%d, ogPro:%d *****\n",
        con->icSuConnId, con->ogSuConnId, con->relPend, con->icProtType,
        con->ogProtType);
    /* plan: stop and start RELEASE timer to kick off release procedure
     * This should handle all cases of relPend in any state (55 or 56) */
    ccStopConTmr(con, TMR_RELEASE);
    oldValue = ccCp.genCfg.tmr.tRLS.val;
    ccCp.genCfg.tmr.tRLS.val = 1; /* force it to expire soon */
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
    ccCp.genCfg.tmr.tRLS.val = oldValue; /* force it to oldValue */
  }
  /* end of bug:24909 */
  RETVALUE(ROK);
} /* end ccConE04S55 */

#if 0
/* This Function has need moved to cc_bdy2_2.c
 * Keeping this function, as we need to populate the functionality of
 * Tone Detection and SIP DTMF detection into the MGCT Framework */

/*
 *      Fun:   ccConE62S10
 *
 *      Desc:  Connection state function
 *             event - MGI Event NOTIFY
 *             state - ANSWERED
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE62S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0 /* CC_MGC */
  MgitInd        *mgitInd     = NULLP;
  SipCnStEvnt sipCnStEvnt;
  AinBCM_t 	*pBcm;

  TRC3(ccConE62S10)
  CCDP(AIN_DBG_LEVEL_1, "ccConE62S10:%ld,%ld,%ld\n", con->icSuConnId,
                         con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);

  mgitInd     = (MgitInd *) event;

  if (!mgitInd)
  {
      CCLOGERR("Error: mgitInd is null! icSuConnId = %ld, ogSuConnId =%ld\n",
               con->icSuConnId, con->ogSuConnId);
      RETVALUE(RFAILED);
  }
  
  /* Verify the type */
  if (mgitInd->type != MGIT_EVENT_IND)
  {
      DP("ccConE62S10: Type is NOT MGIT_EVENT_IND! .\n");
      RETVALUE(RFAILED);
  } 

  switch (mgitInd->u.event.type)
  {
      /* CPDI */
  case MGIT_EVENT_DTMF_DETECT:
    {
      AinBCM_t          *pBcm;
      
      CCDP(AIN_DBG_LEVEL_1, "Event_dtmf_detect.\n");
      /* continue only when ODTMFEntered is armed */
      pBcm = &con->icBcm;
      if ((pBcm->nel[EReqODTMFEntered] == NEL_NOTIFY) ||
          (pBcm->nel[EReqODTMFEntered] == NEL_REQUEST))
      {
          TknStr64 *addrSig = &mgitInd->u.event.u.digits.addrSig;
          U8 len;

          /* CPDI_FIX: we need relinguish old rel event in the buffer */
          /* logic: whenever ccRelEvntHold != NULL, ccEvntHold isn't CCE_RELIND */ 
          CC_FREE_REL_EVNT_HOLD(con);
          
          /* collect the DTMF detection */
          if (!addrSig->pres)
          {
              CCLOGERR("Error: conflict on setting of DTMF detection, icSuConnId = %ld,"
                       "ogSuConnId =%ld, addrSig->pres = %d\n",
                       con->icSuConnId, con->ogSuConnId,  addrSig->pres);
              RETVALUE(RFAILED);
          }
          con->ainInfo.DTMFDigDet.pres = TRUE;

#if 0 /* MCAO-08/28/03: hardcde addrSig */
          len = 2;
          con->ainInfo.DTMFDigDet.len = len;
          strcpy(con->ainInfo.DTMFDigDet.val, "12");
#else /* shall be recovered when CCRM fix the problem */

          len = (addrSig->len <= sizeof(con->ainInfo.DTMFDigDet.val)) ? \
	          (addrSig->len) : sizeof(con->ainInfo.DTMFDigDet.val);

          con->ainInfo.DTMFDigDet.len = len;
          cmMemcpy((U8*)(con->ainInfo.DTMFDigDet.val), (U8 *)(addrSig->val), len);
          con->ainInfo.DTMFDigDet.val[sizeof(con->ainInfo.DTMFDigDet.val) -1] = '\0';
#endif	    
          CCDP(AIN_DBG_LEVEL_1, "ccConE62S10: icSu:%ld, len = %d, val =%s \n", 
               con->icSuConnId, len, con->ainInfo.DTMFDigDet.val);


          /* send ODTMF_Entered to FIC */
          ccProcessODTMFEntered(pBcm);
      }
      RETVALUE(ROK);
      break;
  }/* DTMF_DETECT */

/***************
 *
 *	This case is to handle T.38 event notify from the Mgi.  We assume the
 * 	following:  This is a 2-party call, one side is TDM, the other is IP
 */
  case MGIT_EVENT_FAX_DETECT:
  {

      CCDP(AIN_DBG_LEVEL_1, "Event_fax_detect.\n");
	
      /* don't do anything if we're not talking to an IP protocol */
      if ( (ccIsIPResource(&(con->icBcm))) ||
	   (ccIsIPResource(&(con->ogBcm))) )
      {
	  CCDP(AIN_DBG_LEVEL_4, "FAX Notify.\n");
	  con->t38Prsnt = TRY_T38_AND_G711;
	  if (ccIsIPResource(&(con->icBcm) ) )
	  {
	      pBcm = &(con->icBcm);
    }
	  else 
	  {
	      pBcm = &(con->ogBcm);
	  }

	     /* 
	      *  Call Gopalas' sub-state machine to deal with 
	      *	 doing the sub/add/xfer and dealing with the
	      *	 errors.  if we get an error on request for T.38 
	      *	 then retry with G.711
	      */

	  ccCreateOnSwitchBearer(pBcm, NULLP, ccHandleXferRspFailure, (PTR)con, CCS_ANSWERED, FALSE);

      } /* if protType == IP */
      else
      {
	  CCDP(AIN_DBG_LEVEL_1, "MGIT_EVENT_FAX_DETECT, but neither side is IP!, ignoring! \n");
      }
      RETVALUE(ROK);
      break;

  } /* FAX DETECT */

/**************/
  case MGIT_EVENT_MODEM_DETECT:
  {
      /* don't do anything if we're not talking to an IP protocol */
      CCDP(AIN_DBG_LEVEL_1, "EVENT_MODEM_DETECT.\n");
	
	   /* don't do anything if we're not talking to an IP protocol */
      if ( (ccIsIPResource(&(con->icBcm))) ||
	   (ccIsIPResource(&(con->ogBcm))) )
      {
	  CCDP(AIN_DBG_LEVEL_4, "Modem Notify..\n");
	  con->t38Prsnt = TRY_G711;
	  if (ccIsIPResource(&(con->icBcm) ) )
	  {
	      pBcm = &(con->icBcm);
	  }
	  else 
	  {
	      pBcm = &(con->ogBcm);
	  }

	     /* 
	      *  Call Gopalas' sub-state machine to deal with 
	      *	 doing the sub/add/xfer and dealing with the
	      *	 errors.  if we get an error on request for G.711
	      *	 then we're hosed, just wait for call to hangup
	      */

	  ccCreateOnSwitchBearer(pBcm, NULLP, ccHandleXferRspFailure, (PTR)con, CCS_ANSWERED, FALSE);

      }
      else
      {
	  CCDP(AIN_DBG_LEVEL_1, "MGIT_EVENT_MODEM_DETECT, but neither side is IP!, ignoring! \n");
      }

      RETVALUE(ROK);
      break;

  } /* MODEM DETECT */

/**************/
/* this is a special case of the T.38 handling. This occurs when we've completed the T.38
* or we've exhausted our attempts to come up with a suitable codec for faxing..
*/
  case MGIT_EVENT_EOFAX_DETECT:
  {
      /* don't do anything if we're not talking to an IP protocol */
      CCDP(AIN_DBG_LEVEL_1, "EVENT_EOFAX_DETECT.\n");
	
	   /* don't do anything if we're not talking to an IP protocol */
      if ( (ccIsIPResource(&(con->icBcm))) ||
	   (ccIsIPResource(&(con->ogBcm))) )
      {
	  CCDP(AIN_DBG_LEVEL_4, "END OF FAX Notify..\n");
	  con->t38Prsnt = NO_T38;
	  if (ccIsIPResource(&(con->icBcm) ) )
	  {
	      pBcm = &(con->icBcm);
	  }
	  else 
	  {
	      pBcm = &(con->ogBcm);
	  }

	     /* 
	      *  Call Gopalas' sub-state machine to deal with 
	      *	 doing the sub/add/xfer and dealing with the
	      *	 errors.  if we get an error on this request
	      *	 then we're hosed, just wait for call to hangup
	      */

	  ccCreateOnSwitchBearer(pBcm, NULLP, NULLP, NULLP, CCS_ANSWERED, FALSE);

      }
      else
      {
	  CCDP(AIN_DBG_LEVEL_1, "MGIT_EVENT_EOFAX_DETECT, but neither side is IP!, ignoring! \n");
      }

      RETVALUE(ROK);
      break;

  } /* END-OF-FAX DETECT */

/************/
  case MGIT_EVENT_TONE_DETECT:
    {
      INITEVENT((U8 *)&sipCnStEvnt, sizeof(SipCnStEvnt));

      /* Send the connect request to sip indicating that we got the # key */
      ccPrepareSipCnStReqAndSend(con, CCSIP_ET_SIP_INFO_DTMF_DIGITS, con->direction, &sipCnStEvnt);
      
      RETVALUE(ROK);
      break;
  } /* MGIT_EVENT_TONE_DETECT */
/************/
  default:
    {
      DP("ccConE62S10: Unrecognized event.type %d .\n", mgitInd->u.event.type);
      RETVALUE(RFAILED);

  } /* default: */

  } /* switch */
#endif /* 0 */
  RETVALUE(ROK);
} /* E62S10 */
#endif /* 0 */



/*
*
*      Fun:   ccConCleanUp
*
*      Desc:  Connection state function
*             event - ************
*             state - CCS_***_TOCLR
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConCleanUp
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16             ret           = RFAILED;
  CCDP(AIN_DBG_LEVEL_1, "ccConCleanUp\n");

  if(con->relPend == ICRELONLY)  /* We have Come here because of Status Ind. */
  {
    if (con->ogRscVal)
    {
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
    }

    CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCTMPFAIL, NULL);
    RETVALUE(ROK);
  }
  else   /* We have come here because of a Release Indication */
  {
    con->direction = INCTOOUT;
    con->icEvnt = (CcAllSdus *) con->ccEvntHold;
    if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
 
    if(con->ogRscVal)
    ccDeallocateResource(con, CC_OUTGOING);

    /* Send Resource Dealocation for incoming interface if allocated */
    CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
    ret = ccDeallocateResource(con, CC_INCOMING);
    if (ret == RFAILED)
    { 
       /* error */
       CC_STATE_CHANGE(con, CCS_IDLE);
       ccRelCon(con);
    }
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE47S47
*
*      Desc:  Connection state function
*             event - Send to Resource
*             state - CCS_AWTRSPFORDPEXY_TOCLR
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE47S47
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   SvcHeader_t     header;
   ResourceClear_t resourceClear;
   U8              index           =    0;
   S16             tmpret          =    RFAILED;
   ProtType        icProtType      =    CC_GET_PROTOCOL(con->icProtType);
#ifdef CC_CALEA
   S16 ret = ROK; 
#endif
   msgValCcIDEnum  temp_ccId       = CiInvalid;

#if 1 /* Bug#: 17932 */
   ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */

   TRC3(ccConE47S47)
   if (!con->ainInfo.disconnectLegFlag) 
   {
      /* Send a Resource_Clear FIC message with ClearCause = UsrAbandon */ 
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&resourceClear, 0, sizeof(ResourceClear_t));

      if (con->icBcm.cc)
         temp_ccId = con->icBcm.cc->ccId;
      else
         temp_ccId = CiOriginatingSetup;

      /* Update icBcm parameters */
      ccUpdateBcm(con, PicAnalyzeInformation, temp_ccId, BtOBcm);

      /* Fill ClearCause with ClcUserAbandon */
      con->ainInfo.ClearCause = ClcUserAbandon;

      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
         con->icBcm.nel[index] = NEL_UNARMED;
      }
      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, &(con->icBcm), MSG_Resource_Clear);
      CCDP(AIN_DBG_LEVEL_2," Filled SvcHeader\n");

      /* Fill in parameters in the Resource Clear structure */ 
      ccFillResourceClearParam(&resourceClear, &(con->icBcm));
      CCDP(AIN_DBG_LEVEL_2," Filled ResourceClear\n"); 
     
      /* Send the ResourceClear message to the FIC */ 
      CCDP(AIN_DBG_LEVEL_3,"Sending ResourceClear, TransID=%ld\n",
            header.spTransId);
      CcUiFctResourceClear(&resourceClear, &header);
   }
   switch (con->relPend)
   {
      case ICRELONLY:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
#ifdef CC_CALEA
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
            /* Make sure ur in Tapped Con */
            ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
            if (ret != ROK)
            {
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
            }                    
         }  
#endif
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
         break;

      case OUTRELRSPANDNOREL:
         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
         con->direction = INCTOOUT;
         if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

         CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
         ccDeallocateResource(con, CC_INCOMING);
         RETVALUE(ROK);
         break;

      default:
         CCDP(AIN_DBG_LEVEL_2,"ccConE47S47: Unexpected con->relPend=%d\n",
              con->relPend);

         if(con->ogRscVal == TRUE)
         {
           ccDeallocateResource(con, CC_OUTGOING);
           con->ogRscVal = FALSE;
         }
#if 1
         ccPlayToneOrRelease(con, CCTMPFAIL);
#else /* 1 */
         con->direction = INCTOOUT;
         tmpret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (tmpret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisc success,event detec.: %ld\n",
                                con->icSuConnId);
           RETVALUE(ROK);
         }
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                       con->icProtType, CCTMPFAIL, NULL);
#endif /* 1 */
         break;
   }
   RETVALUE(ROK);
} /* End of ccConE47S47 */ 


/*
 *
 *      Fun:   ccConE11S54
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm
 *             state - CCS_AWTSWTCFM_SENDBOTHREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S54
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16             ret          = RFAILED;
   S16             tmdRel       = 0;
   MgctTxnCfm     *txnCfm       = NULLP;
   CcRelEvnt       relEvnt;
   TknU16          sipCause;
   TknU16          sipStatus;
   U8              cause4Isdn   = con->tempHolderForReleaseCause;

   INITEVENT(&relEvnt, sizeof(CcRelEvnt));

   txnCfm   = (MgctTxnCfm*) event;

   ret = ccHandleMgResponse(con, txnCfm);

   /* FID 15261.0 + */
   if (CC_IS_CALL_MULTI_MG(con))
   {
     if (con->ccmCb.mgPend)
       con->ccmCb.mgPend--;

     if (ret != ROK)
     {
       con->ccmCb.flags |= CC_MG_SUB_ERROR;
     }

     if (con->ccmCb.mgPend)
     {
       RETVALUE(ROK);
     }
   }
   /* FID 15261.0 - */

   if ((ret != ROK) || (con->ccmCb.flags & CC_MG_SUB_ERROR))
   {
      if (con->mgBlock == NULLP)
      {
        CCLOGERR( "ERROR:Handling the Sub Req,anyway Release Call\n");
      }
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
   }

   tmdRel = ccIsTmdRelRequired(con);
   con->lastState = con->state;
   switch(tmdRel)
   { 
     case CC_IC_TMD_RELEASE:
       ccApplyTmdRelease(con, &con->icRsc);
       con->tmdRelApplied = CC_IC_TMD_RELEASE;
       CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

       if(con->ogRscVal == TRUE)
         ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
             con->ogProtType, con->tempHolderForReleaseCause, NULL);
       break;

     case CC_OG_TMD_RELEASE:
       ccApplyTmdRelease(con, &con->ogRsc);
       con->tmdRelApplied = CC_OG_TMD_RELEASE;
       CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

       if(con->icRscVal == TRUE)
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
             con->icProtType, con->tempHolderForReleaseCause, NULL);
       break;

       default :
       {
         if (con->ogRscVal == TRUE)
         {
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
         }
         else
         {
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
         }
         if (con->evntHeld == CCE_INITRELIND)
         {
            ccProcRelCall(con, (CcStaEvnt *)con->ccEvntHold);
            RETVALUE(ROK);
         }
         /* FID 16367.0 + */
         else if ((con->evntHeld == CCE_CNSTIND) && 
                  ((con->evntTypeHeld == CCIN_ET_FACIL) ||
                   (con->evntTypeHeld == CC_ET_FAC && CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_IN)))
         {
            ccStopAllCCTimers(con);
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

            con->icEvnt = (CcAllSdus *) con->ccEvntHold;
            con->ogEvnt = (CcAllSdus *) &relEvnt;

            con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
            con->icEvntType = con->evntTypeHeld;
            ret = ccMapEvent(con, CCE_CNSTIND, con->evntTypeHeld);
            if (ret != ROK)                                                       
            {                                                                     
                CCLOGERR("Error: ccMapEvent failed: icProtType:%d, ogProtType:%d,"
                         " icSu:0x%lx, ogSu:0x%lx\n", con->icProtType,            
                         con->ogProtType, con->icSuConnId, con->ogSuConnId);      

                ccSendRelease(con, con->ogSapCb, con->ogSpConnId,                 
                              con->ogSuConnId, con->ogProtType,                   
                              CCSERVUNAVAIL, NULL);
                ccSendRelease(con, con->icSapCb, con->icSpConnId,                 
                              con->icSuConnId, con->icProtType,                   
                              CCSERVUNAVAIL, NULL);
                RETVALUE(ROK);                                                    
            }                                                                     

            CcLiCctRelReq(&con->icSapCb->pst, con->icSapCb->spId,
                          con->icSpConnId, con->icSuConnId, con->icProtType,
                          (CcRelEvnt *)con->ogEvnt, con->uBuf);
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId,                 
                          con->ogSuConnId, con->ogProtType,                   
                          con->tempHolderForReleaseCause, NULL);

            if (con->callRrtInfo)
            {
                SPutSBuf(ccInit.region, ccInit.pool, con->callRrtInfo, (Size) sizeof(CallRrtInfo));
                con->callRrtInfo = NULL;
            }
                                                                              
            RETVALUE(ROK);                                                    
         }
         /* FID 16367.0 - */

         /*
          * Bug 64217, Table 23/Q.699, T6 expiry, REL(cause value No.102,recovery on
          * timer expiry), DISCONNECT(cause value No.16, normal call clearing)
          */
         CCDP(AIN_DBG_LEVEL_0,"%s:tempHolderForReleaseCause=%d\n", __FUNCTION__,
              con->tempHolderForReleaseCause);
         /*
          * Bug 86292, if icProtType is ISDN except CC_INETSI, T6 expiry, REL(cause value
          * No.102, recovery on time expiry), DISCONNECT(cause value No.19, no answer(user
          * alerted))
          */
         if ((CC_GET_PROTOCOL(con->icProtType) == CC_IN) && 
             (con->tempHolderForReleaseCause == CCTIMERECOVR))
         {
             if ((con->icProtType == CC_INETSI) && (con->isACMSent))
             {
                 cause4Isdn = CCCALLCLR;
             }
             else if (con->isACMSent)
             {
                 cause4Isdn = CCNOANSWR;
             }
             else
             {
                 cause4Isdn = CCNOUSRRSP;
             }

             ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                           con->icProtType, cause4Isdn, NULL);

             /* Bug79409 set Billing relCause when T6 expires */
             ccPrepareINRel(con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, cause4Isdn, &relEvnt,NULL);
             ccGetRelCause(con, con->icProtType,
                           &relEvnt,
                           &con->callDtlInfo.cm.relCause,
                           &sipCause,
                           &sipStatus);
             CCDP(AIN_DBG_LEVEL_0, "T6 expires, Billing relCause = %d\n",
                   con->callDtlInfo.cm.relCause.causeVal.val);
         }
         else
         {
             ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                 con->icProtType,con->tempHolderForReleaseCause, NULL);
         }
         if(con->ogRscVal == TRUE)
         {
	    /*BUG:47216*/
            if( (con->icProtType == CC_INETSI) &&
            (con->isACMSent) &&
            (con->tempHolderForReleaseCause == CCNOANSWR) )
            {
            	ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                            con->ogProtType, CCTIMERECOVR, NULL);
            }
            /* Bug 86292 ++ */
            else if((CC_GET_PROTOCOL(con->ogProtType) == CC_IN) &&
                    (con->tempHolderForReleaseCause == CCTIMERECOVR))
            {
                if ((con->ogProtType == CC_INETSI) && (con->isACMSent))
                {
                    cause4Isdn = CCCALLCLR;
                }
                else if (con->isACMSent)
                {
                    cause4Isdn = CCNOANSWR;
                }
                else
                {
                    cause4Isdn = CCNOUSRRSP;
                }
            
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                		      con->ogProtType, cause4Isdn, NULL);
            }
            /* Bug 86292 -- */
            else
	    	{
                ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                		con->ogProtType, con->tempHolderForReleaseCause, NULL);
	    	}
	    /*End of BUG:47216*/
         }

       }
       break;
   }

   RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE11S55
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm
 *             state - CCS_AWTSWTCFM_SENDONEREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S55
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16             ret           = RFAILED;
    S16             relDisBool    = RFAILED;
    U8              evntType      = 0;
    U8              procDelayRel  = 0;
    MgctTxnCfm     *txnCfm        = NULLP;
    CcConEvnt       ogEvnt;
    ProtType        icProtType    = 0;
    ProtType        ogProtType    = 0;
    TknU16          sipCause;
    TknU16          sipStatus;

    txnCfm   = (MgctTxnCfm*) event;

    /* bug 91532 */
    cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

    /* 27133 */
    ccRestoreReleaseInEvntHold (con);

    ret = ccHandleMgResponse(con, txnCfm);
    /* FID 15261.0 + */
    if (CC_IS_CALL_MULTI_MG(con))
    {
       if (con->ccmCb.mgPend)
         con->ccmCb.mgPend--;

       if (ret != ROK)
       {
         con->ccmCb.flags |= CC_MG_SUB_ERROR;
       }

       if (con->ccmCb.mgPend)
       {
         RETVALUE(ROK);
       }
     }
    /* FID 15261.0 - */

    if ((ret != ROK) || (con->ccmCb.flags & CC_MG_SUB_ERROR))
    {
        cleanUpMgQ(con);
        ccCleanUpMGCtx(con);
    }
#if 1
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif
#ifdef CALEA_3WC
    if (con->mgiPendRelRsp)
    {
        CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S20\n");
        ccProcessCaleaMgiSubRsp(con, FALSE);
        con->mgiPendRelRsp = 0;
    }  
#endif

    con->icEvnt = con->ccEvntHold;
    con->ogEvnt = (CcAllSdus *) &ogEvnt;

    switch(con->relPend)
    {
    case ICRELONLY:
    {
        /* This is a case of tones */
        if(con->ogRscVal == TRUE)
            ccDeallocateResource(con, CC_OUTGOING);
        con->ogRscVal = FALSE;

        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

#if 1 /*GCC_ANNOUNCEMENT*/
        if (con->mgPlayingTone && (con->mgToneType == MGCT_SIG_ID_CG_WT) && ((con->icProtType == CC_CS_LN)||(con->icProtType == CC_GR303)))
        {
            CCDP(AIN_DBG_LEVEL_2,"ccConE11S55 Sending PERM_SIG_0_ADDR RelReq to CAS\n");
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CS_RELREQ_EVENT_PERM_SIG_0_ADDR, NULL);
            RETVALUE(RFAILED);
        }
#endif /*GCC_ANNOUNCEMENT*/

        /* bug 57719 */
        if ((CC_INGRESS_INTER_CCS_CALL(con)) && (con->failCndVal != FC_NOT_APPLICABLE ) )
        {
            ccStopConTmr(con, TMR_SETUP); 
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
            con->direction = OUTTOINC;
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            ccBuildInterCcsReleaseForFailCnd(con, con->failCndVal, (PTR) con->ogEvnt);
            ccSendReleaseReq(con);
            RETVALUE(ROK);
        }

        if ((con->icProtType == CC_GR303) ||
            (con->icProtType == CC_CS_LN) ||
            (con->icProtType == CC_CS_TG))
        { 
            CCDP(AIN_DBG_LEVEL_2,"GR303/CAS: ccConE11S55 Sending CC_RELREQ_EVENT_NORMAL RelReq to CAS was relcause: %d\n", con->tempHolderForReleaseCause);

            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CS_RELREQ_EVENT_NORMAL, NULL);
        }
        else
        {
            /* FID 16204.1 */
            if((con->uusInfo.eh.pres == PRSNT_NODEF) &&
               (con->uusInfo.discReq == TRUE))
            {
                ccSendRelease(con, con->icSapCb, con->icSpConnId,
                        con->icSuConnId, con->icProtType, CCFACNOTIMP, NULL);
            }
            else
            {   
                /*Bug:50893*/
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, con->tempHolderForReleaseCause,
                        ((con->tempHolderForReleaseDiag.pres)?(&(con->tempHolderForReleaseDiag)):NULL));
            }
        }
        RETVALUE(ROK);
    }
    break;

    case OGRELONLY :
    {
#if 1 /* there may be a  CPDI case, just whether to release IC in timer control */     
      S16 tmdRel = CC_NO_TMD_RELEASE_REQUIRED;
      
      tmdRel = ccIsTmdRelRequired(con);
      switch(tmdRel)
    { 
    case CC_IC_TMD_RELEASE_CPDI:

      /* release OG */
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
      if(con->ogRscVal == TRUE)
            ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
      
      ccStopConTmr(con, TMR_SETUP); /* Just in case */
      ccStartConTmr(CC_TMR_TMDREL, con, (PTR)&ccCp.genCfg);  

      CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);
      RETVALUE(ROK);
    default :
      break;
    }
#endif
      
        relDisBool = ccCheckRelOrOnHookInBuffer(&(con->icBcm), &evntType);
        if ((ccCheckEventInBuffer(&(con->ogBcm), CCE_CONCFM)) ||
            (relDisBool == ROK))
        {
          /* Drop the Forward Call Response and process the Connect Confirm */
          DP("Drop the Forw call procs and procs the ConCfm/Rel message:"
             " icSu = 0x%lx, ogTransId = 0x%lx\n", con->icSuConnId,
             con->ogBcm.svcHeader.transId);
          CC_STATE_CHANGE(con, CCS_AWTANS);
          RETVALUE(ROK);
        }

        /* This is a case of CFDA */
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, con->tempHolderForReleaseCause, NULL);
        RETVALUE(ROK);
    }
    break;

    case INRELRSPANDOUTREL:
    {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_INCOMING);
#else
        ccDeallocateResource(con, CC_INCOMING);
#endif
        con->icRscVal = FALSE;

        con->icEvnt = (CcAllSdus *) con->ccEvntHold;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        con->direction = INCTOOUT;
        
        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

        ret = ccMapEvent(con, CCE_RELIND, 0);
        if (ret != ROK)
        { 
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, con->tempHolderForReleaseCause,NULL);
            RETVALUE(ROK);
        }
        /* For Spain, the process is valid only if the ANS was received */
        if ((CC_IS_PROT_TYPE_SPAIN(con->ogProtType) ||
             CC_IS_PROT_TYPE_SPAIN(con->icProtType)))
        {
            procDelayRel = (con->encapCONorANSmsg != 0);
        }
        else
        {
            procDelayRel = TRUE;
        }

        /* Delayed Release Process */
        if (procDelayRel)
        {
            ret = ccProcessDelayedRelease(con);
        
           switch (ret)
           {
             case ROK:
               /* ROK - proceed normally with the call */
               break;

             case ROKIGNORE:
               /* Delayed Release Process executed - The RelReq will not be sent*/
               ccStopConTmr(con, TMR_RELEASE);
               CCDP(AIN_DBG_LEVEL_0,"Delayed Release Process started\n");
               CC_STATE_CHANGE(con, CCS_AWTDELAYEDREL);
               RETVALUE(ROK);

             default:
               break;
          }
        }

        ccSendReleaseReq(con);
    }
    break;

    case OUTRELRSPANDINREL:
    {
        if (con->mrfFlag)
        {
           CCDP(AIN_DBG_LEVEL_1, "mrfFlag %d\n", con->mrfFlag);
           /* Since we are done with tha annoucement, need to clean the anncBlk */
           cmMemset((U8 *)&con->anncBlock, 0, sizeof(con->anncBlock));
           /* release the call with 4xx-6xx  message */
           CCDP(AIN_DBG_LEVEL_0,"MRF response with non-200OK message\n");
           if (con->noRspReqd == FALSE)ccSendReleaseRsp(con);
           ccProcessFailCnd(con, FC_MRF_NOTPLAYANNC, TRUE);
           con->mrfFlag = 0;
           RETVALUE(ROK);
        }

        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
        ccDeallocateResource(con, CC_OUTGOING);
#endif
        con->ogRscVal = FALSE;

        con->icEvnt = (CcAllSdus *) con->ccEvntHold;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        con->direction = OUTTOINC;
        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

        ret = ccMapEvent(con, CCE_RELIND, 0);
        if (ret != ROK)
        { 
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType,con->tempHolderForReleaseCause,NULL);
            RETVALUE(ROK);
        }
        ccSendReleaseReq(con);
    }
    break;

    case OUTRELRSPANDINTONE: /* always Incoming CAS-line/trunk --> SS7/ISDN */
    {
      /* For FID17174.0 we have a special handling */
      if (CC_IS_MRF(con->mrfFlag,MRF_PLAYING_ANNC))
      {
        if (ret != ROK)
        {
          /* IF MG SUB failed, release the call */
          CCLOGERR("Error: mg response handle failed\n");
          cleanUpMgQ(con);
          ccCleanUpMGCtx(con);
          ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
          RETVALUE(RFAILED);
        }
        /* Change back to S155 */
        CC_STATE_CHANGE(con, CCS_AWT_MRFRSP);
        ccDeallocateResource(con, CC_OUTGOING);
        if (con->noRspReqd == FALSE)ccSendReleaseRsp(con);
        con->ogRscVal = FALSE;

        ret = ccPostAnnoucementProcessing(con);
        if (ret != ROK)
        {
          CCLOGERR("Error: ccPostAnnoucementProcessing failed 0x%lx\n",
              con->icSuConnId);
          cleanUpMgQ(con);
          ccHandleCleanUpConCb(con, TRUE, AM_CV_TMPFAIL);
          RETVALUE(RFAILED);
        }
        cmMemset((U8 *)&con->anncBlock, 0, sizeof(con->anncBlock));
        con->mrfFlag = 0;
        RETVALUE(ROK);
      }

        CcCause cause;

        cmMemset((U8 *)&cause, 0, sizeof(CcCause));

        /* Get protocol release cause */
        ccGetRelCause (con, con->ogProtType, (CcRelEvnt *)con->ccEvntHold, 
                       &cause, &sipCause, &sipStatus);

        icProtType = CC_GET_PROTOCOL(con->icProtType);
        ogProtType = CC_GET_PROTOCOL(con->ogProtType);

        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

        if (con->direction == OUTTOINC)
        {
            con->failCndVal = ccMapProtRel2FailCnd (con, &cause, 
                                       &sipCause, &sipStatus);
        }

        if (con->relPend == OUTRELRSPANDINTONE)
        {
#ifdef GUARD_TIMER
          ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
          ccDeallocateResource(con, CC_OUTGOING);
#endif
          con->ogRscVal = FALSE;

          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
        }

        if ((con->failCndVal == FC_NOT_APPLICABLE) &&
            ((cause.causeVal.val == CCUSRBSY) ||
             (cause.causeVal.val == CCNOUSRRSP)) &&
            (CC_ENDPOINT_BCM(&con->icBcm)))
            con->failCndVal = FC_USRBUSY;

        if ((icProtType == CC_CS_TG) || (ccIsLEGSubscriber(&(con->icBcm))) ||
            (con->direction == OUTTOINC && CC_IS_CAUSEMAP_SUPPORTED (ogProtType)) ||
            (con->direction == OUTTOINC && con->failCndVal != FC_NOT_APPLICABLE))
        {
            ccStopConTmr(con, TMR_RELEASE);
	    ccStopConTmr(con, TMR_SETUP); /* Bug 50965 */
            ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);
            ret = ccProcessFailCnd (con, con->failCndVal, FALSE);
            if (ret == ROK)
                RETVALUE(ROK);
        }

        if(CC_IS_REL_IN_EVNT_HOLD(con))
          con->icEvnt = (CcAllSdus *) con->ccEvntHold;
        else if(con->ccRelEvntHold)
          con->icEvnt = (CcAllSdus *)con->ccRelEvntHold;

        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        ret = ccMapEvent(con, CCE_RELIND, 0);
        if (ret != ROK)
        {
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, con->tempHolderForReleaseCause,
                        NULLP);
          RETVALUE(ROK);
        }
        ccSendReleaseReq(con);
        RETVALUE(ROK);
    }
    break;

    case INTONEFORSUBANDRELFORTRK:
    {
        icProtType = CC_GET_PROTOCOL(con->icProtType);

        if ((icProtType == CC_CS_TG) || (ccIsLEGSubscriber(&(con->icBcm))))
        {
            CcCause cause;
            cmMemset((U8 *)&cause, 0, sizeof(CcCause));
            cmMemset ((U8 *)&sipCause, 0, sizeof(TknU16));
            cmMemset ((U8 *)&sipStatus, 0, sizeof(TknU16));

            cause.eh.pres = PRSNT_NODEF;
            cause.causeVal.pres = PRSNT_NODEF;
            cause.causeVal.val = CCNORMUNSPEC;

            ccProcessFailCnd(con, 
                    ccMapProtRel2FailCnd(con, &cause, &sipCause, &sipStatus),
                    TRUE);
            RETVALUE(ROK);
        }
        else
        {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
            if (CC_IS_PROT_TYPE_BRAZIL(con->icProtType) ||
                CC_IS_PROT_TYPE_BRAZIL(con->ogProtType))
            {
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCCALLRJT, NULLP);
            }
            else
            {
                ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                              con->icProtType, CCNORMUNSPEC, NULLP);
            }
            RETVALUE(ROK);
        }
    }
    break;
    case ICRELONLYKEEPCON:
    {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
        RETVALUE(ROK);
    }
    break;

    case OGRELONLYKEEPCON:
    {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
        ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCCALLCLR, NULL);
        RETVALUE(ROK);
    }
    break;

    case OUTRELANDINFAILCOND :
    {
      /* FID 15319.0 */
      if(con->lastState == CCS_BICC_AWT_MGCT_CFMNOT)
      {
         CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
         ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                       con->ogProtType, con->tempHolderForReleaseCause, NULL);
      }
      else
      {
          ccFreeTheRscFromCon(con, OUTTOINC);
      }
      ccProcessFailCnd(con, con->failCndVal, TRUE);
    }
    break;

    /* FID 15801.0 (LGP74) */
    case OUTRELANDADVANCEURI :      
    {
      ccFreeTheRscFromCon(con, OUTTOINC);

      if (CC_IS_SIP_CONTACTURI_AVAIL(con))
      {
        /* Step1 - Restore original EventHold Info and release the backed up EventHold 
                 memory in the con->sip3xxBlock */

        CC_ADVANCE_CONTACT_URI_LIST(con, ret);
        
        if (ret == ROK)
        {
           CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
               "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
               con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
           RETVALUE(ROK);
        }
      }
      else if (CC_IS_SIP3XXCALL(con))
      {
        /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
           is needed for reroute due to default failCndId processing */
        ccRestoreEvntHold(con);
        ccRestoreOrigParamFor3xxCall(con);
      }

      CC_FREE_SIP3XX_BLOCK(con); 
      
      ccProcessFailCnd(con, con->failCndVal, TRUE);
    }
    break;

    case OUTRELANDSCRINFAILCOND :
    {
      ccFreeTheRscFromCon(con, OUTTOINC);
      ccProcessFailCnd(con, FC_SCR_FRAUD_REL, TRUE);
    }
    break;

    case OUTRELANDANSINFAILCOND :
    {
      ccFreeTheRscFromCon(con, OUTTOINC);
      ccProcessFailCnd(con, FC_ANS_SUPER_REL, TRUE);
    }
    break;

    case OUTRELRSPANDINFAILCOND :
    {
      /* This is a case of Disconnect from LM, or disconnect due to fraud, 
       * supervision timer expiry */

      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ccDeallocateResource(con, CC_OUTGOING);
#endif
      con->ogRscVal = FALSE;
      con->relPend = 0;

      con->direction = OUTTOINC;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

      ccProcessFailCnd(con, con->failCndVal, TRUE);

      RETVALUE(ROK);
    }

    /* FID 15801 (LGP74) - SIP 3XX case */
    case OUTRELRSPANDADVANCEURI :
    {
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ccDeallocateResource(con, CC_OUTGOING);
#endif
      con->ogRscVal = FALSE;
      con->relPend = 0;

      con->direction = OUTTOINC;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
  
      if (CC_IS_SIP_CONTACTURI_AVAIL(con))
      {
        /* Step1 - Restore original EventHold Info and release the backed up EventHold 
                 memory in the con->sip3xxBlock */

        CC_ADVANCE_CONTACT_URI_LIST(con, ret);
     
        if (ret == ROK)
        {
           CCDP(AIN_DBG_LEVEL_0,"Sending ORedirect after advancing to the next Contact URI"
               "icSu:%ld, ogSu:%ld, icTsId:%ld,currIndex=%d\n", con->icSuConnId, con->ogSuConnId,
               con->icBcm.svcHeader.transId, con->sip3xxCb->currIndex);
           RETVALUE(ROK);
        }
      }
      else if (CC_IS_SIP3XXCALL(con))
      {
        /* LGP-233:: Need to restore the original contents before SIP 3xx redirect as it 
           is needed for reroute due to default failCndId processing */
        ccRestoreEvntHold(con);
        ccRestoreOrigParamFor3xxCall(con);
      }
 
      CC_FREE_SIP3XX_BLOCK(con); 

      ccProcessFailCnd(con, con->failCndVal, TRUE);

      RETVALUE(ROK);
    }
    break;

    case OUTRELRSPANDSCRINFAILCOND :
    {
      /* This is a case of Disconnect from LM, or disconnect due to fraud, 
       * supervision timer expiry */

      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ccDeallocateResource(con, CC_OUTGOING);
#endif
      con->ogRscVal = FALSE;
      con->relPend = 0;

      con->direction = OUTTOINC;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

      ccProcessFailCnd(con, FC_SCR_FRAUD_REL, TRUE);

      RETVALUE(ROK);
    }
    break;

    case OUTRELRSPANDANSINFAILCOND :
    {
      /* This is a case of Disconnect from LM, or disconnect due to fraud, 
       * supervision timer expiry */

      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);
#ifdef GUARD_TIMER
      ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
      ccDeallocateResource(con, CC_OUTGOING);
#endif
      con->ogRscVal = FALSE;
      con->relPend = 0;

      con->direction = OUTTOINC;
      if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

      ccProcessFailCnd(con, FC_ANS_SUPER_REL, TRUE);

      RETVALUE(ROK);
    }
    break;

    /* FID 16706 + */ 
    case INRELRSPDELAYANDOUTREL:
    {
        CCDP(AIN_DBG_LEVEL_2, "%s(): relPend==INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);

        con->icEvnt = (CcAllSdus *) con->ccEvntHold;
        con->ogEvnt = (CcAllSdus *) &ogEvnt;

        con->direction = INCTOOUT;

        ret = ccMapEvent(con, CCE_RELIND, 0);
        if (ret != ROK)
        { 
            ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                          con->ogProtType, con->tempHolderForReleaseCause,NULL);
            RETVALUE(ROK);
        }
        
        /* For Spain, the process is valid only if the ANS was received */
        if ((CC_IS_PROT_TYPE_SPAIN(con->ogProtType) ||
             CC_IS_PROT_TYPE_SPAIN(con->icProtType)))
        {
            procDelayRel = (con->encapCONorANSmsg != 0);
        }
        else
        {
            procDelayRel = TRUE;
        }

        /* Delayed Release Process */
        if (procDelayRel)
        {
            ret = ccProcessDelayedRelease(con);
        
           switch (ret)
           {
             case ROK:
               /* ROK - proceed normally with the call */
               break;

             case ROKIGNORE:
               /* Delayed Release Process executed - The RelReq will not be sent*/
               ccStopConTmr(con, TMR_RELEASE);
               CCDP(AIN_DBG_LEVEL_0,"Delayed Release Process started\n");
               CC_STATE_CHANGE(con, CCS_AWTDELAYEDREL);
               RETVALUE(ROK);

             default:
               break;
          }
        }

        ccSendReleaseReq(con);
    }
    break;
    /* FID 16706 - */
    /* FID17174.0 ++ */
    case NORELANDPLAYANNC:
    {
      /* Will allocate the ogRsc and then send annoucement to MRF */
      if (con->mrfFlag)
      {
        CCDP(AIN_DBG_LEVEL_1,"MRF call , now allocate the ogRsc mrfFlag%d!\n", con->mrfFlag);
        CC_STATE_CHANGE(con, CCS_AWTRSCALOCCFM);

        ccAllocateResourceArray(con, (CcConEvnt *)con->ccEvntHold,
            CC_OUTGOING, RMT_ALOC,
            con->routeEvnt->ogInterface,
            con->routeEvnt->ogPrtclType,
            con->routeEvnt->numOfOgInterfaces);

        SPutSBuf(ccInit.region, ccInit.pool, con->routeEvnt,
            (Size) sizeof(RtRteCfmEvnt1));
      }
    }
    break;
    /* FID17174.0 -- */
    default :
        CCLOGERR( "ERROR: NoOne expected this relPend value = %d\n",
                  con->relPend);
        break;
    } /* switch on con->relPend */

    RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE11S56
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm
 *             state - CCS_AWTSWTCFM_SENDNOREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE11S56
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   MgctTxnCfm     *txnCfm       = NULLP;
   S16             ret          = RFAILED;
   S16             relDisBool   = RFAILED;
   U8              evntType     = 0;

   txnCfm   = (MgctTxnCfm*) event;

   ret = ccHandleMgResponse(con, txnCfm);
   /* FID 15261.0 + */
   if (CC_IS_CALL_MULTI_MG(con))
   {
     if (con->ccmCb.mgPend)
       con->ccmCb.mgPend--;

     if (ret != ROK)
     {
       con->ccmCb.flags |= CC_MG_SUB_ERROR;
     }

     if (con->ccmCb.mgPend)
     {
       RETVALUE(ROK);
     }
   }
   /* FID 15261.0 - */

   if ((ret != ROK) || (con->ccmCb.flags & CC_MG_SUB_ERROR))
   {
      CCLOGERR( "ERROR:Handling the Sub Req,anyway Release Call\n");
      cleanUpMgQ(con);
      ccCleanUpMGCtx(con);
   }

#ifdef CALEA_3WC
   if (con->mgiPendRelRsp)
   {
      CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S20\n");
      ccProcessCaleaMgiSubRsp(con, FALSE);
      con->mgiPendRelRsp = 0;
   }
#endif 

   switch(con->relPend)
   {
     case INRELRSPANDNOREL:
     {
       /* Bug:26225 Initialize the direction..other events might have
        * changed the direction since the relInd is rcvd */
       con->direction = INCTOOUT;
       /* Do not Relase incoming ISDN rsc on the rcving disconnect
        * from remote side */
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       /* outgoing resource is to be released here */
       if(con->ogRscVal == TRUE)
          ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_INCOMING);
#else
       ccDeallocateResource(con, CC_INCOMING);
#endif

     }
     break;

     case OUTRELRSPANDNOREL:
     {
       /* Bug:26225 Initialize the direction..other events might have
        * changed the direction since the relInd is rcvd */
       con->direction = OUTTOINC;
       /* Do not Relase outgoing ISDN rsc on the rcving disconnect
        * from remote side */
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       /* If not sure, add an extra check for ogRscVal */
       if(con->icRscVal == TRUE)
          ccDeallocateResource(con, CC_INCOMING);
       con->icRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
       ccDeallocateResource(con, CC_OUTGOING);
#endif

     }
     break;

     case INRELRSPANDOUTRELRSP:
     {
#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
        ccDeallocateResource(con, CC_OUTGOING);
#endif
        con->ogRscVal = FALSE;

        CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

        if(con->direction == INCTOOUT)
          con->direction = OUTTOINC;
        else
          con->direction = INCTOOUT;
        if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_INCOMING);
#else
        ccDeallocateResource(con, CC_INCOMING);
#endif
     }
     break;

     case NORELANDNORELRSP:
     {
       if (con->lastState == CCS_AWTRSPFORDPE32)
       {
         con->lastState = con->state;
         relDisBool = ccCheckRelOrOnHookInBuffer(&(con->icBcm), &evntType);
         if ((ccCheckEventInBuffer(&(con->ogBcm), CCE_CONCFM)) ||
             (relDisBool == ROK))
         {
           /* Drop the Forward Call Response and process the Connect Confirm */
           DP("Drop the Forw call procs and procs the ConCfm/Rel message:"
              " icSu = 0x%lx, ogTransId = 0x%lx\n", con->icSuConnId,
              con->ogBcm.svcHeader.transId);
           CC_STATE_CHANGE(con, CCS_AWTANS);
           RETVALUE(ROK);
         }

         /* This is a forward Call scenario */
         ret = ccForwardCallAPI(con);
         if (ret == RFAILED)
         {
           ccStopConTmr(con, TMR_SETUP);
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, CCCALLCLR, NULL);
         }
         RETVALUE(ROK);
       }
       /* This happens, during MParty Calls, when both resoources were 
        * moved out */
       ccRelCon(con);
       RETVALUE(ROK);
     }
     break;
     case NORELANDINFAILCOND:
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccDeallocateResource(con, CC_OUTGOING);
      con->ogRscVal = FALSE;
      if(con->failCndVal != FC_NOT_APPLICABLE)
      {
        ccProcessFailCnd(con, con->failCndVal, TRUE);
        RETVALUE(ROK);
      }
      /* This is an internal switch error, what tone should be played */
      ccPlayToneOrRelease(con, CCTMPFAIL);
      RETVALUE(ROK);
      
     case ONLYINFAILCND:/* BUG:80926 */
      ccProcessFailCnd(con, con->failCndVal, TRUE);
      RETVALUE(ROK);

     default:
       CCLOGERR( "ERROR: Unexpected relPend=%d\n", con->relPend);
     break;
   }

   RETVALUE(ROK);
}

/*
*
*      Fun:   ccConE11S63
*
*      Desc:  Connection state function
*             event - Switching Connect Confirm
*             state - CCS_AWTSWTCFMFORCC6CC10
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE11S63
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16                        ret            = RFAILED;
  S16                        mgret          = RFAILED;
  MgctTxnCfm                *txnCfm         = NULLP;
  CcConCb                   *CSID1con       = NULLP;
  msgValBcmTypeEnum          dbcmType       = BtMax;
  Bool                       releaseNeeded  = FALSE;
  AinBCM_t                  *legId02        = NULLP;
  AinBCM_t                  *legId1         = NULLP;
  AinBCM_t                  *legId2         = NULLP;
  U8                         index          = 0;
  CsReleaseReqEventType_e    releaseCause   = CS_RELREQ_EVENT_NORMAL;
  Bool                       dRscVal        = FALSE;
#ifdef ZC
  ZcUpdParam           upd;
#endif /* ZC */
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED;
#endif


  CCDP(AIN_DBG_LEVEL_1, "ccConE11S63:%ld\n", con->icSuConnId);

  if (con->icBcm.cc == NULLP)
  {
    CCLOGERR( "ERROR: Response Handling FAILED\n");
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }

  txnCfm   = (MgctTxnCfm*) event;
  mgret = ccHandleMgResponse(con, txnCfm);
  if ((mgret != ROK) && (mgret != ROKIGNORE) && (mgret != RNOCONF))
  {
    CCLOGERR( "ERROR: Response Handling FAILED\n");
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  cmMemset((U8 *) &upd, 0, sizeof(ZcUpdParam));

  if (con->icBcm.cc->ccId == CiStableMParty)
  {
    CSID1con = con->icBcm.cc->legId1->con;
    legId02  = con->icBcm.cc->legId02;
    legId1   = con->icBcm.cc->legId1;
    legId2   = con->icBcm.cc->legId2;
    /* We have come here after a Disconnect Leg */
    if (con->ainInfo.legId == 1)
    {
      dbcmType  = con->icBcm.cc->legId1->bcmType;
      if ((dbcmType != BtOBcm) && (dbcmType != BtTBcm))
      {
        CCLOGERR("Error: Invalid bcmType:%d\n", dbcmType);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
      }
      if (dbcmType == BtOBcm)
        dRscVal = con->icBcm.cc->legId1->con->icRscVal;
      else
        dRscVal = con->icBcm.cc->legId1->con->ogRscVal;
      CCDP(AIN_DBG_LEVEL_0, "leg1 Disconnect Leg:%ld\n", con->icSuConnId);
      if (ccFindIfReleaseOrRelRspNeeded(con->icBcm.cc->legId1) == ROK) 
        releaseNeeded = TRUE;

      /**************REPLICATION************************/
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->icSuConnId;
                                            /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
        upd.featMsg.DlegId       = 1; /*Due to which leg */
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
      /**************Call Configuration*******************/
      con->icBcm.cc->legId02->cc = NULLP;
      CC_CLEAN_FIC_TXN(con->icBcm.cc->legId02);
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId1  = &(con->ogBcm);
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId2  = NULLP;

      /*****************MGBLOCK Assocation*****************/
      GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,NULLP,CSID1con)
      con->mgBlock->con = con;

      /* Allocate the mgBlock */
      ret = SGetSBuf(ccInit.region, ccInit.pool,
                    (Data **) &(CSID1con->mgBlock), (Size) sizeof(CcMgBlock_t));

      cmMemset((U8 *) CSID1con->mgBlock, 0, sizeof(CcMgBlock_t));
      GCC_INC_CONCNT(CSID1con->mgBlock);

      /************SEND RELEASE AND CLEANUP CON************/
      ccStopConTmr(CSID1con, TMR_SETUP);
      ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
      if (releaseNeeded)
      {
          if ((dbcmType == BtOBcm) && (dRscVal))
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
            ccSendRelease (CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                           CSID1con->icSuConnId, CSID1con->icProtType,
                           CCCALLCLR, NULLP );
          }
          else if ((dbcmType == BtTBcm) && (dRscVal)) /* It has to be BtTBcm */
          {
            CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
            ccSendRelease (CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                           CSID1con->ogSuConnId, CSID1con->ogProtType,
                           CCCALLCLR, NULLP );
          }
          else
          {
            ccRelCon(CSID1con);
          }
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
        if ((dbcmType == BtOBcm) && (dRscVal))
        {
          CSID1con->direction = INCTOOUT;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          ccDeallocateResource(CSID1con, CC_INCOMING);
        }
        else if ((dbcmType == BtTBcm) && (dRscVal))
        {
          CSID1con->direction = OUTTOINC;
          if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
          ccDeallocateResource(CSID1con, CC_OUTGOING);
        }
        else
        {
          ccRelCon(CSID1con);
        }
      }
      if (con->icBcm.pic == PicOActive)
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
      else
      {
        con->lastState = con->state;
        CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      if (CC_IS_CCID_CC10_AND_ABOVE(legId2))
        ccCreateOnSwitchBearer(&(con->icBcm), NULLP, NULLP, NULLP, con->state,
                               FALSE);
      else
        ccCreateBearer(&(con->icBcm), &(con->ogBcm), NULLP, NULLP,
                       con->state, FALSE);
      RETVALUE(ROK);
    }
    else if (con->ainInfo.legId == 2)
    {
      dbcmType  = con->icBcm.cc->legId2->bcmType;
      if ((dbcmType != BtOBcm) && (dbcmType != BtTBcm) &&
          (con->ogRscVal == TRUE))
      {
        CCLOGERR("Error: Invalid bcmType:%d\n", dbcmType);
        ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
        RETVALUE(RFAILED);
      }
      if (dbcmType == BtOBcm)
        dRscVal = con->icBcm.cc->legId2->con->icRscVal;
      else if (dbcmType == BtTBcm)
        dRscVal = con->icBcm.cc->legId2->con->ogRscVal;

      if (con->lastState == CCS_AWTRSPFORDPE9)
      {
        if (ccFindIfReleaseOrRelRspNeeded(con->icBcm.cc->legId2) == ROK)
          releaseNeeded = TRUE;
      }
      else
      {
        /* This is in the case when Disconnect Leg is due to flash */
        if (con->icBcm.pic == PicOActive)
          releaseCause = CS_RELREQ_EVENT_ALLOW_REORIGINATION;

        releaseNeeded = TRUE;
      }
      CCDP(AIN_DBG_LEVEL_0, "Release Cause:%d, release needed:%d\n",
                             releaseCause, releaseNeeded);

      /**************REPLICATION************************/
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        upd.featMsg.suConnId     = con->icSuConnId;
                                            /*ACT Controlling leg connId*/
        upd.featMsg.ccAinUpdType = CC_DISCONNECT_LEG_CONF;
        upd.featMsg.DlegId       = 2;
        upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
        upd.featMsg.nel          = con->icBcm.nel;
        zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
        zcUpdPeer();
      }
#endif /* ZC */
      ccToggleCC6CtrlHashList(&con->icBcm);
      if (legId02->bcmType == BtOBcm)
      {
/***************CHANGE OWNER OF RESOURCE *************************************/
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_INCOMING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->icSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->icRscVal = TRUE;
        }
      }
      else
      {
        ret = ccAllocateResource(CSID1con, (CcConEvnt *)event, CC_OUTGOING,
                                 RMT_ALOC_CHOWN);
        if (ret != ROK)
        {
          CCLOGERR( "Error:ccAllocateResource failed %ld\n", CSID1con->ogSuConnId);
        }
        else
        {
          con->icRscVal      = FALSE;
          CSID1con->ogRscVal = TRUE;
        }
      }

      /* send ReConnect to CAS-SP with appropriate CONNECTION direction */
      if (!ccIsIPSubscriber(legId02))
      {
        if (legId02->bcmType == BtOBcm)
        {
          ccSendCnStReq(CSID1con, CSID1con->icSapCb->suId,
                        &CSID1con->icSapCb->pst, CSID1con->icSapCb->spId,
                        CSID1con->icSpConnId, CSID1con->icSuConnId,
                        CSID1con->icProtType, CS_CONN_STATUS_RECONNECT_IC,
                        NULLP, NULLP);
        }
        else /* It should be BtTBcm */
        {
          ccSendCnStReq(CSID1con, CSID1con->ogSapCb->suId, 
                        &CSID1con->ogSapCb->pst, CSID1con->ogSapCb->spId, 
                        CSID1con->ogSpConnId, CSID1con->ogSuConnId, 
                        CSID1con->ogProtType, CS_CONN_STATUS_RECONNECT_OG, 
                        NULLP, NULLP);
        }
      }
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
      /**************Call Configuration*******************/
      con->icBcm.cc->ccId    = CiStable2Party;
      con->icBcm.cc->legId01 = con->icBcm.cc->legId02;
      con->icBcm.cc->legId02 = NULLP;
      con->icBcm.cc->legId2  = NULLP;
      con->icBcm.cc          = NULLP;

      /*****************MGBLOCK Assocation*****************/
      GCC_MNG_MGBLOCK_CNTR(con->mgBlock,NULLP,con);
      CSID1con->mgBlock->con = CSID1con;

      /* Allocate the mgBlock */
      ret = SGetSBuf(ccInit.region, ccInit.pool,
                  (Data **) &(con->mgBlock), (Size) sizeof(CcMgBlock_t));

      cmMemset((U8 *) con->mgBlock, 0, sizeof(CcMgBlock_t));
      GCC_INC_CONCNT(con->mgBlock);

      if (con->ogBcm.bcmType == BtTBcm)
      {
        ret = ccProcessDisconnectOnSpecificBCM (&(con->ogBcm));
#ifdef CALEA_3WC
        if (con->surrogate != NULLP)
           ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
        if (ret == ROK)
        {     
          /* If event is armed , we would process this disconnect and
           * the con will be cleaned up in that function */
          CCDP(AIN_DBG_LEVEL_0, "Disconnect Event Armed\n");
          RETVALUE(ROK);
        }
#ifdef CALEA_3WC
        caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                               event);
        if (caleaRet != ROK)
        {
           CCDP(AIN_DBG_LEVEL_4,
               "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
        }
#endif

      }
      
      ccStopConTmr(con, TMR_SETUP);
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      if (releaseNeeded)
      {
        if ((dbcmType == BtOBcm) && (dRscVal))
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease( con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, releaseCause, NULLP );
        }
        else if ((dbcmType == BtTBcm) && (dRscVal)) /* It should be BtTBcm */
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease( con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                         con->ogProtType, releaseCause, NULLP );
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "Dis. Leg case of busy/re-order signals:%ld\n",
                                con->icSuConnId);
          ccRelCon(con);
        }
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
        if ((dbcmType == BtOBcm) && (dRscVal))
        {
          con->direction = INCTOOUT;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          ccDeallocateResource(con, CC_INCOMING);
        }
        else if ((dbcmType == BtTBcm) && (dRscVal))
        {
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          ccDeallocateResource(con, CC_OUTGOING);
        }
        else
        {
          ccRelCon(con);
        }
      }
      if (CC_IS_CCID_CC10_AND_ABOVE(legId1))
        ccCreateOnSwitchBearer((legId02), NULLP, NULLP, NULLP,
                               CSID1con->state, FALSE);
      else
        ccCreateBearer(&(CSID1con->icBcm), &(CSID1con->ogBcm), NULLP, NULLP,
                       CSID1con->state, FALSE);
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Error: LegId not supported:%d, %ld, %d\n",
                con->ainInfo.legId, con->icSuConnId, con->icBcm.cc->ccId);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
    }
  }
  else if (con->icBcm.cc->ccId == CiPartyOnHold) 
  {
    CSID1con = con->icBcm.cc->legId1->con;
    /* Check if we had to roll back, if yes Merge Call failed, send 
     * Failure Outcome to FIC
     * ELSE, Replicate and MG Block manipulation, increment Cascade counter */
#if 1 /* Bug#: 17932 */
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
    if ((mgret == ROKIGNORE) || (mgret == RNOCONF))
    {
      CCDP( AIN_DBG_LEVEL_0, "Switching failed, but rollback success May be"
                             " switching resources are not available:%ld\n",
                             con->icSuConnId );
      cleanUpMgQ(con);
      for (index = 0; index < EReqMax; index++)
        con->icBcm.nel[index] = NEL_UNARMED;

      CC_STATE_CHANGE(con, CCS_AWTRSPFAILOUT);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                         CCS_CANNOTPROCESSEVENTS);
      ccSendFailureOutCome(&con->icBcm);
      RETVALUE(ROK);
    }
    else
    {
      /* Switching was successful */
      CCDP(AIN_DBG_LEVEL_0, "***3WC****Switching successful:%ld\n",
                                                 con->icSuConnId);
      /* Replicate, changed ccId and Associate mgBlocks */
#ifdef ZC
      if (CC_IS_OBCM_PIC_ACTIVE(con))
      {
        /* For 3WC */
        if (con->icBcm.cc->ccId == CiPartyOnHold)
        { 
           upd.featMsg.ccAinUpdType = CC_MERGE_CALL_3WC;
           upd.featMsg.suConnId     = con->icSuConnId;
           upd.featMsg.DlegId       = 0;
           upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
           upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
           upd.featMsg.direction    = con->mgBlockDirection;
           upd.featMsg.nel          = con->icBcm.nel;
           zcRunTimeUpd( ZC_FEAT, CMPFTHA_UPD_REQ, upd );
           zcUpdPeer();
        }
      }
#endif /* ZC */
      con->icBcm.cc->ccId = CiStableMParty;
      if (con->mgBlockDirection == LEGID1)
        ccManageMgBlockPointerAfterDelete(con->icBcm.cc->legId1, con->mgBlock);
      else
        ccManageMgBlockPointerAfterDelete( con->icBcm.cc->legId2,
                                           CSID1con->mgBlock );
      CCDP(AIN_DBG_LEVEL_2, "mgBlockDirection:%d\n", con->mgBlockDirection);
      if (con->icBcm.pic == PicOActive)
      {
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      if (con->ogBcm.bcmType == BtMax)
        ccStopConTmr(con, TMR_SETUP);

#ifdef CC_BUFFER_EVENT
      /* There may be a event sitting on CS1con and CS2con Event Buffer */
      ccPostEventToSelf (CSID1con);
      ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
      RETVALUE(ROK);
    }
  }
  else
  {
    CCLOGERR("ccId not supported:%d\n", con->icBcm.cc->ccId);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE60S64
*
*      Desc:  Connection state function
*             event - Ignore Event from FIC
*             state - CCS_AWTRSPFAILOUT
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE60S64
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcConCb        *CSID1con       = NULLP;
#ifdef ZC
  ZcUpdParam upd; 
#endif /* ZC */

  CCDP(AIN_DBG_LEVEL_1, "ccConE60S64:%ld\n", con->icSuConnId);
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
#ifdef ZC
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.ccAinUpdType = CC_UPDATE_BCM;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */
    CC_STATE_CHANGE(con, CCS_ANSWERED);
  }
  else
  {
    CC_STATE_CHANGE(con, CCS_AWTANS);
  }
  if (con->icBcm.cc)
  {
    if (con->icBcm.cc->legId1)
    {
      CSID1con = con->icBcm.cc->legId1->con;
    }
  }
  if (CSID1con)
  {
    ccPostEventToSelf (CSID1con);
  }
  ccPostEventToSelf (con);

  RETVALUE(ROK);
}


/*
*
*      Fun:   ccConE11S65
*
*      Desc:  Connection state function
*             event - Switching Connect Confirm
*             state - CCS_AWTSWTCFMFORHOLD
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*          
*      File:  cc_bdy2.c
*        
*/
PRIVATE S16 ccConE11S65
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  Bool                 ctxCase      = FALSE;
  S16                  ret          = FALSE;
  CcConCb             *CsId2con     = NULLP;
  MgctTxnCfm          *txnCfm       = NULLP;
  U16                  index        = 0;
  SvcHeader_t          header;
  OriginationAttempt_t originationAttempt;
  U8 leaIndex = 0;

  CCDP(AIN_DBG_LEVEL_1, "ccConE11S65:%ld\n", con->icSuConnId);
  txnCfm   = (MgctTxnCfm*) event;
  ret = ccHandleMgResponse(con, txnCfm);

  if (ret != ROK)
  {
    CCLOGERR( "ERROR: Response Handling FAILED\n");
    cleanUpMgQ(con);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
#ifdef CALEA_3WC
  /* Process any CALEA release when waiting in CCS_AWTSWTCFMFORSVC */
  /* Case when Calea subReq are sent along with Tapped Sub's Signal_DATA request */
  if (con->mgiPendRelRsp)
  {
     CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S65\n");
     ccProcessCaleaMgiSubRsp(con, FALSE);
     con->mgiPendRelRsp = 0;
  }
  if (con->mgiPendAddRsp)
  {
     CCDP(AIN_DBG_LEVEL_1,"Processing Calea SubResp in ccConE11S65\n");
     ccProcessCaleaMgiAddRsp(con, FALSE);
     con->mgiPendAddRsp = 0;
  }
  if (con->mgiPendRelReq)
  {
     ccProcessPendingCaleaMgiRelReq(con);
     con->mgiPendRelReq = 0;
     /* Send the Mg Queue. */
     /* Stay in the same state */
     con->mgBlock->con = con;
     ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
     if (ret != ROK)
     {
       CCLOGERR("Error: ccSendMgiQueue failed icSu = 0x%lx\n",
                con->icSuConnId);
       cleanUpMgQ(con);
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       RETVALUE(RFAILED);
     }
     RETVALUE(ROK);
  }
#endif
/* This case is to handle a call in CCID = 4 (3-Party Setup) */
  /* Bug 20099 */
  if ((con->icBcm.cc) && (con->icBcm.cc->ccId == CiThreePartySetup) &&
      (con->lastState == CCS_AWTRSPFORDPE11))
  {
    CsId2con = con->icBcm.cc->legId01->con;
    CCDP(AIN_DBG_LEVEL_0,"2ic = %ld 2og = %ld in ccConE11S65\n",
                                      CsId2con->icSuConnId, CsId2con->ogSuConnId);
    ctxCase = TRUE;
    /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));

  }
  else if ((con->ogBcm.cc) && (con->ogBcm.cc->ccId == CiThreePartySetup) &&
           (con->lastState == CCS_AWTRSPFORDPE27))
  {
    CsId2con = con->ogBcm.cc->legId01->con;
    CCDP(AIN_DBG_LEVEL_0,"2ic = %ld 2og = %ld in ccConE11S65\n",
                                    CsId2con->icSuConnId, CsId2con->ogSuConnId);
    ctxCase = TRUE;
    /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
  }

  if (ctxCase == TRUE)
  {
    CCDP( AIN_DBG_LEVEL_0, "Call On-hold case:1ic:%ld,1og:%ld,2ic%ld,2og%ld\n",
          con->icSuConnId, con->ogSuConnId, CsId2con->icSuConnId,
          CsId2con->ogSuConnId );
    CC_STATE_CHANGE(con, CCS_ANSWERED);
#ifdef CC_CALEA
    /* Set the noOfCalea count in the CsId2con */
    for (leaIndex = 0; leaIndex < MAX_CALEALEGS_PER_SUB; leaIndex++)
      if (CsId2con->icBcm.cc->caleaLegId[leaIndex] != NULLP)
        CsId2con->ainInfo.noOfCaleaLegs++;
    CCDP(AIN_DBG_LEVEL_0,"CS2 of CT call has %d noOfCaleaLegs so far\n",
         CsId2con->ainInfo.noOfCaleaLegs);
#endif

    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&originationAttempt, 0, sizeof(OriginationAttempt_t));

    /* Update icBcm parameters */
    ccUpdateBcm(CsId2con, PicONull, CiThreePartySetup, BtOBcm);

    /* Update for RecallDialTone */
    CsId2con->ainInfo.ControllingLegTreatment = CltRecallDialToneOn;

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
      CsId2con->icBcm.nel[index] = NEL_UNARMED;
    ccFillSvcHeader(&header, &(CsId2con->icBcm), MSG_Origination_Attempt);

    ccFillOrigAttemptParam(&originationAttempt, &(CsId2con->icBcm), FALSE);

    CC_STATE_CHANGE(CsId2con, CCS_AWTRSPFORDPE1);
    ccChangeCallStateOfAssociatedCalls(&(CsId2con->icBcm), CCS_CANNOTPROCESSEVENTS);

    /* Send the Origination Attempt message to the FIC */
    CCDP(AIN_DBG_LEVEL_0," Sending OriginationAttempt\n");
    CcUiFctOriginationAttempt(&originationAttempt, &header);
    RETVALUE(ROK);
  }
  else
  {
    CCLOGERR("Invalid Call Flow: %ld\n", con->icSuConnId);
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(ROK);
  }
}


/*
 *
 *      Fun:   ccConE15S54
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - CCS_AWTSWTCFM_SENDBOTHREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S54
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  CcMgCtx_t *mgCtx = NULLP;
  CcMgCtx_t *next  = NULLP;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  CCLOGERR("Response from MGI - TimedOut:%ld\n", con->icSuConnId);

  /* Clean up the mgBlock */

  /* First Remove all the entries from the queue
     Before we queue more commands                */
  cleanUpMgQ(con);

  /* Delete the entry from the hash list */
  mgCtx = con->mgBlock->mgCtx;
  
  while(mgCtx)
  {
    next = mgCtx->next;

    cmHashListDelete(&ccMgctInsTbl, (PTR) mgCtx);
    if(mgCtx->mgSapCb)
      cmHashListDelete(&(mgCtx->mgSapCb->ccMgInsTbl), (PTR) mgCtx);
    mgCtx->suCtxId = 0;
    mgCtx->contextId = 0;

    mgCtx = next;
  }

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
      con->icProtType, CCTMPFAIL, NULL);
  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
      con->ogProtType, CCTMPFAIL, NULL);

  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S55
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - CCS_AWTSWTCFM_SENDONEREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S55
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  CcConEvnt       ogEvnt;
  CcMgCtx_t      *mgCtx = NULLP;
  CcMgCtx_t      *next  = NULLP;

  TRC3(ccConE15S55)

  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  CCLOGERR("Response from MGI - TimedOut:%ld\n", con->icSuConnId);
  
  /* Clean up the mgBlock */
  
  /* First Remove all the entries from the queue
     Before we queue more commands                */
  cleanUpMgQ(con);
  
  ccCleanUpMGCtx(con);

  /* Delete the entry from the hash list */
  mgCtx = con->mgBlock->mgCtx;

  while(mgCtx)
  {
    cmHashListDelete(&ccMgctInsTbl, (PTR) mgCtx);
    if(mgCtx->mgSapCb)
      cmHashListDelete(&(mgCtx->mgSapCb->ccMgInsTbl), (PTR) mgCtx);
    mgCtx->suCtxId = 0;
    mgCtx->contextId = 0;

    mgCtx = next;
  }

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
   switch(con->relPend)
   {
     case ICRELONLY:
     {
       /* This is a case of tones */
       if(con->ogRscVal == TRUE)
         ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
           con->icProtType, con->tempHolderForReleaseCause, NULL);
       RETVALUE(ROK);
     }
     break;

     case OGRELONLY :
     {
       /* This is a case of CFDA */
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
       ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
           con->ogProtType, con->tempHolderForReleaseCause, NULL);
       RETVALUE(ROK);
     }
     break;

     case INRELRSPANDOUTREL:
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_INCOMING);
#else
       ccDeallocateResource(con, CC_INCOMING);
#endif
       con->icRscVal = FALSE;

       con->icEvnt = (CcAllSdus *) con->ccEvntHold;
       con->ogEvnt = (CcAllSdus *) &ogEvnt;

       con->direction = INCTOOUT;
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       ret = ccMapEvent(con, CCE_RELIND, 0);
       if (ret != ROK)
       {
         ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
             con->ogProtType, CCPROTERR,NULL);
         RETVALUE(ROK);
       }
       ccSendReleaseReq(con);
     }
     break;

     case OUTRELRSPANDINREL:
     {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
        ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
        ccDeallocateResource(con, CC_OUTGOING);
#endif
        con->ogRscVal = FALSE;

       con->direction = OUTTOINC;
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       con->icEvnt = (CcAllSdus *) con->ccEvntHold;
       con->ogEvnt = (CcAllSdus *) &ogEvnt;

       ret = ccMapEvent(con, CCE_RELIND, 0);
       if (ret != ROK)
       {
         ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
             con->icProtType, CCPROTERR,NULL);
         RETVALUE(ROK);
       }
       ccSendReleaseReq(con);
     }
     break;

     case ICRELONLYKEEPCON:
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
       ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
           con->icProtType, CCCALLCLR, NULL);
       RETVALUE(ROK);
     }
     break;

     case OGRELONLYKEEPCON:
     {
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
       ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
           con->ogProtType, CCCALLCLR, NULL);
       RETVALUE(ROK);
     }
     break;

     /* FID 16706.0 + */
     case INRELRSPDELAYANDOUTREL:
     {
       CCDP(AIN_DBG_LEVEL_2, "%s(): relPend==INRELRSPDELAYANDOUTREL!\n", __FUNCTION__);
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);

       con->icEvnt = (CcAllSdus *) con->ccEvntHold;
       con->ogEvnt = (CcAllSdus *) &ogEvnt;

       con->direction = INCTOOUT;

       ret = ccMapEvent(con, CCE_RELIND, 0);
       if (ret != ROK)
       {
         ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
             con->ogProtType, CCPROTERR,NULL);
         RETVALUE(ROK);
       }
       ccSendReleaseReq(con);
     }
     break;

     /* FID 16706.0 + */

     default :
      CCLOGERR( "ERROR: NoOne expected this relPend value = %d\n",
          con->relPend);
      ccHandleCleanUpConCb (con,TRUE,CCTMPFAIL);
     break;
   } /* switch on con->relPend */
  RETVALUE(ROK);
}


/*
 *
 *      Fun:   ccConE15S56
 *
 *      Desc:  Connection state function
 *             event - RELEASE Timer Expired
 *             state - CCS_AWTSWTCFM_SENDNOREL
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE15S56
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  CcMgCtx_t *mgCtx = NULLP;
  CcMgCtx_t *next  = NULLP;

  ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE, 
             LCC_CAUSE_RELEASETMR_EXP, (U8 *) &con->icSuConnId);

  CCLOGERR("Response from MGI - TimedOut:%ld\n", con->icSuConnId);
  
  /* Clean up the mgBlock */
  
  /* First Remove all the entries from the queue
     Before we queue more commands                */
  cleanUpMgQ(con);
  
  /* Delete the entry from the hash list */
  mgCtx = con->mgBlock->mgCtx;
  
  while(mgCtx)
  {
    next = mgCtx->next;

    cmHashListDelete(&ccMgctInsTbl, (PTR) mgCtx);
    if(mgCtx->mgSapCb)
      cmHashListDelete(&(mgCtx->mgSapCb->ccMgInsTbl), (PTR) mgCtx);
    mgCtx->suCtxId = 0;
    mgCtx->contextId = 0;
    
    mgCtx = next;
  }

  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

   switch(con->relPend)
   {
     case INRELRSPANDNOREL:
     {
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       if(con->ogRscVal == TRUE)
         ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_INCOMING);
#else
       ccDeallocateResource(con, CC_INCOMING);
#endif
     }
     break;

     case OUTRELRSPANDNOREL:
     {
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       /* If not sure, add an extra check for ogRscVal */
       if(con->icRscVal == TRUE)
          ccDeallocateResource(con, CC_INCOMING);
       con->icRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
       ccDeallocateResource(con, CC_OUTGOING);
#endif
     }
     break;

     case INRELRSPANDOUTRELRSP:
     {
#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
       ccDeallocateResource(con, CC_OUTGOING);
#endif
       con->ogRscVal = FALSE;

       CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

       if(con->direction == INCTOOUT)
         con->direction = OUTTOINC;
       else
         con->direction = INCTOOUT;
       if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

#ifdef GUARD_TIMER
       ccGuardOrDeallocResource(con, CC_INCOMING);
#else
       ccDeallocateResource(con, CC_INCOMING);
#endif
     }
     break;

     case NORELANDNORELRSP:
     {
       if (con->lastState == CCS_AWTRSPFORDPE32)
       {
         con->lastState = con->state;

         /* This is a forward Call scenario */
         ret = ccForwardCallAPI(con);
         if (ret == RFAILED)
         {
           ccStopConTmr(con, TMR_SETUP);
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, CCCALLCLR, NULL);
         }
         RETVALUE(ROK);
       }
       /* This happens, during MParty Calls, when both resoources were
        * moved out */
       ccRelCon(con);
       RETVALUE(ROK);
     }
     break;

#if 1 /* Bug# 63245 */
     case OUTRELANDINFAILCOND:
     {
       /* No point in playing treatment to incoming that could result in
          going to MG as it is already in congestion */
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
     }
     break;
    
     case NORELANDINFAILCOND:
     { /* No point in processing failCond as MG is already in congestion ,
          release the call with temporary failure */
       ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
     }
     break;
#endif
     default:
       CCLOGERR( "ERROR: Unexpected relPend=%d\n", con->relPend);
     break;
   }
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE48S52
 *
 *             event - CCE_TSUSPEXP 
 *             state - CCS_AWT_RESUME
 *
 *             Event 48:Suspend Timer Expiry, State 52:AWT_RESUME (CAS / CCCS)
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE48S52
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16         ret           = RFAILED;
#ifdef CC_CALEA
  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
#endif 


    /* rkhan, bug#26079 */
    if (con->callDtlInfo.cm.tckRelIndRcvd.val)
    {
        /* Bug# 20640 */ 
        con->callDtlInfo.cm.tckRelIndRcvd.pres = PRSNT_NODEF;
    }
    else 
    {
       /* bug#35437, tfredericks. Guarantee that a Release Indication time is set. */
       
       con->callDtlInfo.cm.tckRelIndRcvd.pres = PRSNT_NODEF;
       (Void) SGetSysTime(&con->callDtlInfo.cm.tckRelIndRcvd.val);
    }

    con->direction = con->suspendDirection;
    /* Release the call now */
    {
        S16 tmdRel = 0;

        /* CPDI */
        ccStopConTmr(con, CC_TMR_TIMEOUT);
	/* CPDI */
        /* bug72209 */
        con->tempHolderForReleaseCause = CCTMRRECOV;

	if (con->direction == OUTTOINC)
	  {
	    ret = ccProcessDiscWithTmdRel(con, event);
            /* TEMP BLOCK MCAO_DOUBT */
	    if (ret == ROK)
               {
                   RETVALUE(ROK);
               }
	  }    
        ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
        if (con->surrogate != NULLP)
           ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
        if (ret == ROK)
        {
          CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
          RETVALUE(ROK);
        }
        else if (ret == RFAILED)
        {
          CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
        }
        /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
        CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

        /* Release the call */
        ccStopConTmr(con, CC_TMR_CALLDTL);
        ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

#ifdef CC_CALEA
        if (icProtType != CC_LOCAL_SWT_PROT)
        {
           /* Make sure ur in Tapped Con */
           ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
           if (ret != ROK)
           {
              CCDP(AIN_DBG_LEVEL_4,
              "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
           }
        }
#endif
        /* Initiate De-switching */
        if (CC_IS_CONTEXT_PRESENT(con))
        {
          /* Blow off the switching and Release the Call */
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */

          con->lastState = con->state;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
          con->mgBlock->con = con;
          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret != ROK)
          {
            cleanUpMgQ(con);
            CCLOGERR( "ERROR occured \n");
          }
          else
           RETVALUE(ROK);
        }
        else
        {
#ifdef CALEA_3WC
          if (con->icProtType == CC_LOCAL_SWT_PROT)
          {
             if (con->icBcm.cc != NULLP)
             {
                if (con->icBcm.cc->tappedLegId != NULLP)
                {
                   CCDP(AIN_DBG_LEVEL_0,"Deswitching of CALEA  in Tapped con\n");
                   /* bug# 17896 */ 
                   ccUpdateCloseCause(con, CC_BOTH, CscCallTerminated); 
                   ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, 
                                         event, CCE_TSUSPEXP, 0);
                   RETVALUE(ROK);
                }
                else
                   CCLOGERR( "ERROR: con->icBcm.cc->tappedLegId is NULLP\n");
             } 
             else
                CCLOGERR( "ERROR: con->icBcm.cc is NULLP \n");

          } 
          else
#endif 
          CCLOGERR( "ERROR: No Switching Context Found\n");
        }

        /* Anyway go ahead and clean up the call */
        tmdRel = ccIsTmdRelRequired(con);
        switch(tmdRel)
        {
          case CC_IC_TMD_RELEASE:
            ccApplyTmdRelease(con, &con->icRsc);
            con->tmdRelApplied = CC_IC_TMD_RELEASE;
            CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

            if(con->ogRscVal == TRUE)
              ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                            con->ogSuConnId, con->ogProtType,
                            CCCALLCLR, NULL);

            break;

          case CC_OG_TMD_RELEASE:
            ccApplyTmdRelease(con, &con->ogRsc);
            con->tmdRelApplied = CC_OG_TMD_RELEASE;
            CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

            if(con->icRscVal == TRUE)
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, CCCALLCLR, NULL);
            break;

          default :
          {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                          con->icProtType, CCCALLCLR, NULL);
            if(con->ogRscVal == TRUE)
               ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                             con->ogSuConnId, con->ogProtType,
                             CCCALLCLR, NULL);
          }
          break;
        }
    /* Release the call */
    RETVALUE(ROK);
    }

    RETVALUE(ROK);
} /* end ccConE48S52 */


/*
 *
 *      Fun:   ccConE49S53
 *
 *             event:49 - CCE_TTMDRELEXP 
 *             state:53 - CCS_AWT_TMDRELEXP (CAS / CCCS)
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE49S53
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  Bool            notIndFlag         = FALSE;

  switch(con->tmdRelApplied)
  {
    case CC_IC_TMD_RELEASE:
      con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
      if(con->ogRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      }
         
      ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                    con->icProtType, CCCALLCLR,
                    NULL);

      break;

    case CC_OG_TMD_RELEASE:
      con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
      if(con->icRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
      }
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, CCCALLCLR,
                    NULL);
      break;
#if 1 /* CPDI */
    case CC_IC_TMD_RELEASE_CPDI:
    {
        SvcHeader_t          header;
        ODisconnect_t        oDisconnect;
        U8                   index  = 0;
        AinBCM_t             *pBcm  = &(con->icBcm);
    
        con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

        /* if it's a CPDI case, send O_disconnect to FIC */
        if ((pBcm->nel[EReqODisconnectCalled] == NEL_REQUEST)  ||
            (pBcm->nel[EReqODisconnectCalled] == NEL_NOTIFY))
        {
           if ((pBcm->svcHeader.transId == 0) || (pBcm->cc == NULLP))
           {
             CCDP(AIN_DBG_LEVEL_4, "Critical Error, transId = %ld\n",
                                pBcm->svcHeader.transId);
             RETVALUE(RFAILED);
           }

            cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
            cmMemset((U8 *)&oDisconnect, 0, sizeof(ODisconnect_t));
        
            /* 28361 */
            ccRegenerateEvntHold(con);

            /* Fill in parameters in the Service Header Structure */
            ccFillSvcHeader(&header, pBcm, MSG_O_Disconnect);
            CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");
      
            notIndFlag = (pBcm->nel[EReqODisconnectCalled] == NEL_REQUEST) ?
                          FALSE: TRUE;

            /* Fill in parameters in the O_Disconnect Structure */
            ccFillODisconnectParam(&oDisconnect, pBcm, notIndFlag);
            /* FID: 15045.1 */
            ccFillUUdata(&(oDisconnect.uuData),pBcm);
            CCDP(AIN_DBG_LEVEL_0," Filled O_Disconnect, TransID=%ld\n",
                 header.spTransId);

            if (pBcm->nel[EReqODisconnectCalled] == NEL_REQUEST)
            {
                CCDP(AIN_DBG_LEVEL_0, "ODisconnectCalled requested:0x%lx\n",
                                      con->icSuConnId);
                for (index = 0; index < EReqMax; index++)
                    pBcm->nel[index] = NEL_UNARMED;
                con->lastState = con->state;
                CC_STATE_CHANGE(con, CCS_AWTRSPODISCONNECT);
                ccChangeCallStateOfAssociatedCalls(pBcm,
                                                   CCS_CANNOTPROCESSEVENTS);
                CcUiFctODisconnect(&oDisconnect, &header);
                RETVALUE(ROK);
            }
            else
            {
                CCDP(AIN_DBG_LEVEL_0, "ODisconnectCalled notification:0x%lx\n",
                                      con->icSuConnId);
                CcUiFctODisconnect(&oDisconnect, &header);
            }
        }
        if(con->ogRscVal == TRUE)
        {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
        }
        else
        {
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        }
         
        ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                      con->icProtType, CCCALLCLR, NULL);
        RETVALUE(ROK);
    }
#endif      
    default :
      if(con->icRscVal == TRUE && con->ogRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
      }
      else if(con->icRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      }
      else if(con->ogRscVal == TRUE)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
      }
      break;
  }

  RETVALUE(ROK);
} /* end ccConE49S53 */


/*
 *
 *      Fun:   ccConE50SXX
 *
 *             event:50 - CCE_TNOANSEXP
 *             state:09 - CCS_AWTANS, CCS_AWTSWTCFM, CCS_AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE50SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16                  ret        = RFAILED;
   SvcHeader_t          header;
   TNoAnswer_t          tNoAnswer;
   U8                   index      = 0;
   msgValCcIDEnum       ccId       = CiInvalid;

   TRC3(ccConE50SXX)
   CCDP(AIN_DBG_LEVEL_1,"ccConE50SXX: T_NO_ANSWER timer expiry event\n"); 
   /* Send TNoAnswer message to FIC */

   /* Feature 1789 - German ISUP */
   /* stop the Toiw2 Timer if running */
   ccStopConTmr(con, CC_TMR_TOIW2);

   if (con->ogBcm.svcHeader.transId == 0)
   {
     CCLOGERR( "Critical Error, transId = %ld\n",
                            con->ogBcm.svcHeader.transId);
     RETVALUE(RFAILED);
   }
   /* Initializing the message buffers */
   cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
   cmMemset((U8 *)&tNoAnswer, 0, sizeof(TNoAnswer_t));

   if(con->ccHeldSdpForCfna)
   {
     /* for CFNA  */
     if(con->ccHeldSdpForCfna->numDecode)	/* sdp changed here... Bart */
     {
      cmGetCleanSdp(ccInit.region, ccInit.pool, &(con->ogIpParam.locDesc));
      cmCpyAndFreeSdp(ccInit.region, ccInit.pool, con->ogIpParam.locDesc,
          &con->ccHeldSdpForCfna); 
     }
     else
     {
      cmGetCleanSdp(ccInit.region, ccInit.pool, &(con->icIpParam.rmtDesc));
      cmCpyAndFreeSdp(ccInit.region, ccInit.pool, con->icIpParam.rmtDesc,
         &con->ccHeldSdpForCfna); 
     }
    
   }
    
   /* FillBCMInfo for TBCM */
   if (con->ogBcm.cc)
     ccId = con->ogBcm.cc->ccId;
   else
     ccId = CiTerminatingSetup;

   ret = ccFillBCMInfo(con, &(con->ogBcm), con->ogBcm.svcHeader.transId,
                       ccId, PicTAlerting, BtTBcm,
                       DP_T_NO_ANSWER);    

   /* Cleaning up the NEL as per R5-241 GR1298 */
   for (index = 0; index < EReqMax; index++)
   {
      con->ogBcm.nel[index] = NEL_UNARMED;
   }
   /* Fill in parameters in the Service Header Structure */
   ccFillSvcHeader(&header, &(con->ogBcm), MSG_TNoAnswer); 
   CCDP(AIN_DBG_LEVEL_2," Filled SvcHeader\n");

   /* Fill in parameters in the TNoAnswer Structure */
   ccFillTNoAnswerParam(&tNoAnswer, &(con->ogBcm), FALSE);
   CCDP(AIN_DBG_LEVEL_2,"Filled TNoAnswerParam\n"); 

   con->lastState = con->state;
   CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE32);
   ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);

   /* Send the TNoAnswer message to the FIC */
   CCDP(AIN_DBG_LEVEL_2," TNoAnswer, TransID=%ld\n",
        header.spTransId);
   CcUiFctTNoAnswer(&tNoAnswer, &header);
   RETVALUE(ROK);
   
} /* End of ccConE50SXX */


/*
 *
 *      Fun:   ccConE51SXX
 *
 *             event:51 - CCE_ONOANSEXP
 *             state:09 - CCS_AWTANS, CCS_AWTSWTCFM, CCS_AWTANSSWT
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE51SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16                  ret        = RFAILED;
   SvcHeader_t          header;
   ONoAnswer_t          oNoAnswer;
   U8                   index      = 0;
   msgValCcIDEnum       temp_ccId  = CiInvalid;
   Bool                 notify     = FALSE;

   CCDP(AIN_DBG_LEVEL_1, "%s: Encountered O_NO_ANSWER timer expiry event\n",
        __FUNCTION__);
   /* Send ONoAnswer message to FIC */

   /* Feature 1789 - German ISUP */
   /* stop the Toiw2 Timer if running */
   ccStopConTmr(con, CC_TMR_TOIW2);
   /* BUG:84642 Fix the CC_TMR_AWAITANS time out issue*/
   if (CC_IS_ICA_CALL(con))
   {
     ccStopConTmr(con, CC_TMR_AWAITANS);
   }

   /* Initializing the message buffers */
   cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
   cmMemset((U8 *)&oNoAnswer, 0, sizeof(ONoAnswer_t));

   if (con->icBcm.svcHeader.transId == 0)
   {
     CCLOGERR( "Critical Error, transId = %ld\n",
                           con->icBcm.svcHeader.transId);
     RETVALUE(RFAILED);
   }
   if (con->icBcm.cc)
     temp_ccId = con->icBcm.cc->ccId;
   else
     temp_ccId = CiOriginatingSetup;

   /* FillBCMInfo for TBCM */
   ret = ccFillBCMInfo(con, &(con->icBcm), con->icBcm.svcHeader.transId,
                       temp_ccId,PicOAlerting, BtOBcm, DP_O_NO_ANSWER);

   /* bug70975 */
   if (con->icBcm.nel[EReqONoAnswer] == NEL_REQUEST)
   {
       /* Cleaning up the NEL as per R5-241 GR1298 */
       for (index = 0; index < EReqMax; index++)
       {
          con->icBcm.nel[index] = NEL_UNARMED;
       }
       con->lastState = con->state;
       CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE33);
       ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                          CCS_CANNOTPROCESSEVENTS);
   }
   else if (con->icBcm.nel[EReqONoAnswer] == NEL_NOTIFY)
       notify = TRUE;
   else
   {
       CCDP(AIN_DBG_LEVEL_0, "Suprizingly Event not armed:icSu:0x%lx\n",
            con->icSuConnId);
       RETVALUE(ROK);
   }

   con->tempHolderForReleaseCause = CCCALLCLR;
   /* Fill in parameters in the Service Header Structure */
   ccFillSvcHeader(&header, &(con->icBcm), MSG_O_No_Answer);
   CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

   /* Fill in parameters in the ONoAnswer Structure */
   ccFillONoAnswerParam(&oNoAnswer, &(con->icBcm), notify);
   CCDP(AIN_DBG_LEVEL_0,"Filled ONoAnswerParam\n");

   /* Send the ONoAnswer message to the FIC */
   CCDP(AIN_DBG_LEVEL_0," ONoAnswer, TransID=%ld\n", header.spTransId);
   CcUiFctONoAnswer(&oNoAnswer, &header);
   RETVALUE(ROK);
   
} /* End of ccConE51SXX */

/*
 *
 *      Fun:   ccConE53SXX
 *
 *             event:53 - CCE_ORIGINATE_CALEA_CALL
 *             state:     CCS_AWTRSPFORDPE22, CCS_AWTRSPFORDPE20, CCS_AWTRSPFORDPE30 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE53SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
   CcConCb *caleaCon = NULLP;
   SvcHeader_t          header;
   InfoCollected_t infoCollected;
   U8 index = 0;
   msgValCcIDEnum temp_ccId = CiInvalid;
   SvcHeader_t       *occSvcHeader    = NULLP;
   U8 leaIndex = 0;
   TRC3(ccConE53SXX)

/* Handling of the Svc Header with ERROR */ 
   CCDP(AIN_DBG_LEVEL_1, "ccConE53SXX: %ld\n", con->icSuConnId);
   occSvcHeader = (SvcHeader_t *) event;

   if (occSvcHeader->lastTransactionFlag == TRUE)
     ccDeleteBcm(&(con->ogBcm));

   for (leaIndex = MAX_CALEALEGS_PER_SUB ; leaIndex > 0; leaIndex--)
   {
     if (con->ogBcm.cc->caleaLegId[leaIndex-1] != NULLP)
     {
       caleaCon = con->ogBcm.cc->caleaLegId[leaIndex-1]->con;
       break;
     }
   } 
/* Normal Call Flow */
 
   /* Process the caleaCon */
#if 0
   con->icRscVal = TRUE; /* Assume the icRsc is allocated for Ingress */ 
#endif

   if (ccCopyCdPty2ClAddr(caleaCon) != ROK)
   {
      CCDP(AIN_DBG_LEVEL_2," Populating the Called Party Address failed\n");
      ccStopConTmr(con, TMR_SETUP);
      ccCp.sts.fRoutUnavail++;
      ccRelCon(caleaCon);
      RETVALUE(RFAILED);
   }

   /* Initializing the message buffers */
   cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
   cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

   temp_ccId = caleaCon->icBcm.cc->ccId;

   ccUpdateBcm(caleaCon, PicCollectInformation, temp_ccId, BtOBcm);

   /* Cleaning up the NEL as per R5-241 GR1298 */
   for (index = 0; index < EReqMax; index++)
   {
      caleaCon->icBcm.nel[index] = NEL_UNARMED;
   }
   /* Fill in parameters in the Service Header Structure */
   ccFillSvcHeader(&header, &(caleaCon->icBcm), MSG_Info_Collected);
   CCDP(AIN_DBG_LEVEL_2," Filled SvcHeader\n");

   /* Fill in parameters in the Info Collected Structure */
   ccFillInfoColltdParam(&infoCollected, &(caleaCon->icBcm));
   CCDP(AIN_DBG_LEVEL_2," Filled InfoCollected\n");

   CC_STATE_CHANGE(caleaCon, CCS_AWTRSPFORDPE3);

   /* Send the Info Collected message to the FIC */
   CCDP(AIN_DBG_LEVEL_3," Sending InfoCollected\n");
   CcUiFctInfoCollected(&infoCollected, &header);
#endif /* End of CC_CALEA */

   RETVALUE(ROK);
} /* End of ccConE53SXX */

/*
 *
 *      Fun:   ccConE53S36
 *
 *             event:53 - CCE_ORIGINATE_CALEA_CALL
 *             state:36 - CCS_AWTRSPFORDPE1 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE53S36
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
   CcConCb *caleaCon = NULLP;
   SvcHeader_t          header;
   InfoCollected_t infoCollected;
   U8 index = 0;
   msgValCcIDEnum temp_ccId = CiInvalid;
   SvcHeader_t       *occSvcHeader           = NULLP;
   U8 leaIndex = 0;

   TRC3(ccConE53S36)
/* Code that handles the ERROR received in Fic Svc Header */
   CCDP(AIN_DBG_LEVEL_1, " ccConE53S36 : %ld\n", con->icSuConnId);
   occSvcHeader = (SvcHeader_t *) event;

   if (occSvcHeader->lastTransactionFlag == TRUE)
   {
     if (con->icBcm.cc)
     {
       if (con->icBcm.cc->ccId != CiForward)
         ccDeleteBcm(&(con->icBcm));
     }
     else
       ccDeleteBcm(&(con->icBcm));
   }

   for (leaIndex = MAX_CALEALEGS_PER_SUB ; leaIndex > 0; leaIndex--)
   {
     if (con->icBcm.cc->caleaLegId[leaIndex-1] != NULLP)
     {
       caleaCon = con->icBcm.cc->caleaLegId[leaIndex-1]->con;
       break;
     }
   } 
/*  Normal CAll flow */
   /* Process the caleaCon */
#if 0
   con->icRscVal = TRUE; /* Assume the icRsc is allocated for Ingress */ 
#endif
   /* Start the SETUP timer for Calea Call */
   ccStartConTmr(TMR_SETUP, caleaCon, (PTR)&ccCp.genCfg);
   ccCp.sts.totalCalls++;

   if (ccCopyCdPty2ClAddr(caleaCon) != ROK)
   {
      CCDP(AIN_DBG_LEVEL_2," Populating the Called Party Address failed\n");
      ccStopConTmr(con, TMR_SETUP);
      ccCp.sts.fRoutUnavail++;
      ccRelCon(caleaCon);
      RETVALUE(RFAILED);
   }

   /* Initializing the message buffers */
   cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
   cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

   temp_ccId = caleaCon->icBcm.cc->ccId;

   ccUpdateBcm(caleaCon, PicCollectInformation, temp_ccId, BtOBcm);

   /* Cleaning up the NEL as per R5-241 GR1298 */
   for (index = 0; index < EReqMax; index++)
   {
      caleaCon->icBcm.nel[index] = NEL_UNARMED;
   }
   /* Fill in parameters in the Service Header Structure */
   ccFillSvcHeader(&header, &(caleaCon->icBcm), MSG_Info_Collected);
   CCDP(AIN_DBG_LEVEL_2," Filled SvcHeader\n");

   /* Fill in parameters in the Info Collected Structure */
   ccFillInfoColltdParam(&infoCollected, &(caleaCon->icBcm));
   CCDP(AIN_DBG_LEVEL_2," Filled InfoCollected\n");

   CC_STATE_CHANGE(caleaCon, CCS_AWTRSPFORDPE3);

   /* Send the Info Collected message to the FIC */
   CCDP(AIN_DBG_LEVEL_3," Sending InfoCollected\n");
   CcUiFctInfoCollected(&infoCollected, &header);
#endif /* End of CC_CALEA */

   RETVALUE(ROK);
} /* End of ccConE53S36 */

/*
 *
 *      Fun:   ccConE11S50
 *        
 *             event:11 - CCE_MGCTTXNCFM
 *             state:50 - CCS_AWTCALEALEGSWTCFM 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE11S50
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
   MgctTxnCfm    *txnCfm         = NULLP;
   CcRelEvnt ogEvnt;
   Bool       ic_suspendCall = FALSE;
   Bool       og_suspendCall = FALSE;
   Bool        suspendCall   = FALSE;
   ProtType icProtType       = CC_GET_PROTOCOL(con->icProtType);
   S16 ret = ROK; 
   S16 tmdRel = 0;
   Bool mgiReqFailed = FALSE;  

#ifdef ZC
    ZcUpdParam upd;
#endif /* ZC */
   
   TRC3(ccConE11S50)   

   CCDP(AIN_DBG_LEVEL_1, "ccConE11S50\n"); 

   /* bug 91532 */
   cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

   txnCfm   = (MgctTxnCfm*) event;
   ret = ccHandleMgResponse(con, txnCfm);

   if (ret == RFAILED)
   {
      /* Even though the subReq failed, go ahead sending RelRsp to CaleaCon and
       * put back the Tapped State machine to its original state */ 
      CCLOGERR( "ERROR:MGI SubReq FAILED\n"); 
      mgiReqFailed = TRUE; 
   }

   /* Send RelRsp to the CaleaLeg for which MGI SubReq Failed/Succeeded */ 
   if ((con->icBcm.cc == NULLP) && (con->ogBcm.cc == NULLP))
   {
      /* Bug# 15511 */
      /* LEA can be in Surrogate BCM, hence go ahead */
      CCLOGERR( "CRITICAL ERROR:BOTH con->icBcm.cc  and con->ogBcm.cc are NULLP\n");
   } 

   if ((con->mgiPendRelRsp & ORGSUBRELRSP) ||
      (con->mgiPendRelRsp & TERMSUBRELRSP))      
   {
      CC_STATE_CHANGE(con, con->lastState); 
      if (con->state == CCS_AWTSWTCFM_SENDBOTHREL)
      {
         tmdRel = ccIsTmdRelRequired(con);
         switch(tmdRel)
         {
            case CC_IC_TMD_RELEASE:
               ccApplyTmdRelease(con, &con->icRsc);
               con->tmdRelApplied = CC_IC_TMD_RELEASE;
               CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

               if(con->ogRscVal == TRUE)
                 ccSendRelease(con, con->ogSapCb, con->ogSpConnId, 
                               con->ogSuConnId,
                               con->ogProtType, CCCALLCLR, NULL);
               break;

            case CC_OG_TMD_RELEASE:
               ccApplyTmdRelease(con, &con->ogRsc);
               con->tmdRelApplied = CC_OG_TMD_RELEASE;
               CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

               if(con->icRscVal == TRUE)
                 ccSendRelease(con, con->icSapCb, con->icSpConnId, 
                               con->icSuConnId,
                               con->icProtType, CCCALLCLR, NULL);
               break;

            default :
            {
               if (con->ogRscVal == TRUE)
               {
                 CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
               }
               else
               {
                 CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
               }
               if (con->evntHeld == CCE_INITRELIND)
               {
                  ccProcRelCall(con, (CcStaEvnt *)con->ccEvntHold);
                  RETVALUE(ROK);
               }
               ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                   con->icProtType, CCCALLCLR, NULL);
               if(con->ogRscVal == TRUE)
               {
                  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, CCCALLCLR, NULL);
               }
            }
            break;
         }
         RETVALUE(ROK);
      }
      else if (con->state == CCS_AWTSWTCFM_SENDONEREL)
      {
         con->icEvnt = con->ccEvntHold;
         con->ogEvnt = (CcAllSdus *) &ogEvnt;

         switch(con->relPend)
         {
            case ICRELONLY:
            {
               /* This is a case of tones */
               if(con->ogRscVal == TRUE)
                  ccDeallocateResource(con, CC_OUTGOING);
               con->ogRscVal = FALSE;

               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
               ccSendRelease(con, con->icSapCb, con->icSpConnId, 
                             con->icSuConnId, con->icProtType, 
                             con->tempHolderForReleaseCause, NULL);
               RETVALUE(ROK);
            }
            break;

            case OGRELONLY :
            {
               /* This is a case of CFDA */
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
               ccSendRelease(con, con->ogSapCb, con->ogSpConnId, 
                             con->ogSuConnId, con->ogProtType, 
                             con->tempHolderForReleaseCause, 
                             NULL);
               RETVALUE(ROK);
            }
            break;

            case INRELRSPANDOUTREL:
            {
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
               ccGuardOrDeallocResource(con, CC_INCOMING);
#else
               ccDeallocateResource(con, CC_INCOMING);
#endif
               con->icRscVal = FALSE;

               con->direction = INCTOOUT;
               if (con->noRspReqd == FALSE) 
                  ccSendReleaseRsp(con);

               ret = ccMapEvent(con, CCE_RELIND, 0);
               if (ret != ROK)
               {
                  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, 
                                con->ogSuConnId,
                                con->ogProtType, CCPROTERR,NULL);
                  RETVALUE(ROK);
               }
               ccSendReleaseReq(con);
            }
            break;

            case OUTRELRSPANDINREL:
            {
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
               ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
               ccDeallocateResource(con, CC_OUTGOING);
#endif
               con->ogRscVal = FALSE;

               con->direction = OUTTOINC;
               if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

               ret = ccMapEvent(con, CCE_RELIND, 0);
               if (ret != ROK)
               {
                  ccSendRelease(con, con->icSapCb, con->icSpConnId, 
                                con->icSuConnId,
                                con->icProtType, CCPROTERR,NULL);
                  RETVALUE(ROK);
               }
               ccSendReleaseReq(con);
            }
            break;

            case ICRELONLYKEEPCON:
            {
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);
              RETVALUE(ROK);
            }
            break;

            case OGRELONLYKEEPCON:
            {
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_KEEP_CON);
              ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                  con->ogProtType, CCCALLCLR, NULL);
              RETVALUE(ROK);
            }
            break;

            default :
               CCLOGERR( "ERROR: NoOne expected this relPend value = %d\n",
                          con->relPend);
            break;
         } /* switch on con->relPend */
         RETVALUE(ROK);
      }
      else
      {
         CCDP(AIN_DBG_LEVEL_4,"Error, not a valid state at this time \n");
      }
   }
   if (con->mgiPendRelRsp)
   {
      ccProcessCaleaMgiSubRsp(con, mgiReqFailed);
      con->mgiPendRelRsp = 0;
   }

   if (con->mgiPendAddRsp)
   {
      ccProcessCaleaMgiAddRsp(con, mgiReqFailed); 
      con->mgiPendAddRsp = 0;
   }

   /* Check out if Tapped subjects have released the call */ 
   if ((con->mgiPendRelReq & ORGSUBRELREQ) || 
       (con->mgiPendRelReq & TERMSUBRELREQ))
   {
      if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                           con->direction))
      {

         if (con->lastState == CCS_AWT_RESUME)
         {
            /* Bug# 18105 */
            /* From E03S52 */
            /* CALEA release was received when con->state was in CCS_AWT_RESUME */
            CC_STATE_CHANGE(con, con->lastState);
            if (con->ccEvntHold)
               cmMemcpy( (U8 *)event, (U8 *) con->ccEvntHold, sizeof(CcCnStEvnt));
            if (con->mgiPendRelReq & ORGSUBRELREQ)
            {
               con->mgiPendRelReq &= ~ORGSUBRELREQ;
            }
            else
            {
               con->mgiPendRelReq &= ~TERMSUBRELREQ;
            }
            ccConE03S52(con, event, bcm, event2);
            RETVALUE(ROK);
         }

         /* this is taken from ccConE03S10 */
         /* For CAS */
         if (con->icBcm.cc)
         {
            if (!((con->icBcm.cc->ccId >= CiThreePartySetup) &&
               (con->icBcm.cc->ccId <= CiStableMParty)))
            {
               CCDP(AIN_DBG_LEVEL_0, "icBcm.cc->ccId = %d\n", con->icBcm.cc->ccId);
               ic_suspendCall = TRUE;
            }
         }
         else
            ic_suspendCall = TRUE;

         if (con->ogBcm.cc)
         {
            if (!((con->ogBcm.cc->ccId >= CiThreePartySetup) &&
               (con->ogBcm.cc->ccId <= CiStableMParty)))
            {
               CCDP(AIN_DBG_LEVEL_0, "ogBcm.cc->ccId = %d\n", con->ogBcm.cc->ccId);
               og_suspendCall = TRUE;
            }
         }
         else
            og_suspendCall = TRUE;

         if ((ic_suspendCall) && (og_suspendCall))
         {
            if (ccIsSuspRequired(con) == CC_SUSP_REQUIRED)
               suspendCall = TRUE;
         }
         else
            suspendCall = FALSE;

         if (suspendCall)
         {
            CC_STATE_CHANGE(con, CCS_AWT_RESUME);
            ccSuspendCall(con, (PTR)con->ccEvntHold);

            RETVALUE(ROK);
         }
         else
         {
            S16 tmdRel = 0;

            ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
            if (con->surrogate != NULLP)
               ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
            if (ret == ROK)
            {
               CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
               RETVALUE(ROK);
            }
            else if (ret == RFAILED)
            {
               CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
            }
            /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
            CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");
#ifdef CC_CALEA
            if (icProtType != CC_LOCAL_SWT_PROT)
            {
               /* Make sure ur in Tapped Con */
               ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
               if (ret != ROK)
               {
                  CCDP(AIN_DBG_LEVEL_4,
                   "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
               }
            }
#endif
            /* Release the call incase of CAS */
            if (CC_IS_CONTEXT_PRESENT(con))
            {
              /* Blow off the switching and Release the Call */
              ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId,
                                   con);
              ccStopConTmr(con, CC_TMR_CALLDTL);
              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

              if (con->lastState == CCS_AWTBUSYREL_IC)
              {
                con->relPend = ICRELONLY;
                con->lastState = CCS_AWTSWTCFM_SENDONEREL;
              } 
              else
              {
                con->relPend = BOTHREL;
                con->lastState = CCS_AWTSWTCFM_SENDBOTHREL;
              }
#ifdef ZC      
              upd.icSuConnId = con->icSuConnId;
              zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
              zcUpdPeer();
#endif
              con->mgBlock->con = con;
              ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
              /* Bug# 18105 */
              if (con->mgiPendRelReq & ORGSUBRELREQ)
              {
                con->mgiPendRelRsp |= ORGSUBRELRSP;
                con->mgiPendRelReq &= ~ORGSUBRELREQ;
              }
              else
              {
                con->mgiPendRelRsp |= TERMSUBRELRSP;
                con->mgiPendRelReq &= ~TERMSUBRELREQ;
              }
              con->mgiPendAddReq = 0;
            }
            else
            {
               ret = RFAILED; 
               CCLOGERR("CRITICAL ERROR:: suCtxID is 0 \n");
            }
            if (ret != ROK)
            {
               /* Anyway Go ahead and Clean the Call */
               ccStopConTmr(con, CC_TMR_CALLDTL);
               ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC      
               upd.icSuConnId = con->icSuConnId;
               zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
               zcUpdPeer();
#endif
               tmdRel = ccIsTmdRelRequired(con);
               switch(tmdRel)
               {
               case CC_IC_TMD_RELEASE:
                  ccApplyTmdRelease(con, &con->icRsc);
                  con->tmdRelApplied = CC_IC_TMD_RELEASE;
                  CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

                  if(con->ogRscVal == TRUE)
                    ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                                  con->ogSuConnId, con->ogProtType,
                                  CCCALLCLR, NULL);
                  break;

               case CC_OG_TMD_RELEASE:
                  ccApplyTmdRelease(con, &con->ogRsc);
                  con->tmdRelApplied = CC_OG_TMD_RELEASE;
                  CC_STATE_CHANGE(con, CCS_AWT_TMDRELEXP);

                  if(con->icRscVal == TRUE)
                    ccSendRelease(con, con->icSapCb, con->icSpConnId,
                                  con->icSuConnId, con->icProtType,
                                  CCCALLCLR, NULL);
                  break;

               default :
                  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                  ccSendRelease(con, con->icSapCb, con->icSpConnId,
                                con->icSuConnId, con->icProtType,
                                CCCALLCLR, NULL);
                  if(con->ogRscVal == TRUE)
                     ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                                   con->ogSuConnId, con->ogProtType,
                                   CCCALLCLR, NULL);
               }/* End of switch */
               RETVALUE(ROK);
            } 
         }
      }/* End of IF for CAS */ 
      else
      {
         if (con->lastState == CCS_AWT_RESUME)
         {
            /* Bug# 18105 */
            /* CALEA release was received when con->state was in CCS_AWT_RESUME */
            CC_STATE_CHANGE(con, con->lastState);
            cmMemcpy( (U8 *)event, (U8 *) con->ccEvntHold, sizeof(CcRelEvnt));
            if (con->mgiPendRelReq & ORGSUBRELREQ)
            {
               con->mgiPendRelReq &= ~ORGSUBRELREQ;
            }
            else
            {
               con->mgiPendRelReq &= ~TERMSUBRELREQ;
            }
            ccConE04S52(con, event, bcm, event2);
            RETVALUE(ROK);
         }
         ret = ccProcessDisconnectEvent(con, event);
#ifdef CC_CALEA
         if (con->surrogate != NULLP)
            ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
         if (ret == ROK)
         {
           CCDP(AIN_DBG_LEVEL_0,"ccProcessDisconnectEvent success,event detec.\n");
           RETVALUE(ROK);
         }
         else if (ret == RFAILED)
         {
           CCDP(AIN_DBG_LEVEL_3,"Failed to Check if (O/T)Disc event is armed\n");
         }
         /* If the ccProcessDisconnectEvent returns ROKDNA, we continue */
         CCDP(AIN_DBG_LEVEL_0, "O/T_Disconnect event is not Armed\n");

         ccStopConTmr(con, CC_TMR_CALLDTL);

         /* Release all connections */
         /* Blow off the the switching fabric Connection */
         ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
         /* CALL release before the Tapped subject goes to ANSWERED state */
         if (icProtType != CC_LOCAL_SWT_PROT)
         {
            /* Make sure ur in Tapped Con */
            ret = ccProcessDisconnectNotfnForCaleaLegs(con, event);
            if (ret != ROK)
            {
               CCDP(AIN_DBG_LEVEL_4,
                "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
            }
         }

         /* This is taken from ccConE04S10 */ 
         /* Release from any other protocol */
         /* Blow off the switching and Release the Call */
         ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
         if (con->direction == INCTOOUT)
           con->relPend = INRELRSPANDOUTREL;
         else
           con->relPend = OUTRELRSPANDINREL;

         CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
         /* Bug# 18105 */
         if (con->mgiPendRelReq & ORGSUBRELREQ)
         {
           con->mgiPendRelRsp |= ORGSUBRELRSP;
           con->mgiPendRelReq &= ~ORGSUBRELREQ;
         }
         else
         {
           con->mgiPendRelRsp |= TERMSUBRELRSP;
           con->mgiPendRelReq &= ~TERMSUBRELREQ;
         }

         con->mgBlock->con = con;
         ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
         con->mgiPendAddReq = 0;
         if (ret != ROK)
         {
            cleanUpMgQ(con);
            CCLOGERR( "ERROR: No Switching Ctx found\n");
            if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

            if (con->direction == INCTOOUT)
            {
               /* Deallocate the IC Resources */
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
#ifdef GUARD_TIMER
               ccGuardOrDeallocResource(con, CC_INCOMING);
#else
               ccDeallocateResource(con, CC_INCOMING);
#endif
               con->icRscVal = FALSE;
            }
            else if (con->direction == OUTTOINC)
            {
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
#ifdef GUARD_TIMER
               ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
               ccDeallocateResource(con, CC_OUTGOING);
#endif
               con->ogRscVal = FALSE;
            }

            ret = ccMapEvent(con, CCE_RELIND, 0);
            if (ret != ROK)
            {
               if (con->direction == INCTOOUT)
               {
                  ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                                con->ogSuConnId,
                                con->ogProtType, CCPROTERR,NULL);
               }
               else if (con->direction == OUTTOINC)
               {
                  ccSendRelease(con, con->icSapCb, con->icSpConnId, 
                                con->icSuConnId,
                                con->icProtType, CCPROTERR,NULL);
               }
               RETVALUE(ROK);
            }
            ccSendReleaseReq(con);

            RETVALUE(ROK);
         }
      }/* If of other protocol */
   }/* End of Orig and Term Release IF */

   if ((con->mgiPendRelReq) || (con->mgiPendAddReq))
   { 
   /* Now process any outstanding Calea subReq **********/ 
      if (con->mgiPendRelReq)
         ccProcessPendingCaleaMgiRelReq(con);
      if (con->mgiPendAddReq)
         ccProcessPendingCaleaMgiAddReq(con); 
      if ((con->mgiPendRelRsp != 0) || (con->mgiPendAddRsp != 0)) 
      {
         ccSendCaleaMgiReq(con);
         RETVALUE(ROK);
      } 
   }

   /* Put back the Tapped state machine back to original state */
   CC_STATE_CHANGE(con, con->lastState);
#endif
   RETVALUE(ROK); 
} /* End of ccConE11S50 */


/*
 *
 *      Fun:   ccConE01S50
 *        
 *             event:1 - CCE_CONCFM
 *             state:50 - CCS_AWTCALEALEGSWTCFM 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE01S50
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
   ccConE01S09(con, event, bcm, event2);
   con->lastState = con->state;
   CC_STATE_CHANGE(con,CCS_AWTCALEALEGSWTCFM); 
#endif
   RETVALUE(ROK);
} /* End of ccConE01S50 */

/*
 *
 *      Fun:   ccConE01S61
 *
 *             event:1  - CCE_CONCFM
 *             state:61 - CCS_NOTIFYRSPFORMSUB
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE01S61
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  U8                   index               = 0;
  OriginationAttempt_t originationAttempt;
  SvcHeader_t          header;
  CcConEvnt            *conEvnt = NULLP;

  conEvnt = (CcConEvnt *) event;

  if (con->icProtType == CC_MGCP_LN || con->icProtType == CC_MGCP_TG)
     ccExtractProtSdp(ccInit.region, ccInit.pool, con,
                      &(conEvnt->m.mgcpCctEvnt.sdp));

  CCDP(AIN_DBG_LEVEL_1, "ccConE01S61: %ld\n", con->icSuConnId);
  /* Send an Origination Attempt message to the FIC */

  ccStopConTmr(con, TMR_NOTIFYCC);
  ccStartConTmr(TMR_SETUP, con, (PTR)&ccCp.genCfg);

  /* Initializing the message buffers */
  cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
  cmMemset((U8 *)&originationAttempt, 0, sizeof(OriginationAttempt_t));

  /* Update icBcm parameters */
  ccUpdateBcm(con, PicONull, CiOriginatingSetup, BtOBcm);

  /* Cleaning up the NEL as per R5-241 GR1298 */
  for (index = 0; index < EReqMax; index++)
  {
    con->icBcm.nel[index] = NEL_UNARMED;
  }
  /* Fill in parameters in the Service Header Structure */
  ccFillSvcHeader(&header, &(con->icBcm), MSG_Origination_Attempt);

  /* Fill in parameters in the Info Collected Structure */
  ccFillOrigAttemptParam(&originationAttempt, &(con->icBcm), FALSE);

  if (ccInit.acnt == TRUE)
  {
#if 1 /* change from local time to UTC in billing */
      SwTimevalGet (&con->callDtlInfo.cm.timevalStart,
		    SW_TIMEVAL_IcConIndRcvd, NULL);
#else
      (Void) SGetDateTime(&con->callDtlInfo.cm.tmIcConIndRcvd);
#endif
      con->callDtlInfo.cm.tckIcConIndRcvd.pres = PRSNT_NODEF;
      (Void) SGetSysTime(&con->callDtlInfo.cm.tckIcConIndRcvd.val);
  }

  CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE1);

  /* Send the Origination Attempt message to the FIC */
  CCDP(AIN_DBG_LEVEL_0,"Sending OriginationAttempt, TransID = %ld\n",
                        header.spTransId);
  CcUiFctOriginationAttempt(&originationAttempt, &header);
  RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE03S50
 *        
 *             event:3 - CCE_CNSTIND
 *             state:50 - CCS_AWTCALEALEGSWTCFM 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE03S50
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    S16         ret           = RFAILED;
    CcCnStEvnt  ogEvnt;
    Buffer     *uBuf          = NULLP;
    ProtType   icProtType     = CC_GET_PROTOCOL(con->icProtType);

    /* First verify if a HOLD is in progress,  Both incoming and */
    /* outgoing resources shall be valid  if no HOLD is in progress */

    /* map connection status event */
    con->icEvnt = (CcAllSdus *)event;
    con->ogEvnt = (CcAllSdus *)&ogEvnt;
    cmMemset((U8 *)&ogEvnt, 0, sizeof(CcCnStEvnt));


    /* Store the event as it is needed in ccConE11S50 () */
    if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event, sizeof(CcCnStEvnt)))!= ROK)
    {
       CCDP(AIN_DBG_LEVEL_4,
            "ERROR !! Cannot store the CnStEvnt having ONHOOK\n"); 
    }

    /* If not a 911 caller */
    if (ccIs911HoldCall(con) == FALSE)
    {
        if (ccIsFlashRcvd(con->icProtType, con->ogProtType, con->icEvntType,
          con->direction))
        {
            con->lastState = con->state;
            ret = ccProcessMidCallEvent(con);
            if (ret == ROK)
            {
                CCDP(AIN_DBG_LEVEL_0, "ccProcessMidCallEvent success, event detected\n");
                RETVALUE(ROK);
            }
            else if (ret == RFAILED)
            {
                CCDP(AIN_DBG_LEVEL_3, "MidCall Requested Event to FIC failed\n");
            }
            /* If the ccProcessMidCallEvent returns ROKDNA, we continue*/
        }

        if (ccIsOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                           con->direction))
        {
            if (con->direction == INCTOOUT)
               con->mgiPendRelReq |= ORGSUBRELREQ;
            else
               con->mgiPendRelReq |= TERMSUBRELREQ; 
            RETVALUE(ROK); 
        }
    } /* If not a 911 caller */

    if ((con->direction == INCTOOUT) && (icProtType == CC_SI))
    {
      /* IC releases the Call when connection the Emergency call
          category type, DO NOT PASS THE RELEASE TO OG */

      CCDP(AIN_DBG_LEVEL_0, "No need to Map: %ld\n", con->icSuConnId);
      RETVALUE(ROK);
    }

    ret = ccMapEvent(con, CCE_CNSTIND, con->icEvntType);
    if (ret == CCIGNOREMAPPING)
    {
        ccDropUBuf(&con->uBuf);
        RETVALUE(ROK);
    }
    else if (ret != ROK)
    {
        CCDP(AIN_DBG_LEVEL_4,
            "CRITICAL ERROR: Can't send MGI subReq as we are in awt MGI SubReq for CALEA CAll\n"); 
        RETVALUE(RFAILED);
    }

    uBuf = con->uBuf;
    con->uBuf = NULLP;
    if (con->direction == INCTOOUT)
    {
        ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                      con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
    }
    else
    {
        ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                      con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                      con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
    }
   RETVALUE(ROK);
} /* End of ccConE03S50 */

/*
 *
 *      Fun:   ccConE04S50
 *        
 *             event:4 - CCE_RELIND
 *             state:50 - CCS_AWTCALEALEGSWTCFM 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE04S50
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
  /* This code is taken from ccConE04S10 */
  S16         ret           = RFAILED;

  /* FID 14732 */                      
  ccExtractSipwMBufFromRel(con, CCE_RELIND, (PTR) event);
  /* FID 14732 */

  if ((ret = ccStoreEvnt(con->evntType, con->icEvntType, con, (U8 *)event,
       sizeof(CcRelEvnt))) != ROK)
  {
    CCLOGERR( "ERROR: ccStoreEvnt()failed. Continuing with call\n");
  }

  if (con->direction == INCTOOUT)
     con->mgiPendRelReq |= ORGSUBRELREQ;
  else
     con->mgiPendRelReq |= TERMSUBRELREQ; 
#endif
   RETVALUE(ROK);
} /* End of ccConE04S50 */

/*
 *
 *      Fun:   ccConE54SXX
 *        
 *             event:54 - CCE_DATAREQ
 *             state:50 - CCS_AWTSWTCFM, CCS_ANSWERED, CC_AWTRSPFORDPE30,
 *                         CC_AWTRSPFORDPE11 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE54SXX
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
   SvcHeader_t  header;
   DataCfm_t    dataCfm;
   TRC3(ccConE54S10)

   CCDP(AIN_DBG_LEVEL_1, "ccConE54SXX: %ld\n", con->icSuConnId);

   /* Feature 1789 - German ISUP */
   /* stop the Toiw2 Timer if running */
   ccStopConTmr(con, CC_TMR_TOIW2);

   cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
   cmMemset((U8 *)&dataCfm, 0, sizeof(DataCfm_t));

   CCDP(AIN_DBG_LEVEL_0," TransId for TBCM = %ld\n",
          con->ogBcm.svcHeader.transId );
   ccFillSvcHeader(&header, &(con->ogBcm), MSG_Data_Cfm);

   /* Fill in parameters in the DATA CFM structure */
   ccFillDataCfmParam(&dataCfm, &(con->ogBcm));
   CCDP(AIN_DBG_LEVEL_0," Filled DataCfm, TransID = %ld\n",
        header.spTransId); 
   /* No Change of State is required, stay in the same state */
   CcUiFctDataCfm(&dataCfm, &header);
   CCDP(AIN_DBG_LEVEL_0,"Sending DataCfm\n");
 #endif
   RETVALUE(ROK);
}/* End of ccConE54SXX */

/*
 *
 *      Fun:   ccConE56S10
 *        
 *             event:56 - CCE_CALEALEGEXP
 *             state:10 - CCS_ANSWERED 
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE56S10
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#ifdef CC_CALEA
#ifdef ZC
   ZcUpdParam upd;
#endif /* ZC */

   if (zcCb.protState == ACTIVE)
   {
      CCDP(AIN_DBG_LEVEL_0,"CC_CALEA_LEG_TMR expired on ACTIVE \n"); 
      /* This is the case where Calea call was replicated and failover
       * occurred before the subjects answered */ 
      ccStopConTmr(con, CC_TMR_CALLDTL);
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
      /* REL CON */
      upd.icSuConnId = con->icSuConnId;
      zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
      ccSendRelease(con, con->ogSapCb, con->ogSpConnId,
                    con->ogSuConnId, con->ogProtType,
                    CCCALLCLR, NULL);
   }
   else
   {
      /* If the Timer expired on standby */
      CCDP(AIN_DBG_LEVEL_0,"CC_CALEA_LEG_TMR expired on STANDBY \n"); 
      ccGenAlarm(LCM_CATEGORY_PROTOCOL, LCM_EVENT_INV_STATE,
                 LCC_CAUSE_CALEALEGTMR_EXP, (U8 *) &con->icSuConnId); 
      ccRelCon(con);
   } 
#endif 
   RETVALUE(ROK);
} /* End of ccConE56S10 */

/*
 *
 *      Fun:   ccConE11S76
 *
 *      Desc:  Connection state function
 *             event - Switching Connect Confirm
 *             state - CCS_AWTSWTCFMFORCC6CC11
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE11S76
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   S16                       mgret          = RFAILED;
   MgctTxnCfm                *txnCfm        = NULLP;
   CcConCb                   *CSID1con      = NULLP;
   U8                        index          = 0; 
#ifdef ZC
  ZcUpdParam           upd;
#endif /* ZC */

   CCDP(AIN_DBG_LEVEL_1, "ccConE11S76:%ld\n", con->icSuConnId);

   cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam)); 
   if (con->icBcm.cc == NULLP)
   {
      CCLOGERR( "ERROR: Response Handling FAILED\n");
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
   }

   txnCfm   = (MgctTxnCfm*) event;
   mgret = ccHandleMgResponse(con, txnCfm);
   if ((mgret != ROK) && (mgret != ROKIGNORE) && (mgret != RNOCONF))
   {
      CCLOGERR( "ERROR: Response Handling FAILED\n");
      cleanUpMgQ(con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(RFAILED);
   }

#if 1
   ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif

   if (con->icBcm.cc->ccId == CiPartyOnHold)
   {
      CSID1con = con->icBcm.cc->legId1->con;
      /* Check if we had to roll back, if yes Merge Call failed, send 
       * Failure Outcome to FIC
       * ELSE, Replicate and MG Block manipulation, increment Cascade counter */
      if ((mgret == ROKIGNORE) || (mgret == RNOCONF))
      {
         CCDP( AIN_DBG_LEVEL_0, "Switching failed, but rollback success May be"
                                " switching resources are not available:%ld\n",
                                con->icSuConnId );
         cleanUpMgQ(con);
         for (index = 0; index < EReqMax; index++)
           con->icBcm.nel[index] = NEL_UNARMED;

         CC_STATE_CHANGE(con, CCS_AWTRSPFAILOUT);
         ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                            CCS_CANNOTPROCESSEVENTS);
         ccSendFailureOutCome(&con->icBcm);
         RETVALUE(ROK);
      }
      else
      {
         /* Switching was successful */
         CCDP(AIN_DBG_LEVEL_0, "***AOTC****Switching successful:%ld\n",
                                                 con->icSuConnId);
         /* Replicate, changed ccId and Associate mgBlocks */
#ifdef ZC
         if (CC_IS_OBCM_PIC_ACTIVE(con))
         {
            /* For Call Transfer */
            upd.featMsg.suConnId     = con->icSuConnId;
            upd.featMsg.ccAinUpdType = CC_MERGE_CALL;
            upd.featMsg.DlegId       = 0;
            upd.featMsg.suCtxId1     = (CSID1con->mgBlock->mgCtx ? CSID1con->mgBlock->mgCtx->suCtxId : 0);
            upd.featMsg.suCtxId2     = (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0);
            upd.featMsg.direction    = con->mgBlockDirection;
            upd.featMsg.nel          = con->icBcm.nel;
            zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
            zcUpdPeer();
         }
#endif
      }
      con->icBcm.cc->ccId = CiTransfer;
      if (con->mgBlockDirection == LEGID1)
        ccManageMgBlockPointerAfterDelete(con->icBcm.cc->legId1, con->mgBlock);
      else
        ccManageMgBlockPointerAfterDelete( con->icBcm.cc->legId2,
                                           CSID1con->mgBlock );
      CCDP(AIN_DBG_LEVEL_2, "mgBlockDirection:%d\n", con->mgBlockDirection);
      if (con->icBcm.pic == PicOActive)
      {
        CC_STATE_CHANGE(con, CCS_ANSWERED);
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_AWTANS);
      }
      if (con->ogBcm.bcmType == BtMax)
        ccStopConTmr(con, TMR_SETUP);

#ifdef CC_BUFFER_EVENT
      /* There may be a event sitting on CS1con and CS2con Event Buffer */
      ccPostEventToSelf (CSID1con);
      ccPostEventToSelf (con);
#endif /* CC_BUFFER_EVENT */
      RETVALUE(ROK);
   }
   else
   {
      CCLOGERR("ccId not supported:%d\n", con->icBcm.cc->ccId);
      RETVALUE(ROK);
   }

   RETVALUE(ROK);
} /* End of ccConE11S76 */


/*
 *
 *      Fun:   ccConE01S85
 *
 *      Desc:  Connection state function
 *             event - Connect Confirm 
 *             state - AWTMWIUPDCFM
 *      connection confirm to request for updateMWI.
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE01S85
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

    VmsMwiCfm_t         vmsMwiCfm;
    SvcHeader_t         header;
    CcConEvnt           *conEvnt = (CcConEvnt*)event;
    CasCctEvent_t    *conCfmEvnt = &conEvnt->m.casCctEvnt;
    
    TRC3(ccConE01S85)

    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));      

       /* Cancel the <setup, notify> timers */
    ccStopConTmr(con, TMR_SETUP);
    ccStopConTmr(con, TMR_NOTIFYCC);
   
       /* figure out what status to return to FIC based on lampresult and ringresult */

    switch(con->mwiType) 
    {   
/*****************/
/* request to turn the Lamp On or off */

    case CC_MWI_OP:     /* turn the Lamp On */
    case CC_MWI_RMV:        /* turn the Lamp Off */
    {
    if(conCfmEvnt->lampResult.pres == PRSNT_NODEF && conCfmEvnt->lampResult.val == CS_CON_CFM_SUCCESS)
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_OK;
        CCDP(AIN_DBG_LEVEL_0,
         " conCfm. lampReq ok..\n");

    }
    else
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
        CCDP(AIN_DBG_LEVEL_2,
         " conCfm. lampReq failed.\n");
    }

    break;
    } /* CC_MWI_OP */

/*****************/
/* we tried to play abbreviated Ring */

    case CC_MWI_ABR:
    {
    if(conCfmEvnt->ringResult.pres == PRSNT_NODEF && conCfmEvnt->ringResult.val == CS_CON_CFM_SUCCESS)
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_OK;
        CCDP(AIN_DBG_LEVEL_0,
         " conCfm. ring Req ok..\n");

    }
    else
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
        CCDP(AIN_DBG_LEVEL_2,
        " conCfm. ring Req failed..\n");
    }

    break;
    } /* CC_MWI_ABR */
    
/*****************/
/* both lamp and ring actions */

    case CC_MWI_OP_ABR:     /* Lamp on and play abbrev ring */
    case CC_MWI_RMV_ABR:        /* Lamp OFF and play abbrev ring */
    {
    if((conCfmEvnt->lampResult.pres == PRSNT_NODEF && conCfmEvnt->lampResult.val == CS_CON_CFM_SUCCESS) &&
       (conCfmEvnt->ringResult.pres == PRSNT_NODEF && conCfmEvnt->ringResult.val == CS_CON_CFM_SUCCESS))
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_OK;
        CCDP(AIN_DBG_LEVEL_0,
         " conCfm. lamp and ring Req ok..\n");
        
    }
    else
    {
        vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
        CCDP(AIN_DBG_LEVEL_2,
         " conCfm. lamp and/or ring Req failed..\n");
    }
    
    break;
    } /* CC_MWI_OP_ABR */
    
/*****************/
/* mwiType is checked prior to here, so this is unlikely. */
    default:
    {
    CCLOGERR("ERROR: Invalid MWIType: %d\n", con->mwiType);
    
    break;
    } /* default */
    } /* switch */
    
    
       /* 
    * send status to FIC
    * variables can be declared on the stack, they get 'packed' and then sent along 
    */
    
    ccFillSvcHeader(&header, &(con->icBcm), MSG_Close); 
    header.lastTransactionFlag = TRUE;
    vmsMwiCfm.srvcId        = con->icBcm.svcHeader.srvcId;
    CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);
  
       /* change state to CCS_AWTRELCFM_IC (17) */
    CC_STATE_CHANGE(con,  CCS_AWTRELCFM_IC);
  
       /* start the release timer */
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      
       /* ccSendRelease */

    ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                  con->icProtType, CCCALLCLR, NULL);

    RETVALUE(ROK);
} /* End of ccConE01S85 */


/*
 *
 *      Fun:   ccConE03S85
 *
 *      Desc:  Connection state function
 *             event - Connect Status indication
 *             state - AWTMWIUPDCFM
 *      connection status indication. Can only be FORCED_ON_HOOK,
 *      anything
 *      else is an error
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE03S85
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    ProtType    icProtType     = CC_GET_PROTOCOL(con->icProtType);
    ProtType    ogProtType     = CC_GET_PROTOCOL(con->ogProtType);

    CCDP(AIN_DBG_LEVEL_0, "ccConE03S85:  icEvntType=%d, icProtType=%d, "
        " ogProtType=%d\n", con->icEvntType, icProtType, ogProtType);

    if (ccIsForcedOnHookRcvd(con->icProtType, con->ogProtType, con->icEvntType,
                 con->direction))
    {
      VmsMwiCfm_t         vmsMwiCfm;
      SvcHeader_t         header;

      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));

      /* Cancel the notify timer */ 
      ccStopConTmr(con, TMR_NOTIFYCC);

      /* start the release timer */
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);

       /* 
        * send maint_busy
        * variables can be declared on the stack, they get 'packed' and then 
        * sent along */

      ccFillSvcHeader(&header, &(con->icBcm), MSG_Close);
      header.lastTransactionFlag = TRUE;

      vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
      vmsMwiCfm.srvcId        = con->icBcm.svcHeader.srvcId;
      CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);

      CCDP(AIN_DBG_LEVEL_0, "RCVD FORCED ON_HOOK RCVD:%ld\n", con->icSuConnId);

      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(ROK);
    } /* FORCED_ON_HOOK received */

    /* 
     *  If I get anything except FORCED_ON_HOOK then complain
     */

    CCLOGERR("ccConE03S85(): unExpected evnt in state = %d, \
          ProtocolType = %d, direction = %d, evnType =%d\n",
     con->state, con->icProtType, con->direction, con->icEvntType);

    RETVALUE(ROK);
} /* ccConE03S85 */


/*
*
*      Fun:   ccConE14S85
*
*      Desc:  Connection state function
*             event - SETUP Tmr Expiry
*             state - AWTMWIUPDCFM
*       SETUP timer expired while waiting for connection confirm for updateMWI
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE14S85
(   
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  VmsMwiCfm_t         vmsMwiCfm;
  SvcHeader_t         header;

  cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));      
  ccStopConTmr(con, TMR_NOTIFYCC);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  /* 
   * send maint_busy
   * variables can be declared on the stack, they get 'packed' and then sent along 
   */
  ccFillSvcHeader(&header, &(con->icBcm), MSG_Close); 
  header.lastTransactionFlag = TRUE;

  vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
  vmsMwiCfm.srvcId        = con->icBcm.svcHeader.srvcId;
  CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);
  CC_STATE_CHANGE(con,  CCS_AWTRELCFM_IC);
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCRESCUNAVAIL, NULL);
  RETVALUE(ROK);
} /* End of ccConE14S85 */

/*
*
*      Fun:   ccConE58S85
*
*      Desc:  Connection state function
*             event - CCE_NOTIFYTIMEREXP.
*             state - CCS_AWTMWIUPDCFM
*       NOTIFY Timer expired while waiting for connection confirm to update MWI
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: 
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE58S85
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  VmsMwiCfm_t         vmsMwiCfm;
  SvcHeader_t         header;

  cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));      

  ccStopConTmr(con, TMR_SETUP);
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  /* 
   * send fail status to FIC
   * variables can be declared on the stack, they get 'packed' and then sent along 
   */
      
  ccFillSvcHeader(&header, &(con->icBcm), MSG_Close); 
  header.lastTransactionFlag = TRUE;

  vmsMwiCfm.mwiDlvrStatus = CC_MWI_DLVR_FAIL;
  vmsMwiCfm.srvcId        = con->icBcm.svcHeader.srvcId;
  CcUiFctMwiDeliveryStatus (&vmsMwiCfm, &header);

  CC_STATE_CHANGE(con,  CCS_AWTRELCFM_IC);
  
  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCTMPFAIL, NULL);
  RETVALUE(ROK);
} /* ccConE58S85 */

/*
*
*      Fun:   ccDisconnectCallInCC10
*
*      Desc:  This functions is used to Disconnect a party who is in ccId = CC10
*             Disconnect is also propagated to asssociated BCM's.
*
*      Ret:   None.
*
*      Notes: 
*
*      File:  cc_bdy2.c
*
*/
PUBLIC Void ccDisconnectCallInCC10
(
CcConCb      *con,
Bool          split,
PTR           event
)
{
  S16                   ret               = RFAILED;
  CcConCb              *CSID1con          = NULLP;
  AinBCM_t             *legId02           = NULLP;
  AinBCM_t             *legId1            = NULLP;
  msgValBcmTypeEnum     bcmType           = BtMax;
  U8                    cause             = CCCALLCLR;
  U8                    tmp_icEvntType    = 0;

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */
#ifdef CALEA_3WC
  S16 caleaRet = RFAILED;
#endif
#ifdef CC_BUFFER_EVENT
  U8                relDisBool     = RFAILED;
  U8                evntType       = 0;
  Bool              releaseNeeded  = FALSE;
#endif /* CC_BUFFER_EVENT */


  if (con == NULLP)
  {
    CCLOGERR("Error: con is NULLP\n");
    RETVOID;
  }
  CSID1con = con->icBcm.cc->legId1->con;
  legId02  = con->icBcm.cc->legId02;
  legId1   = con->icBcm.cc->legId1;
  bcmType  = legId02->bcmType;

  CCDP(AIN_DBG_LEVEL_1, "ccDisconnectCallInCC10:%ld, %ld, %ld, %ld\n",
                        CSID1con->icSuConnId, CSID1con->ogSuConnId,
                        con->icSuConnId, con->ogSuConnId);
  if ((legId02 == NULLP) || (legId1 == NULLP))
  {
    CCLOGERR("Error: legId02 or legId1 is NULLP:%lx %lx\n", (U32 )legId02, (U32)legId1);
    RETVOID;
  }
  cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
#if 1 /* Bug#: 17932 */
      ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif /* 1 */
  /* Bug# 18043 */
  if (ccInit.acnt == TRUE)
     ccSetRelIndTckForMPartyCall(con, CSID1con, BtOBcm);

  legId02->cc = NULLP;
  CC_CLEAN_FIC_TXN(legId02);

  con->icBcm.cc->ccId       = CiStable2Party;
  con->icBcm.cc->legId1     = &(con->ogBcm);
  con->icBcm.cc->legId02    = NULLP;
  con->icBcm.cc->legId2     = NULLP;
#ifdef ZC
  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
    upd.featMsg.ccAinUpdType = CC_DISCONNECT;
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.DlegId       = 0;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
  }
#endif /* ZC */
  if (split == FALSE)
  {
/********************MG BLOCK MANIPULATION**********************************/
    GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,NULLP,CSID1con);
    con->mgBlock->con = con;

    /* Allocate the mgBlock */
    ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(CSID1con->mgBlock),
                   (Size) sizeof(CcMgBlock_t));

    cmMemset((U8 *) CSID1con->mgBlock, 0, sizeof(CcMgBlock_t));
    GCC_INC_CONCNT(CSID1con->mgBlock);
    CSID1con->mgBlock->con = CSID1con;
  }


  ret = ccProcessDisconnectOnSpecificBCM (&(con->ogBcm));
#ifdef CALEA_3WC
  /* we must not send the DisconnectNofn for the CaleaLegs of 
   * controller as they will be moved into CS1, but the surrogate 
   * LEAs must be released*/ 
  if (con->surrogate != NULLP)
     ccProcessDisconnectNotfnForSurrogateLegs(con, event);
#endif
  if (ret == ROK)
  {
    /* If event is armed , we would process this disconnect and
     * the con will be cleaned up in that function */
  }
  else
  {
#ifdef CALEA_3WC
     /* The passive leg is not involved in MParty Call */
     caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),
                                                               event);
     if (caleaRet != ROK)
     {
        CCDP(AIN_DBG_LEVEL_4,
        "Critical Error!!ccProcessDisconnectNotfnForCaleaLegs FAILED\n");
     }
#endif

    if (split == FALSE)
    {
/********************MG BLOCK MANIPULATION**********************************/
      FREE_MGBLOCK(CSID1con->mgBlock);
      GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,con->mgBlock,CSID1con);
      CSID1con->mgBlock->con     = CSID1con;
      GCC_MNG_MGBLOCK_CNTR(con->mgBlock,NULLP,con);
      /* Allocate the mgBlock */
      ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->mgBlock),
                     (Size) sizeof(CcMgBlock_t));

      cmMemset((U8 *) con->mgBlock, 0, sizeof(CcMgBlock_t));
      GCC_INC_CONCNT(con->mgBlock);
    }
/******************CHECK FOR BUFFERED REL OR ON-HOOKS***********************/
#ifdef CC_BUFFER_EVENT
    relDisBool = ccCheckRelOrOnHookInBuffer(&(con->ogBcm), &evntType);
    if (relDisBool == ROK)
    {
      ccDeleteBufferedEvent(con, con->ogSuConnId, evntType);
      if (ccFindIfReleaseOrRelRspNeeded(&(con->ogBcm)) == ROK)
        releaseNeeded = TRUE;
    }
#endif /* CC_BUFFER_EVENT */
/************************CLEAN UP THE CS2 CALL******************************/
    ccStopConTmr(con, CC_TMR_CALLDTL); 
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
    upd.icSuConnId = con->icSuConnId;
    zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif
/************************CLEAN UP THE CS2 CALL******************************/
    if (CC_IS_CONTEXT_PRESENT(con))
    {
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      ret = ROK; /* Need this set to invoke ccSendMgiQueue */
      con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
      con->tempHolderForReleaseCause = cause;
      if ((con->icRscVal) && (con->ogRscVal))
      {
#ifdef CC_BUFFER_EVENT
        if ((relDisBool == ROK) && (releaseNeeded == FALSE))
        {
          con->relPend = OUTRELRSPANDINREL;
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDBOTHREL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else if (con->icRscVal)
      { 
        con->relPend = ICRELONLY;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      }
      else if (con->ogRscVal)
      {
#ifdef CC_BUFFER_EVENT
        if ((relDisBool == ROK) && (releaseNeeded == FALSE))
        {
          con->relPend = OUTRELRSPANDNOREL;
        }
        else
        {
          con->relPend = OGRELONLY;
        }
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
#endif /* CC_BUFFER_EVENT */
      }
      else
      { 
        con->lastState = 0;
        con->relPend = NORELANDNORELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
      }

      if (ret == ROK)
      { 
        con->mgBlock->con = con;
        ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);
      }

      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "MGI Operation success:%ld, %ld, %ld\n",
                 con->icSuConnId, con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
      }
      CCLOGERR("Did we send the MGI:%d\n", ret);
    }
    else
    {
      /* If we reach here, we have a problem so cleaning up the call
       * without caring about Switching */

      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);

      if ((con->icRscVal) && (con->ogRscVal))
      {
#ifdef CC_BUFFER_EVENT
        if ((relDisBool == ROK) && (releaseNeeded == FALSE))
        {
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          ccDeallocateResource(con, CC_OUTGOING);
          con->ogRscVal = FALSE;
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, cause, NULL);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, cause, NULL);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, cause, NULL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else if (con->icRscVal)
      {
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, cause, NULL);
      }
      else if (con->ogRscVal)
      {
#ifdef CC_BUFFER_EVENT
        if ((relDisBool == ROK) && (releaseNeeded == FALSE))
        {
          con->direction = OUTTOINC;
          if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);
          CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);
          ccDeallocateResource(con, CC_OUTGOING);
        }
        else
        {
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
          ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                        con->ogProtType, cause, NULL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else
      {
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
    }
  }

  /* Initialize the ret var */
  ret                = RFAILED;
  relDisBool         = RFAILED;
  releaseNeeded      = FALSE;

  if ((legId02->con) && (legId02->con->state == CCS_CANNOTPROCESSEVENTS))
  {
    tmp_icEvntType = con->icEvntType;
    con->icEvntType = ccReturnOnHookEvnt(legId02);
    ccBufferEventToQueue(legId02->con, legId02, NULLP, CCE_CNSTIND, 0,
                       ((legId02->bcmType == BtOBcm) ? legId02->con->icSuConnId:
                         legId02->con->ogSuConnId), NULLP, 0);
    con->icEvntType = tmp_icEvntType;
    RETVOID;
  }
  ret = ccProcessDisconnectOnSpecificBCM (legId1);
#ifdef CALEA_3WC
  /* we must not send the DisconnectNofn for the CaleaLegs of 
   * controller as they will be moved into CS1, but the surrogate 
   * LEAs must be released*/ 
  if ((legId1->con != NULLP) && (legId1->bcmType == BtTBcm))
  { 
     if (legId1->con->surrogate != NULLP)
        ccProcessDisconnectNotfnForSurrogateLegs(legId1->con, event);
  }
#endif

  if (ret == ROK)
  {
    /* If event is armed , we would process this disconnect and
     * the con will be cleaned up in that function */
  }
  else
  {
#ifdef CALEA_3WC
     /* The passive leg is not involved in MParty Call */
     if(legId1->con != NULLP)
      caleaRet = ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(legId1,
                                                                event);
      if (caleaRet != ROK)
      {
         CCDP(AIN_DBG_LEVEL_4,
         "Critical Error!!ccProcessDisconnectNotfnForSpecificBcmCaleaLegs"
         " FAILED\n");
      }
#endif
#ifdef CC_BUFFER_EVENT 
    relDisBool = ccCheckRelOrOnHookInBuffer(legId1, &evntType);
    if (relDisBool == ROK)
    {
      if (legId1->bcmType == BtOBcm) 
         ccDeleteBufferedEvent(CSID1con, CSID1con->icSuConnId, evntType);
      else if (legId1->bcmType == BtTBcm)
         ccDeleteBufferedEvent(CSID1con, CSID1con->ogSuConnId, evntType);

      if (ccFindIfReleaseOrRelRspNeeded(legId1) == ROK)
        releaseNeeded = TRUE;
    }
#endif /* CC_BUFFER_EVENT */
/************************CLEAN UP THE CS1 CALL******************************/
    ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
    ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
#ifdef ZC
    upd.icSuConnId = CSID1con->icSuConnId;
    zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif /* ZC */

    if (CC_IS_CONTEXT_PRESENT(CSID1con))
    {
      ccUpdateMgQForSubRsc((PTR) NULLP, CSID1con->mgBlock->mgCtx->suCtxId,
                           CSID1con);
      ret = ROK; /* Need this set to invoke ccSendMgiQueue */
      CSID1con->tempHolderForReleaseCause = cause;
      CSID1con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
      if ((CSID1con->icRscVal) && (CSID1con->ogRscVal))
      {
#ifdef CC_BUFFER_EVENT
        if ((relDisBool == ROK) && (releaseNeeded == FALSE))
        {
          if (legId1->bcmType == BtOBcm)
            CSID1con->relPend = INRELRSPANDOUTREL;
          else /* It should be BtTBcm */
            CSID1con->relPend = OUTRELRSPANDINREL;

          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
        }
        else
        {
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDBOTHREL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else if (CSID1con->icRscVal)
      {
#ifdef CC_BUFFER_EVENT
        if( ((relDisBool == ROK) && (releaseNeeded == FALSE) &&
            (legId1->bcmType == BtOBcm))||(con->ainInfo.legId ==1))
        {
          CSID1con->relPend = INRELRSPANDNOREL;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
        }
        else
        {
          CSID1con->relPend = ICRELONLY;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else if (CSID1con->ogRscVal)
      {
#ifdef CC_BUFFER_EVENT
       /*BUG 81362:Send 200 OK BYE after A party release the call*/
        if (((relDisBool == ROK) && (releaseNeeded == FALSE) && 
            (legId1->bcmType == BtTBcm))||(con->ainInfo.legId == 1))
        {
          CSID1con->relPend = OUTRELRSPANDNOREL;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
        }
        else
        {
          CSID1con->relPend = OGRELONLY;
          CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
        }
#endif /* CC_BUFFER_EVENT */
      }
      else
      {
        CSID1con->lastState = 0;
        CSID1con->relPend = NORELANDNORELRSP;
        CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
      }

      if (ret == ROK)
      {
        CSID1con->mgBlock->con = CSID1con;
        ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                             CSID1con->mgBlock);
      }

      if (ret == ROK)
      {
        RETVOID;
      }
      CCLOGERR("Did we send an MGI request:%d\n", ret);
    }
    /* If we reach here, we have a problem so cleaning up the call
     * without caring about Switching */

    cleanUpMgQ(CSID1con);
    ccCleanUpMGCtx (CSID1con);
    if ((CSID1con->icRscVal) && (CSID1con->ogRscVal))
    {
#ifdef CC_BUFFER_EVENT
      if ((relDisBool == ROK) && (releaseNeeded == FALSE) &&
          (legId1->bcmType == BtOBcm))
      {
        CSID1con->direction = INCTOOUT;
        if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
        ccDeallocateResource(CSID1con, CC_INCOMING);
        CSID1con->icRscVal = FALSE;
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
        ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId, CSID1con->ogSuConnId,
                      CSID1con->ogProtType, cause, NULL);
      }
      else if ((relDisBool == ROK) && (releaseNeeded == FALSE) &&
               (legId1->bcmType == BtTBcm))
      {
        CSID1con->direction = OUTTOINC;
        if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
        ccDeallocateResource(CSID1con, CC_OUTGOING);
        CSID1con->ogRscVal = FALSE;
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
        ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId, CSID1con->icSuConnId,
                      CSID1con->icProtType, cause, NULL);
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_BOTH);
        ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                      CSID1con->icSuConnId, CSID1con->icProtType, cause, NULL);
        ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                      CSID1con->ogSuConnId, CSID1con->ogProtType, cause, NULL);
      } 
#endif /* CC_BUFFER_EVENT */
    }
    else if (CSID1con->icRscVal)
    {
#ifdef CC_BUFFER_EVENT
      if ((relDisBool == ROK) && (releaseNeeded == FALSE) &&
          (legId1->bcmType == BtOBcm))
      {        
        CSID1con->direction = INCTOOUT;
        if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
        CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
        ccDeallocateResource(CSID1con, CC_INCOMING); 
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
        ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                      CSID1con->icSuConnId, CSID1con->icProtType, cause, NULL);
      }
#endif /* CC_BUFFER_EVENT */
    }
    else if (CSID1con->ogRscVal)
    {
#ifdef CC_BUFFER_EVENT
      if ((relDisBool == ROK) && (releaseNeeded == FALSE) &&
          (legId1->bcmType == BtTBcm))
      {
        CSID1con->direction = OUTTOINC;
        if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
        CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
        ccDeallocateResource(CSID1con, CC_OUTGOING); 
      }
      else
      {
        CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
        ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId,
                      CSID1con->ogSuConnId, CSID1con->ogProtType, cause, NULL);
      }
#endif /* CC_BUFFER_EVENT */
    }
    else
    {
#ifdef CALEA_3WC
      if (CSID1con->icProtType != CC_LOCAL_SWT_PROT)
         ccReleaseCaleaLegs(CSID1con);
#endif
      CC_STATE_CHANGE(CSID1con, CCS_IDLE);
      ccRelCon(CSID1con);
    }
  }
  RETVOID;
}


/*
*
*      Fun:   ccProcessOCalledPartyBusy
*
*      Desc:  This function checks if there is an OCalledPartyBusy event
*             armed.
*             If Armed sends a message to FIC.
*
*      Ret:   ROK       - successful, Event detected and Message sent to FIC.
*             RFAILED   - failed
*             ROKIGNORE - GCC state machine can go ahead with the call
*                         (Notification sent)
*             ROKDNA    - No event was armed
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PUBLIC S16 ccProcessOCalledPartyBusy
(
AinBCM_t       *pBcm
)
{
  CcConCb            *con           = NULLP;
  U8                  index         = 0;
  OCdPtyBusy_t        oCdPtyBusy;
  SvcHeader_t         header;
  S16                  ret         = RFAILED;

  CCDP(AIN_DBG_LEVEL_1, "ccProcessOCalledPartyBusy:%ld\n",
                        pBcm->con->icSuConnId);
  con = pBcm->con;

  if ((pBcm->nel[EReqOCalledPartyBusy] == NEL_REQUEST) &&
      (pBcm->svcHeader.transId))
  {
    CCDP(AIN_DBG_LEVEL_0, "OCalledPartyBusy is Armed Req Evnt:%ld\n",
                           con->icSuConnId);
    ccRestoreEvntHold(con);

    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&oCdPtyBusy, 0, sizeof(OCdPtyBusy_t));

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
      pBcm->nel[index] = NEL_UNARMED;

    CCDP(AIN_DBG_LEVEL_0," TransId for OBCM = %ld\n", pBcm->svcHeader.transId);
    ccFillSvcHeader(&header, pBcm, MSG_O_Called_Party_Busy);
    CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

    ret = ccFillOCdPtyBusyParam (&oCdPtyBusy, pBcm, FALSE);
    if (ret != ROK)
    {
      CCLOGERR("ERROR: ccFillOCdPtyBusyParam failed: %ld\n", con->icSuConnId);
      RETVALUE(RFAILED);
    }
    CCDP(AIN_DBG_LEVEL_0," Filled OCdPtyBusy,TransID= %ld\n", header.spTransId);

    con->lastState = con->state;
    CC_STATE_CHANGE (con, CCS_AWTRSPFORDPE19);
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
    CCDP(AIN_DBG_LEVEL_0," Sending OCdPtyBusy: %ld\n", con->icSuConnId);
    CcUiFctOCdPtyBusy(&oCdPtyBusy, &header);
    RETVALUE(ROK);
  }
  else if ((pBcm->nel[EReqOCalledPartyBusy] == NEL_NOTIFY) &&
           (pBcm->svcHeader.transId))
  {
    CCDP(AIN_DBG_LEVEL_0, "OCalledPartyBusy  is Armed Notification evnt:%ld\n",
                                                    con->icSuConnId);
    ccRestoreEvntHold(con);

    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&oCdPtyBusy, 0, sizeof(OCdPtyBusy_t));

    ccFillSvcHeader(&header, pBcm, MSG_O_Called_Party_Busy);
    ret = ccFillOCdPtyBusyParam (&oCdPtyBusy, pBcm, TRUE);
    if (ret != ROK)
    {
      CCLOGERR("ERROR: ccFillOCdPtyBusyParam failed: %ld\n", con->icSuConnId);
      RETVALUE(RFAILED);
    }
    CCDP(AIN_DBG_LEVEL_0," Sending OCdPtyBusy: %ld\n", con->icSuConnId);
    CcUiFctOCdPtyBusy(&oCdPtyBusy, &header);
    RETVALUE(ROKIGNORE);
  }
  else /* It has to be NEL_UNARMED */
  {
    CCDP(AIN_DBG_LEVEL_0, "Event not armed:%ld\n", con->icSuConnId);
    RETVALUE(ROKDNA);
  }
}


/*
*
*      Fun:   ccRouteCall
*
*      Desc:  If GCC has any trunkgroups it grabs those, else sends
*             a route Request to get thoses.
*
*      Ret:   VOID
*
*       Notes: THIS SHOULD BE ONLY CALLED AFTER RECEIVING A ANALYZE ROUTE.
*
*      File:  cc_bdy2.c
*
*/
PUBLIC Void ccRouteCall
(
CcConCb          *con,
Bool              mgwAdvance
)
{
  S16                 ret                = RFAILED;
  U32                 numOfOgInterfaces  = 0;
  U32                 index              = 0;
  U8                  mgIndex            = 0;
  ProtType            protType           = 0;
  RmInterface         interface;
  Bool                egressInterCcsCall = FALSE;
  Bool                mgwList            = FALSE;
  ProtType            icProtType         = 0;     /* Bug 80583 */
  ProtType            ingressCCS_IcProtType = 0;  /* Bug 80583 */
  U16                 sendPChargingVector = TRUE; /* Bug 87538 */
  U16                 ogProtType         = 0;     /* Bug 87538 */
  Bool                shortCallId        = FALSE; /* FID 17044.0*/ 

  icProtType = CC_GET_PROTOCOL((con->icIntfcCb)?con->icIntfcCb->protType:con->icProtType);

  CCDP(AIN_DBG_LEVEL_1, "ccRouteCall:icSu:%ld, ogSu:%ld, suCtxId = %ld,"
       " icTransId:%ld, mgwAdvance %d\n", con->icSuConnId, con->ogSuConnId,
       (con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0), con->icBcm.svcHeader.transId, mgwAdvance);

  con->piSentState = PI_ST_NULL; /*FID 14811.0 Reset piSentState for ReRoute*/

  if (mgwAdvance) /* FID 14732.0 */
  {
      /* If Reroute is due to MG advance, we need to look at the correct
       * interface, the con->routeEvnt->currentInterface is pointing to the next
       * one already so point it back
       * we dont need to revert this as the currentInterface for the route List
       * is registered in E09S04 again */
      if (con->routeEvnt)
      {
          if (!CC_EGRESS_INTER_CCS_CALL(con)) /* BUG: 78856 */
            con->routeEvnt->currentInterface--;
      }
      else
      {
          CCLOGERR("%s: error: routeEvnt is null for a reroute:0x%lx\n",
                   __FUNCTION__, (U32)con->routeEvnt);
          RETVOID;
      }
  }
#ifdef ATCA /* FID 16766.0 +*/
  else
  {
	/* we do not want new code to be hit if doing MG advancing */

	/* for intra-ccs and inter-ccs, currentInterfaces has NOT already been
		bumped up by the time we enter ccRouteCall */

	CCDP(AIN_DBG_LEVEL_0, "%s: CC_GR_OVRFLW_PRES_AND_UNANCHORED %d, con->routeEvnt->numOfOgInterfaces %d, con->routeEvnt->currentInterface %d, CC_EGRESS_INTER_CCS_CALL %d\n", __FUNCTION__, CC_GR_OVRFLW_PRES_AND_UNANCHORED(con), (int)con->routeEvnt->numOfOgInterfaces, (int)con->routeEvnt->currentInterface, CC_EGRESS_INTER_CCS_CALL(con));

      if ((CC_GR_OVRFLW_PRES_AND_UNANCHORED(con)) && (con->routeEvnt->numOfOgInterfaces == (con->routeEvnt->currentInterface + 1)) &&
          (!CC_IS_CONTEXT_PRESENT(con))) /* BUG: 91840 */
      {
	    CCDP(AIN_DBG_LEVEL_0, "%s: unanchored and GR OVRFLW PRES and looking at last interface\n", __FUNCTION__);

	    /* This handled the same way for both SIP and SIPT ingress */	

	    /* no need to check CC_FLAG_GROVRFLW_SKIP here as we know from code
		in ccCheckForInterfaces() that we would have already passed over
		the GR TG */

            CCDP(AIN_DBG_LEVEL_1,"overflowing to other MGC\n");
            ccStopConTmr(con, TMR_SETUP);
            ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
            CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);

            /* tell SIPA to send a 302 */
            /* when we send this 302, we maybe be overflowing to the
               peer MGC.  We may also be overflowing internally to
               our own MGC because the ingress CCS did not control
               the egress group.  In both cases, FIC has setup the
               last route as the GR trunk.  However, when we are
               overflowing to our own MGC, we need to include the
               xMgGroup header so our local SFED will know to keep
               the egress on the same MGC.  CC will internally
               overflowing if (ccCp.grCntrl == MGC_GRCNTRL_FULL).
            */
            /* cause CCOVERFLOW will map to SIPCAUSE_302_MOVEDT*/

            ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                con->icProtType, CCOVERFLOW, NULL);

            RETVOID;
      }
      else
      {
	CCDP(AIN_DBG_LEVEL_0, "%s: not unanchored and GR OVRFLW PRES and using last interface\n", __FUNCTION__);
      }
  }
#endif /* FID 16766.0 0*/

  con->direction = INCTOOUT;  /* On reroute we are making sure that
                                  the direction is back to inctoout */
  /* bug:24551 */
  ccRestoreEvntHold(con);
  if ((con->routeEvnt) &&
      (con->routeEvnt->numOfOgInterfaces > con->routeEvnt->currentInterface))
  {
    ccCleanUpOGForReRoute(con);
    /* FID 15319.0 */
    while(con->routeEvnt->numOfOgInterfaces > con->routeEvnt->currentInterface)
    {
    ret = ccGetIntfcSap(&con->ogIntfcCb,
        &(con->routeEvnt->ogInterface[con->routeEvnt->currentInterface]));

    if (ret != ROK)
    {
#if (ERRCLASS & ERRCLS_DEBUG)
      CCLOGERROR(ERRCLS_DEBUG, ECC338, (ErrVal) ret,
                 "ccRouteCall() Failed, ccGetIntfcSap failed");
#endif
      /*FID16206 +*/
      if(con->dummyCallInfo)
      {
        ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
        RETVOID;
      }
      /*FID16206 -*/
	  
      /* FID 16970.0 + */
      if (con->ccbsIsdnCallInfo)
      {
          ccRelCon(con);
          RETVOID;
      }
      /* FID 16970.0 - */
	  
      if ((con->icBcm.SndNotInd != SND_NOTIF_NOT_PRSNT) &&
          (con->icBcm.SndNotInd != SND_NOTIF_MAX))
      {
        CCDP(AIN_DBG_LEVEL_0, "Sending TermNot in ccRouteCall\n");
        ret = ccSendTerminationNot(&con->icBcm);
        if (ret != ROK)
          CCLOGERR("Failed to send TermNotif after NEL event\n");
      }
      ccCp.sts.fRoutUnavail++;
      /* CC_CALEA failure is taken care in ccHandleInternalErrorIC */
      ccPlayToneOrRelease(con, CCTMPFAIL);
      RETVOID;
    }

        /* + Bug 87538 + */
        if (con->ogIntfcCb)
        {
            ogProtType = CC_GET_PROTOCOL(con->ogIntfcCb->protType);
            
            if ( con->ogIntfcCb->ccTgCb && (ogProtType == CC_SIP || ogProtType == CC_SIPT))
            {
                if(ogProtType == CC_SIP && con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr)
                {
                  sendPChargingVector = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr->pChargingSent;
                  shortCallId = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr->shortCallId;
                }
                else if(ogProtType == CC_SIPT && con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr)
                {
                  sendPChargingVector = con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr->pChargingSent;
                  shortCallId = con->ogIntfcCb->ccTgCb->tgAtt.sipTPrflPtr->shortCallId;
                }
                
                CCDP(AIN_DBG_LEVEL_1, "sendPChargingVector = %d, shortCallId = %d \n", sendPChargingVector, shortCallId);
                /*FID 17044.0 +*/
                if (shortCallId)
                {
                   ret = ccGetNewVarSipCallId (&(con->callDtlInfo.un.ogSipId), CC_SHORT_SIP_ID_LENGTH,
                                               con->ogSuConnId,TRUE);
                   if(ret != ROK) 
                      CCDP(AIN_DBG_LEVEL_3,"Error in getting new short sip call-id!!!");
                }
                /*FID 17044.0 -*/
                if ( !sendPChargingVector && (con->callDtlInfo.cm.sipOrigIoi.pres) )
                {
                    cmFreeTknStrVar(&(con->callDtlInfo.cm.sipOrigIoi));
                    con->callDtlInfo.cm.sipOrigIoi.pres = NOTPRSNT;
                }
                /* bug88105 ++ clear the stored TermIOI, if PCHARGING=N is on egress PRFL-SIP*/
                if ( !sendPChargingVector && (con->callDtlInfo.cm.sipTermIoi.pres == PRSNT_NODEF) )
                {
                    cmFreeTknStrVar(&(con->callDtlInfo.cm.sipTermIoi)); 
                    con->callDtlInfo.cm.sipTermIoi.pres = NOTPRSNT;
                }
                /* bug88105 --*/
            }
        }
        /* - Bug 87538 - */

        /* FID 16747.0 */
        if(((icProtType == CC_EXT_BICC) && (ogProtType == CC_SIP)) ||
           ((icProtType == CC_EXT_BICC) && (CC_OPT_IWBASEVARIANT(con->icIntfcCb) == CC_BASE_ISUPANS92)
            && ((ogProtType == CC_SIPT) || (ogProtType == CC_IN))) ||
           ((icProtType == CC_SIP) && (ogProtType == CC_EXT_BICC)) ||
           ((ogProtType == CC_EXT_BICC) && (CC_OPT_IWBASEVARIANT(con->ogIntfcCb) == CC_BASE_ISUPANS92)
            && ((icProtType == CC_SIPT) || (icProtType == CC_IN))) ||
           ((icProtType != CC_EXT_BICC) && (ogProtType != CC_EXT_BICC)))
        {
           break;
        }
        else
        {
            con->routeEvnt->currentInterface++;
        }
    }/* End of while */

    /* Bug 82488 */
    /* FID 16747.0 only support BICCITU to/from SIP call, BICCANSI to/from SIP&SIPT&ISDN call */
    if((CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb) &&
             (ogProtType != CC_SIP) && (ogProtType != CC_SIPT) && (ogProtType != CC_IN)) ||
        ((icProtType == CC_EXT_BICC) && (!CC_IS_PROT_TYPE_ANSI_BICC(con->icIntfcCb)) && (ogProtType != CC_SIP)) ||
        (CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb) &&
             (icProtType != CC_SIP) && (icProtType != CC_SIPT) && (icProtType != CC_IN)) ||
        ((ogProtType == CC_EXT_BICC) && (!CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb)) && (icProtType != CC_SIP)))
    {
        con->failCndVal = FC_NOROUTDST;
        if (CC_IS_CONTEXT_PRESENT(con))
        {
           ccStopConTmr(con, TMR_SETUP);
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           ccQSubBasedOnCcn(con);

           ret = ccSendMgiQueue(0, con->mgBlock);
           if (ret != ROK)
           {
               CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
               cleanUpMgQ(con);
               ccCleanUpMGCtx(con);
           }
           else
           {
               CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
               con->relPend = ICRELONLY;
               con->tempHolderForReleaseCause = CCNORTTODEST;
               RETVOID;
           }
        }
        CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
        ccProcessFailCnd(con, con->failCndVal, TRUE);
        RETVOID;
    }
    /* End of FID 15319.0 */
    /* Bug 79182 */
    /* Bug 80583, only support enbloc everlap for SIP/SIPT/ISUP */
    CC_GET_INGRESS_CCS_GENERIC_ICPROTTYPE(con, ingressCCS_IcProtType);

    if ((icProtType == CC_SIP) || (ingressCCS_IcProtType == CC_SIP) ||
        (icProtType == CC_SI) || (ingressCCS_IcProtType == CC_SI) ||
        (icProtType == CC_EXT_BICC) || (ingressCCS_IcProtType == CC_EXT_BICC) ||
        (icProtType == CC_SIPT) || (ingressCCS_IcProtType == CC_SIPT))
    {
        if(CC_IS_SI_BICC_ICOVERLAP(con) ||
           CC_IS_SIP_ICOVERLAP(con)  ||
           CC_IS_SIPT_ICOVERLAP(con))
        {
           if (ccOverlapToEnbloc(con))
           {
              RETVOID;
           }
        }
    }

    ccRegisterEgressInterCcsCall (con, &mgwList);
    /*FID16206+*/
    if((con->dummyCallInfo) && (con->dummyCallInfo->dummyCallType != NONDUMMYCALL))
    {
        if(CC_GET_PROTOCOL(con->ogIntfcCb->protType) != CC_SIP)
        {
            ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
            RETVOID;
        }
        else
        {
            CcMsgEvnt ogEvnt;
            S16 ret = RFAILED;

            if ((ret = ccGetPsSap(&con->ogSapCb,
                                   &con->ogIntfcCb->intfc))!= ROK)
            {
              CCLOGERR("ccAllocateResourceArray() Failed, ccGetPsSap failed");
              ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
              RETVOID;
            }
            con->ogSapCb->nmbActvConn++;
            con->ogProtType = con->ogIntfcCb->protType;

            cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
            con->ogEvnt = (CcAllSdus *)&ogEvnt;
            con->direction = INCTOOUT;
            CC_STATE_CHANGE(con, CCS_AWTNCCFM);
            ret = ccMapEvent(con, CCE_NCIND, con->icEvntType);
            if(ret != ROK)
            {
              CCDP(AIN_DBG_LEVEL_1," Mapping message indication failed\n");
              if(con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val != NULLP)
              {
                CCDP(AIN_DBG_LEVEL_1," Deallocate sipXmlInfo.xmlBody.val = %lx\n",(U32)con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val);
                SPutSBuf(ccInit.region, ccInit.pool, con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val,
                 (Size)(con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.size));
              }
              ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
              RETVOID;
            }

            if (con->callDtlInfo.un.ogSipId.pres == PRSNT_NODEF)
            {
              con->callDtlInfo.un.ogSipId.len = strlen(con->callDtlInfo.un.ogSipId.val);
              ccCopyTknStrVar(&con->dummyCallInfo->callId, &con->callDtlInfo.un.ogSipId);
              con->dummyCallInfo->callId.pres = con->callDtlInfo.un.ogSipId.pres;
              CCDP(AIN_DBG_LEVEL_0,"con->dummyCallInfo->callId.len=%d\n", con->dummyCallInfo->callId.len);
              memcpy(&con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.callId, &con->dummyCallInfo->callId, sizeof(TknStrVar));
            }
            else
            {
              CCDP(AIN_DBG_LEVEL_0,"Error in getting new sip call-id!!!\n");
              ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
              RETVOID;
            }

            if(con->dummyCallInfo->dummyCallType == INTERROGATION)
            {
              ret = cmHashListInsert(&ccDummyCallInfoTbl, (PTR)con->dummyCallInfo,
                            (U8 *)con->dummyCallInfo->callId.val,(U16)con->dummyCallInfo->callId.len);
              if(ret != ROK )
              {
                CCLOGERR("cmHashListInsert failed ccDummyCallInfoTbl\n");
                ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
                RETVOID;
              }
            }

            ccStartConTmr(CC_TMR_CFXCALLINDP, con, (PTR)&ccCp.genCfg);
            CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId, con->ogProtType, &ogEvnt);
            if(con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val != NULLP)
            {
              CCDP(AIN_DBG_LEVEL_1," Deallocate sipXmlInfo.xmlBody.val = %lx\n",(U32)con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val);
              SPutSBuf(ccInit.region, ccInit.pool, con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.val,
               (Size)(con->ogEvnt->m.ccMsgEvnt.m.ncEvnt.u.msgReq.sipXmlInfo.xmlBody.size));
            }
            RETVOID;
        }
    }
    /*FID16206-*/

    if(con->ccbsIsdnCallInfo)
    {    
       CCDP(AIN_DBG_LEVEL_3, "%s: entering ccbs call \n",__FUNCTION__);

        if ((con->icIntfcCb) && (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_IN))
        {
            TknU8 causeVal;
            TknU8 errType;
            memset(&causeVal, 0, sizeof(TknU8));
            memset(&errType, 0, sizeof(TknU8));

            if(con->ccbsIsdnCallInfo->cgPtyNum.eh.pres != PRSNT_NODEF)
            {
               causeVal.pres = PRSNT_NODEF;
               causeVal.val = CCINFOELMSSG;
               errType.pres = PRSNT_NODEF;
               errType.val = LGTERMDENIAL;
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
               ccbsIsdnSendRelReq(con, causeVal, errType);
               RETVOID;
            }

            if ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_SIP))
            {
                S16 ret = RFAILED;

                if ((ret = ccGetPsSap(&con->ogSapCb,
                                       &con->ogIntfcCb->intfc))!= ROK)
                {
                  CCLOGERR("ccAllocateResourceArray() Failed, ccGetPsSap failed");
                  causeVal.pres = PRSNT_NODEF;
                  causeVal.val = CCINCOMPDEST;
                  errType.pres = PRSNT_NODEF;
                  errType.val = LGTERMDENIAL;
                  CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
                  ccbsIsdnSendRelReq(con, causeVal, errType);
                  
                  RETVOID;
                }
                con->ogSapCb->nmbActvConn++;
                con->ogProtType = con->ogIntfcCb->protType;
                con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_REG;
                ccbsIsdnCallStateMachine(con, (PTR)NULL); 
                RETVOID;
            }
            else
            {
                CCDP(AIN_DBG_LEVEL_0,"outgoing is not SIP, CCBS-T-R retErr\n");
                causeVal.pres = PRSNT_NODEF;
                causeVal.val = CCINCOMPDEST;
                errType.pres = PRSNT_NODEF;
                errType.val = LGTERMDENIAL;
                CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
                ccbsIsdnSendRelReq(con, causeVal, errType);
                RETVOID;
            }
        }
    }

    egressInterCcsCall = CC_EGRESS_INTER_CCS_CALL(con);
    /* Need to skip the router */
    CCDP(AIN_DBG_LEVEL_0, "Sending RscReq:icSu:%ld, numOfOgInterfaces:%ld"
         "currentInterface:%ld, inter-ccs:%d\n", con->icSuConnId,
         con->routeEvnt->numOfOgInterfaces, con->routeEvnt->currentInterface,
         egressInterCcsCall);

    ccFillRealmIdFromtgAtt(con);
    if (egressInterCcsCall)
    {
      cmMemset((U8 *)&interface, 0, sizeof(RmInterface));
      interface.intfType            = CC_BICC_INTFC;
      protType                      = CC_BICC;

#if 0
      interface.t.biccDesc.dstCcsId = con->routeEvnt->ogInterface[con->\
                              routeEvnt->currentInterface].t.biccDesc.dstCcsId;
#else
      if (mgwList) /* FID 14732. 0 */
      {
          CcMgSapCb *pMgSap = NULLP;
          SpId mgSpId;

          index   = con->routeEvnt->currentInterface;
          mgIndex = con->routeEvnt->cacInfo[index].currentMgw;
          mgSpId = con->routeEvnt->cacInfo[index].mgwInfo[mgIndex].mgSpId;

          cmHashListFind(&ccMgSapTbl, (U8 *)&(mgSpId),
                         (U16)sizeof(SpId), (U16)0, (PTR *)&pMgSap);

          if (pMgSap)
          {
            interface.t.biccDesc.dstCcsId = pMgSap->ccsId;
            CCDP(AIN_DBG_LEVEL_0, "%s:dstCcsId:%d,index:%ld, mgIndex:%d\n",
                 __FUNCTION__, interface.t.biccDesc.dstCcsId, index, mgIndex);
          }
      }
      else
      {
          interface.t.biccDesc.dstCcsId =
                       con->routeEvnt->ccsId[con->routeEvnt->currentInterface];
          CCDP(AIN_DBG_LEVEL_0, "%s:dstCcsId:%d\n", __FUNCTION__,
                  interface.t.biccDesc.dstCcsId);
      }
#endif
    }

    ccBillUpdCdPtyNum (__FILE__, __LINE__, con);
    CC_STATE_CHANGE(con, CCS_AWTRSCALOCCFM);

    if ((con->routeEvnt)&&(con->cacCb)&&(!CC_INGRESS_INTER_CCS_CALL(con)))
    {
      con->cacCb->ogswtchComCodec = 
        con->routeEvnt->cacInfo[con->routeEvnt->currentInterface].swtchComCodec;
    }

    if (egressInterCcsCall)
    {
      ccAllocateResourceArray(con, (CcConEvnt *)con->ccEvntHold,
                              CC_OUTGOING, RMT_DONTCARE,
                              &interface, &protType, 1);
    }
    else
    {
      index = con->routeEvnt->currentInterface;
      numOfOgInterfaces = con->routeEvnt->numOfOgInterfaces - 
                          con->routeEvnt->currentInterface;

      /* bug92978 */
      if(ROK != ccCheckForInterfaces(con))
      {
         ccProcessFailCnd(con, FC_RESUNAVAIL, TRUE);
         RETVOID;
      }

      /* FID 14716.0 +*/
      if(CC_GR_OVRFLW_PRES(con) &&
         CC_IS_CALL_FLAG_SET(con->flag, CC_FLAG_GROVRFLW_SKIP))
      {   
          numOfOgInterfaces -= 1;

          /* bug92978 */
          if(numOfOgInterfaces < 1)
          {
             ccProcessFailCnd(con, FC_RESUNAVAIL, TRUE);
             RETVOID;
          }
      }
      /* FID 14716.0 -*/

      ccAllocateResourceArray(con, (CcConEvnt *)con->ccEvntHold,
                              CC_OUTGOING, RMT_DONTCARE,
                              &con->routeEvnt->ogInterface[index],
                              &con->routeEvnt->ogPrtclType[index],
                              numOfOgInterfaces);
    }
    RETVOID;
  }
  else
  {
    CCLOGERR("**: NO more routes. This should never happen. icSu:%lx\n",
        con->icSuConnId);
    CC_TRACE_DUMP(con);
    ccProcessFailCnd(con, FC_INTERNAL, TRUE);
  }
  RETVOID;
}


/*
*
*      Fun:   ccProcessNetworkBusy
*
*      Desc:  When all the resources are busy for a particular route, GCC tries
*             to route on the other carrier if present. If all the carries are
*             exhuasted function returns ROKDNA
*
*      Ret:   ROK    - successful (Network Busy Armed/detected/msg to FIC sent).
*             ROKDNA - successful (Network Busy not armed).
*
*       Notes: This function assumes that the first attempt was routed using
*              TNS.
*
*      File:  cc_lib.c
*
*/
PUBLIC S16 ccProcessNetworkBusy
(
AinBCM_t          *pBcm,
FcNBRelType_e      relType
)
{
  CcConCb            *con           = NULLP;
  U8                  index         = 0;
  S16                 ret           = RFAILED;
  SvcHeader_t         header;
  NetworkBusy_t       networkBusy;

  CCDP(AIN_DBG_LEVEL_1, "ccProcessNetworkBusy:%ld, %ld\n",
                        pBcm->con->icSuConnId, pBcm->con->ogSuConnId);
  con = pBcm->con;

  if ((pBcm->nel[EReqNetworkBusy] == NEL_REQUEST) && (pBcm->svcHeader.transId))
  {
    CCDP(AIN_DBG_LEVEL_0, "NetworkBusy is Armed Req Evnt:%ld, %ld\n",
         con->icSuConnId, con->ogSuConnId);

    ccRestoreEvntHold(con);
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&networkBusy, 0, sizeof(NetworkBusy_t));

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
      pBcm->nel[index] = NEL_UNARMED;

    CCDP(AIN_DBG_LEVEL_0," TransId for OBCM = %ld\n", pBcm->svcHeader.transId);
    ccFillSvcHeader(&header, pBcm, MSG_Network_Busy);
    CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

    ret = ccFillNetworkBusy (&networkBusy, pBcm, FALSE, relType);
    if (ret != ROK)
    {
      CCLOGERR("ERROR: ccFillNetworkBusy failed: %ld\n", con->icSuConnId);
      RETVALUE(RFAILED);
    }                                 
    con->lastState = con->state;
    CC_STATE_CHANGE (con, CCS_AWTRSPFORDPE17);
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
    CCDP(AIN_DBG_LEVEL_0," Sending NetworkBusy: %ld\n", con->icSuConnId);
    CcUiFctNetworkBusy(&networkBusy, &header);
    RETVALUE(ROK);
  }
  else if ( (pBcm->nel[EReqNetworkBusy] == NEL_NOTIFY) && (pBcm->svcHeader.transId))
  {
     ProtType ogProtType =0;
     if (CC_EGRESS_INTER_CCS_CALL(con))
     {
        if (con->ogIntfcCb)
        {
           ogProtType = con->ogIntfcCb->protType;
        }
        else
        {
           ogProtType = con->realLegProtType;
        }
     }
     else
        ogProtType = con->ogProtType;

     CCDP(AIN_DBG_LEVEL_2, "ogProtType %d\n", ogProtType);

    if ((con->direction == OUTTOINC) && CC_IS_PROT_TYPE_BRAZIL(ogProtType))
    {
       CCDP(AIN_DBG_LEVEL_0, "BRAZIL-NetworkBusy is Armed Notf Evnt:%ld, %ld\n",
             con->icSuConnId, con->ogSuConnId);

       ccRestoreEvntHold(con);
       
       cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
       cmMemset((U8 *)&networkBusy, 0, sizeof(NetworkBusy_t));
       CCDP(AIN_DBG_LEVEL_0," TransId for OBCM = %ld\n", pBcm->svcHeader.transId);
       ccFillSvcHeader(&header, pBcm, MSG_Network_Busy);
       CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

       /* FID16901.0 As for CCTMPFAIL GCC will still try to report
        * O_CALLED_PARTY_BUSY to SCP, eliminate here! 
        * This is a hard-code here, when doing the common feature for
        * INAP to report correct events to SCP, needs to remove this
        * then  */
       if (pBcm->nel[EReqOCalledPartyBusy] == NEL_REQUEST )
          pBcm->nel[EReqOCalledPartyBusy] =  NEL_UNARMED;

       ret = ccFillNetworkBusy (&networkBusy, pBcm, TRUE, relType);
       if (ret != ROK)
       {
          CCLOGERR("ERROR: ccFillNetworkBusy failed: %ld\n", con->icSuConnId);
          RETVALUE(RFAILED);
       }                                 
       CCDP(AIN_DBG_LEVEL_0," Sending NetworkBusy: %ld\n", con->icSuConnId);
       CcUiFctNetworkBusy(&networkBusy, &header);
       RETVALUE(ROKIGNORE);
    }
    else
    {
       CCDP(AIN_DBG_LEVEL_0, "NetwortBusy event not armed:%ld, %ld\n",
             con->icSuConnId, con->ogSuConnId);
       RETVALUE(ROKDNA);
    }

  }
  else /* It has to be NEL_UNARMED */
  {
    CCDP(AIN_DBG_LEVEL_0, "NetwortBusy event not armed:%ld, %ld\n",
         con->icSuConnId, con->ogSuConnId);
    RETVALUE(ROKDNA);
  }
}
/*
 *
 *      Fun:   ccConE31SBUF
 *        
 *             event:56 - CCE_MGCTSVCCHGIND
 *             state:     CCE_XXXXXXXX
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE31SBUF
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
#if 0/* PENDING */
  DP("ccConE31SBUF : %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_MGCTSVCCHGIND, sizeof(MgitInd), 0,
                       NULLP, 0);
#endif /* PENDING */
  RETVALUE(ROK);
} 



/*
 *
 *      Fun:   ccConE11SBUF
 *        
 *             event:11 - CCE_MGCTTXNCFM
 *             state:     CCS_XXXXXXXX
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
PRIVATE S16 ccConE11SBUF
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  DP("ccConE11SBUF : %ld\n", con->icSuConnId);

  ccBufferEventToQueue(con, bcm, event, CCE_MGCTTXNCFM, sizeof(MgctTxnCfm), 0,
                       NULLP, 0);
  RETVALUE(ROK);
} 

/*FID16206 +*/
/*
 * *
 * *      Fun:   ccConE99S00
 * *
 * *      Desc:  Connection state function
 * *             event - None call Indication
 * *             state - IDLE
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE99S00
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;

  if(con->icEvntType == DUMMYFAC_IND)
  {
    SvcHeader_t header;
    InfoCollected_t infoCollected;
    int index = 0;
    FacEvnt   *facEvnt = ((CcMsgEvnt*)event)->m.dcEvnt.u.dfInd.inFacEvnt;

    ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->dummyCallInfo),
                   (Size) sizeof(DummyCallInfo));
    if (ret != ROK)
    {
      ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                 LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
      ccRelCon(con);
      RETVALUE(RFAILED);
    }
    cmMemset((U8 *)con->dummyCallInfo, 0, sizeof(DummyCallInfo));   

    if((facEvnt->facilityStr1.eh.pres == NOTPRSNT) ||
       (ccFacStr2FacInfo(&facEvnt->facilityStr1.facilityStr, con->dummyCallInfo, ACTIVATION) != ROK))
    {
      CCDP(AIN_DBG_LEVEL_0, "%s: ccDecFacInfo4Div failed\n", __FUNCTION__);
      memcpy(&con->dummyCallInfo->callSte, &facEvnt->callSte, sizeof(CcCallSte));
      con->dummyCallInfo->dChan = ((CcMsgEvnt*)event)->m.dcEvnt.u.dfInd.dChan;
      ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
      RETVALUE(RFAILED);
    }

    memcpy(&con->dummyCallInfo->callSte, &facEvnt->callSte, sizeof(CcCallSte));
    con->dummyCallInfo->dChan = ((CcMsgEvnt*)event)->m.dcEvnt.u.dfInd.dChan;

    if(facEvnt->callSte.eh.pres == NOTPRSNT ||
       facEvnt->callSte.callGlblSte.pres == NOTPRSNT ||
       facEvnt->callSte.callGlblSte.val != CS_CALLINDEP)
    {
      CCDP(AIN_DBG_LEVEL_0, "%s: Call state is invalid\n", __FUNCTION__);
      ccCleanDummyCall(con, IN_FAC_COMP_INVCALLSTA);
      RETVALUE(RFAILED);
    }

    con->dummyCallInfo->con = con;       
    ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->icBcm.cc),
                   (Size) sizeof(AinCallConfig_t));
    if (ret != ROK)
    {
      ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                 LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
      ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
      RETVALUE(RFAILED);
    }
    cmMemset((U8 *) (con->icBcm.cc), 0, sizeof(AinCallConfig_t));
    con->icBcm.svcHeader.transId = ccGetNewtransId();
    CCDP(AIN_DBG_LEVEL_0," TransId= %ld\n", con->icBcm.svcHeader.transId);
    ret = ccFillBCMInfo(con, &(con->icBcm), con->icBcm.svcHeader.transId,
                      CiOriginatingSetup, PicONull, BtOBcm,
                      DP_ORIGINATION_ATTEMPT);
    con->icBcm.cc->legId01 = & (con->icBcm);
    /* Insert in icBCM Hash table */
    ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(con->icBcm),
                           (U8 *)&(con->icBcm.svcHeader.transId),
                           (U16)sizeof(UConnId));
    if (ret != ROK)
    {
      CCDP(AIN_DBG_LEVEL_3," ccicBCMInsTbl Insertion failed\n");
      ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
      RETVALUE(RFAILED);
    }

    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

    for (index = 0; index < EReqMax; index++)
    {
      con->icBcm.nel[index] = NEL_UNARMED;
    }

    /* Fill in parameters in the Service Header Structure */
    ccFillSvcHeader(&header, &(con->icBcm), MSG_Info_Collected);
    CCDP(AIN_DBG_LEVEL_1," Filled SvcHeader\n");

    /* Fill in parameters in the Info Collected Structure */
    ret = ccFillInfoColltdParam4DummyCall(&infoCollected, &(con->icBcm));

    if (RFAILED == ret)
    {
      CCDP(AIN_DBG_LEVEL_3," ccFillInfoColltdParam4DummyCall failed\n");
      ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
      RETVALUE(RFAILED);
    }
    else if(RINVSEVUSRNR == ret)
    {
      CCDP(AIN_DBG_LEVEL_3," ccFillInfoColltdParam4DummyCall failed\n");
      ccCleanDummyCall(con, IN_FAC_COMP_INVSEVUSRNR);
      RETVALUE(RFAILED);
    }

    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);

    CCDP(AIN_DBG_LEVEL_1,"%s: Sending InfoCollected\n",__FUNCTION__);
    CcUiFctInfoCollected(&infoCollected, &header);
  }
  /* FID 16970.0 */
  else if((con->icEvntType == IN_REGISTER_IND) && (con->icIntfcCb)
        && (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_IN)) 
  {
    SvcHeader_t header;
    InfoCollected_t infoCollected;
    int index = 0;
    RegEvnt   *regEvnt = ((CcMsgEvnt*)event)->m.dcEvnt.u.rInd.inRegEvnt;
    InvokeCompCCBSTReq ccbsTReq;
    TknU8 causeVal;
    TknU8 errType;

    ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->ccbsIsdnCallInfo),
                                 (Size) sizeof(CcbsIsdnCallInfo));
    if (ret != ROK)
    {
       ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
             LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
       CC_STATE_CHANGE(con, CCS_IDLE);
       ccRelCon(con);
       RETVALUE(RFAILED);
    }
    cmMemset((U8 *)&causeVal, 0, sizeof(TknU8));
    cmMemset((U8 *)&errType, 0, sizeof(TknU8));

    cmMemset((U8 *)con->ccbsIsdnCallInfo, 0, sizeof(CcbsIsdnCallInfo));
    cmMemset((U8 *)&ccbsTReq, 0, sizeof(InvokeCompCCBSTReq));
    con->icEvnt = (CcAllSdus *) event;

    if((regEvnt->facilityStr.eh.pres == NOTPRSNT) ||
          (ccFacStr2FacInfo(&regEvnt->facilityStr.facilityStr, (void*)&ccbsTReq, CCBS_T_REQUEST) != ROK))
    {
       CCLOGERR("%s: ccFacStr2FacInfo failed or no facilityStr\n", __FUNCTION__);
       causeVal.pres = PRSNT_NODEF;
       causeVal.val = CCFACREJ;
       ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccbsIsdnSendRelReq(con, causeVal, errType);
       RETVALUE(ROK);
    }
    ccCp.ccbsSts.praCCBSrequestRx++;

    con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_REQUEST;
    con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.invokeCompRequest = ccbsTReq;
    /* Check if the ISDN-IF support CCBS feature. */
    if( (con->icIntfcCb != NULL) && 
        ((con->icIntfcCb->ccbsIsdnMap != CCBS_INMMAP_ORIG) &&
        (con->icIntfcCb->ccbsIsdnMap != CCBS_INMMAP_BOTH)))
    {
       CCDP(AIN_DBG_LEVEL_0, "%s: CCBS is not active!\n", __FUNCTION__);

       causeVal.pres = PRSNT_NODEF;
       causeVal.val = CCFACNOTSUB;
       errType.pres = PRSNT_NODEF; 
       errType.val = NOTSUBSCRIBED;
       ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccbsIsdnSendRelReq(con, causeVal, errType);
       RETVALUE(RFAILED);
    }

    con->ccbsIsdnCallInfo->expires2xx = con->icIntfcCb->ccbsSubscriptionTmr * 60;

    /* save CGPN/CDPN */
    ccConvtAddress2AagCgPtyNum(&ccbsTReq.ccbstreq.orgAddr, 
          &(con->ccbsIsdnCallInfo->cgPtyNum));
    if(con->ccbsIsdnCallInfo->cgPtyNum.eh.pres == PRSNT_NODEF && ccbsTReq.ccbstreq.presAllowInd.pres)
    {
       if(ccbsTReq.ccbstreq.presAllowInd.val)
       {
          con->ccbsIsdnCallInfo->cgPtyNum.presRest.val = PRESALLOW;
       }
       else
       {
          con->ccbsIsdnCallInfo->cgPtyNum.presRest.val = PRESREST;
       }
       con->ccbsIsdnCallInfo->cgPtyNum.presRest.pres = PRSNT_NODEF;
    }
    CCDP(AIN_DBG_LEVEL_3, "%s: presRest pres %d, val %d\n", __FUNCTION__,
          ccbsTReq.ccbstreq.presAllowInd.pres,
          ccbsTReq.ccbstreq.presAllowInd.val);

    ret = ccConvtAddress2AagCdPtyNum(&ccbsTReq.ccbstreq.dstAddr, 
          &(con->ccbsIsdnCallInfo->cdPtyNum));
    if(ret != ROK)
    {
       causeVal.pres = PRSNT_NODEF;
       causeVal.val = CCINVNMBFRM;
       errType.pres = PRSNT_NODEF;
       errType.val = LGTERMDENIAL;
       ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccbsIsdnSendRelReq(con, causeVal, errType);
       RETVALUE(RFAILED);
    }

    if((ccbsTReq.ccbstreq.retSupported.pres) && (ccbsTReq.ccbstreq.retSupported.val == TRUE))
    {
       CCBS_ISDN_SET_RETENTION_SUPPORT_MASK(con->ccbsIsdnCallInfo->ccbsIsdnFlag);
    }
    con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_REG;
    cmInitTimers(con->ccbsIsdnCallInfo->timer, CCBS_ISDN_MAX_RUN_TMR);
    

    ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->icBcm.cc),
                   (Size) sizeof(AinCallConfig_t));
    if (ret != ROK)
    {
      ccGenAlarm(LCM_CATEGORY_RESOURCE, LCC_EVENT_MEMALOC_FAILED,
                 LCC_CAUSE_MALLOC_FAIL, (U8 *) &ret);
      ccRelCon(con);
      RETVALUE(RFAILED);
    }
    cmMemset((U8 *) (con->icBcm.cc), 0, sizeof(AinCallConfig_t));
    con->icBcm.svcHeader.transId = ccGetNewtransId();
    CCDP(AIN_DBG_LEVEL_0," TransId= %ld\n", con->icBcm.svcHeader.transId);
    ret = ccFillBCMInfo(con, &(con->icBcm), con->icBcm.svcHeader.transId,
                      CiOriginatingSetup, PicONull, BtOBcm,
                      DP_ORIGINATION_ATTEMPT);
    con->icBcm.cc->legId01 = & (con->icBcm);
    /* Insert in icBCM Hash table */
    ret = cmHashListInsert(&ccicBCMInsTbl, (PTR) &(con->icBcm),
                           (U8 *)&(con->icBcm.svcHeader.transId),
                           (U16)sizeof(UConnId));
    if (ret != ROK)
    {
      CCLOGERR("ccicBCMInsTbl Insertion failed\n");
      causeVal.pres = PRSNT_NODEF;
      causeVal.val = CCTMPFAIL;
      errType.pres = PRSNT_NODEF;
      errType.val = LGTERMDENIAL;

      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccbsIsdnSendRelReq(con, causeVal, errType);
      RETVALUE(RFAILED);
    }

    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&infoCollected, 0, sizeof(InfoCollected_t));

    for (index = 0; index < EReqMax; index++)
    {
      con->icBcm.nel[index] = NEL_UNARMED;
    }

    /* Fill in parameters in the Service Header Structure */
    ccFillSvcHeader(&header, &(con->icBcm), MSG_Info_Collected);
    CCDP(AIN_DBG_LEVEL_1," Filled SvcHeader\n");

    /* Fill in parameters in the Info Collected Structure */
    ret = ccFillInfoColltdParam4Ccbs(&infoCollected, &(con->icBcm));
    infoCollected.isCcbsTReq = TRUE;

    if (RFAILED == ret)
    {
      causeVal.pres = PRSNT_NODEF;
      causeVal.val = CCTMPFAIL;
      errType.pres = PRSNT_NODEF; 
      errType.val = LGTERMDENIAL;
      CCDP(AIN_DBG_LEVEL_3," ccFillInfoColltdParam4DummyCall failed\n");
      ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
      CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
      ccbsIsdnSendRelReq(con, causeVal, errType);
      RETVALUE(RFAILED);
    }

    CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE3);

    CCDP(AIN_DBG_LEVEL_1,"%s: Sending InfoCollected\n",__FUNCTION__);
    CcUiFctInfoCollected(&infoCollected, &header);
    CCDP(AIN_DBG_LEVEL_1,"%s: CCBS virtual call counter %ld\n",__FUNCTION__, ccCp.sts.totalCCBSVirtual);
  }
  else if((con->icEvntType == BICC_REGISTER_REQ) && (CC_INGRESS_INTER_CCS_CALL(con)) &&
         (con->icProtType == CC_BICCETSI)) 
  {
      CCDP(AIN_DBG_LEVEL_3,"%s: Exgress ccs received register CCBSINFO from BICC.\n",__FUNCTION__);
      CcMsgEvnt ogEvnt;
      RegEvnt inRegEvnt;
      cmMemset((U8 *)&inRegEvnt, 0, sizeof(RegEvnt));
      cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
      ogEvnt.m.dcEvnt.u.rReq.inRegEvnt = &inRegEvnt;
      con->ogEvnt = (CcAllSdus *)&ogEvnt;

      ret = ccMapEvent(con, CCE_NCIND, con->icEvntType);//ccSI2INMapS06M18
      if(ret != ROK)
      {
          CCLOGERR("Error: %s: ccMapEvent failed when map BICC register CCBSINFO to ISDN REGISTER.\n",__FUNCTION__);
          ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, CCTMPFAIL, NULL);
          RETVALUE(RFAILED);
   
      }
      CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId,
                           con->ogSpConnId, con->ogSuConnId,
                           con->ogProtType, &ogEvnt);
      CC_STATE_CHANGE(con,CCS_AWTNCCFM);

  }
  else
  {
    CCLOGERR("Error: %s:Unexpected status.\n",__FUNCTION__);
    ccRelCon(con);
  }

  RETVALUE(ROK);
}

/*
 * *
 * *      Fun:   ccConE99S151
 * *
 * *      Desc:  Connection state function
 * *             event - None Call Indication
 * *             state - CCS_AWTNCCFM
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE99S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
   CCDP(AIN_DBG_LEVEL_1, "%s:\n",__FUNCTION__);
   CcMsgEvnt *msgEvnt = (CcMsgEvnt*) event;
   con->icEvnt = (CcAllSdus *)event;
   /*FID 16970.0 R8068*/
   if( (con->ccbsIsdnCallInfo) && 
	   (CC_GET_PROTOCOL(con->icProtType) == CC_SIP) && 
	   (con->icEvntType == SUBSCRIBE_IND) )
   {
     if ( (msgEvnt->m.ncEvnt.u.subInd.u.ccbsEvntPkg.qOperation.pres == PRSNT_NODEF) &&
          ( (msgEvnt->m.ncEvnt.u.subInd.u.ccbsEvntPkg.qOperation.val == CCBS_Q_OPR_SUSPEND) || 
            (msgEvnt->m.ncEvnt.u.subInd.u.ccbsEvntPkg.qOperation.val == CCBS_Q_OPR_RESUME) ) )
     {
         CCDP(AIN_DBG_LEVEL_1, "%s: buffer suspend and resume.\n",__FUNCTION__); 
         ccBufferEventToQueue(con, bcm, event, CCE_NCIND, sizeof(CcMsgEvnt), 0,
                          NULLP, 0);
         RETVALUE(ROK);
     }

     con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_SUB_IND;
     ccbsIsdnCallStateMachine(con, (PTR)msgEvnt); /* CcbsIsdnHndlE00S */

   }
   else
   {
     ccBufferEventToQueue(con, bcm, event, CCE_NCIND, sizeof(CcMsgEvnt), 0,
                          NULLP, 0);
   }
   RETVALUE(ROK);
}

/*
 * *
 * *      Fun:   ccConE100S151
 * *
 * *      Desc:  Connection state function
 * *             event - None Call Confirm
 * *             state - CCS_AWTNCCFM
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE100S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  NcEvents_t *ncEvnt = (NcEvents_t*) event;
  int ccbsCallFlag = FALSE;  /* FID 16970.0 */

  if((con->dummyCallInfo == NULLP) ||
     (con->dummyCallInfo->dummyCallType == NONDUMMYCALL) ||
     (ncEvnt->u.msgCfm.statusCode.pres != PRSNT_NODEF ))
  {
      ccbsCallFlag = TRUE;
  }
  CCDP(AIN_DBG_LEVEL_1, "ccConE100S151: ccbsCallFlag %d\n", ccbsCallFlag);

  if( ccbsCallFlag == FALSE)
  {
      switch(ncEvnt->u.msgCfm.statusCode.val)
      {
          case SIPCNSTS_200_OK:
              break;
          case SIPCAUSE_400_BADRQST:
          case SIPCAUSE_403_FORBID:
          case SIPCAUSE_409_CONFLCT:
          default:
              CCDP(AIN_DBG_LEVEL_0,"Not 200OK Message received, send Error\n");
              ccStopConTmr(con, CC_TMR_CFXCALLINDP);
              ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
              RETVALUE(ROK);
      } 
      if(con->dummyCallInfo->dummyCallType == INTERROGATION)
      {
          CC_STATE_CHANGE(con, CCS_AWTNCIND);
      }
      else
      {
          FacEvnt inFacEvnt;
          CcMsgEvnt ogEvnt;

          cmMemset((U8 *)&inFacEvnt, 0, sizeof(FacEvnt)); 
          cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
          ogEvnt.m.dcEvnt.u.dfReq.inFacEvnt = &inFacEvnt;

          ccStopConTmr(con, CC_TMR_CFXCALLINDP);

          con->icEvnt = (CcAllSdus *) event;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          con->direction = OUTTOINC;

          ret =  ccMapEvent(con, CCE_NCCFM, con->icEvntType);
          if(ret != ROK)
          {
              CCDP(AIN_DBG_LEVEL_1," Mapping message confirm failed\n");
              ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
              RETVALUE(ROK);
          }

          CcLiCctMsgReq(&con->icSapCb->pst, con->icSapCb->spId, con->icSpConnId,
               con->icSuConnId, con->icProtType, &ogEvnt);

          CC_STATE_CHANGE(con, CCS_IDLE);

          ccRelCon(con);
      }
  }
  else  /* FID 16970.0 */
  {
      FacEvnt inFacEvnt;
      CcMsgEvnt ogEvnt;
      SiCnStEvnt ogEvnt1;
      CcbsEvntPkg_t ccbsEvntPkg;
      TknU8 causeVal;   
      TknU8 errorType;
      ZcUpdParam  upd;

      if(con == NULLP || (con->ccbsIsdnCallInfo == NULLP)) 
      {
          RETVALUE(RFAILED);
      }
      cmMemset ((U8*)&ogEvnt1,0,sizeof(SiCnStEvnt));
      cmMemset ((U8*)&ccbsEvntPkg,0,sizeof(CcbsEvntPkg_t));
      cmMemset((U8 *)&inFacEvnt, 0, sizeof(FacEvnt)); 
      cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
      cmMemset((U8 *)&causeVal, 0, sizeof(TknU8));
      cmMemset((U8 *)&errorType, 0, sizeof(TknU8));
      ogEvnt.m.dcEvnt.u.dfReq.inFacEvnt = &inFacEvnt;

      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      con->direction = OUTTOINC;

      if (((CC_GET_PROTOCOL(con->ogProtType) == CC_IN) && (con->icEvntType == FACILITY_CFM)) ||
         ((con->ogProtType == CC_BICCETSI) && (con->icEvntType == FACILITY_CFM)))  /* ISDN FACILITY msg */
      {
          CCDP(AIN_DBG_LEVEL_1,"FACILITY_CFM , %s \n", __FUNCTION__);

          if(CC_INGRESS_INTER_CCS_CALL(con))
          {
              CCDP(AIN_DBG_LEVEL_1,"%s: Exgress ccs received FACILITY_CFM.\n",__FUNCTION__);

              ret = ccMapEvent(con, CCE_NCCFM, con->icEvntType);//ccIN2SIMapS05M14
              if(ret != ROK)
              {
                  CCLOGERR("Error: %s: ccMapEvent failed when map ISDN FAC to BICC facility CCBSINFO.\n",__FUNCTION__);
                  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                  /*Send REL to the ic bicc */
                  ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                                con->icProtType, CCTMPFAIL, NULL);
                  /*Send REL to the og ISDN*/
                  causeVal.pres = PRSNT_NODEF;
                  causeVal.val = CCCALLCLR;
                  errorType.pres = NOTPRSNT;
                  ccbsIsdnSendRelReq(con, causeVal, errorType);

                  RETVALUE(RFAILED);
              }
              ogEvnt1.callIndpMsgType = ogEvnt.m.biccMsgEvnt.callIndpMsgType;
              ogEvnt1.optElmnt = ogEvnt.m.biccMsgEvnt.optElmnt;
              con->ogEvnt = (CcAllSdus *)&ogEvnt1;
              CC_STATE_CHANGE(con,CCS_AWTNCIND);
#ifdef ZC
              cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
              upd.con = con;
              zcRunTimeUpd(ZC_CON_CB, CMPFTHA_CREATE_REQ, upd);
              zcUpdPeer();
#endif /* ZC */

              con->ogEvntType = CC_ET_CALLINDPFAC;

              CcLiCctCnStReq (&con->icSapCb->pst, con->icSapCb->spId,
                           con->icSpConnId, con->icSuConnId, con->icProtType,
                           con->ogEvntType, (CcCnStEvnt *)(con->ogEvnt), NULLP);
          }
          else
          {
              if(CC_EGRESS_INTER_CCS_CALL(con))
              {
                  CCDP(AIN_DBG_LEVEL_1,"%s: INGRESS CCS received BICC FAC CFM.\n",__FUNCTION__);
                  ret = ccUnPkBiccCcbsCallInfoForInterCcsCall(con,ccCp.genCfg.ownCcsId ,(PTR)event);
                  if(ret != ROK)
                  {
                      CCDP(AIN_DBG_LEVEL_0,"%s:ccUnPkBiccCcbsCallInfoForInterCcsCall failed.\n",__FUNCTION__);
                      CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                      /*Send notify terminated to sip side*/
                      CcbsEvntPkg_t ccbsEvntPkg;
                      cmMemset((U8 *)&ccbsEvntPkg, 0, sizeof(CcbsEvntPkg_t));
                      ccbsEvntPkg.pres = NOTPRSNT;
                      ccbsIsdnSendNotReq(con,(U8)NOTIFY_SUB_STATE_TERMINATED,0,(U32)0,ccbsEvntPkg);

                      /*Send release to exgress ccs*/
                      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                                    con->ogProtType, CCTMPFAIL, NULL);
                      RETVALUE(RFAILED);
                  }
                  if((con->ccbsIsdnCallInfo->ccbsIsdnOpr.type == CCBS_T_REQ_RETRST) &&
                     (con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.returnResultComp.resSeq.reSupported.val))
                  {
                      CCBS_ISDN_SET_RETENTION_SUPPORT_MASK(con->ccbsIsdnCallInfo->ccbsIsdnFlag);
                  }
              }
              con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_FAC;
              ccbsIsdnCallStateMachine(con, (PTR)NULL); /* CcbsIsdnHndlE06S09 */

              ccCp.ccbsSts.praCCBSreturnResultRx++;

              CcLiCctMsgReq(&con->icSapCb->pst, con->icSapCb->spId, con->icSpConnId,
                            con->icSuConnId, con->icProtType, &ogEvnt);
          }
      }
      else if( (CC_GET_PROTOCOL(con->icProtType) == CC_SIP) && 
			   (con->icEvntType == NOTIFY_CFM) )
      {
          switch(ncEvnt->u.notCfm.u.ccbsNotResult.statusCode)
          {
              case SIPCNSTS_200_OK:
              case SIPCAUSE_202_ACCEPTED: 
                  break;
              case SIPCAUSE_400_BADRQST:
              case SIPCAUSE_403_FORBID:
              case SIPCAUSE_409_CONFLCT:
              default:
                  {
                  CCDP(AIN_DBG_LEVEL_0,"%s: Not 200OK Message received for notify," 
                                    "send release to both sides.\n", __FUNCTION__);
                  CC_STATE_CHANGE(con,CCS_AWTRELCFM_BOTH);
                  /*FID 16970.0 R8080*/
                  /*Send Release to ISDN side*/
                  causeVal.pres = PRSNT_NODEF;
                  causeVal.val = CCTMPFAIL;
                  errorType.pres = PRSNT_NODEF;
                  errorType.val = SHTERMDENIAL;
                  if(CC_EGRESS_INTER_CCS_CALL(con))
                  {
                      ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                            con->ogProtType, CCTMPFAIL, NULL);
                  }
                  else
                  {
                      ccbsIsdnSendRelReq(con,causeVal,errorType);
                  }

                  /*Send terminate notify to SIP side*/
                  ccbsEvntPkg.pres = PRSNT_NODEF;
                  ccbsEvntPkg.cancelReason.pres = PRSNT_NODEF;
                  ccbsEvntPkg.cancelReason.val = SIP_CAN_REAS_OPR_RECALL_TIMEOUT;
                  ccbsEvntPkg.qNature = CCBS_Q_NATURE_YES;
                  ccbsIsdnSendNotReq(con,(U8)NOTIFY_SUB_STATE_TERMINATED, 
                           SIP_SUB_STATE_REASON_TIMEOUT,(U32)0,ccbsEvntPkg);

                  RETVALUE(ROK);
                  }
          } 
          CC_STATE_CHANGE(con, CCS_AWTNCIND);

          con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_NOT_CFM;
          ccbsIsdnCallStateMachine(con, (PTR)NULL); /* CcbsIsdnHndlE03S12 */
      }
      else if( (CC_GET_PROTOCOL(con->ogProtType) == CC_SIP) && 
			   (con->icEvntType == SUBSCRIBE_CFM) )
      {
         switch(ncEvnt->u.subCfm.statusCode.val)
         {
            case SIPCNSTS_200_OK:
            case SIPCAUSE_202_ACCEPTED: 
               break;
            case SIPCAUSE_400_BADRQST:
            case SIPCAUSE_403_FORBID:
            case SIPCAUSE_409_CONFLCT:
            default:
               CCDP(AIN_DBG_LEVEL_0,"%s: Not 200OK Message received, send Error\n", __FUNCTION__);

               if(CCBS_ISDN_IS_IC_RELEASED(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
               {
                   CCDP(AIN_DBG_LEVEL_1,"%s: already sent release. No need to anything.\n", __FUNCTION__);
                   ccRelCon(con);
               }
               else
               {
                  causeVal.pres = PRSNT_NODEF;
                  causeVal.val = CCTMPFAIL;
                  errorType.pres = PRSNT_NODEF;
                  errorType.val = SHTERMDENIAL;

                  CC_STATE_CHANGE(con,CCS_AWTRELCFM_IC);
                  CCBS_ISDN_STATE_CHANGE(con->ccbsIsdnCallInfo, CCBS_ISDN_ST_WAIT_RELEASE_COMPLETE);
                  ccbsIsdnSendRelReq(con,causeVal,errorType);
               }
               RETVALUE(ROK);
         }
         CC_STATE_CHANGE(con, CCS_AWTNCIND);
         con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_SUB_CFM;
         ccbsIsdnCallStateMachine(con, (PTR)ncEvnt);
      }
  }
  RETVALUE(ROK);
}

PRIVATE S16 ccConE04S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                   /* bcm */
PTR     event2                   /* event */
)
{
   CcRelEvnt *relEvnt = (CcRelEvnt*) event;
   S16 ret = RFAILED;

   if(con->ccbsIsdnCallInfo == NULL)
   {
       ccRelCon(con);
       RETVALUE(ROK);
   }

   con->icEvnt = (CcAllSdus *)event;
   /*FID 16970.0 R8070*/
   if(con->ccbsIsdnCallInfo->ccbsIsdnMode == CCBS_ISDN_MODE_NOTIFIER)
   {
       con->icEvnt = (CcAllSdus *)event;
       if(CC_INGRESS_INTER_CCS_CALL(con))
       {
           CCDP(AIN_DBG_LEVEL_1, "%s:Exgress CCS received RELEASE IND.\n",__FUNCTION__);
           if(con->direction == INCTOOUT)
           {
              /*send release complete to ic BICC*/
              ccSendReleaseRsp(con);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
              /*send release to ISDN*/
              TknU8 causeVal;
              TknU8 errorType;
              causeVal.pres = PRSNT_NODEF;
              causeVal.val = CCCALLCLR;
              errorType.pres = NOTPRSNT;
              ccbsIsdnSendRelReq(con, causeVal, errorType);
           }
           else
           {
               RetErrComp *retErr = &(con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.returnErrorComp);
               RejectComp *reject = &(con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.rejectComp);
               ret = ccFacStr2FacInfo(&(relEvnt->m.inDiscEvnt.facilityStr1.facilityStr), retErr , CCBS_T_REQ_RETERR);
               if (ret != ROK)
               {
                   ret = ccFacStr2FacInfo(&(relEvnt->m.inDiscEvnt.facilityStr1.facilityStr),reject, CCBS_T_REQ_REJECT);
                   if (ret != ROK)
                   {
                       CCDP(AIN_DBG_LEVEL_0,"%s: No CCBS-T-REQUTET return error component or reject component in RELEASE message.\n",__FUNCTION__);
                   }
                   else
                   {
                       con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_REQ_REJECT;
                   }
               }
               else
               {
                   con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_REQ_RETERR;
               }
           }
           /*Send REL COMPLETE to the og ISDN side*/
           ccSendReleaseRsp(con);

           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           /*Send REL to the ic bicc */
           ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                         con->icProtType, CCTMPFAIL, NULL);
           RETVALUE(ROK);           

       }
       con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_REL;
       ccbsIsdnCallStateMachine(con, (PTR)relEvnt); /* CcbsIsdnHndlE07S09 */
       ccCp.ccbsSts.praCCBSreturnErrorRx++;
   }
   else if(con->ccbsIsdnCallInfo->ccbsIsdnMode == CCBS_ISDN_MODE_SUBSCRIBER)
   {
      CcMsgEvnt ogEvnt;
      S16       ret;

      CCBS_ISDN_SET_IC_RELEASED_MASK(con->ccbsIsdnCallInfo->ccbsIsdnFlag);
      ccSendReleaseRsp(con);

      if (con->ccbsIsdnCallInfo->ccbsIsdnState != CCBS_ISDN_ST_WAIT_SUB200OK_ADD &&
            (!CCBS_ISDN_IS_REFRESH_SUB_SENT(con->ccbsIsdnCallInfo->ccbsIsdnFlag)))
      {
          CCDP(AIN_DBG_LEVEL_1, "%s: need to map RELEASE to SUBSCRIBE\n",__FUNCTION__);
          con->icEvnt = (CcAllSdus *) event;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          ret = ccMapEvent(con, CCE_NCIND, IN_RELEASE_IND);
          if(ret != ROK)
          {
              CCLOGERR(" mapping  RELEASE to SUBSCRIBE failed \n");
              ccRelCon(con);
              RETVALUE(ROK);
          }
          CC_STATE_CHANGE(con, CCS_AWTNCCFM);
          CCBS_ISDN_STATE_CHANGE(con->ccbsIsdnCallInfo,
                               CCBS_ISDN_ST_WAIT_SUB200OK_TERMINATE);
          CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSpConnId,
                          con->ogSuConnId, con->ogProtType, &ogEvnt);
       }
   }
   RETVALUE(ROK);
}

/*
 * *
 * *      Fun:   ccConE99S152
 * *
 * *      Desc:  Connection state function
 * *             event - None call Indication
 * *             state - CCS_AWTNCIND
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE99S152
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = RFAILED;
  FacEvnt inFacEvnt;
  CcMsgEvnt ogEvnt;
  NotifyInd_t *notInd; 
  TknU8 errorType;
  TknU8 causeVal;
  U32 expires = 0;
  U16 wait = 0;
  SiCnStEvnt ogEvnt1;
  ZcUpdParam  upd;

  cmMemset ((U8*)&ogEvnt1,0,sizeof(SiCnStEvnt));
  cmMemset((U8 *)&inFacEvnt, 0, sizeof(FacEvnt));
  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
  cmMemset((U8 *)&errorType, 0, sizeof(TknU8));

  /* FID16970.0 */
  if(con->ccbsIsdnCallInfo && 
	 (con->icEvntType == FACILITY_IND) && 
	 ( (CC_GET_PROTOCOL(con->ogProtType) == CC_IN) ||
	   (CC_GET_PROTOCOL(con->icProtType) == CC_IN) ) &&
	 (con->direction == INCTOOUT))
  {
     FacEvnt   *facEvnt = ((CcMsgEvnt*)event)->m.dcEvnt.u.dfInd.inFacEvnt;
     InvokeCompCCBSTRelated invokeCompCCBSTRelated;
     U8          cause = 0;
     Bool        statusReq = FALSE;
     Bool        isSuspend = FALSE;
     Bool        isResume = FALSE;

     CCDP(AIN_DBG_LEVEL_0, "%s: received FACILITY, ccbsIsdnState %d\n", __FUNCTION__, con->ccbsIsdnCallInfo->ccbsIsdnState);

     cmMemset((U8 *)&invokeCompCCBSTRelated, 0, sizeof(InvokeCompCCBSTRelated));
     /* check current state for SUSPEND and RESUME */
     ret = ccFacStr2FacInfo(&(facEvnt->facilityStr1.facilityStr),&invokeCompCCBSTRelated , CCBS_T_RELATED);
     if(ret != ROK) 
     {
        RejectComp  rejectComp;
        CCLOGERR("%s: decoding CCBS_T_RELATED failed\n", __FUNCTION__);
        cmMemset((U8 *)&rejectComp, 0, sizeof(RejectComp));
        if(ccFacStr2FacInfo(&(facEvnt->facilityStr1.facilityStr),&rejectComp , CCBS_T_REQ_REJECT) == ROK)
        {
           CcbsEvntPkg_t ccbsEvntPkg;
           causeVal.pres = PRSNT_NODEF;
           causeVal.val = CCFACREJ;
           errorType.pres = NOTPRSNT;

           con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_REQ_REJECT;
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
           ccbsIsdnSendRelReq(con, causeVal, errorType);
           cmMemset((U8 *)&ccbsEvntPkg, 0, sizeof(CcbsEvntPkg_t));
           ccbsIsdnSendNotReq(con,(U8)NOTIFY_SUB_STATE_TERMINATED, SIP_SUB_STATE_REASON_REJECTED,(U32)0,ccbsEvntPkg);
           RETVALUE(ROK);
        }

        cause = CCINVINFOEL;
        statusReq = TRUE;
     }
     isSuspend = CC_IS_CCBS_TSUSPEND(invokeCompCCBSTRelated.invCompOperation.u.glVal);
     isResume = CC_IS_CCBS_TRESUME(invokeCompCCBSTRelated.invCompOperation.u.glVal);

     CCDP(AIN_DBG_LEVEL_1,"%s: isSuspend %d, isResume %d, ccbs state %d \n", __FUNCTION__, 
           isSuspend, isResume, con->ccbsIsdnCallInfo->ccbsIsdnState);

     if(!isSuspend && !isResume)
     {
        cause = CCINVINFOEL;
        statusReq = TRUE;
     }

     if(statusReq == TRUE)
     {
        /* req8042 send STATUS back */
        ccSendStaReq(con, CCE_NCIND, cause, INCTOOUT);

        RETVALUE(ROK);
     }


     CCDP(AIN_DBG_LEVEL_0, "%s: received SUSPEND/RESUME\n", __FUNCTION__);

     if(isSuspend)
     {
        con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_SUSPEND;
        memcpy(&con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.invokeCompSuspend, 
              &invokeCompCCBSTRelated, sizeof(InvokeCompCCBSTRelated));
        ccCp.ccbsSts.praCCBSsuspendRx++;
     }
     if(isResume)
     {
        con->ccbsIsdnCallInfo->ccbsIsdnOpr.type = CCBS_T_RESUME;
        memcpy(&con->ccbsIsdnCallInfo->ccbsIsdnOpr.u.invokeCompResume,
              &invokeCompCCBSTRelated, sizeof(InvokeCompCCBSTRelated));
        ccCp.ccbsSts.praCCBSresumeRx++;
     }

     con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_FAC;
     ccbsIsdnCallStateMachine(con, (PTR)event);
     RETVALUE(ROK);
  }
  /*FID 16970.0*/
  else if((con->icEvntType == FACILITY_IND) &&
         (con->ccbsIsdnCallInfo) && con->direction == OUTTOINC)
  {
      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      if(CC_INGRESS_INTER_CCS_CALL(con))
      {
          CCDP(AIN_DBG_LEVEL_1,"%s: Exgress ccs received FACILITY_IND.\n",__FUNCTION__);
          ret =  ccMapEvent(con, CCE_NCIND, con->icEvntType);/*ccIN2SIMapS05M14*/
          if(ret != ROK)
          {
              CCLOGERR("Error: %s: ccMapEvent failed when map ISDN FAC to BICC facility CCBSINFO.\n",__FUNCTION__);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
              /*Send REL to the ic bicc */
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, CCTMPFAIL, NULL);
              /*Send REL to the og ISDN*/
              TknU8 causeVal;
              TknU8 errorType;
              causeVal.pres = PRSNT_NODEF;
              causeVal.val = CCCALLCLR;
              errorType.pres = NOTPRSNT;
              ccbsIsdnSendRelReq(con, causeVal, errorType);

              RETVALUE(RFAILED);
          }
          ogEvnt1.callIndpMsgType = con->ogEvnt->m.ccMsgEvnt.m.biccMsgEvnt.callIndpMsgType;
          ogEvnt1.optElmnt = con->ogEvnt->m.ccMsgEvnt.m.biccMsgEvnt.optElmnt;
          con->ogEvnt = (CcAllSdus *) &ogEvnt1;
#ifdef ZC
          cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
          upd.featMsg.suConnId     = con->icSuConnId;
          upd.featMsg.ccAinUpdType = CC_UPDATE_CCBSINFO;
          upd.featMsg.ccbsInfo = con->ccbsIsdnCallInfo;
          zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
          zcUpdPeer();
#endif /* ZC */

          con->ogEvntType = CC_ET_CALLINDPFAC;

          CcLiCctCnStReq (&con->icSapCb->pst, con->icSapCb->spId,
                           con->icSpConnId, con->icSuConnId, con->icProtType,
                           con->ogEvntType, (CcCnStEvnt *)(con->ogEvnt), NULLP);

          RETVALUE(ROK);
      }
      else
      {
          if(CC_EGRESS_INTER_CCS_CALL(con))
          {
              CCDP(AIN_DBG_LEVEL_1,"%s: INGRESS CCS received BICC FAC IND.\n",__FUNCTION__);
              ret = ccUnPkBiccCcbsCallInfoForInterCcsCall(con,ccCp.genCfg.ownCcsId ,(PTR)event);
              if(ret != ROK)
              {
                  CCDP(AIN_DBG_LEVEL_0,"%s:ccUnPkBiccCcbsCallInfoForInterCcsCall failed.\n",__FUNCTION__);
                  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
                  /*Send notify terminated to sip side*/
                  CcbsEvntPkg_t ccbsEvntPkg;
                  cmMemset((U8 *)&ccbsEvntPkg, 0, sizeof(CcbsEvntPkg_t));
                  ccbsEvntPkg.pres = NOTPRSNT;
                  ccbsIsdnSendNotReq(con,(U8)NOTIFY_SUB_STATE_TERMINATED,0,(U32)0,ccbsEvntPkg);

                  /*Send release to exgress ccs*/
                  ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                                    con->ogProtType, CCTMPFAIL, NULL);
                  RETVALUE(RFAILED);
              }
          }
          con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_FAC;
          ccbsIsdnCallStateMachine(con, (PTR)NULL); /* CcbsIsdnHndlE06S11 */

          ccCp.ccbsSts.praCCBSremoteUserFreeRx++;
      }

      if(con->state == CCS_AWTRELCFM_IC || con->state == CCS_AWTRELCFM_OG || con->state == CCS_AWTRELCFM_BOTH)
         RETVALUE(ROK);
      else
         CC_STATE_CHANGE(con, CCS_AWTNCCFM);

      RETVALUE(ROK);
  }
  else if((con->icEvntType == SUBSCRIBE_IND) && (con->ccbsIsdnCallInfo))
  {
      SubscribeInd_t *subInd;
      subInd = &(((CcMsgEvnt *)event)->m.ncEvnt.u.subInd);
      con->icEvnt = (CcAllSdus *)event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;

      if (subInd->u.ccbsEvntPkg.pres != PRSNT_NODEF)
      {
          CCDP(AIN_DBG_LEVEL_1,"%s: receive a subscribe without a body.\n", __FUNCTION__);
          if (subInd->expires.pres == PRSNT_NODEF )
          {
              if (subInd->expires.val != 0)
              {
                  CCDP(AIN_DBG_LEVEL_1,"%s: update timer to: %d\n", __FUNCTION__, (int)(subInd->expires.val)); 
                  ccbsIsdnStopTmr(CCBS_ISDN_SUBSCRIPTION_TMR, con);
                  expires = subInd->expires.val; 
                  ccbsIsdnSendSubRsp(con, SIPCNSTS_200_OK, 0, expires);
                  ccbsIsdnStartTmr(CCBS_ISDN_SUBSCRIPTION_TMR, con, subInd->expires.val);
              }
              else
              {
                  CCDP(AIN_DBG_LEVEL_1,"%s: expires=0, release call. \n", __FUNCTION__); 
                  con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_SUB_IND;
                  ccbsIsdnCallStateMachine(con, (PTR)NULL);
              }
          }
          else
          {
              CCDP(AIN_DBG_LEVEL_1,"%s: receive a refresh subscribe" 
                    "with no body and expires, just send 200 OK.\n", 
                    __FUNCTION__);

              ccbsIsdnTmrGetRemain(CCBS_ISDN_SUBSCRIPTION_TMR, con, &wait);
              CCDP(AIN_DBG_LEVEL_1,"%s: remain timer: %d. \n", __FUNCTION__, (int)wait);

              ccbsIsdnSendSubRsp(con, SIPCNSTS_200_OK, 0, wait);
          }
      }
      else
      {
          /*FID 16970.0 R8086*/
          con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_SUB_IND;
          ccbsIsdnCallStateMachine(con, (PTR)NULL); /* CcbsIsdnHndlE00S13 */
          if(con->state == CCS_AWTRELCFM_IC || con->state == CCS_AWTRELCFM_OG || con->state == CCS_AWTRELCFM_BOTH)
             RETVALUE(ROK);
          else
             CC_STATE_CHANGE(con, CCS_AWTNCCFM);
      }

      RETVALUE(ROK);
  }
  else if((con->icEvntType == FACILITY_SUSPEND || con->icEvntType == FACILITY_RESUME) &&
           (CC_INGRESS_INTER_CCS_CALL(con)) && (con->icProtType == CC_BICCETSI)) 
  {
      /* inter-ccs for suspend & resume */
      CCDP(AIN_DBG_LEVEL_1,"%s: Exgress ccs received SUB IND.\n",__FUNCTION__);

      ret = ccUnPkBiccCcbsCallInfoForInterCcsCall(con,ccCp.genCfg.ownCcsId ,(PTR)event);
      if(ret != ROK)
      {
          CCLOGERR("Error: %s: UnPkBiccCcbsCallInfo failed when map BICC facility CCBSINFO to ISDN FAC.\n",__FUNCTION__);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL, NULL);
          
          TknU8 causeVal;
          TknU8 errorType;
          causeVal.pres = PRSNT_NODEF;
          causeVal.val = CCCALLCLR;
          errorType.pres = NOTPRSNT;
          ccbsIsdnSendRelReq(con, causeVal, errorType);

          RETVALUE(RFAILED);
      }

      cmMemset((U8 *)&inFacEvnt, 0, sizeof(FacEvnt));
      cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));
      ogEvnt.m.dcEvnt.u.dfReq.inFacEvnt = &inFacEvnt;
      con->ogEvnt = (CcAllSdus *)&ogEvnt;
      con->icEvnt = (CcAllSdus *)event;

      ret =  ccMapEvent(con, CCE_NCIND, con->icEvntType);/*ccSI2INMapS06M19*/
      if(ret != ROK)
      {
          CCLOGERR("Error: %s: ccMapEvent failed when map BICC facility CCBSINFO to ISDN FAC.\n",__FUNCTION__);
          CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);
          ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                        con->icProtType, CCTMPFAIL, NULL);
          TknU8 causeVal;
          TknU8 errorType;
          causeVal.pres = PRSNT_NODEF;
          causeVal.val = CCCALLCLR;
          errorType.pres = NOTPRSNT;
          ccbsIsdnSendRelReq(con, causeVal, errorType);

          RETVALUE(RFAILED);
      }
#ifdef ZC
      cmMemset((U8 *)&upd, 0, sizeof(ZcUpdParam));
      upd.featMsg.suConnId     = con->icSuConnId;
      upd.featMsg.ccAinUpdType = CC_UPDATE_CCBSINFO;
      upd.featMsg.ccbsInfo = con->ccbsIsdnCallInfo;
      zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
      zcUpdPeer();
#endif /* ZC */

      CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId,
                           con->ogSpConnId, con->ogSuConnId,
                           con->ogProtType, &ogEvnt);
      RETVALUE(ROK);
  }

  notInd = &(((CcMsgEvnt *)event)->m.ncEvnt.u.notInd);

  if(con->ccbsIsdnCallInfo && con->icEvntType == NOTIFY_IND &&
        (notInd->u.ccbsEvntPkg.pres == PRSNT_NODEF)) 
  {
     if (CCBS_ISDN_IS_REFRESH_SUB_SENT(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
     {
        if(notInd->subState.pres && notInd->subState.val == NOTIFY_SUB_STATE_TERMINATED)
        {
           ccbsIsdnSendNotRsp(con, SIPCNSTS_200_OK);
        }
        else
        {
           /*Invalid Notify received, terminate the call */
           ccbsIsdnSendNotRsp(con, SIPCAUSE_400_BADRQST);
        }

        if (CCBS_ISDN_IS_IC_RELEASED(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
        {
           ccRelCon(con);
        }
        else
        {
           errorType.pres = PRSNT_NODEF;
           errorType.val = SHTERMDENIAL;
           causeVal.pres = PRSNT_NODEF;
           causeVal.val = CCNORMUNSPEC;
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           CCBS_ISDN_STATE_CHANGE(con->ccbsIsdnCallInfo, CCBS_ISDN_ST_WAIT_RELEASE_COMPLETE);
           ccbsIsdnSendRelReq(con, causeVal, errorType);
        }
        RETVALUE(ROK);
     }

     /* req 8062 */
     if (notInd->subState.pres && notInd->subState.val == NOTIFY_SUB_STATE_TERMINATED) 
     {
        ccbsIsdnStopAllTmrs(con);
        causeVal.pres = PRSNT_NODEF;
        causeVal.val = CCNORMUNSPEC;
        errorType.pres = NOTPRSNT;

        CCDP(AIN_DBG_LEVEL_3, "%s: cancelReason pres %d, val %d\n", __FUNCTION__, 
              notInd->u.ccbsEvntPkg.cancelReason.pres,
              notInd->u.ccbsEvntPkg.cancelReason.val);
        CCDP(AIN_DBG_LEVEL_3, "%s: denialReason pres %d, val %d\n", __FUNCTION__, 
              notInd->u.ccbsEvntPkg.denialReason.pres,
              notInd->u.ccbsEvntPkg.denialReason.val);

        ccbsIsdnSendNotRsp(con, SIPCNSTS_200_OK);

        if(notInd->u.ccbsEvntPkg.cancelReason.pres) 
        {
           if(notInd->u.ccbsEvntPkg.cancelReason.val == SIP_CAN_REAS_OPR_TIMEOUT ||
                 notInd->u.ccbsEvntPkg.cancelReason.val == SIP_CAN_REAS_OPR_RECALL_TIMEOUT) 
           {
              causeVal.val = CCTMRRECOV;
           }

           if(notInd->u.ccbsEvntPkg.cancelReason.val == SIP_CAN_REAS_OPR_TIMEOUT)
           {
              errorType.pres = PRSNT_NODEF;
              errorType.val = SHTERMDENIAL;
           }
        }
        else
        {
           errorType.pres = PRSNT_NODEF;

           if(notInd->u.ccbsEvntPkg.denialReason.pres)
           {
              if(notInd->u.ccbsEvntPkg.denialReason.val == CCBS_DENIAL_REASON_LONGTERM)
                 errorType.val = LGTERMDENIAL;
              else
                 errorType.val = SHTERMDENIAL;
           }
           else
           {
              errorType.val = SHTERMDENIAL;
           }
        }

        if(CCBS_ISDN_IS_IC_RELEASED(con->ccbsIsdnCallInfo->ccbsIsdnFlag) ||
           con->ccbsIsdnCallInfo->ccbsIsdnState == CCBS_ISDN_ST_WAIT_NOTIFY_TERMINATE)
           ccRelCon(con);
        else
        { 
           ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
           ccbsIsdnSendRelReq(con, causeVal, errorType);
        }
        RETVALUE(ROK);
     }
     else
     {
        if(notInd->subState.pres && notInd->subState.val == NOTIFY_SUB_STATE_ACTIVE &&
              ((notInd->eventType == EVT_TYPE_CCBS &&
                notInd->u.ccbsEvntPkg.qNature  == CCBS_Q_NATURE_YES &&
               (notInd->u.ccbsEvntPkg.qState.val == CCBS_REQ_STATE_QUEUED ||
                 notInd->u.ccbsEvntPkg.qState.val == CCBS_REQ_STATE_FREE4RECALL)) ||
               (notInd->eventType == EVT_TYPE_NONE &&
                (con->ccbsIsdnCallInfo->ccbsIsdnState == CCBS_ISDN_ST_WAIT_NOTIFY_SUSPEND_REQ_QUEUED ||
                 con->ccbsIsdnCallInfo->ccbsIsdnState == CCBS_ISDN_ST_WAIT_NOTIFY_RESUME_REQ_QUEUED))))
        {
           CCDP(AIN_DBG_LEVEL_3, "%s: CCBS qstate %d\n", __FUNCTION__, notInd->u.ccbsEvntPkg.qState.val);
           ccbsIsdnSendNotRsp(con, SIPCNSTS_200_OK);
           con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_NOT_IND;
           ccbsIsdnCallStateMachine(con, (PTR)event);
        }
        else
        {
           ccbsIsdnSendNotRsp(con, SIPCAUSE_400_BADRQST);
           /* received invalid NOTIFY */
           if (CCBS_ISDN_IS_IC_RELEASED(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
              ccRelCon(con);
           else
           {
               ccbsIsdnStopAllTmrs(con);
               causeVal.pres = PRSNT_NODEF;
               causeVal.val = CCNORMUNSPEC;
               errorType.pres = PRSNT_NODEF; /* bug93908 */
               errorType.val  = SHTERMDENIAL;

               ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
               CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
               ccbsIsdnSendRelReq(con, causeVal, errorType);
           }
        }
     }
     RETVALUE(ROK);
  }
  else if (con->ccbsIsdnCallInfo && con->icEvntType == NOTIFY_IND &&
           (notInd->u.ccbsEvntPkg.pres == NOTPRSNT))
  {
      CCDP(AIN_DBG_LEVEL_3, "%s: receive notify with no ccbs body. just send 200 OK.\n", __FUNCTION__);
      ccbsIsdnSendNotRsp(con, SIPCNSTS_200_OK); 
      con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_NOT_IND;
      ccbsIsdnCallStateMachine(con, (PTR)event);
      RETVALUE(ROK);
  }

  ogEvnt.m.dcEvnt.u.dfReq.inFacEvnt = &inFacEvnt;

  ccStopConTmr(con, CC_TMR_CFXCALLINDP);

  con->icEvnt = (CcAllSdus *) event;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;
  con->direction = OUTTOINC;
  ret = ccMapEvent(con, CCE_NCIND, con->icEvntType);
  if(ret != ROK)
  {
    CCDP(AIN_DBG_LEVEL_1," Mapping message indication failed\n");
    ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
    RETVALUE(ROK);
  }

  CcLiCctMsgReq(&con->icSapCb->pst, con->icSapCb->spId, con->icSpConnId,
                   con->icSuConnId, con->icProtType, &ogEvnt);

  CC_STATE_CHANGE(con, CCS_IDLE);

  ccRelCon(con);

  RETVALUE(ROK);
}

/*
 * *
 * *      Fun:   ccConE101S151
 * *
 * *      Desc:  Connection state function
 * *             event - Call Independent Timer Expire
 * *             state - CCS_AWTNCCFM
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE101S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  CCDP(AIN_DBG_LEVEL_1," Timeout for waiting message confirm\n");
  ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
  RETVALUE(ROK);
}

/*
 * *
 * *      Fun:   ccConE101S152
 * *
 * *      Desc:  Connection state function
 * *             event - Call Independent Timer Expire
 * *             state - CCS_AWTNCCFM
 * *      Ret:   ROK     - successful,
 * *             RFAILED - unsuccessful
 * *
 * *      Notes: None.
 * *
 * *      File:  cc_bdy2.c
 * *
 * */
PRIVATE S16 ccConE101S152
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{

  CCDP(AIN_DBG_LEVEL_1," Timeout for waiting message indication\n");
  ccCleanDummyCall(con, IN_FAC_COMP_NOTAVE);
  RETVALUE(ROK);
}

/*FID16206 -*/

/* TELICA-jwh-10/05/2001:  Add GCC fsm profiling */
#ifdef CC_FSM_PROFILE
#define CC_FSM_PROFILE_DUMP_FILE "../../log/ccprofile.log"
#define CC_FSM_PROFILE_MAX_SAMP (500000)
#define CC_FSM_PROFILE_HL_BINS (32)

typedef struct CcFsmProfileHlKey_Tag
{
  char *lastFile;
  int lastLine;
  U8 evntType;
  char *newFile;
  int newLine;
}CcFsmProfileHlKey_t;

typedef struct CcFsmProfileState_Tag
{
  CmHashListEnt hl;  /* Hash List entry structure */
  CcFsmProfileHlKey_t key;
  U8 oldState;
  U8 newState;
  U32 numSamp;
  U32 cumTicks;
  U32 lowTicks;
  U32 highTicks;
  U32 cumClkTicks;
  U32 lowClkTicks;
  U32 highClkTicks;
} CcFsmProfileState_t;

typedef struct CcFsmProfileDumpRecord_Tag
{
  CcFsmProfileHlKey_t key;
  U8 oldState;
  U8 newState;
  PTR handle;
  U16 cpuTicks;
  U32 clkTicks;
}CcFsmProfileDumpRecord_t;

typedef CcFsmProfileDumpRecord_t CcFsmProfileDumpRecordArrayElement_t[1];

typedef struct CcFsmProfileCb_Tag
{
  U32 alocBytes;  /* Size of allocated buffer */
  U32 totalLog;   /* number of records the user wants to dump */
  U32 currLog;    /* number of records ready to be dumped */
  FILE *stream;
  CcFsmProfileDumpRecord_t *ccFsmProfileDumpLog;
} CcFsmProfileCb_t;

typedef enum CcFsmProfileAction_Tag
{
  CC_FSM_CMD_INVALID,
  CC_FSM_CMD_START,
  CC_FSM_CMD_STOP,
  CC_FSM_CMD_PRINT,
  CC_FSM_CMD_DUMP,
  CC_FSM_CMD_MAX
}CcFsmProfileAction_t;

CmHashListCp ccFsmProfileHlCp;
CcFsmProfileCb_t ccFsmProfileCb = {0,0,0,NULL,NULL};

CcFsmProfileStatus_t ccFsmProfileStatus = CC_FSM_PROFILE_NONE;      /* Profiling status */

static void ccFsmProfileWalkHl(CcFsmProfileAction_t cmd);

void ccProfileEvtDump(void);


/************************************************************************
 ** ccFsmProfileCmd
 **
 **     Desc:  This functions handle sigdbg commands related to GCC FSM
 **            profiling.
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccFsmProfileCmd(char *string)
{
  char cmdStr[81]="";
  U32 numSamp=0;
  int numArg;
  U16 ret;
  CcFsmProfileAction_t cmd = CC_FSM_CMD_INVALID;

  numArg = sscanf(string, "%*s %s %lu", cmdStr, &numSamp);

  if (numArg)
    {
      if (strncmp (cmdStr, "start", strlen ("start")) == 0)
        {
          cmd = CC_FSM_CMD_START;
        }
      else if (strncmp (cmdStr, "stop", strlen ("stop")) == 0)
        {
          cmd = CC_FSM_CMD_STOP;
        }
      else if (strncmp (cmdStr, "print", strlen ("print")) == 0)
        {
          cmd = CC_FSM_CMD_PRINT;
        }
      else if ( (numArg == 2) && 
                (strncmp (cmdStr, "dump", strlen ("dump")) == 0) &&
                (numSamp > 0) && (numSamp <= CC_FSM_PROFILE_MAX_SAMP))
        {
          cmd = CC_FSM_CMD_DUMP;
        }

      switch(cmd)
        {
        case CC_FSM_CMD_START:

          if (ccFsmProfileHlCp.hl == NULL)
            {
              if (cmHashListInit(&ccFsmProfileHlCp, (U16) CC_FSM_PROFILE_HL_BINS, 0,
                                 (Bool)FALSE, (U16)CM_HASH_KEYTYPE_DEF, DFLT_REGION,DFLT_POOL)!=ROK)
                {
                  DP("cmHashListInit failed\n");              
                  return;
                }
            }
          else if (ccFsmProfileStatus == CC_FSM_PROFILE_ACTIVE) 
            {
              /* Walk hash list, reseting all stats */
              ccFsmProfileWalkHl(cmd);

              /* Reset dump buffer if necessary */
              if (ccFsmProfileCb.ccFsmProfileDumpLog)
                {
                  ccFsmProfileCb.currLog = 0;
                }
            }            

          ccFsmProfileStatus = CC_FSM_PROFILE_ACTIVE;

          break;

        case CC_FSM_CMD_STOP: 
 
          if (ccFsmProfileStatus == CC_FSM_PROFILE_ACTIVE)
            {
              /* Walk hash list printing stats and freeing control blocks */
              ccFsmProfileWalkHl(cmd);

              /* Free dump log if necessary */
              if (ccFsmProfileCb.ccFsmProfileDumpLog != NULL)
                {
                  fclose(ccFsmProfileCb.stream);

                  ret = SPutSBuf(DFLT_REGION, DFLT_POOL, 
                                 ccFsmProfileCb.ccFsmProfileDumpLog,
                                 ccFsmProfileCb.alocBytes); 
                  if (ret != ROK)
                    {
                      DP("CC profile: Error freeing dump log\n");
                    }
                          
                  ccFsmProfileCb.alocBytes = 0;
                  ccFsmProfileCb.totalLog = 0;
                  ccFsmProfileCb.currLog = 0;
                  ccFsmProfileCb.stream = NULL;
                  ccFsmProfileCb.ccFsmProfileDumpLog = NULL;
                }

              ccIntProfileStop();


              DP("CC Profile:  stopping\n");

              ccProfileEvtDump();

            }


          ccFsmProfileStatus = CC_FSM_PROFILE_STOPPED;

          break;

        case CC_FSM_CMD_PRINT: 

          if (ccFsmProfileStatus == CC_FSM_PROFILE_ACTIVE)
            {
              /* Walk hash list printing stats */
              ccFsmProfileWalkHl(cmd);
            }
          break;

        case CC_FSM_CMD_DUMP:
          if (ccFsmProfileStatus == CC_FSM_PROFILE_ACTIVE)
            {
              if (ccFsmProfileCb.ccFsmProfileDumpLog != NULL)
                {
                  DP("CC profile:  a dump is already in progress.  %ld of %ld records have been collected\n",
                     ccFsmProfileCb.currLog, ccFsmProfileCb.totalLog);
                }
              else
                {
                  /* Open log file */ 
                  if ((ccFsmProfileCb.stream = fopen(CC_FSM_PROFILE_DUMP_FILE, "w")) == NULL)
                    {
                      DP("CC profile: Error:  Can't open %s\n",CC_FSM_PROFILE_DUMP_FILE);
                      return;
                    }

                  ccFsmProfileCb.totalLog = numSamp;
                  ccFsmProfileCb.currLog = 0;

                  /* Determine number of bytes to allocate */
                  ccFsmProfileCb.alocBytes = sizeof(CcFsmProfileDumpRecordArrayElement_t)*ccFsmProfileCb.totalLog;

                  /* Allocate dump buffer */
                  ret = SGetSBuf(DFLT_REGION, DFLT_POOL, (Data **) &ccFsmProfileCb.ccFsmProfileDumpLog,
                                 ccFsmProfileCb.alocBytes); 
                  if (ret != ROK)
                    {
                      DP("CC profile: Error:  Can't alloc %ld bytes for dump\n",ccFsmProfileCb.alocBytes);

                      fclose(ccFsmProfileCb.stream);

                      ccFsmProfileCb.alocBytes = 0;
                      ccFsmProfileCb.totalLog = 0;
                      ccFsmProfileCb.currLog = 0;
                      ccFsmProfileCb.stream = NULL;
                      ccFsmProfileCb.ccFsmProfileDumpLog = NULL;
                    }
                }
            }
          else
            {
              DP("CC profile:  Error:  profiling is not active\n");
            }

          break;

        default:
          DP("CC profile:  Error: Invalid command\n");
          break;
        } /* switch */
    }
}    /* End of ccFsmProfileCmd */

/************************************************************************
 ** ccStateStr
 **
 **     Desc:  Convert state to string.
 **
 **     Ret:   state string or "INVALID_STATE"
 **
 ************************************************************************/
extern char *ccStateStr(U8 state)
{
  char *stateStr;

  switch (state)
    {
    case CCS_IDLE                   : /* connection idle */
      stateStr = "CCS_IDLE";
      break;
    case CCS_AWTROUTERSC            : /* awaiting resource to start routing */
      stateStr = "CCS_AWTROUTERSC";
      break;
    case CCS_AWTROUTEDGT            : /* awaiting digits to start routing */
      stateStr = "CCS_AWTROUTEDGT";
      break;
    case CCS_AWTRSPODISCONNECT          : /* awaiting routing confirmation */
      stateStr = "CCS_AWTRSPODISCONNECT";
      break;
    case CCS_AWTRSCALOCCFM          : /* awaiting resource aloc confirmation */
      stateStr = "CCS_AWTRSCALOCCFM";
      break;
    case CCS_AWTENBLOCSND           : /* awaiting digits for enblock con req */
      stateStr = "CCS_AWTENBLOCSND";
      break;
    case CCS_AWTOGRSC               : /* awaiting outgoing resources */
      stateStr = "CCS_AWTOGRSC";
      break;
    case CCS_AWTANSSWT              : /* awaiting answer and switching cfm */
      stateStr = "CCS_AWTANSSWT";
      break;
    case CCS_AWTSWTCFM              : /* awaiting switching cfm */
      stateStr = "CCS_AWTSWTCFM";
      break;
    case CCS_AWTANS                 : /* awaiting answer */
      stateStr = "CCS_AWTANS";
      break;
    case CCS_ANSWERED               : /* call established */
      stateStr = "CCS_ANSWERED";
      break;
    case CCS_AWTRSPTIMEOUT          : /* awaiting route confirm to clear */
      stateStr = "CCS_AWTRSPTIMEOUT";
      break;
    case CCS_AWTRSCCFM_TOCLR        : /* awaiting resource aloc conf to clear*/
      stateStr = "CCS_AWTRSCCFM_TOCLR";
      break;
    case CCS_AWTOGRSC_TOCLR         : /* awaiting outgoing resource to clear */
      stateStr = " CCS_AWTOGRSC_TOCLR";
      break;
    case CCS_AWT_MGI_XFERQRYHOLD    : /* awaiting txnCfm for Hold/Xfer/qry */
      stateStr = "CCS_EMPTY_STATE_1";
      break;
    case CCS_AWTRSCALLOCCFM_GLARE : /* awaiting resource alloc cfm - To resolve internal glare - CC and SI seized same rsc for 2 different calls */
      stateStr = "CCS_AWTRSCALLOCCFM_GLARE";
      break;
    case COT_OG_DONE              : /* */
      stateStr = "COT_OG_DONE";
      break;
    case CCS_AWTRELCFM_IC           : /* awaiting release confirmation from incoming */
      stateStr = "CCS_AWTRELCFM_IC";
      break;
    case CCS_AWTRELCFM_OG           : /* awaiting release confirmation from outgoing */
      stateStr = "CCS_AWTRELCFM_OG";
      break;
    case CCS_AWTRELCFM_BOTH         : /* awaiting release confirmation from both */
      stateStr = "CCS_AWTRELCFM_BOTH";
      break;
    case CCS_AWTSWTCFM_TOCLR        : /* awaiting swtching complete to clear */
      stateStr = "CCS_AWTSWTCFM_TOCLR";
      break;
    case CCS_AWTDEALOCCFM           : /* awaiting Dealloc confirmation from  */
      stateStr = "CCS_AWTDEALOCCFM";
      break;
    case CCS_RETRIEVE               : /* Incoming Retrieve in progress */
      stateStr = "CCS_RETRIEVE";
      break;
    case CCS_AWTALOCCFM_TOCLR       : /* Resource Allocation Confirm to clear*/
      stateStr = "CCS_AWTALOCCFM_TOCLR";
      break;
    case CCS_AWTMGCTCFMCOTIC0       : /* awaiting switching to start routing */
      stateStr = "CCS_AWTMGCTCFMCOTIC0";
      break;
    case CCS_AWTCOT                 : /* awaiting COT */
      stateStr = "CCS_AWTCOT";
      break;
    case CCS_AWTMGCTCFMCOTIC1       : /* Continuity failure detected  : incoming continuity */
      stateStr = "CCS_AWTMGCTCFMCOTIC1";
      break;
    case COT_IC_DONE                : /* Outgoing continuity result : normal call    */
      stateStr = "COT_IC_DONE";
      break;
    case CCS_AWTOGSWTCFM            : /* Outgoing Switch confirm  : normal call */
      stateStr = "CCS_AWTOGSWTCFM";
      break;
    case CCS_AWTMGCTCFMCOTOG0       : /* AWT CCR timeout : outgoing continuity */
      stateStr = "CCS_AWTMGCTCFMCOTOG0";
      break;
    case CCS_AWTMGCTNOTIFY1         : /* Await continuity check result in case of CCR */
      stateStr = "CCS_AWTMGCTNOTIFY1";
      break;
    case CCS_AWTDELFROMACT          : /* Await delete from active side in FT/HA environment */
      stateStr = "CCS_AWTDELFROMACT";
      break;
    case CCS_LOCALLYANSWERED        : /* Call terminated on switch  */
      stateStr = "CCS_LOCALLYANSWERED";
      break;
    case CCS_AWTSWTCFMFORSVC        : /* awaiting switching confirmation */
      stateStr = "CCS_AWTSWTCFMFORSVC";
      break;
    case CCS_AWT_ADDR_CFM:
      stateStr = "CCS_AWT_ADDR_CFM"; /* awaiting address confirmation */
      break;
    case CCS_AWT_MID_CALL_CFM:
      stateStr = "CCS_AWT_MID_CALL_CFM"; /* awaiting mid call confirmation */
      break;
    case CCS_AWTRSPFORDPE1:
        stateStr = "CCS_AWTRSPFORDPE1"; /* AWT for RSP for MSG sent on DP E1  */
        break;

    case CCS_AWTRSPFORDPE3:
        stateStr = "CCS_AWTRSPFORDPE3"; /* AWT for RSP for MSG sent on DP E3  */
        break;

    case CCS_AWTRSPFORDPE37:
        stateStr = "CCS_AWTRSPFORDPE37"; /* AMT for RSP for ODTMFEntered */
        break;

    case CCS_AWTRSPFORDPE20:
        stateStr = "CCS_AWTRSPFORDPE20";/* AWT for RSP for MSG sent on DP E20 */
        break;

    case CCS_AWTRSPFORDPE30:
        stateStr = "CCS_AWTRSPFORDPE30";/* AWT for RSP for MSG sent on DP E30 */
        break;

    case CCS_AWTRSPFORDPE11:
        stateStr = "CCS_AWTRSPFORDPE11";/* AWT for RSP for MSG sent on DP E11 */
        break;

    case CCS_AWTRSPFORDPE27:
        stateStr = "CCS_AWTRSPFORDPE27";/* AWT for RSP for MSG sent on DP E27 */
        break;

    case CCS_AWTRSPFORDPE28:
        stateStr = "CCS_AWTRSPFORDPE28";/* AWT for RSP for MSG sent on DP E28 */
        break;

    case CCS_AWTRSPFORDPE9:
        stateStr = "CCS_AWTRSPFORDPE9"; /* AWT for RSP for MSG sent on DP E9  */
        break;

    case CCS_AWTRSPFORDPE33:
        stateStr = "CCS_AWTRSPFORDPE33";/* AWT for RSP for MSG sent on DP E33 */
        break;

    case CCS_AWTRSPFORDPE32:
        stateStr = "CCS_AWTRSPFORDPE32";/* AWT for RSP for MSG sent on DP E32 */
        break;

    case CCS_AWTRSPFORDPEXY_TOCLR:
        stateStr = "CCS_AWTRSPFORDPEXY_TOCLR";/* AWT FOR RSP for MSG sent on
                                                 DP E[1,3,4,20] */
        break;

    case CCS_AWT_REATTEMPT:
        stateStr = "CCS_AWT_REATTEMPT";
        break;

    case CCS_AWTRSPFORDPE22:
        stateStr = "CCS_AWTRSPFORDPE22";
        break;

    case CCS_AWTCALEALEGSWTCFM:
        stateStr = "CCS_AWTCALEALEGSWTCFM";
        break;

    case CCS_AWTBUSYREL_IC:
        stateStr = "CCS_AWTBUSYREL_IC";
        break;

    case CCS_AWT_RESUME:
        stateStr = "CCS_AWT_RESUME";
        break;

    case CCS_AWT_TMDRELEXP:
        stateStr = "CCS_AWT_TMDRELEXP";
        break;

    case CCS_AWTSWTCFM_SENDBOTHREL:
        stateStr = "CCS_AWTSWTCFM_SENDBOTHREL";
        break;

    case CCS_AWTSWTCFM_SENDONEREL:
        stateStr = "CCS_AWTSWTCFM_SENDONEREL";
        break;

    case CCS_AWTSWTCFM_SENDNOREL:
        stateStr = "CCS_AWTSWTCFM_SENDNOREL";
        break;

    case CCS_AWTMGCTCFMFORMODIFY0:
        stateStr = "CCS_AWTMGCTCFMFORMODIFY0";
        break;

    case CCS_AWTMGCTCFMFORMODIFY1:
        stateStr = "CCS_AWTMGCTCFMFORMODIFY1";
        break;

    case CCS_AWTRELCFM_KEEP_CON:
        stateStr = "CCS_AWTRELCFM_KEEP_CON";
        break;

    case CCS_AWTRSCCFMNOTIFY:
        stateStr = "CCS_AWTRSCCFMNOTIFY";
        break;

    case CCS_NOTIFYRSPFORMSUB:
        stateStr = "CCS_NOTIFYRSPFORMSUB";
        break;

    case CCS_AWTSWTCFMFORCC6CC10:
        stateStr = "CCS_AWTSWTCFMFORCC6CC10";
        break;

    case CCS_AWTRSPFAILOUT:
        stateStr = "CCS_AWTRSPFAILOUT";
        break;

    case CCS_AWTSWTCFMFORHOLD:
        stateStr = "CCS_AWTSWTCFMFORHOLD";
        break;

    case CCS_AWTSWTCFMFORSPLIT3WC:
        stateStr = "CCS_AWTSWTCFMFORSPLIT3WC";
        break;

    case CCS_CANNOTPROCESSEVENTS:
        stateStr = "CCS_CANNOTPROCESSEVENTS";
        break;

    case CCS_AWTSWTCFMFORMERGEINCC4:
        stateStr = "CCS_AWTSWTCFMFORMERGEINCC4";
        break;

    case CCS_AWTSWTCFM_MERGEINCC6IC:
        stateStr = "CCS_AWTSWTCFM_MERGEINCC6IC";
        break;

    case CCS_AWTSWTCFM_MERGEINCC6OG:
        stateStr = "CCS_AWTSWTCFM_MERGEINCC6OG";
        break;

    case CCS_AWT_PERMSIG_TREATMENT_CFM:
        stateStr = "CCS_AWT_PERMSIG_TREATMENT_CFM";
        break;

    case CCS_AWT_QRYRSP:
        stateStr = "CCS_AWT_QRYRSP";
        break;

    case CCS_AWT_XFRRSP_FROM_1:
        stateStr = "CCS_AWT_XFRRSP_FROM_1";
        break;

    case CCS_AWT_XFRRSP_FROM_2:
        stateStr = "CCS_AWT_XFRRSP_FROM_2";
        break;

    case CCS_AWTSWTCFMFORCC6CC11:
        stateStr = "CCS_AWTSWTCFMFORCC6CC11";
        break;

    case CCS_AWT_MGI_SUBCFM_TO_QRY:
        stateStr = "CCS_AWT_MGI_SUBCFM_TO_QRY";
        break;

    case CCS_AWT_RSP_TO_CLR_BEARER:
        stateStr = "CCS_AWT_RSP_TO_CLR_BEARER";
        break;

    case CCS_AWT_FIC_RSP_TO_KILL:
        stateStr = "CCS_AWT_FIC_RSP_TO_KILL";
        break;

    case CCS_AWT_QRYRSP_ONSWITCH:
        stateStr = "CCS_AWT_QRYRSP_ONSWITCH";
        break;

    case CCS_AWT_XFRRSP_1_ONSWITCH:
        stateStr = "CCS_AWT_XFRRSP_1_ONSWITCH";
        break;

    case CCS_AWTANNCMPLT_CTR:
        stateStr = "CCS_AWTANNCMPLT_CTR";
        break;

    case CCS_AWT_XFRRSP_2_ONSWITCH:
        stateStr = "CCS_AWT_XFRRSP_2_ONSWITCH";
        break;

    case CCS_AWTRSCALLOCCFM_MWI   :
        stateStr = "CCS_AWTRSCALLOCCFM_MWI";
        break;

    case CCS_AWTMWIUPDCFM         :
        stateStr = "CCS_AWTMWIUPDCFM";
        break;

    case CCS_AWTRSPFORDPE17       :
        stateStr = "CCS_AWTRSPFORDPE17";
        break;

    case CCS_AWTSWTCFMFORDP       :
        stateStr = "CCS_AWTSWTCFMFORDP";
        break;

    case CCS_AWTFICRSP_2_XFER     :
        stateStr = "CCS_AWTFICRSP_2_XFER";
        break;

    case CCS_AWTMGCTNOTIFY0       :
        stateStr = "CCS_AWTMGCTNOTIFY0";
        break;

    case CCS_AWTMGCTCFMFORMODIFY2 :
        stateStr = "CCS_AWTMGCTCFMFORMODIFY2";
        break;

    case CCS_AWTPAUSETIMEREXPIRY  :
        stateStr = "CCS_AWTPAUSETIMEREXPIRY";
        break;

    case CCS_AWTMGCTCFMCOTOG1     :
        stateStr = "CCS_AWTMGCTCFMCOTOG1";
        break;

    case CCS_AWTMINDIGITS         :
        stateStr = "CCS_AWTMINDIGITS";
        break;

    case CCS_AWTMAXDIGITS         :
        stateStr = "CCS_AWTMAXDIGITS";
        break;
/*euysal - 04/21/2005 - Support for O_Answer request */
    case CCS_AWTRSPFORDPE08         :
        stateStr = "CCS_AWTRSPFORDPE08";
        break;

#if 0        
    case CCS_AWTINFO              :
        stateStr = "CCS_AWTINFO";
        break;
#else       
    case CCS_AWTMOREINFO              :
        stateStr = "CCS_AWTMOREINFO";
        break;
#endif

    case CCS_AWTMGCTCFMFORMODIFY1_CTR  :
        stateStr = "CCS_AWTMGCTCFMFORMODIFY1_CTR";
        break;
    case CCS_AWTMGCTCFMFORMODIFY2_CTR  :
        stateStr = "CCS_AWTMGCTCFMFORMODIFY2_CTR";
        break;
    case CCS_AWTRSPFORDPE12  :
        stateStr = "CCS_AWTRSPFORDPE12";
        break;
    case CCS_AWTMGCTCFMFOREARLYACM  :
        stateStr = "CCS_AWTMGCTCFMFOREARLYACM";
        break;

    case CCS_AWTTMGCTFORSWAPCALL  :
        stateStr = "CCS_AWTTMGCTFORSWAPCALL";
        break;

    case CCS_AWTTMGCTFORMOVECALL  :
        stateStr = "CCS_AWTTMGCTFORMOVECALL";
        break;

    case CCS_AWTIDISCONNECT  :
        stateStr = "CCS_AWTIDISCONNECT";
        break;

    case CCS_AWTRSPFORDPE7  :
        stateStr = "CCS_AWTRSPFORDPE7";
        break;

    case CCS_AWT_MGCTCFM_LLTR  :
        stateStr = "CCS_AWT_MGCTCFM_LLTR";
        break;

    case CCS_AWT_MGCTCFM_TSTLNTONE  :
        stateStr = "CCS_AWT_MGCTCFM_TSTLNTONE";
        break;

    case CCS_AWT_MG_PRACKRSP  :
        stateStr = "CCS_AWT_MG_PRACKRSP";
        break;

    case CCS_AWT_MGI_CFM_FOR_DL2:
        stateStr = "CCS_AWT_MGI_CFM_FOR_DL2";
        break;

    case CCS_AWT_RSP_FOR_SO:
        stateStr = "CCS_AWT_RSP_FOR_SO";
        break;

    case CCS_AWT_CONGOVRLD_CFM:
        stateStr = "CCS_AWT_CONGOVRLD_CFM";
        break;

    case CCS_CMAB_AWT_IC_QRY_RESP:
        stateStr = "CCS_CMAB_AWT_IC_QRY_RESP";
        break;

    case CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP:
        stateStr = "CCS_CMAB_AWT_MGI_CFM_IC_QRY_RESP";
        break;

    case CCS_CMAB_AWT_OG_XFER_RESP:
        stateStr = "CCS_CMAB_AWT_OG_XFER_RESP";
        break;

    case CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP:
        stateStr = "CCS_CMAB_AWT_MGI_CFM_OG_XFER_RESP";
        break;
    case CCS_BICC_AWTICBEARER:
        stateStr = "CCS_BICC_AWTICBEARER";
        break;

    case CCS_BICC_AWT_MGCT_CFMNOT:
        stateStr = "CCS_BICC_AWT_MGCT_CFMNOT";
        break;

    case CCS_AWTOREDIRECT_RSP:  /* FID 15801.0 */
        stateStr = "CCS_AWTOREDIRECT_RSP";
        break;

    case CCS_AWTHPCMGRETRYTIMEREXPRIY:  /* FID 14457.0 */
        stateStr = "CCS_AWTHPCMGRETRYTIMEREXPRIY";
        break;
    case CCS_AWTNCCFM:
        stateStr = "CCS_AWTNCCFM";   /*FID 16206.0*/
        break;
    case CCS_AWTNCIND:
        stateStr = "CCS_AWTNCIND";   /*FID 16206.0*/
        break;
    case CCS_AWT_MRFRSP:
        stateStr = "CCS_AWT_MRFRSP"; /* FID 17174 Annc Support via External MRF */  
        break;
    case CCS_AWTSWTCFM_FOR_DIALINGTONE:
        stateStr = "CCS_AWTSWTCFM_FOR_DIALINGTONE"; /* FID 17555.0 Kavon */  
        break;

    default:
      stateStr = "INVALID_STATE";
      break;
    }

  return(stateStr);

} /* End of ccStateStr */


/************************************************************************
 ** ccEventStr
 **
 **     Desc:  Convert event to string.
 **
 **     Ret:   event string or "INVALID_EVENT"
 **
 ************************************************************************/
extern char *ccEventStr(U8 event)
{
  char *eventStr;

  switch (event)
    {
    case CCE_CONIND                 : /* Connect indication */
      eventStr = "CCE_CONIND";
      break;
    case CCE_CONCFM                 : /* Connct confirm */
      eventStr = "CCE_CONCFM";
      break;
    case CCE_ADDRIND                : /* Address Indication */
      eventStr = "CCE_ADDRIND";
      break;
    case CCE_CNSTIND                : /* Connection progress status indication */
      eventStr = "CCE_CNSTIND";
      break;
    case CCE_RELIND                 : /* Connection release indication */
      eventStr = "CCE_RELIND";
      break;
    case CCE_RELCFM                 : /* Connection release confirmation */
      eventStr = "CCE_RELCFM";
      break;
    case CCE_RSCCFM                 : /* Resouce Confirm */
      eventStr = "CCE_RSCCFM";
      break;
    case CCE_REATIND                : /* Status Indication - Reattempt */
      eventStr = "CCE_REATIND";
      break;
    case CCE_TIMEOUTTMREXP          : /* Time Out Timer Expired */
      eventStr = "CCE_TIMEOUTTMREXP";
      break;
    case CCE_ALOCCFM                : /* Resource Allocation Confirmation */
      eventStr = "CCE_ALOCCFM";
      break;
    case CCE_DEALOCCFM              : /* Resource Allocation Confirmation */
      eventStr = "CCE_DEALOCCFM";
      break;
    case CCE_MGCTTXNCFM             : /* SF Connection Confirmation */
      eventStr = "CCE_MGCTTXNCFM";
      break;
    case CCE_SVC_IND                : /* Service Indication         */
      eventStr = "CCCE_SVC_IND";
      break;
    case CCE_INITRELIND             : /* Status Indication - Initiate Release */
      eventStr = "CCE_INITRELIND";
      break;
    case CCE_SETUPTMREXP             : /* SETUP Timer Expired */
      eventStr = "CCE_SETUPTMREXP";
      break;
    case CCE_RLSTMREXP              : /* RELEASE Timer Expired */
      eventStr = "CCE_RLSTMREXP";
      break;
    case CCE_INTERDGTTMREXP         : /* Inter Digit Timer Expired */
      eventStr = "CCE_INTERDGTTMREXP";
      break;
    case CCE_INITLMRELREQ           : /* Layer Management Initiated Release */
      eventStr = "CCE_INITLMRELREQ";
      break;
    case CCE_HLDIND                 : /* Connection Hold indication */
      eventStr = "CCE_HLDIND";
      break;
    case CCE_RTRIND                 : /* Connection Retrieve indication */
      eventStr = "CCE_RTRIND";
      break;
    case CCE_PCC_MSG                : /* Message from peer GCC layer */
      eventStr = "CCE_PCC_MSG";
      break;
    case CCE_DEALOCIND              : /* Resource Deallocation Indication */
      eventStr = "CCE_DEALOCIND";
      break;
    case CCE_CALLDTLEXP             : /* Call Detail Timer Expiry */
      eventStr = "CCE_CALLDTLEXP";
      break;
    case CCE_CONTREP                : /* Continuity Report */
      eventStr = "CCE_CONTREP";
      break;
    case CCE_CCR                    : /* Initiate Continuity check */
      eventStr = "CCE_CCR";
      break;
    case CCE_STA_STPCONTIN          : /* Stop Continuity */
      eventStr = "CCE_STA_STPCONTIN";
      break;
    case CCE_LOOPBACKACK            : /* Loop back Acknowledgement */
      eventStr = "CCE_LOOPBACKACK";
      break;
    case CCE_TMINDIGITEXPIRY      :
        eventStr = "CCE_TMINDIGITEXPIRY";
      break;

    case CCE_TMAXDIGITEXPIRY      :
        eventStr = "CCE_TMAXDIGITEXPIRY";
      break;
    case CCE_TAWAITANSEXPIRY      :  /* Awaiting Answer Timer Expiry */
      eventStr = "CCE_TAWAITANSEXPIRY";
      break;
    case CCE_BUFFERTMREXP           :
      eventStr = "CCE_BUFFERTMREXP";
      break;
    case CCE_MGCTSVCCHGIND          :
      eventStr = "CCE_MGCTSVCCHGIND";
      break;
    case CCE_TMR_REINVITE           :
      eventStr = "CCE_TMR_REINVITE";
      break;
    case CCE_VIRTUALCALLSETUP       : /* Service Duration expiration */
      eventStr = "CCE_VIRTUALCALLSETUP";
      break;
    case CCE_CALLDTLEXP_STATS       :   /* Stats Call Detail Timer Expiry */
      eventStr = "CCE_CALLDTLEXP_STATS";
      break;
    case CCE_ADDRCFM                :  /* address confirmation */
      eventStr = "CCE_ADDRCFM";
      break;
    case CCE_MIDCALLCFM             :  /* mid-call confirmation */
      eventStr = "CCE_MIDCALLCFM";
      break;
    case CCE_ANALYZE_ROUTE          :  /* Analyze Route       */
        eventStr = "CCE_ANALYZE_ROUTE";
        break;

    case CCE_AUTHORIZE_TERMINATE    :  /* Authorize Terminate */
        eventStr = "CCE_AUTHORIZE_TERMINATE";
        break;

    case CCE_CONTINUE               :  /* Continue            */
        eventStr = "CCE_CONTINUE";
        break;

    case CCE_DISCONNECT_LEG         :  /* Disconnect Leg      */
        eventStr = "CCE_DISCONNECT_LEG";
        break;

    case CCE_FORWARD_CALL           :  /* Forward Call        */
        eventStr = "CCE_FORWARD_CALL";
        break;

    case CCE_MERGE_CALL             :  /* Merge Call          */
        eventStr = "CCE_MERGE_CALL";
        break;

    case CCE_MOVE_LEG               :  /* Move Leg            */
        eventStr = "CCE_MOVE_LEG";
        break;

    case CCE_OFFER_CALL             :  /* Offer Call          */
        eventStr = "CCE_OFFER_CALL";
        break;

    case CCE_ORIGINATE_CALL         :  /* Originate Call      */
        eventStr = "CCE_ORIGINATE_CALL";
        break;

    case CCE_RECONNECT              :  /* Reconnect Call      */
        eventStr = "CCE_RECONNECT";
        break;

    case CCE_SEND_TO_RESOURCE       :  /* Send To Resource    */
        eventStr = "CCE_SEND_TO_RESOURCE";
        break;

    case CCE_DISCONNECT             :  /* Disconnect    */
        eventStr = "CCE_DISCONNECT";
        break;

    case CCE_ORIGINATE_CALEA_CALL   :  /* Originate Calea Call */
        eventStr = "CCE_ORIGINATE_CALEA_CALL";
        break;

    case CCE_DATAREQ              :  /* DATA REQ  */
        eventStr = "CCE_DATAREQ";
        break;

    case CCE_CONREQ                 :
      eventStr = "CCE_CONREQ";
      break;
    case CCE_CONRSP                 :
      eventStr = "CCE_CONRSP";
      break;
    case CCE_CNSTREQ                :
      eventStr = "CCE_CNSTREQ";
      break;
    case CCE_RELREQ                 :
      eventStr = "CCE_RELREQ";
      break;
    case CCE_RELRSP                 :
      eventStr = "CCE_RELRSP";
      break;
    case CCE_RSCRSP                 :
      eventStr = "CCE_RSCRSP";
      break;
    case CCE_MNTSTAREQ              :
      eventStr = "CCE_MNTSTAREQ";
      break;
    case CCE_MNTSTAIND              :
      eventStr = "CCE_MNTSTAIND";
      break;
    case CCE_PROFIND                :
      eventStr = "CCE_PROFIND";
      break;
    case CCE_RTEREQ                 :
      eventStr = "CCE_RTEREQ";
      break;
    case CCE_RTEMNTSTAREQ           :
      eventStr = "CCE_RTEMNTSTAREQ";
      break;
    case CCE_RTERSP                 :
      eventStr = "CCE_RTERSP";
      break;
    case CCE_RTERELREQ              :
      eventStr = "CCE_RTERELREQ";
      break;
    case CCE_ALOCREQ                :
      eventStr = "CCE_ALOCREQ";
      break;
    case CCE_DEALOCREQ              :
      eventStr = "CCE_DEALOCREQ";
      break;
    case CCE_SWTCONREQ              :
      eventStr = "CCE_SWTCONREQ";
      break;
    case CCE_SFRELREQ               :
      eventStr = "CCE_SFRELREQ";
      break;
    case CCE_ADDRREQ                :
      eventStr = "CCE_ADDRREQ";
      break;
    case CCE_MIDCALLREQ             :
      eventStr = "CCE_MIDCALLREQ";
      break;
    case CCE_ORIGATTEMPT            :
        eventStr = "CCE_ORIGATTEMPT";
        break;

    case CCE_INFOCOLLECTED          :
        eventStr = "CCE_INFOCOLLECTED";
        break;

    case CCE_INFOANALYZED           :
        eventStr = "CCE_INFOANALYZED";
        break;

    case CCE_TERMATTEMPT            :
        eventStr = "CCE_TERMATTEMPT";
        break;

    case CCE_TBUSY                  :
        eventStr = "CCE_TBUSY";
        break;

    case CCE_OMIDCALL               :
        eventStr = "CCE_TMIDCALL";
        break;

    case CCE_TMIDCALL               :
        eventStr = "CCE_TMIDCALL";
        break;

    case CCE_TDISCONNECT            :
        eventStr = "CCE_TDISCONNECT";
        break;

    case CCE_ODISCONNECT            :
        eventStr = "CCE_ODISCONNECT";
        break;

    case CCE_OANSWER                :
        eventStr = "CCE_OANSWER";
        break;

    case CCE_ONOANSWER              :
        eventStr = "CCE_ONOANSWER";
        break;

    case CCE_TNOANSWER              :
        eventStr = "CCE_TNOANSWER";
        break;

    case CCE_CALEALEGEXP            :
        eventStr = "CCE_CALEALEGEXP";
        break;

    case CCE_CREATECALL             :
        eventStr = "CCE_CREATECALL";
        break;

    case CCE_NOTIFYTIMEREXP         :
        eventStr = "CCE_NOTIFYTIMEREXP";
        break;

    case CCE_EVENTUSEDFORBUFF       :
        eventStr = "CCE_EVENTUSEDFORBUFF";
        break;

    case CCE_IGNOREFROMFIC          :
        eventStr = "CCE_IGNOREFROMFIC";
        break;

    case CCE_CRA                :
        eventStr = "CCE_CRA";
        break;

    case CCE_MGCTNOTIFY              :
        eventStr = "CCE_MGCTNOTIFY";
        break;

    case CCE_STA_CRM                :
        eventStr = "CCE_STA_CRM";
        break;

    case CCE_NEGOTIATION_TMR        :
        eventStr = "CCE_NEGOTIATION_TMR";
        break;

    case CCE_FCTMWIREQ              :
        eventStr = "CCE_FCTMWIREQ";
        break;

    case CCE_CLOSEFROMFIC           :
        eventStr = "CCE_CLOSEFROMFIC";
        break;

   case CCE_CONGOVRLD_CFM:
        eventStr = "CCE_CONGOVRLD_CFM";
        break;

    case CCE_KILLCALL               :
        eventStr = "CCE_KILLCALL";
        break;

    case CCE_FIC_ERROR              :
        eventStr = "CCE_FIC_ERROR";
        break;

    case CCE_PAUSETMREXPIRY         :
        eventStr = "CCE_PAUSETMREXPIRY";
        break;

    /* Feature 1789 - German ISUP */
    case CCE_TOIW2TMREXPIRY         :
        eventStr = "CCE_TOIW2TMREXPIRY";
	break;
	
    case CCE_RELEASECALL            :
        eventStr = "CCE_RELEASECALL";
        break;

    case CCE_EARLYACMTMREXP         :
        eventStr = "CCE_EARLYACMTMREXP";
        break;

    case CCE_CAC         :
        eventStr = "CCE_CAC";
        break;

    case CCE_SWAPCALL         :
        eventStr = "CCE_SWAPCALL";
        break;

    case CCE_MOVECALL         :
        eventStr = "CCE_MOVECALL";
        break;

    case CCE_INT_SWAPCALL         :
        eventStr = "CCE_INT_SWAPCALL";
        break;

    case CCE_INT_MOVECALL         :
        eventStr = "CCE_INT_MOVECALL";
        break;

    case CCE_PREANMTMREXP         :
        eventStr = "CCE_PREANMTMREXP";
        break;

    case CCE_TESTLINE:
        eventStr = "CCE_TESTLINE";
        break;

    case CCE_TSTLNDSCNTMREXP:
        eventStr = "CCE_TSTLNDSCNTMREXP";
        break;

    case CCE_TSTLNCDTMREXP:
        eventStr = "CCE_TSTLNCDTMREXP";
        break;

    case CCE_SENDMSG:
        eventStr = "CCE_SENDMSG";
        break;

    case CCE_CANCEL:
        eventStr = "CCE_CANCEL";
        break;

    case CCE_TOIW3TMREXP:
        eventStr = "CCE_TOIW3TMREXP";
        break;

    case CCE_LIMANINV:
        eventStr = "CCE_LIMANINV";
        break;

        /* FID 15310.1 + */
    case CCE_ICA:
        eventStr = "CCE_ICA";
        break;
    case CCE_IACA:
        eventStr = "CCE_IACA";
        break;
        /* FID 15310.1 - */
        /* FID 14457.0 + */
    case CCE_CALLQUEUED:
        eventStr = "CCE_CALLQUEUED";
        break;
    case CCE_HPCMGRETRYTMREXP:
        eventStr = "CCE_HPCMGRETRYTMREXP";
        break;
        /* FID 14457.0 - */

    case CCE_HPCDELAYREQ:  /* FID 14457.0, BUG:88025 */
        eventStr = "CCE_HPCDELAYREQ";
        break;
    case CCE_NCIND:        /* FID 16206.0*/
        eventStr = "CCE_NCIND";
        break;
    case CCE_NCCFM:        /* FID 16206.0*/
        eventStr = "CCE_NCCFM";
        break;
    case CCE_CFXCALLINDPTMREXP:        /* FID 16206.0*/
        eventStr = "CCE_CFXCALLINDPTMREXP";
        break;    
    case CCE_INV_EVENT:
    default:
      eventStr = "INVALID_EVENT";
      break;
    }
  return(eventStr);

} /* End of ccEventStr */



/************************************************************************
 ** ccFsmProfileWalkHl
 **
 **     Desc:  Walk hash lists and do command apprpriate procressing
 **
 **     Ret:   ROK     - successful
 **            RFAILED - failed
 **
 ************************************************************************/
static void ccFsmProfileWalkHl(CcFsmProfileAction_t cmd)
{
  CcFsmProfileState_t *prevCb = NULL;
  CcFsmProfileState_t *cb;

  DP("********************* CC Profile - Report *********************\n");

  while(cmHashListGetNext(&ccFsmProfileHlCp, (PTR)prevCb, (PTR *)&cb) == ROK)
    {
      prevCb = cb;

      DPN("%s:%d:%d:%s -> %s:%d:%d:%s, evnt=%d:%s\n", 
          cb->key.lastFile, cb->key.lastLine, cb->oldState, ccStateStr(cb->oldState),
          cb->key.newFile, cb->key.newLine, cb->newState, ccStateStr(cb->newState),
          cb->key.evntType, ccEventStr(cb->key.evntType));

      DPN("\tsamps=%10ld,  cpu: %7lu, %7.3f, %4lu, %4lu,  clk: %10lu, %6lu, %4lu, %4lu\n\n", 
          cb->numSamp, /* Number of samples*/
          cb->cumTicks, ((float)cb->cumTicks)/cb->numSamp, cb->lowTicks, cb->highTicks,      /* Average CPU Ticks */
          cb->cumClkTicks, cb->cumClkTicks/cb->numSamp, cb->lowClkTicks, cb->highClkTicks);  /* Average clock Ticks */

      switch(cmd)
        {
        case CC_FSM_CMD_START:  /* Reset stats */

          cb->numSamp = cb->cumTicks = cb->highTicks = cb->cumClkTicks = cb->highClkTicks = 0;
          cb->lowTicks = cb->lowClkTicks = (U32) -1;
          prevCb = cb;
          break;

        case CC_FSM_CMD_STOP:  

          /* Remove from hash list */
          cmHashListDelete(&ccFsmProfileHlCp, (PTR)cb);
            
          /* Free control block */
          SPutSBuf(DFLT_REGION, DFLT_POOL, cb, sizeof(CcFsmProfileState_t));

          prevCb = NULL;
          break;

        case CC_FSM_CMD_PRINT:  
        default:
          prevCb = cb;
          break;
        }

    }
  DP("********************* CC Profile - Report *********************\n");

}    /* End of ccFsmProfileWalkHl */



/************************************************************************
 ** ccFsmProfile
 **
 **     Desc:  This functions handles profile processing when CC fsm 
 **            transitions state.
 **
 **     Ret:   None
 **
 ************************************************************************/
__inline__ void ccFsmProfileInitCon(CcConCb *con, char *file, int line)
{

  con->lastFile = file;
  con->lastLine = line;
  con->evntType = 0xFF;

  if (ccFsmProfileStatus != CC_FSM_PROFILE_ACTIVE)
    {
      con->lastTicks = 0;
      con->lastClkTicks = 0;
    }
  else
    {
      struct tms buff;
      struct timeval time; 

      /* Get current ticks */
#ifndef LINUXNOTSUPPORT 
      /* lig, waiting for changes on proc.h */
      buff.tms_utime = ccSt->thread_utime;
      buff.tms_stime = ccSt->thread_stime;
#endif

      gettimeofday(&time, (struct timezone *)NULL);
        
      con->lastTicks = buff.tms_utime + buff.tms_stime;
      con->lastClkTicksSec = time.tv_sec;
      con->lastClkTicks = time.tv_usec;
    }

} /* End of ccFsmProfileInitCon */

/************************************************************************
 ** ccFsmProfile
 **
 **     Desc:  This functions handles profile processing when CC fsm 
 **            transitions state.
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccFsmProfile(CcConCb *con, char *newFile, int newLine, U8 newState)
{
  U16 ret;
  struct tms buff;
  struct timeval time; 
  CcFsmProfileHlKey_t key;
  CcFsmProfileState_t *cb = NULL;
  U32 delta;
  U32 deltaClk;

  if (con->lastTicks == 0)
    {
      con->state = newState;
      return;
    }

  /* Make sure entire key structure is initialized */
  cmMemset((U8 *)&key, 0, sizeof(CcFsmProfileHlKey_t));

  /* Initialize key for hash list search */
  key.lastFile = con->lastFile;
  key.lastLine = con->lastLine;
  key.evntType = con->evntType;
  key.newFile = newFile;
  key.newLine = newLine;

  /* Get current ticks */
#ifndef LINUXNOTSUPPORT
  buff.tms_utime = ccSt->thread_utime;
  buff.tms_stime = ccSt->thread_stime;
#endif
  delta = (buff.tms_utime + buff.tms_stime - con->lastTicks);

  gettimeofday(&time, (struct timezone *)NULL);


  if (time.tv_usec < con->lastClkTicks)
    {
        deltaClk = (time.tv_usec + 1000000 - con->lastClkTicks) +
            ((time.tv_sec - 1 - con->lastClkTicksSec)*1000000);
    }
  else
    {
        deltaClk = (time.tv_usec - con->lastClkTicks) +
            ((time.tv_sec - con->lastClkTicksSec)*1000000);
    }

  /* Find control block for this transition */
  cmHashListFind (&ccFsmProfileHlCp, (U8 *)&key, (U16)sizeof(CcFsmProfileHlKey_t),
                  (U16)0, (PTR *) &cb);

  if (cb == NULL)
    {
      /* Allocate a control block for this transition */
      SGetSBuf(DFLT_REGION, DFLT_POOL, (Data **) &cb, sizeof(CcFsmProfileState_t));
            
      cmMemset((U8 *)&(cb->hl), 0, sizeof(CmHashListEnt));
      cb->key = key;
      cb->oldState = con->state;
      cb->newState = newState;

      cb->numSamp = 1;
      cb->lowTicks = cb->highTicks = cb->cumTicks = delta;
      cb->lowClkTicks = cb->highClkTicks = cb->cumClkTicks = deltaClk;

      /* Insert into hash list */
      cmHashListInsert(&ccFsmProfileHlCp, (PTR)cb, (U8 *)&cb->key, (U16)sizeof(CcFsmProfileHlKey_t));
    }
  else  /* Update stats for this transition */
    {
      cb->numSamp++;
            
      cb->cumTicks += delta;

      if (delta > cb->highTicks)
        cb->highTicks = delta;
            
      if (delta < cb->lowTicks)
        cb->lowTicks = delta;

      cb->cumClkTicks += deltaClk;

      if (deltaClk > cb->highClkTicks)
        cb->highClkTicks = deltaClk;
            
      if (deltaClk < cb->lowClkTicks)
        cb->lowClkTicks = deltaClk;
    }
        

  if (ccFsmProfileCb.ccFsmProfileDumpLog != NULL)
    {
      CcFsmProfileDumpRecord_t *dumpCb;
        
      dumpCb = &ccFsmProfileCb.ccFsmProfileDumpLog[ccFsmProfileCb.currLog++];

      dumpCb->key = cb->key;
      dumpCb->oldState = cb->oldState;
      dumpCb->newState = cb->newState;
      dumpCb->handle = (PTR)con->icSuConnId;
      dumpCb->cpuTicks = delta;
      dumpCb->clkTicks = deltaClk;

      if (ccFsmProfileCb.currLog >= ccFsmProfileCb.totalLog)
        {
          int i;

          for (i=0; i<ccFsmProfileCb.totalLog; i++)
            {

              dumpCb = &ccFsmProfileCb.ccFsmProfileDumpLog[i];

              /* Dump record to disk */
              fprintf(ccFsmProfileCb.stream, "%s:%d ,%3d, %s:%d, %3d, %3d, %08lX, %5hd, %6ld\n", 
                      dumpCb->key.lastFile, dumpCb->key.lastLine, 
                      dumpCb->key.evntType,
                      dumpCb->key.newFile, dumpCb->key.newLine,
                      dumpCb->oldState, dumpCb->newState,
                      dumpCb->handle,
                      dumpCb->cpuTicks, /* CPU Ticks */
                      dumpCb->clkTicks  /* clock Ticks */
                      ); 
            }

          fclose(ccFsmProfileCb.stream);

          DP("CC profile: Wrote %ld ccprofile records to %s\n",
             ccFsmProfileCb.currLog,
             CC_FSM_PROFILE_DUMP_FILE);
            
          ret = SPutSBuf(DFLT_REGION, DFLT_POOL, 
                         ccFsmProfileCb.ccFsmProfileDumpLog,
                         ccFsmProfileCb.alocBytes); 

          if (ret != ROK)
            {
              DP("CC profile: Error freeing dump log\n");
            }
                          
          ccFsmProfileCb.stream = 0;
          ccFsmProfileCb.ccFsmProfileDumpLog = NULL;
          ccFsmProfileCb.currLog = 0;
          ccFsmProfileCb.totalLog = 0;
          ccFsmProfileCb.alocBytes = 0;
        }
    }

  /* Update con */
  con->state =  newState;
  con->lastTicks = buff.tms_utime + buff.tms_stime;
  con->lastClkTicks = time.tv_usec;
  con->lastClkTicksSec = time.tv_sec;
  con->lastFile = newFile;
  con->lastLine = newLine;

}    /* End of ccFsmProfile */




typedef struct CcIntProfile_Tag
{
  U16 idx;
  U32 numSamp;
  U32 cumTicks;
  U32 lowTicks;
  U32 highTicks;
  U32 cumClkTicks;
  U32 lowClkTicks;
  U32 highClkTicks;

  char *lastFile;
  int lastLine;
  char *newFile;
  int newLine;

  U32 lastTicks;
  U32 lastClkTicks;
  U32 lastClkTicksSec;

} CcIntProfile_t;

#define CC_INT_PROFILE_BINS (32)
CcIntProfile_t *ccIntProfileCp[CC_INT_PROFILE_BINS];

/************************************************************************
 ** ccIntProfileSampStart
 **
 **     Desc:  This functions handles internal profile processing start
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccIntProfileSampStart(char *file, int line, unsigned short idx)
{
    struct tms buff;
    struct timeval time; 
    CcIntProfile_t *cb = NULL;

    if (idx >= CC_INT_PROFILE_BINS) return;

    /* Get current CPU ticks */
#ifndef LINUXNOTSUPPORT
    buff.tms_utime = ccSt->thread_utime;
    buff.tms_stime = ccSt->thread_stime;
#endif

    /* Get current CLK ticks */
    gettimeofday(&time, (struct timezone *)NULL);

    /* Find control block for this transition */
    cb = ccIntProfileCp[idx];

    if (cb == NULL)
    {
        /* Allocate a control block for this transition */
        SGetSBuf(DFLT_REGION, DFLT_POOL, (Data **) &cb, sizeof(CcIntProfile_t));

        cmMemset((U8 *)cb, 0, sizeof(CcIntProfile_t));
            
        cb->idx = idx;
        cb->lowTicks = cb->lowClkTicks = 0xFFFFFFFF;

        cb->lastFile = file;
        cb->lastLine = line;

        /* Insert into list */
        ccIntProfileCp[idx] = cb;
    }

    cb->lastTicks = buff.tms_utime + buff.tms_stime;
    cb->lastClkTicksSec = time.tv_sec;
    cb->lastClkTicks = time.tv_usec;

}    /* End of ccIntProfileSampStart */

/************************************************************************
 ** ccIntProfileSampEnd
 **
 **     Desc:  This functions handles internal profile processing end
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccIntProfileSampEnd(char *file, int line, unsigned short idx)
{
    CcIntProfile_t *cb;
    struct tms buff;
    struct timeval time; 
    U32 delta;
    U32 deltaClk;

    if (idx >= CC_INT_PROFILE_BINS) return;

    /* Find control block for this transition */
    cb = ccIntProfileCp[idx];

    if (cb == NULL)
    {
        DP("%s NULL cb\n", __FUNCTION__);              
        return;
    }

    /* Get current CPU ticks */
#ifndef LINUXNOTSUPPORT
    buff.tms_utime = ccSt->thread_utime;
    buff.tms_stime = ccSt->thread_stime;
#endif
    delta = (buff.tms_utime + buff.tms_stime - cb->lastTicks);

    /* Get current CLK ticks */
    gettimeofday(&time, (struct timezone *)NULL);
    if (time.tv_usec < cb->lastClkTicks)
    {
        deltaClk = (time.tv_usec + 1000000 - cb->lastClkTicks) +
            ((time.tv_sec - 1 - cb->lastClkTicksSec)*1000000);
    }
    else
    {
        deltaClk = (time.tv_usec - cb->lastClkTicks) +
            ((time.tv_sec - cb->lastClkTicksSec)*1000000);
    }

    cb->newFile = file;
    cb->newLine = line;

    cb->numSamp++;
            
    cb->cumTicks += delta;
    
    if (delta > cb->highTicks)
        cb->highTicks = delta;
    
    if (delta < cb->lowTicks)
        cb->lowTicks = delta;
    
    cb->cumClkTicks += deltaClk;
    
    if (deltaClk > cb->highClkTicks)
        cb->highClkTicks = deltaClk;
            
    if (deltaClk < cb->lowClkTicks)
        cb->lowClkTicks = deltaClk;


}    /* End of ccIntProfileSampEnd */

/************************************************************************
 ** ccIntProfileStop
 **
 **     Desc:  This functions handles internal profile processing end
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccIntProfileStop(void)
{
    U16 idx;
    CcIntProfile_t *cb;

    DPN("\n\n INT PROFILE START \n\n");
        
    for (idx=0; idx<CC_INT_PROFILE_BINS; idx++)
    {
        /* Find control block for this transition */
        cb = ccIntProfileCp[idx];

        if (cb != NULL)
        {

            DPN("%d:  %s:%d -> %s:%d\n", 
                idx,
                cb->lastFile, cb->lastLine,
                cb->newFile, cb->newLine);
            
            DPN("\tsamps=%10lu,  cpu: %7lu, %7.3f, %4lu, %4lu,  clk: %10lu, %6lu, %4lu, %4lu\n\n", 
                cb->numSamp, /* Number of samples*/
                cb->cumTicks, ((float)cb->cumTicks)/cb->numSamp, cb->lowTicks, cb->highTicks,      /* Average CPU Ticks */
                cb->cumClkTicks, cb->cumClkTicks/cb->numSamp, cb->lowClkTicks, cb->highClkTicks);  /* Average clock Ticks */

            /* Free memory for this sample */
            SPutSBuf(DFLT_REGION, DFLT_POOL, cb, sizeof(CcIntProfile_t));
            ccIntProfileCp[idx] = NULL;
        }

    }

    DPN("\n\n INT PROFILE END \n\n");


}    /* End of ccIntProfileStop */


typedef struct CcEvtProfileCb_Tag
{
    Ticks startTicksCpu;
    Ticks stopTicksCpu;
    struct timeval startTicksClk;
    struct timeval stopTicksClk;
} CcEvtProfileCb_t;

CcEvtProfileCb_t ccEvtProfileCb;

typedef struct CcEvtProfileEntry_Tag
{
    U32 cumTicksCpu;
    U32 cumTicksClk;

    U32 lowTicks;
    U32 highTicks;
    U32 lowClkTicks;
    U32 highClkTicks;

    U32 tickSamps;
} CcEvtProfileEntry_t;

CcEvtProfileEntry_t *(*evtProfileTable)[CCMAXSTATES];


/************************************************************************
 ** ccProfileEvtStart
 **
 **     Desc:  This functions handles FSM event profiling start
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccProfileEvtStart(Ticks *startTicksCpu, struct timeval *startTicksClk)
{
#ifndef LINUXNOTSUPPORT
    *startTicksCpu = ccSt->thread_utime +ccSt->thread_stime;
#endif
    gettimeofday(startTicksClk, (struct timezone *)NULL);
}

/************************************************************************
 ** ccProfileEvtEnd
 **
 **     Desc:  This functions handles FSM event profiling end
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccProfileEvtEnd(Ticks startTicksCpu, struct timeval startTicksClk, U8 evntType, U8 oldstate)
{
    U32 delta;
    U32 deltaClk;
    Ticks stopTicksCpu = 0;
    struct timeval stopTicksClk;
    CcEvtProfileEntry_t *cb;

    if (evtProfileTable == NULL)
    {
        S16 ret;

        /* Allocate two dimensional array of pointers */
        ret = SGetSBuf(DFLT_REGION, DFLT_POOL, (Data **) &evtProfileTable, sizeof(CcEvtProfileEntry_t *)*CCMAXEVENTS*CCMAXSTATES);
        if (ret != ROK)
        {
            evtProfileTable = NULL;
            return;
        }

        cmMemset((U8 *)evtProfileTable, 0, sizeof(CcEvtProfileEntry_t *)*CCMAXEVENTS*CCMAXSTATES);
    }

    /* Get Control block for this event/state */
    cb = evtProfileTable[evntType][oldstate];
    if (cb == NULL)
    {
        S16 ret;

        /* Allocate a control block for this transition */
        ret = SGetSBuf(DFLT_REGION, DFLT_POOL, (Data **) &cb, sizeof(CcEvtProfileEntry_t));
        if (ret != ROK)
        {
            return;
        }

        cmMemset((U8 *)cb, 0, sizeof(CcEvtProfileEntry_t));

        evtProfileTable[evntType][oldstate] = cb;
    }

    /* Get current time */
#ifndef LINUXNOTSUPPORT
    stopTicksCpu = ccSt->thread_utime +ccSt->thread_stime;
#endif
    gettimeofday(&stopTicksClk, (struct timezone *)NULL);

    if (cb->tickSamps == 0)
    {
        cb->lowTicks = cb->lowClkTicks = 0xFFFFFFFF;
    }


    /* Calculate delta time */

    delta = stopTicksCpu - startTicksCpu;

    if (stopTicksClk.tv_usec < startTicksClk.tv_usec)
    {
        deltaClk = (stopTicksClk.tv_usec + 1000000 - startTicksClk.tv_usec) +
            ((stopTicksClk.tv_sec - 1 - startTicksClk.tv_sec)*1000000);
    }
    else
    {
        deltaClk = (stopTicksClk.tv_usec - startTicksClk.tv_usec) +
            ((stopTicksClk.tv_sec - startTicksClk.tv_sec)*1000000);
    }

    if (ccEvtProfileCb.startTicksCpu)
    {
        /* Subtract time used by last frame */

        delta -= (ccEvtProfileCb.stopTicksCpu - ccEvtProfileCb.startTicksCpu);

        if (ccEvtProfileCb.stopTicksClk.tv_usec < ccEvtProfileCb.startTicksClk.tv_usec)
        {
            deltaClk -= (ccEvtProfileCb.stopTicksClk.tv_usec + 1000000 - ccEvtProfileCb.startTicksClk.tv_usec) +
                ((ccEvtProfileCb.stopTicksClk.tv_sec - 1 - ccEvtProfileCb.startTicksClk.tv_sec)*1000000);
        }
        else
        {
            deltaClk -= (ccEvtProfileCb.stopTicksClk.tv_usec - ccEvtProfileCb.startTicksClk.tv_usec) +
                ((ccEvtProfileCb.stopTicksClk.tv_sec - ccEvtProfileCb.startTicksClk.tv_sec)*1000000);
        }

    }

    /* Update cb */

    cb->tickSamps++;

    cb->cumTicksCpu += delta;
    
    if (delta > cb->highTicks)
        cb->highTicks = delta;
    
    if (delta < cb->lowTicks)
        cb->lowTicks = delta;
    
    cb->cumTicksClk += deltaClk;
    
    if (deltaClk > cb->highClkTicks)
        cb->highClkTicks = deltaClk;
            
    if (deltaClk < cb->lowClkTicks)
        cb->lowClkTicks = deltaClk;


    /* Save time for lower frame to subract */
    if (ccFsmFrameCnt)
    {
        ccEvtProfileCb.startTicksCpu = startTicksCpu;
        ccEvtProfileCb.stopTicksCpu = stopTicksCpu;
        ccEvtProfileCb.startTicksClk = startTicksClk;
        ccEvtProfileCb.stopTicksClk = stopTicksClk;
    }
    else
    {
        ccEvtProfileCb.startTicksCpu = 0;
        ccEvtProfileCb.stopTicksCpu = 0;
        ccEvtProfileCb.startTicksClk = (struct timeval){0,0};
        ccEvtProfileCb.stopTicksClk = (struct timeval){0,0};
    }
}

/************************************************************************
 ** ccProfileEvtDump
 **
 **     Desc:  This functions prints FSM event profiling data
 **
 **     Ret:   None
 **
 ************************************************************************/
void ccProfileEvtDump(void)
{
    U8 state;
    U8 evntType;
    CcEvtProfileEntry_t *cb;

    DPN("\n\n EVT PROFILE START \n\n");
        
    for (evntType=0; evntType<CCMAXEVENTS; evntType++)
    {
        for(state=0; state<CCMAXSTATES; state++)
        {
            cb = evtProfileTable[evntType][state];
            
            if ((cb) && (cb->tickSamps))
            {
                DPN("E%02dS%02d, samps=%10lu, cpu= %7lu, %7.3f, %4lu, %4lu, clk= %10lu, %6lu, %4lu, %4lu\n", 
                    evntType, state,
                    cb->tickSamps, /* Number of samples*/
                    cb->cumTicksCpu, ((float)cb->cumTicksCpu)/cb->tickSamps, cb->lowTicks, cb->highTicks,      /* Average CPU Ticks */
                    cb->cumTicksClk, cb->cumTicksClk/cb->tickSamps, cb->lowClkTicks, cb->highClkTicks);  /* Average clock Ticks */
                
                cmMemset((U8 *)cb, 0, sizeof(CcEvtProfileEntry_t));
                
            }
        }
    }
    

    DPN("\n\n EVT PROFILE END \n\n");

}


#endif /* CC_FSM_PROFILE */




/* TELICA - Bugzilla-4321 - Bukucu - 10.25.01 - update sts func  */
PUBLIC S16 ccUpdSts(CcPsSap *icPsSap, CcPsSap *ogPcSap)
{

  /* Bug#15674, rkhan */
  if ( (icPsSap == NULLP) && (ogPcSap == NULLP) )
  {
    CCLOGERR("Error: ccUpdSts, Both incoming and outgoing saps are NULL\n");
    RETVALUE(ROK);
  }

  /* This means it called from ConInd function, Incoming call */
  if ( (icPsSap != NULLP) && (ogPcSap == NULLP) )
  {
    icPsSap->sts.incoming++;
    RETVALUE(ROK);
  }

  /* This means it called where ConReq function is called, Outgoing call */
  ogPcSap->sts.outgoing++;
  RETVALUE(ROK);
}
/* Bugzilla-4321 */

/************************************************************************
 ** ccPermSignalHack
 **
 **     Desc:  Temporary hack to enable permanent signal handling.  
 **            This code will be deleted for GA release.
 **
 **     Ret:   NONE
 **
 ************************************************************************/
static void ccPermSignalHack(RmRsc *rsc)
{
#ifndef TELICA_MGI_MEGACO    
    Pst pst = {SFndProcId(), SFndProcId(), ENTSF, 0, ENTCC, 0, PRIOR0, RTESPEC, 0, DFLT_REGION, DFLT_POOL, 0, 0};

#if 0
    CCDP(AIN_DBG_LEVEL_2, "PERM SIGNAL:  Playing ROH on (%ld,%ld,%ld)\n",
         rsc->t.ds0Rsc>>19 &0x1F, 
         rsc->t.ds0Rsc>>5 &0x3FF, 
         rsc->t.ds0Rsc &0x1F);
#endif
    CcLiSftToneReq(&pst, 0, MS_ROH, rsc);
#endif /* TELICA_MGI_MEGACO */    
}    /* End of ccPermSignalHack */

/************************************************************************
 ** ccSendToneReq
 **
 **     Desc:  Send loosely coupled tone request to SFM/MGI
 **
 **     Ret:   NONE
 **
 ************************************************************************/
void ccSendToneReq(RmRsc *rsc, U32 operation)
{
#ifndef TELICA_MGI_MEGACO    
    Pst pst = {SFndProcId(), SFndProcId(), ENTSF, 0, ENTCC, 0, PRIOR0, RTESPEC, 0, DFLT_REGION, DFLT_POOL, 0, 0};

    CcLiSftToneReq(&pst, 0, operation, rsc);
#endif /* TELICA_MGI_MEGACO */    
}    /* End of ccSendToneReq */

extern Bool siCheckCon(U32 spInstId, RmRsc *rsc);

void ccChkSi(CcConCb *CON, U8 newState)
{                                                         
    if (((newState) == CCS_IDLE) && (CC_GET_PROTOCOL(CON->icProtType) == CC_SI))    
    {                                                                               
        if (siCheckCon(CON->icSpConnId, &CON->icRsc)) 
            CC_TRACE_DUMP(CON);
    }
}



/*
*
*      Fun:   ccProcessONoAnswer
*
*      Desc:  This Functions checks if there is a ONoAnswer event
*             armed, if yes, starts a ONoAnwer timer on the connection block
*             to which the bcm belongs.
*
*
*      Ret:   Void.
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PUBLIC Void ccProcessONoAnswer
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con       = NULLP;
  CCDP(AIN_DBG_LEVEL_1, "ccProcessONoAnswer:%ld,%ld,%d\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId, ccCp.genCfg.tmr.tAinONoAns.val);
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVOID;
  }
  con = pBcm->con;

  if (pBcm->nel[EReqONoAnswer])
  {
    CCDP(AIN_DBG_LEVEL_0,"O_No_Answer event is ARMED:%ld, %ld\n",
         con->icSuConnId, con->ainInfo.ONoAnswerTimer.val);
    if (con->ainInfo.ONoAnswerTimer.pres)
    {
      ccCp.genCfg.tmr.tAinONoAns.val = con->ainInfo.ONoAnswerTimer.val;
      ccStartConTmr(AIN_O_NO_ANS_TMR, con, (PTR)&ccCp.genCfg);
      CCDP(AIN_DBG_LEVEL_0, "icSu:%ld, ogSu:%ld, val:%d\n", con->icSuConnId,
                             con->ogSuConnId, ccCp.genCfg.tmr.tAinONoAns.val);
    }
    con->ainInfo.ONoAnswerTimer.pres = NOTPRSNT;
    RETVOID;
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqONoAnswer event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVOID;
  }
}


/*
*
*      Fun:   ccProcessODTMFEntered
*
*      Desc:  As Per AIN ccProcessODTMFEntered can only be a EDP-Notification.
*             This functions checks if there is a ODTMFEntered armed in the
*             NEL of the BCM.
*
*      Ret:   Void.
*      Notes:
*
*      File: cc_bdy2.c
*
*/
PUBLIC S16 ccProcessODTMFEntered
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  ODTMFEntered_t     oDTMFEntered;
  U8                 index = 0;

  CCDP(AIN_DBG_LEVEL_1, "ccProcessODTMFEntered:%ld, %ld\n",
       pBcm->svcHeader.transId, pBcm->con->icSuConnId);
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType = %d, icSu = %ld\n", pBcm->bcmType,
             pBcm->con->icSuConnId);
    RETVALUE(RFAILED);
  }
  con = pBcm->con;

  if ((pBcm->nel[EReqODTMFEntered] == NEL_NOTIFY) ||
      (pBcm->nel[EReqODTMFEntered] == NEL_REQUEST))
  {
    if (pBcm->svcHeader.transId != 0)
    {
          /* Need to send an Notification Event to FIC ( O_DTMF_Entered) */

      /* Initializing the message buffers */
      CCDP(AIN_DBG_LEVEL_0," Sending ODTMFEntered transId = 0x%lx\n",
           pBcm->svcHeader.transId);
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oDTMFEntered, 0, sizeof(ODTMFEntered_t));

      /* 28361 */
      ccRegenerateEvntHold(con);

      ccFillSvcHeader(&header, pBcm, MSG_O_DTMF_ENTERED);
      ccFillODTMFEnteredParam(&oDTMFEntered, pBcm);
      con->lastState = con->state;
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm),
                                         CCS_CANNOTPROCESSEVENTS);
      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE37);
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      
      /* FID 15461.0 */
      ccPegStndCalls(con, CC_DECREASE);

          /* Send the OTermSeized message to the FIC */
          /* CPDI 28361 replicate before FIC interactions */
          if (zcCb.protState == ACTIVE)
          {
             ZcUpdParam upd; 

             /* DEL CON */
             cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));
             upd.icSuConnId = con->icSuConnId;
             zcRunTimeUpd(ZC_CON_CB, CMPFTHA_DELETE_REQ, upd);
             zcUpdPeer ();
          }
          
      CcUiFctODTMFEntered(&oDTMFEntered, &header);
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("ODTMF_Entered to Fic Not Sent, going ahead: 0x%lx,0x%lx\n",
               con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqODTMFEntered is NOT ARMED as R: %ld, %d\n",
         con->icSuConnId , pBcm->nel[EReqODTMFEntered]);
    RETVALUE(RFAILED);
  }
}


/*
*
*      Fun:   ccProcessCTRClear
*
*      Desc:  As Per AIN ccProcessCTRClear can only be a EDP-Notification.
*             This functions checks if there is a OTermSeized armed in the
*             NEL of the BCM, if yes sends a Notification message to the FIC.
*
*      Ret:   Void.
*      Notes:
*
*      File:
*
*/
PUBLIC Void ccProcessCTRClear
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  CTRClear_t         ctrClear;


  CCDP( AIN_DBG_LEVEL_1, "ccProcessCTRClear:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVOID;
  }
  con = pBcm->con;

  if (pBcm->svcHeader.transId != 0)
  {
    /* Need to send an Notification Event to FIC ( CTR_Clear) */

    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&ctrClear, 0, sizeof(CTRClear_t));

    /* Fill in parameters in the Service Header Structure */
    ccFillSvcHeader(&header, pBcm, MSG_CTRClear);

    /* Fill in parameters in the CTR_CLEAR Structure */
    ccFillCTRClearParam(&ctrClear, pBcm);
    /* euysal - 03/29/2005 - ACC Support we need to send CTRClear with 0 digits*/
    if (con->relPend == PLAYINGANNCFORCONNECTTORSC)
    {   
       cmMemset((U8 *)&ctrClear.clAddrInfo, 0, sizeof(FcClAddrInfo)); 
    }
    con->lastState = con->state;
    CC_STATE_CHANGE(con, CCS_AWTRSPTIMEOUT);
    CCDP(AIN_DBG_LEVEL_0," Filled CTR_Clear, TransID=%ld\n", header.spTransId);
    ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);

    /* Send the OTermSeized message to the FIC */
    CcUiFctCTRClear(&ctrClear, &header);
    RETVOID;
  }
  else
  {
    CCLOGERR("Not able to notify ctrClear,still going ahead: %ld, %ld\n",
             con->icSuConnId, pBcm->svcHeader.transId);
  }
  RETVOID;
}


/*
*
*      Fun:   ccProcessOTermSeized
*
*      Desc:  As Per AIN OTermSeized can only be a EDP-Notification.
*             This functions checks if there is a OTermSeized armed in the
*             NEL of the BCM, if yes sends a Notification message to the FIC.
*
*      Ret:   Void.
*      Notes:
*
*      File:
*
*/
PUBLIC S16 ccProcessOTermSeized
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  OTermSeized_t      oTermSeized;
  U8                 index   = 0;


  CCDP( AIN_DBG_LEVEL_1, "ccProcessOTermSeized:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(RFAILED);
  }
  con = pBcm->con;

  if (pBcm->nel[EReqOTermSeized] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to send an Notification Event to FIC ( O_Term_Seized) */

      /* Initializing the message buffers */
      CCDP(AIN_DBG_LEVEL_0," Sending O_Term_Seized\n");
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oTermSeized, 0, sizeof(OTermSeized_t));

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Term_seized);

      /* Fill in parameters in the Term Seized Structure */
      ccFillOTermSeizedParam(&oTermSeized, pBcm, TRUE);

      /* Send the OTermSeized message to the FIC */
      CcUiFctOTermSeized(&oTermSeized, &header);
      RETVALUE(ROKDRSIG);
    }
    else
    {
      CCLOGERR("Not able to notify OTermSeized,still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(ROKDRSIG);
    }
  }
  else if (pBcm->nel[EReqOTermSeized] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to send an Notification Event to FIC ( O_Term_Seized) */

      /* Initializing the message buffers */
      CCDP(AIN_DBG_LEVEL_0," Sending O_Term_Seized\n");
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oTermSeized, 0, sizeof(OTermSeized_t));

      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Term_seized);

      /* Fill in parameters in the Term Seized Structure */
      ccFillOTermSeizedParam(&oTermSeized, pBcm, FALSE);

      CC_STATE_CHANGE(con,CCS_AWTRSPFORDPE7);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      /* Send the OTermSeized message to the FIC */
      CcUiFctOTermSeized(&oTermSeized, &header);
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to notify OTermSeized,still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }

  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOTermSeized event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}


/*
*
*      Fun:   ccProcessOAnswer
*
*      Desc:  As Per AIN OAnswer can only be a EDP-Notification.
*             This functions checks if there is a OAnswer armed in the
*             NEL of the BCM, if yes sends a Notification message to the FIC.
*
*      Ret:   Void.
*      Notes:
*
*      File:
*
*/
/*euysal - 04/21/2005 - Support for O_Answer request */
#if 1
PUBLIC S16 ccProcessOAnswer
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  OAnswer_t          oanswer;
  U8                 index   = 0;

  CCDP( AIN_DBG_LEVEL_1, "ccProcessOAnswer:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(RFAILED);
  }
  con = pBcm->con;

  if (pBcm->nel[EReqOAnswer] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to Send a OAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oanswer, 0, sizeof(OAnswer_t));

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Answer);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OANSWER Structure */
      ccFillOAnswerParam(&oanswer, pBcm, TRUE);
      CCDP(AIN_DBG_LEVEL_0," Filled OANSWER\n");

      /* Send the OANSWER Notification Message to the FIC */
      CcUiFctOAnswer(&oanswer, &header);
      RETVALUE(ROKDRSIG);
    }
    else
    {
      CCLOGERR("Not able to notify OANSWER,still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(ROKDRSIG);
    }
  }
  else if (pBcm->nel[EReqOAnswer] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0, "OgRsc is available send OAnswer Event\n");
      /* Need to Send a OAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oanswer, 0, sizeof(OAnswer_t));

      CCDP(AIN_DBG_LEVEL_0," TransId for OBCM :%ld\n", pBcm->svcHeader.transId );
      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Answer);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OANSWER Structure */
      ccFillOAnswerParam(&oanswer, pBcm, FALSE);
      CCDP(AIN_DBG_LEVEL_0," Filled OANSWER, TransID= %ld\n", header.spTransId);

      CC_STATE_CHANGE(con,CCS_AWTRSPFORDPE08);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      /* Send the OANSWER Notification Message to the FIC */
      CcUiFctOAnswer(&oanswer, &header);
      CCDP(AIN_DBG_LEVEL_0," Sending EReqOAnswer Event\n");
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to send EReqOAnswer event: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOAnswer event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}
#else
PUBLIC Void ccProcessOAnswer
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  OAnswer_t          oanswer;

  CCDP( AIN_DBG_LEVEL_1, "ccProcessOAnswer:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVOID;
  }
  con = pBcm->con;

  if (pBcm->nel[EReqOAnswer] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to Send a OAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oanswer, 0, sizeof(OAnswer_t));

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Answer);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OANSWER Structure */
      ccFillOAnswerParam(&oanswer, pBcm, TRUE);
      CCDP(AIN_DBG_LEVEL_0," Filled OANSWER\n");

      /* Send the OANSWER Notification Message to the FIC */
      CcUiFctOAnswer(&oanswer, &header);
      RETVOID;
    }
    else
    {
      CCLOGERR("Not able to notify OANSWER,still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVOID;
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOAnswer event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVOID;
  }
}
#endif

/*
*
*      Fun:   ccProcessTNoAnswer
*
*      Desc:  This Functions checks if there is a TNoAnswer event
*             armed, if yes, starts a TNoAnwer timer on the connection block
*             to which the bcm belongs.
*
*
*      Ret:   Void.
*      Notes: None.
*
*      File:
*
*/
PUBLIC Void ccProcessTNoAnswer
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con       = NULLP;

  CCDP(AIN_DBG_LEVEL_1, "ccProcessTNoAnswer:%ld,%ld,%d\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId, ccCp.genCfg.tmr.tAinTNoAns.val);
  if (pBcm->bcmType != BtTBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVOID;
  }
  con = pBcm->con;

  if (pBcm->nel[EReqTNoAnswer] == NEL_REQUEST)
  {
    CCDP(AIN_DBG_LEVEL_0,"T_No_Answer event is ARMED\n");
    /* BUG 17114 fix - pkumar */
    if ((con->ainInfo.TnoAnswerTimer.pres) &&
        (con->ainInfo.TnoAnswerTimer.val != 0))
    {
      ccCp.genCfg.tmr.tAinTNoAns.val = con->ainInfo.TnoAnswerTimer.val;
      ccStartConTmr(AIN_T_NO_ANS_TMR, con, (PTR)&ccCp.genCfg);
      CCDP(AIN_DBG_LEVEL_0, "ccCp.genCfg.tmr.tAinTNoAns.val = %d\n",
                            ccCp.genCfg.tmr.tAinTNoAns.val);
      /* Copying the Remote-SDP-of-IcBcm to CcConCb.
       * We need this if the call gets re-routed for CFNA */

      if(con->ogIpParam.locDesc)
        cmCopySdp(ccInit.region, ccInit.pool, &(con->ccHeldSdpForCfna),
            con->ogIpParam.locDesc);
      else
        cmCopySdp(ccInit.region, ccInit.pool, &(con->ccHeldSdpForCfna),
         con->icIpParam.rmtDesc);

      CCDP(AIN_DBG_LEVEL_0, "ccProcessTNoAnswer: ccHeldSdpForCfna Now has"
          "icIpParam.rmtDesc\n");
      if (AIN_DBG_LEVEL_0>=inDbgMsk)
      {
          cmSdpPrint(con->icSpConnId, con->ccHeldSdpForCfna);
      }
    }
    con->ainInfo.TnoAnswerTimer.pres = NOTPRSNT;
    RETVOID;
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqTNoAnswer event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVOID;
  }
}


/*
*
*      Fun:   ccProcessTermResourceAvailable
*
*      Desc:  This Functions checks if there is a TermResourceAvailable event
*             armed, if yes, sends a TermResourceAvailable Notification
*
*
*      Ret:   ROK      - Requested Event detected and sent to FIC.
*             ROKDRSIG - Continue with Call Processing, notif was sent (may be)
*             RFAILED  - Function failed , check error prints.
*      Notes: None.
*
*      File:
*
*/
PUBLIC S16 ccProcessTermResourceAvailable
(
AinBCM_t          *pBcm
)
{
  CcConCb                  *con       = NULLP;
  SvcHeader_t               header;
  TermResourceAvailable_t   termResource;
  U8                        index   = 0;

  CCDP(AIN_DBG_LEVEL_1, "ccProcessTermResourceAvailable:%ld,%ld\n",
                         pBcm->svcHeader.transId, pBcm->con->icSuConnId);
  if (pBcm->bcmType != BtTBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(RFAILED);
  }
  con = pBcm->con;
  if (pBcm->nel[EReqTermResourceAvailable] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0, "OgRsc is available send TermRscAvail Event:N\n");
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t)); 
      cmMemset((U8 *)&termResource, 0, sizeof(TermResourceAvailable_t));

      CCDP(AIN_DBG_LEVEL_0," TransId for TBCM :%ld\n", pBcm->svcHeader.transId );

      ccFillSvcHeader(&header, pBcm, MSG_Term_Resource_Available);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      ccFillTermResourceAvailableParam(&termResource, pBcm, TRUE);
      CCDP(AIN_DBG_LEVEL_0,"Filled TermResourceAvailable,TransID= %ld\n",
                            header.spTransId);
      CcUiFctTermResourceAvailable(&termResource, &header);
      CCDP(AIN_DBG_LEVEL_0," Sending TermResourceAvailable Event\n");
      RETVALUE(ROKDRSIG);
    }
    else
    {
      CCLOGERR("Not able to notify TermResourceAvailable Notify: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else if (pBcm->nel[EReqTermResourceAvailable] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0, "OgRsc is available send TermRscAvail Event\n");
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t)); 
      cmMemset((U8 *)&termResource, 0, sizeof(TermResourceAvailable_t));

      CCDP(AIN_DBG_LEVEL_0," TransId for TBCM :%ld\n", pBcm->svcHeader.transId );

      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      ccFillSvcHeader(&header, pBcm, MSG_Term_Resource_Available);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      ccFillTermResourceAvailableParam(&termResource, pBcm, FALSE);
      CCDP(AIN_DBG_LEVEL_0,"Filled TermResourceAvailable,TransID= %ld\n",
                            header.spTransId);
      CC_STATE_CHANGE(con,CCS_AWTRSPFORDPE22);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      CcUiFctTermResourceAvailable(&termResource, &header);
      CCDP(AIN_DBG_LEVEL_0," Sending TermResourceAvailable Event\n");
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to notify TermResourceAvailable Request: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOTermResourceAvailable event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}


/*
*
*      Fun:   ccProcessTAnswer
*
*      Desc:  As Per AIN TAnswer can only be a EDP-Notification.
*             This functions checks if there is a TAnswer armed in the
*             NEL of the BCM, if yes sends a Notification message to the FIC.
*
*      Ret:   Void.
*      Notes:
*
*      File:
*
*/
PUBLIC S16 ccProcessTAnswer
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  TAnswer_t          tanswer;
  U8                 index = 0;

  CCDP( AIN_DBG_LEVEL_1, "ccProcessTAnswer:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtTBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(ROKIGNORE);
  }
  con = pBcm->con;

  if (pBcm->nel[EReqTAnswer] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to Send a TAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&tanswer, 0, sizeof(TAnswer_t));

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_T_Answer);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OANSWER Structure */
      ccFillTAnswerParam(&tanswer, pBcm, TRUE);
      CCDP(AIN_DBG_LEVEL_0," Filled TANSWER\n");

      /* Send the TANSWER Notification Message to the FIC */
      CcUiFctTAnswer(&tanswer, &header);
      RETVALUE(ROKDRSIG);;
    }
    else
    {
      CCLOGERR("Not able to notify TANSWER,still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);;
    }
  }
  else if (pBcm->nel[EReqTAnswer] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0, "OgRsc is available send TAnswer Event\n");
      /* Need to Send a TAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&tanswer, 0, sizeof(TAnswer_t));

      CCDP(AIN_DBG_LEVEL_0," TransId for TBCM :%ld\n", pBcm->svcHeader.transId );
      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_T_Answer);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      ccFillTAnswerParam(&tanswer, pBcm, FALSE);
      CCDP(AIN_DBG_LEVEL_0," Filled TANSWER, TransID= %ld\n", header.spTransId);

      CC_STATE_CHANGE(con,CCS_AWTRSPFORDPE08);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      /* Send the OANSWER Notification Message to the FIC */
      CcUiFctTAnswer(&tanswer, &header);
      CCDP(AIN_DBG_LEVEL_0," Sending EReqTAnswer Event and change the state to CCS_AWTRSPFORDPE08\n");
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to send EReqTAnswer event: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqTAnswer event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}

/*
*
*      Fun:   ccProcessTBusy
*
*      Desc:  As Per AIN TBusy can be a TDP-R or an EDP-R
*             This function checks if there is a TBUSY event armed.
*             If yes sends a message to FIC.
*
*      Ret:   ROK      - TBUSY is armed and Request sent to FIC.
*             ROKDRSIG - TBUSY is not armed and no message sent to FIC.
*             RFAILED  - Something failed while processing.
*      Notes:
*
*      File:
*
*/
PUBLIC S16 ccProcessTBusy
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  S16                ret            = RFAILED;
  SvcHeader_t        header;
  TBusy_t            tBusy;
  CcConCb           *tempcon        = NULLP;
  msgValBcmTypeEnum  bcmType        = BtMax;
  UConnId            busySuConnId   = 0;
  U8                 index          = 0;

  CCDP( AIN_DBG_LEVEL_1, "ccProcessTBusy:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtTBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(ROK);
  }
  con = pBcm->con;

  if (pBcm->nel[EReqTBusy] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId == 0)
    {
      CCLOGERR( "Critical Error, transId = %ld, %ld\n", con->icSuConnId,
                                 pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }

    /* Cleaning up the NEL as per R5-241 GR1298 */
    for (index = 0; index < EReqMax; index++)
    {
      pBcm->nel[index] = NEL_UNARMED;
    }

    /* Send a TBusy Request to FIC */
    /* Initializing the message buffers */
    cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
    cmMemset((U8 *)&tBusy, 0, sizeof(TBusy_t));

    /* Fill in parameters in the Service Header Structure */
    ccFillSvcHeader(&header, &(con->ogBcm), MSG_T_Busy);
    CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

    busySuConnId = con->busySuConnId;
    if (con->ogRscSta == RMT_RES_ALOC_FAILURE)
    {
      /* The call is not busy in a call, it may come here for CF */
      /* Fill in parameters in the TBusy Structure */
      ccFillTBusyParam(&tBusy, &(con->ogBcm), FALSE,
                       CALL_STATE_NOT_ACTIVE);
      CCDP(AIN_DBG_LEVEL_0," Filled TBusy\n");
      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE30);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      CcUiFctTBusy(&tBusy, &header);
      RETVALUE(ROK);
    }
    else
    {
      /* Find the connection block with which this resource is busy */
      ret = cmHashListFind (&ccSuInstTbl, (U8 *)&busySuConnId,
                            (U16)sizeof(UConnId), (U16)0,
                            (PTR *) &tempcon);
      if (ret != ROK)
      {
        ret = cmHashListFind(&ccSuOgInstTbl, (U8 *)&busySuConnId,
                             (U16)sizeof(UConnId), (U16)0,
                             (PTR *) &tempcon);
        if (ret != ROK)
        {
          CCLOGERR( "Error: Associated con for Resource not found,%ld\n",
                     con->ogSuConnId);
          RETVALUE(RFAILED);
        }
        else
        {
          CCDP(AIN_DBG_LEVEL_0, "Found the CON:%ld\n", busySuConnId);
          bcmType = BtTBcm;
        }
      }
      else
      {
        CCDP(AIN_DBG_LEVEL_0, "Found the CON:%ld\n", busySuConnId);
        bcmType = BtOBcm;
      }
      if (tempcon->state != CCS_ANSWERED)
      {
        /* Fill in parameters in the TBusy Structure */
        ccFillTBusyParam(&tBusy, &(con->ogBcm), FALSE,
                         CALL_STATE_NOT_ACTIVE);
      }
      else
      {
        /* Fill in parameters in the TBusy Structure */
        ccFillTBusyParam(&tBusy, &(con->ogBcm), FALSE,
                         CALL_STATE_ACTIVE);
      }
      CCDP(AIN_DBG_LEVEL_0," Filled TBusy\n");
      CC_STATE_CHANGE(con, CCS_AWTRSPFORDPE30);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      CcUiFctTBusy(&tBusy, &header);
      RETVALUE(ROK);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqTBusy event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}
/* euysal - 05/25/2005 - ACC Support */
#if 1
PUBLIC S16 ccProcessOSuspended
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  OSuspended_t       osuspended;
  U8                 index   = 0;

  CCDP( AIN_DBG_LEVEL_1, "ccProcessOSuspended:%ld,%ld\n",pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(RFAILED);
  }
  con = pBcm->con;

  if (pBcm->nel[EReqOSuspended] == NEL_NOTIFY)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      /* Need to Send a OSuspended message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&osuspended, 0, sizeof(OSuspended_t));

      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Suspended);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OSuspended Structure */
      ccFillOSuspendedParam(&osuspended, pBcm, TRUE);
      CCDP(AIN_DBG_LEVEL_0," Filled OSuspended\n");

      /* Send the OSuspended Notification Message to the FIC */
      CcUiFctOSuspended(&osuspended, &header);
      RETVALUE(ROKDRSIG);
    }
    else
    {
      CCLOGERR("Not able to notify OSUSPENDED, still going ahead: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(ROKDRSIG);
    }
  }
  else if (pBcm->nel[EReqOSuspended] == NEL_REQUEST)
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0, "OgRsc is available send OSuspended Event\n");
      /* Need to Send a OAnswer message to FIC */
      /* Initializing the message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&osuspended, 0, sizeof(OSuspended_t));

      CCDP(AIN_DBG_LEVEL_0," TransId for OBCM :%ld\n", pBcm->svcHeader.transId );
      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Suspended);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OSuspended Structure */
      ccFillOSuspendedParam(&osuspended, pBcm, FALSE);
      CCDP(AIN_DBG_LEVEL_0," Filled OSuspended, TransID= %ld\n", header.spTransId);

      CC_STATE_CHANGE(con,CCS_AWTRSPFORDPE12);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);
      /* Send the OSuspended Requested Event to the FIC */
      CcUiFctOSuspended(&osuspended, &header);
      CCDP(AIN_DBG_LEVEL_0," Sending EReqOSuspended Event\n");
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to send EReqOSuspended event: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOSuspended event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}
#endif


/*
*
*      Fun:   ccProcessOCallSent
*
*      Desc:  This is a non-standard event. Currently this is only detected as 
*             a Notification event.
*             This functions checks if there is a OCallSent armed in the
*             NEL of the BCM, if yes processes and sends a message to FIC.
*
*      Ret:   Void.
*      Notes:
*
*      File:
*
*/
PUBLIC Void ccProcessOCallSent
(
AinBCM_t          *pBcm
)
{
    CcConCb        *con       = NULLP;
    SvcHeader_t     header;
    OCallSent_t     oCallSent;

    if (pBcm)
        con = pBcm->con;

    if ((pBcm == NULLP) || (con == NULLP))
    {
        CCLOGERR("Error %s: Null pointers: pBcm = 0x%lx, con = 0x%lx\n",
                  __FUNCTION__, (PTR) pBcm, (PTR)con);
        RETVOID;
    }

    if (pBcm->bcmType != BtOBcm)
    {
        CCLOGERR("Error: Invalid bcmType = %d, icSu:0x%lx\n", pBcm->bcmType,
                 con->icSuConnId);
        RETVOID;
    }

    CCDP(AIN_DBG_LEVEL_1, "%s:0x%lx, 0x%lx\n", __FUNCTION__,
         pBcm->svcHeader.transId, con->icSuConnId);

    if ((pBcm->nel[EReqOCallSent] == NEL_NOTIFY) && (pBcm->svcHeader.transId))
    {
        cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
        cmMemset((U8 *)&oCallSent, 0, sizeof(OCallSent_t));

        ccFillSvcHeader(&header, pBcm, MSG_O_CallSent);
        ccFillOCallSentParam(&oCallSent, pBcm, TRUE);

        CcUiFctOCallSent(&oCallSent, &header);

        CCDP(AIN_DBG_LEVEL_1, "%s:Event Dectected: 0x%lx, 0x%lx\n",
             __FUNCTION__, pBcm->svcHeader.transId, con->icSuConnId);
        RETVOID;
    }
    RETVOID;
}

/* FID 14234.0 + */
/*
 *
 *      Fun:   ccProcessOApm
 *
 *      Desc:  Currently this is only detected as a Request event.
 *             This functions checks if there is an oApm armed in the
 *             NEL of the BCM, if yes processes and sends a message to FIC.
 *
 *      Ret:  ROK ----  Successful 
 *            RFAILED --- Failure
 *
 *      File: cc_bdy2.c
 *
 */
PUBLIC S16 ccProcessOApm
(
AinBCM_t          *pBcm
)
{
  CcConCb           *con            = NULLP;
  SvcHeader_t        header;
  OApm_t             oapm;
  U8                 index   = 0;

  if (pBcm == NULLP)
  {
    CCLOGERR("Error: pBcm is NULL\n");
    RETVALUE(RFAILED);
  }
  CCDP(AIN_DBG_LEVEL_1, "%s:%ld,%ld\n",__FUNCTION__,pBcm->svcHeader.transId,
                        pBcm->con->icSuConnId );
  if (pBcm->bcmType != BtOBcm)
  {
    CCLOGERR("Error: Invalid bcmType:%d,%ld\n", pBcm->bcmType,
              pBcm->con->icSuConnId );
    RETVALUE(RFAILED);
  }
  con = pBcm->con;

  if ((pBcm->nel[EReqOApm] == NEL_REQUEST) ||
      (pBcm->nel[EReqOApmCalled] == NEL_REQUEST))
  {
    if (pBcm->svcHeader.transId != 0)
    {
      CCDP(AIN_DBG_LEVEL_0," TransId for OBCM :%ld\n", pBcm->svcHeader.transId );

      /* Initializing the OAPM message buffers */
      cmMemset((U8 *)&header, 0, sizeof(SvcHeader_t));
      cmMemset((U8 *)&oapm, 0, sizeof(OApm_t));

      oapm.notInd = FALSE;

      /* Hard code legId in these cases */
      if(pBcm->nel[EReqOApm] == NEL_REQUEST)
      {
          con->ainInfo.legId = 0;
      }
      else
      {
          con->ainInfo.legId = 1;
      }

      /* Cleaning up the NEL as per R5-241 GR1298 */
      for (index = 0; index < EReqMax; index++)
      {
        pBcm->nel[index] = NEL_UNARMED;
      }
      /* Fill in parameters in the Service Header Structure */
      ccFillSvcHeader(&header, pBcm, MSG_O_Apm);
      CCDP(AIN_DBG_LEVEL_0," Filled SvcHeader\n");

      /* Fill in parameters in the OApm Structure */
      ccFillOApmParam(&oapm, pBcm, FALSE);
      CCDP(AIN_DBG_LEVEL_0," Filled OSuspended, TransID= %ld\n", header.spTransId);

      con->lastState = con->state;

      CC_STATE_CHANGE(con,CCS_AWTRSPOAPM);
      ccChangeCallStateOfAssociatedCalls(&(con->icBcm), CCS_CANNOTPROCESSEVENTS);

      /* Send the OApm Requested Event to the FIC */
      CcUiFctOApm(&oapm, &header);

      CCDP(AIN_DBG_LEVEL_0," Sending EReqOApm Event\n");
      RETVALUE(ROK);
    }
    else
    {
      CCLOGERR("Not able to send EReqOApm event: %ld, %ld\n",
                                   con->icSuConnId, pBcm->svcHeader.transId);
      RETVALUE(RFAILED);
    }
  }
  else
  {
    CCDP(AIN_DBG_LEVEL_0,"EReqOApm event is NOT ARMED: %ld\n",
                          con->icSuConnId);
    RETVALUE(ROKDRSIG);
  }
}
/* FID 14234.0 - */


/*
 *
 *      Fun:   ccDisconnectCallInCC11
 *
 *      Desc:  This functions is used to Disconnect a party who is in ccId = CC11
 *             Disconnect is also propagated to asssociated BCM's.
 *
 *      Ret:   None.
 *
 *      Notes: 
 *
 *      File:  cc_bdy2.c
 *
 */
PUBLIC Void ccDisconnectCallInCC11
(
CcConCb      *con,
Bool          split,
PTR           event
)
{
  S16                   ret               = RFAILED;
  CcConCb              *CSID1con          = NULLP;
  AinBCM_t             *legId02           = NULLP;
  AinBCM_t             *legId01           = NULLP;
  AinBCM_t             *legId1            = NULLP;
  AinBCM_t             *legId2            = NULLP;
  msgValBcmTypeEnum     bcmType           = BtMax;
  U8                    cause             = CCCALLCLR;
  ProtType             conOgProtType  = 0; 
  ProtType             conIcProtType  = 0; 

#ifdef ZC
  ZcUpdParam upd;
#endif /* ZC */

  if (con == NULLP)
  {
    CCLOGERR("Error: con is NULLP\n");
    RETVOID;
  }
  CSID1con = con->icBcm.cc->legId1->con;
  legId02  = con->icBcm.cc->legId02;
  legId01  = con->icBcm.cc->legId01;
  legId1   = con->icBcm.cc->legId1;
  legId2   = con->icBcm.cc->legId2; 
  bcmType  = legId02->bcmType;

  CCDP(AIN_DBG_LEVEL_1, "ccDisconnectCallInCC11:%ld, %ld, %ld, %ld\n",
                        CSID1con->icSuConnId, CSID1con->ogSuConnId,
                        con->icSuConnId, con->ogSuConnId);
  if ((legId02 == NULLP) || (legId1 == NULLP))
  {
    CCLOGERR("Error: legId02 or legId1 is NULLP:%lx %lx\n", (U32 )legId02, (U32)legId1);
    RETVOID;
  }

#if 1
  ccRestoreCallStateOfAssociatedCalls(&(con->icBcm));
#endif
#ifdef ZC
  /* Bug# 20268 */
  cmMemset((U8*) &upd, 0, sizeof(ZcUpdParam));

  if (CC_IS_OBCM_PIC_ACTIVE(con))
  {
    upd.featMsg.ccAinUpdType = CC_DISCONNECT;
    upd.featMsg.suConnId     = con->icSuConnId;
    upd.featMsg.DlegId       = 0;
    upd.featMsg.nel          = con->icBcm.nel;
    zcRunTimeUpd(ZC_FEAT, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
  }
#endif /* ZC */

  if (con->ainInfo.legId == 2)
  {
     if (ccInit.acnt == TRUE)
        ccSetRelIndTckForMPartyCall(con, CSID1con, BtOBcm);

     /* Remove Association between CS1 and CS2 */
     CC_PUT_BCM_INTO_TWO_PARTY(legId02, legId1);
     
     con->icBcm.cc->ccId       = CiStable2Party;
     con->icBcm.cc->legId1     = &(con->ogBcm);
     con->icBcm.cc->legId02    = NULLP;
     con->icBcm.cc->legId2     = NULLP;

     ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(con->ogBcm),event);

     if (split == FALSE)
     {
/********************MG BLOCK MANIPULATION**********************************/
       GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,con->mgBlock,CSID1con);
       CSID1con->mgBlock->con     = CSID1con;
       GCC_MNG_MGBLOCK_CNTR(con->mgBlock,NULLP,con);
       /* Allocate the mgBlock */
       ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(con->mgBlock),
                      (Size) sizeof(CcMgBlock_t));

       cmMemset((U8 *) con->mgBlock, 0, sizeof(CcMgBlock_t));
       GCC_INC_CONCNT(con->mgBlock);
     } 

/************************CLEAN UP THE CS2 CALL******************************/
    ccStopConTmr(con, CC_TMR_CALLDTL);
    ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
#ifdef ZC
    upd.icSuConnId = con->icSuConnId;
    zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
    zcUpdPeer();
#endif
/************************CLEAN UP THE CS2 CALL******************************/


    if (CC_IS_CONTEXT_PRESENT(con))
    {
      ccUpdateMgQForSubRsc((PTR) NULLP, con->mgBlock->mgCtx->suCtxId, con);
      con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;
      con->tempHolderForReleaseCause = cause;

      if (con->ogRscVal)
      {
         conOgProtType = CC_GET_PROTOCOL(con->ogProtType);
         /* FID15310.1 ICA call only need for ogRel */
         if(CC_IS_ICA_CALL(con))
         {
           con->relPend = OGRELONLY;
           CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
           CCDP(AIN_DBG_LEVEL_1, "%s: ICA call only need  one release\n", __FUNCTION__);
         }
         else if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->ogBcm, conOgProtType))
         {
           con->relPend = OUTRELRSPANDNOREL;
           CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
         }
         else
         { 
           con->relPend = OGRELONLY;
           CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
         }
      }
      else
      {
        con->lastState = 0;
        con->relPend = NORELANDNORELRSP;
        CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
      }

      con->mgBlock->con = con;
      ret = ccSendMgiQueue(con->mgBlock->mgCtx->suCtxId, con->mgBlock);

      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_0, "MGI Operation success:%ld, %ld, %ld\n",
                 con->icSuConnId, con->ogSuConnId, con->mgBlock->mgCtx->suCtxId);
      }
      else
      {
        CCLOGERR("SendMgiQ failed :%d\n", ret);
        /* Follow the path of No-Context code */
      }
    }

    if ((!CC_IS_CONTEXT_PRESENT(con)) || (ret != ROK))
    {                             
      /* If we reach here, we have a problem so cleaning up the call
       * without caring about Switching */

      cleanUpMgQ(con);
      ccCleanUpMGCtx (con);

      if (con->ogRscVal)
      {
         conOgProtType = CC_GET_PROTOCOL(con->ogProtType);
         if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&con->ogBcm, conOgProtType))
         {
           con->direction = OUTTOINC;
           if (con->noRspReqd == FALSE) ccSendReleaseRsp(con);

           CC_STATE_CHANGE(con, CCS_AWTDEALOCCFM);

#ifdef GUARD_TIMER
           ccGuardOrDeallocResource(con, CC_OUTGOING);
#else
           ccDeallocateResource(con, CC_OUTGOING);
#endif
         }
         else
         { 
           CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
           ccSendRelease(con, con->ogSapCb, con->ogSpConnId, con->ogSuConnId,
                      con->ogProtType, cause, NULL);
         }
      }
      else
      {
        if (con->icProtType != CC_LOCAL_SWT_PROT)
           ccReleaseCaleaLegs(con);
        CC_STATE_CHANGE(con, CCS_IDLE);
        ccRelCon(con);
      }
    }

    ret = ccProcessDisconnectOnSpecificBCM (legId1);
#ifdef CALEA_3WC
    if ((legId1->con != NULLP) && (legId1->bcmType == BtTBcm))
    {
       if (legId1->con->surrogate != NULLP)
          ccProcessDisconnectNotfnForSurrogateLegs(legId1->con, event);
    }
#endif

    if (ret == ROK)
    {
      /* If event is armed , we would process this disconnect and
       * the con will be cleaned up in that function */
    }
    else
    {
#ifdef CALEA_3WC
       /* The passive leg is not involved in MParty Call */
        ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(legId1,
                                                        event);
#endif
        /***************CLEAN UP THE CS1 CALL***********************/
        ccSendReleasesOnBothSidesWithSwitching(CSID1con, CCNORMUNSPEC);
    }
  }
  else if (con->ainInfo.legId == 1)
  {
     if (bcmType == BtOBcm)
     {
         if (ccInit.acnt == TRUE)
            ccSetRelIndTckForMPartyCall(CSID1con, con, BtOBcm);

         CC_PUT_BCM_INTO_TWO_PARTY(legId01, legId2);
         CSID1con->icBcm.cc->ccId       = CiStable2Party;
         CSID1con->icBcm.cc->legId01    = legId02;
         CSID1con->icBcm.cc->legId1     = &(CSID1con->ogBcm);
         CSID1con->icBcm.cc->legId02    = NULLP;
         CSID1con->icBcm.cc->legId2     = NULLP;

         ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(CSID1con->ogBcm), 
                                                        event); 
     }
     else if (bcmType == BtTBcm) 
     {
        if (ccInit.acnt == TRUE)
            ccSetRelIndTckForMPartyCall(CSID1con, con, BtTBcm);

        CC_PUT_BCM_INTO_TWO_PARTY(legId01, legId2);
        CSID1con->ogBcm.cc->ccId       = CiStable2Party;
        CSID1con->ogBcm.cc->legId01    = legId02;
        CSID1con->ogBcm.cc->legId1     = &(CSID1con->icBcm);
        CSID1con->ogBcm.cc->legId02    = NULLP;
        CSID1con->ogBcm.cc->legId2     = NULLP;

        ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(&(CSID1con->icBcm),
                                                        event);
     }


     if (split == FALSE)
     {
/********************MG BLOCK MANIPULATION**********************************/
        GCC_MNG_MGBLOCK_CNTR(con->mgBlock,CSID1con->mgBlock,con);
        con->mgBlock->con     = con;
        GCC_MNG_MGBLOCK_CNTR(CSID1con->mgBlock,NULLP,CSID1con);
        /* Allocate the mgBlock */
        ret = SGetSBuf(ccInit.region, ccInit.pool, (Data **) &(CSID1con->mgBlock),
                      (Size) sizeof(CcMgBlock_t));

        cmMemset((U8 *) CSID1con->mgBlock, 0, sizeof(CcMgBlock_t));
        GCC_INC_CONCNT(CSID1con->mgBlock);
     }

     ccStopConTmr(CSID1con, CC_TMR_CALLDTL);
     ccStartConTmr(TMR_RELEASE, CSID1con, (PTR)&ccCp.genCfg);
#ifdef ZC
     upd.icSuConnId = CSID1con->icSuConnId;
     zcRunTimeUpd(ZC_RELCON_CB, CMPFTHA_UPD_REQ, upd);
     zcUpdPeer();
#endif
          

     if (CC_IS_CONTEXT_PRESENT(CSID1con))
     {       
        ccUpdateMgQForSubRsc((PTR) NULLP, CSID1con->mgBlock->mgCtx->suCtxId, 
                             CSID1con);

        CSID1con->tempHolderForReleaseCause = cause;
        CSID1con->tmdRelApplied = CC_NO_TMD_RELEASE_REQUIRED;

        if (CSID1con->ogRscVal)
        {
           conOgProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
           /* FID15310.1 ICA call only need for ogRel */
           if(CC_IS_ICA_CALL(CSID1con))
           {
             CSID1con->relPend = OGRELONLY;
             CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
             CCDP(AIN_DBG_LEVEL_1, "%s: ICA call only need for one release\n", __FUNCTION__);
           }
           else if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->ogBcm, conOgProtType))
           {
              CSID1con->relPend = OUTRELRSPANDNOREL;
              CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
           } 
           else
           {
              CSID1con->relPend = OGRELONLY;
              CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL); 
           } 
        }
        else if (CSID1con->icRscVal)
        {
           conIcProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
           if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->icBcm, conIcProtType))
           {
              CSID1con->relPend = INRELRSPANDNOREL;
              CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
           }
           else
           {
              CSID1con->relPend = ICRELONLY;
              CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDONEREL);
           }
        }
        else
        {
           CSID1con->lastState = 0; 
           CSID1con->relPend = NORELANDNORELRSP;
           CC_STATE_CHANGE(CSID1con, CCS_AWTSWTCFM_SENDNOREL);
        }

        CSID1con->mgBlock->con = CSID1con;
        ret = ccSendMgiQueue(CSID1con->mgBlock->mgCtx->suCtxId,
                                CSID1con->mgBlock);
         
        if (ret == ROK)
        {
           CCDP(AIN_DBG_LEVEL_0, "MGI Operation success:%ld, %ld, %ld\n",
                CSID1con->icSuConnId, CSID1con->ogSuConnId, 
                CSID1con->mgBlock->mgCtx->suCtxId);
        }
        else
        {
          CCLOGERR("SendMgiQ failed:%d\n", ret);            
        }
     }

     if ((!CC_IS_CONTEXT_PRESENT(CSID1con)) || (ret != ROK))
     {
        /* If we reach here, we have a problem so cleaning up the call
         * without caring about Switching */

        cleanUpMgQ(CSID1con);
        ccCleanUpMGCtx (CSID1con);

        if (CSID1con->ogRscVal)
        {
           conOgProtType = CC_GET_PROTOCOL(CSID1con->ogProtType);
           if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->ogBcm, conOgProtType))
           {
             CSID1con->direction = OUTTOINC;
             if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
             CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
#ifdef GUARD_TIMER
             ccGuardOrDeallocResource(CSID1con, CC_OUTGOING);
#else
             ccDeallocateResource(CSID1con, CC_OUTGOING);
#endif
           }
           else
           {
             CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_OG);
             ccSendRelease(CSID1con, CSID1con->ogSapCb, CSID1con->ogSpConnId, 
                         CSID1con->ogSuConnId, CSID1con->ogProtType, cause, 
                         NULL);
           }
        }
        else if (CSID1con->icRscVal)
        {
           conIcProtType = CC_GET_PROTOCOL(CSID1con->icProtType);
           if (CC_RELRSP_NEEDED_FOR_DISCONNECT(&CSID1con->icBcm, conIcProtType))
           {
             CSID1con->direction = INCTOOUT;
             if (CSID1con->noRspReqd == FALSE) ccSendReleaseRsp(CSID1con);
             CC_STATE_CHANGE(CSID1con, CCS_AWTDEALOCCFM);
#ifdef GUARD_TIMER
             ccGuardOrDeallocResource(CSID1con, CC_INCOMING);
#else
             ccDeallocateResource(CSID1con, CC_INCOMING);
#endif
           }
           else
           {
             CC_STATE_CHANGE(CSID1con, CCS_AWTRELCFM_IC);
             ccSendRelease(CSID1con, CSID1con->icSapCb, CSID1con->icSpConnId,
                         CSID1con->icSuConnId, CSID1con->icProtType, cause,
                         NULL);
           }
        }
        else
        {
           if (CSID1con->icProtType != CC_LOCAL_SWT_PROT)
              ccReleaseCaleaLegs(CSID1con);
           CC_STATE_CHANGE(CSID1con, CCS_IDLE);
           ccRelCon(CSID1con);
        }
     } 

     ret = ccProcessDisconnectOnSpecificBCM (legId2);
#ifdef CALEA_3WC
     /* we must not send the DisconnectNofn for the CaleaLegs of 
      * controller as they will be moved into CS1, but the surrogate 
      * LEAs must be released*/
     if ((legId2->con != NULLP) && (legId2->bcmType == BtTBcm))
     {
        if (legId2->con->surrogate != NULLP)
           ccProcessDisconnectNotfnForSurrogateLegs(legId2->con, event);
     }
#endif

     if (ret == ROK)
     {
       /* If event is armed , we would process this disconnect and
        * the con will be cleaned up in that function */
     }
     else
     { 
#ifdef CALEA_3WC
       /* The passive leg is not involved in MParty Call */
        ccProcessDisconnectNotfnForSpecificBcmCaleaLegs(legId2,
                                                        event);
#endif
        /***************CLEAN UP THE CS2 CALL***********************/
        ccSendReleasesOnBothSidesWithSwitching(con, CCNORMUNSPEC);
      }
  }
  else
     CCLOGERR("ERROR!! INVALID LegId %ld\n", con->icSuConnId);

  RETVOID;
}

void
ccBillUpdCdPtyNum (char *file, int line, CcConCb *con)
{
    CcAllSdus          *eventHold;
    int                i;
    int                portedNumIndex = -1;
    int                natAddrIndex = -1;
    int                numPlan1Index = -1;

    eventHold = CC_IS_CON_IN_EVNT_HOLD(con) ? con->ccEvntHold : con->icConEvntHold;

    if (eventHold == NULL)
    {
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: null event hold file %s:%d\n",
             file, line);
        return;
    }

    BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: called for con 0x%lx file %s:%d\n", (U32)con, file, line);

    for (i = 0; i < MF_MAX_GAP; ++i)
    {
        if (con->ainInfo.genAddrList.genAddr [i].eh.pres == NOTPRSNT)
            continue;

        if (con->ainInfo.genAddrList.genAddr[i].typeOfAddr.pres)
        {
            if (con->ainInfo.genAddrList.genAddr[i].typeOfAddr.val == PORTNUM)
            {
                portedNumIndex = i;
            }
        }
        
        if (con->ainInfo.genAddrList.genAddr[i].natAddr.pres)
        {
            natAddrIndex = i;
        }

        if (con->ainInfo.genAddrList.genAddr[i].numPlan1.pres)
        {
            numPlan1Index = i;
        }
    }         


    /* BUG#71570 only update the original GAP in ainInfo to CDR:
     * Only two cases will update to CDR:
     * 1.The GAP LGP received from the imcoming IAM(or INVITE ect )message;
     * 2.The incoming IAM(or INVITE ect)does not have GAP, but a LNP query is made in our LGP, and this GAP from SCF 
     * will also be updated to CDR;
     */
    switch (con->icRsc.intfc.intfType)
    {
    case CC_SI_INTFC:
    case CC_BICC_INTFC:
    case CC_EXT_BICC_INTFC:
    case CC_SIP_INTFC:
        if (portedNumIndex != -1)
        {
          if(con->icBcm.pic < PicSelectRoute)
          {
            ccExtractGapNmb(con->ainInfo.genAddrList.genAddr[portedNumIndex].addrSig.val,//from
                            &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb); // to
/*euysal - 01/25/2006 - Bug: 44152 We need to populate nature of address and numbering plan too */
           if (con->ainInfo.genAddrList.genAddr[portedNumIndex].numPlan1.pres)
           {   
               con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbPlanId.pres = 
               con->ainInfo.genAddrList.genAddr[portedNumIndex].numPlan1.pres;
               con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbPlanId.val =  
               con->ainInfo.genAddrList.genAddr[portedNumIndex].numPlan1.val;
           }    
           if (con->ainInfo.genAddrList.genAddr[portedNumIndex].natAddr.pres)
           {   
               con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.typeNmb0.pres = 
               con->ainInfo.genAddrList.genAddr[portedNumIndex].natAddr.pres;   
               con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.typeNmb0.val  = 
               con->ainInfo.genAddrList.genAddr[portedNumIndex].natAddr.val; 
           }
          }
          else
          {
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum:No Need to update the GAP to CDR\n");
            return;
          }
        }
        else
        {
            ccExtractCDRCalledNum(&con->ainInfo.cdPtyNum, /* from */
                                  &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);//to
        }
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum - called from %s:%d, "
             "type:(SI/BICC/SIP), CDR.CdPtyNmb:(eh.pres,nmb.pres,nmb.len,nmb.val):"
             "(%d,%d,%d,%s)\n", file, line,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.eh.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.len,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.val) ;
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum - "
             "CDR.CdPtyNmb:(numPlanId.pres,numPlanId.val,typeNmb0.pres,typeNmb0.val):"
             "(%d,%d,%d,%d)\n",
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbPlanId.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbPlanId.val,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.typeNmb0.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.typeNmb0.val) ;
        break;

    case CC_IN_INTFC:
        if (portedNumIndex != -1)
        {
          if(con->icBcm.pic < PicSelectRoute)
          {
            ccExtractGapNmb(con->ainInfo.genAddrList.genAddr[portedNumIndex].addrSig.val, 
                  &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
          }
          else
          {
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum:No Need to update the GAP to CDR\n");
            return;
          }
        }
        else
        {
            ccExtractCDRCalledNum (&con->ainInfo.cdPtyNum,
                             &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
        }
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum - called from %s:%d, "
             "type:(ISDN), CDR.CdPtyNmb:(eh.pres,nmb.pres,nmb.len,nmb.val):"
             "(%d,%d,%d,%s)\n", file, line,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.eh.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.len,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.val) ;
        break;

    case CC_CS_LN_INTFC:
    case CC_CS_TG_INTFC:
    case CC_G3_INTFC:
        if (portedNumIndex != -1)
        {
          if(con->icBcm.pic < PicSelectRoute)
          {
            ccExtractGapNmb(con->ainInfo.genAddrList.genAddr[portedNumIndex].addrSig.val, 
                            &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
          }
          else
          {
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum:No Need to update the GAP to CDR\n");
            return;
          }
        }
        else
        {
            ccExtractCDRCalledNum (&con->ainInfo.cdPtyNum,
                                   &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
        }
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum - called from %s:%d, "
             "type:(CSLN/CSTG/GR303), CDR.CdPtyNmb:(eh.pres,nmb.pres,nmb.len,nmb.val):"
             "(%d,%d,%d,%s)\n", file, line,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.eh.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.pres,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.len,
             con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb.nmbDigits.val) ;
        break;

    case CC_LOCAL_SWT_PROT_INTFC:
        if (portedNumIndex != -1)
        {
          if(con->icBcm.pic < PicSelectRoute)
          {
            ccExtractGapNmb(con->ainInfo.genAddrList.genAddr[portedNumIndex].addrSig.val, 
                  &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
             BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: got (LEA)"
                  " Terminating Called Party Number file %s:%d\n",
                  file, line);
          }
          else
          {
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum:No Need to update the GAP to CDR\n");
            return;
          }
        }
        else
        {
            ccExtractCDRCalledNum (&con->ainInfo.cdPtyNum,
                             &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: got (CC_LOCAL_SWT_PROT_INTFC)"
                 " Terminating Called Party Number file %s:%d\n",
                 file, line);
        }
        break;

    case CC_MGCP_LN_INTFC:
        if (portedNumIndex != -1)
        {
          if(con->icBcm.pic < PicSelectRoute)
          {
            ccExtractGapNmb(con->ainInfo.genAddrList.genAddr[portedNumIndex].addrSig.val, 
                  &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: got (LEA)"
                  " Terminating Called Party Number file %s:%d\n",
                 file, line);
          }
          else
          {
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum:No Need to update the GAP to CDR\n");
            return;
          }
        }
        else
        {
            ccExtractCDRCalledNum (&con->ainInfo.cdPtyNum,
                             &con->callDtlInfo.un.telicaCDR_extention.cdPtyNmb);
            BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: got (MGCP_LN)"
                 " Terminating Called Party Number file %s:%d\n",
                 file, line);
        }
        break;

    default:
        BDBG(BILLING_DBG_LEVEL_1, "ccBillUpdCdPtyNum: no code to retrieve"
             " Called Party Number for IF type %d file %s:%d\n",
             con->icRsc.intfc.intfType, file, line);
        break;
    }

    return;
} /* end ccBillUpdCdPtyNum */

/********************************************************************
bug:24575 wr
********************************************************************/
void updateBillingForExit(ProtType ogProtocolType, U8 icEventType, CcCallDtlInfo *cdi)
{
    char fn[] = "updateBillingForExit" ;

    if (((ogProtocolType == CC_SI) ||
         (ogProtocolType == CC_EXT_BICC)) && /* FID 15319.0 */
        icEventType == CC_ET_EXIT)
    {
        cdi->un.telicaCDR_extention.icIncEvntStatus = CC_CES_BISUP_EXM_GOTTEN ;
        CCDP(AIN_DBG_LEVEL_0,"%s - icEventType:%d, ogProtocolType:%d, Got EXIT, "
             "billing->icIncEvntStatus:%d\n", fn, icEventType, ogProtocolType,
             cdi->un.telicaCDR_extention.icIncEvntStatus) ;
    }
    return ;
}
#ifdef CC_FID_2138_2167_2168_2169_2171
/* Req 7359 */
/*
 *
 *      Fun:   ccCheckIncIsupCUG
 *
 *      Desc:  IC Call - Check the Incoming ISUP  IAM OFCI cug parameter value
 *      Ret:   ROK     -  OFCI cug is 0x03
 *             RFAILED -  For the other value or no OFCI 
 *             
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
 #ifdef ANSI
PUBLIC S16 ccCheckIncIsupCUG
(
CcConCb *con                    /* connection */
 )
#else
PUBLIC S16 ccCheckIncIsupCUG(con)
CcConCb *con;                    /* connection */
#endif
{
    S16      ret = RFAILED;
    SiConEvnt  *si = NULLP;
    U8 tmpOpFwdCalIndPres = 0;
    U8 tmpClsdUGrpCaIndVal = 0;
    U8 tmpClsdUGrpCaIndPres = 0;	
    
    	if (con == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "con is NULLP\n");
		return(ret);
	}

      si = &(con->icEvnt->m.ccConEvnt.m.siConEvnt);	
	if (si == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "si is NULLP\n");
		return(ret);		
	}
	
		switch (con->icProtType)
		{
         case CC_SIPOLAND:
         case CC_SIVENEZUELA:
         case CC_SIMEXICO:
         case CC_SIBRAZIL:
         case CC_SI76792:
         case CC_SITHAILAND:
         case CC_SISPAIN:
         case CC_SIUK:
#if 0 /* Bug:45335 */
         case CC_SIRUSSIA:
#endif
         case CC_BICCPOLAND:
         case CC_BICCVENEZUELA:
         case CC_BICCMEXICO:
         case CC_BICCBRAZIL:
         case CC_BICC76792:
         case CC_BICCTHAILAND:
         case CC_BICCUK:
         case CC_BICCSPAIN:
#if 0 /* Bug:45335 */
         case CC_BICCRUSSIA:
#endif
         case CC_SIPTPOLAND:
         case CC_SIPTVENEZUELA:
         case CC_SIPTMEXICO:
         case CC_SIPTBRAZIL:
         case CC_SIPT76792:
         case CC_SIPTTHAILAND:
         case CC_SIPTUK:
         case CC_SIPTSPAIN:
#if 0 /* Bug:45335 */
         case CC_SIPTRUSSIA:
#endif
            tmpOpFwdCalIndPres = si->opFwdCalIndQ.eh.pres;
            if (tmpOpFwdCalIndPres)
            {
               tmpClsdUGrpCaIndPres = si->opFwdCalIndQ.clsdUGrpCaInd.pres;
               if (tmpClsdUGrpCaIndPres)
                 tmpClsdUGrpCaIndVal = si->opFwdCalIndQ.clsdUGrpCaInd.val;
            }
            break;
         case CC_SIITU92:
         case CC_BICCITU92:
         case CC_SIPTITU92:
            if (si->opFwdCalIndQ.eh.pres)
            {
                tmpOpFwdCalIndPres = si->opFwdCalIndQ.eh.pres;
                if (tmpOpFwdCalIndPres)
                {
                    tmpClsdUGrpCaIndPres = si->opFwdCalIndQ.clsdUGrpCaInd.pres;
                    if (tmpClsdUGrpCaIndPres)
                    {
                        tmpClsdUGrpCaIndVal = si->opFwdCalIndQ.clsdUGrpCaInd.val;
                    }
                }
            }
            /* Since ITU92, RUSSIA and NTT have the same variant value at GCC, 
             * here get the OFCI by opFwdCalInd(Q).eh.pres value. From ISUP point
             * of view, either opFwdCalInd(ITU92) or opFwdCalIndQ(Russia,NTT) is
             * sent to GCC.
             */
            if (si->opFwdCalInd.eh.pres)
            {
                tmpOpFwdCalIndPres = si->opFwdCalInd.eh.pres;
                if (tmpOpFwdCalIndPres)
                {
                    tmpClsdUGrpCaIndPres = si->opFwdCalInd.clsdUGrpCaInd.pres;
                    if (tmpClsdUGrpCaIndPres)
                    {
                        tmpClsdUGrpCaIndVal = si->opFwdCalInd.clsdUGrpCaInd.val;
                    }
                }
            }
            break;
         default:
			tmpOpFwdCalIndPres = si->opFwdCalInd.eh.pres;
			if (tmpOpFwdCalIndPres)
            {
               tmpClsdUGrpCaIndPres = si->opFwdCalInd.clsdUGrpCaInd.pres;
               if (tmpClsdUGrpCaIndPres)
                 tmpClsdUGrpCaIndVal = si->opFwdCalInd.clsdUGrpCaInd.val;
            }
            break;
       }
       CCDP(AIN_DBG_LEVEL_2, "Closed User Group Call Indicator: OpFwdCalInd.pres=%d,ClsdUGrpCaInd.pres=%d, ClsdUGrpCaInd.val=%d \n",tmpOpFwdCalIndPres, tmpClsdUGrpCaIndPres, tmpClsdUGrpCaIndVal);
       
       		if ((tmpOpFwdCalIndPres != NOTPRSNT) &&
       		(tmpClsdUGrpCaIndPres != NOTPRSNT) &&
       			((((tmpClsdUGrpCaIndVal) & CUG_MASK) >> CUG_OFFSET) == CUG_ACCNOTALLOW))
       		{
	 		ret = ROK;
	 	}
    	return (ret);
}

/* End of 7359 */
#else
/* Bug 42104 */
/*
 *
 *      Fun:   ccCheckIsupToSipCUG
 *
 *      Desc:  IC Call - Check the ISUP to SIP call SIP profile and IAM OFCI cug parameter
 *      Ret:   ROK     - No SIP profile or OFCI cug NOT 0x03
 			   RFAILED - SIP profile CUGIWPROC  set to Q19125 and IAM OFCI cug set to 0x03
 *             
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
 */
 #ifdef ANSI
PUBLIC S16 ccCheckIsupToSipCUG
(
CcConCb *con                    /* connection */
 )
#else
PUBLIC S16 ccCheckIsupToSipCUG(con)
CcConCb *con;                    /* connection */
#endif
{
	S16      ret = ROK;
	SiConEvnt  *si = NULLP;
	CcSipPrflCb *sipPrflPtr = NULLP;
	char fn[] = __FUNCTION__ ;
	U8 tmpOpFwdCalIndPres = 0;
	U8 tmpClsdUGrpCaIndVal = 0;
	U8 tmpClsdUGrpCaIndPres = 0;	
	CcAllSdus         *ccEvntHold     = NULLP;
	
	if (con == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "con is NULLP\n");
		return(ret);
	}
	if (con->ccEvntHold == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccEvntHold is NULLP\n");
		return(ret);
	}
	
	ccEvntHold = con->ccEvntHold;

	si  = &(ccEvntHold->m.ccConEvnt.m.siConEvnt);
	
	if (si == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "si is NULLP\n");
		return(ret);		
	}
	
	if (con->icIntfcCb != NULLP)
	{
		sipPrflPtr = con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr;
		CCDP(AIN_DBG_LEVEL_2,"%s Get SIP profile from IC trunk group\n", fn); 
	}
	
	if (sipPrflPtr == NULLP && con->ogIntfcCb != NULLP)
	{
		sipPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr;
		CCDP(AIN_DBG_LEVEL_2,"%s Get SIP profile from OG trunk group\n", fn);
	}
	
	if (sipPrflPtr == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_2,"%s Can not get sip profile from Both side\n", fn);
		return (ret);
	}
	
	/* Check SIP profile CUGIWPROC setting */
	 if ( (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) ||
              ((sipPrflPtr != NULL) && ((sipPrflPtr->cugIwProc == LCC_SIP_IW_PROC_Q1912_5) ||
               (sipPrflPtr->cugIwProc == LCC_SIP_IW_PROC_Q735_1)))) /* FID 16522.0 */
	 {
		switch (con->icProtType)
		{
         case CC_SIPOLAND:
         case CC_SIVENEZUELA:
         case CC_SIMEXICO:
         case CC_SIBRAZIL:
#if 0 /* Bug:45335 */
         case CC_SIRUSSIA:
#endif
         case CC_SI76792:
         case CC_SITHAILAND:
         case CC_SIUK:
         case CC_SISPAIN:
         case CC_BICCPOLAND:
         case CC_BICCVENEZUELA:
         case CC_BICCMEXICO:
         case CC_BICCBRAZIL:
#if 0 /* Bug:45335 */
         case CC_BICCRUSSIA:
#endif
         case CC_BICC76792:
         case CC_BICCTHAILAND:
         case CC_BICCUK:
         case CC_BICCSPAIN:
         case CC_SIPTPOLAND:
         case CC_SIPTVENEZUELA:
         case CC_SIPTMEXICO:
         case CC_SIPTBRAZIL:
#if 0 /* Bug:45335 */
         case CC_SIPTRUSSIA:
#endif
         case CC_SIPT76792:
         case CC_SIPTTHAILAND:
         case CC_SIPTUK:
         case CC_SIPTSPAIN:
            tmpOpFwdCalIndPres = si->opFwdCalIndQ.eh.pres;
            if (tmpOpFwdCalIndPres)
            {
               tmpClsdUGrpCaIndPres = si->opFwdCalIndQ.clsdUGrpCaInd.pres;
               if (tmpClsdUGrpCaIndPres)
                 tmpClsdUGrpCaIndVal = si->opFwdCalIndQ.clsdUGrpCaInd.val;
            }
            break;
         case CC_SIITU92:
         case CC_BICCITU92:
         case CC_SIPTITU92:
            if (si->opFwdCalIndQ.eh.pres)
            {
                tmpOpFwdCalIndPres = si->opFwdCalIndQ.eh.pres;
                if (tmpOpFwdCalIndPres)
                {
                    tmpClsdUGrpCaIndPres = si->opFwdCalIndQ.clsdUGrpCaInd.pres;
                    if (tmpClsdUGrpCaIndPres)
                    {
                        tmpClsdUGrpCaIndVal = si->opFwdCalIndQ.clsdUGrpCaInd.val;
                    }
                }
            }
            /* Since ITU92, RUSSIA and NTT have the same variant value at GCC, 
             * here get the OFCI by opFwdCalInd(Q).eh.pres value. From ISUP point
             * of view, either opFwdCalInd(ITU92) or opFwdCalIndQ(Russia,NTT) is
             * sent to GCC.
             */
            if (si->opFwdCalInd.eh.pres)
            {
                tmpOpFwdCalIndPres = si->opFwdCalInd.eh.pres;
                if (tmpOpFwdCalIndPres)
                {
                    tmpClsdUGrpCaIndPres = si->opFwdCalInd.clsdUGrpCaInd.pres;
                    if (tmpClsdUGrpCaIndPres)
                    {
                        tmpClsdUGrpCaIndVal = si->opFwdCalInd.clsdUGrpCaInd.val;
                    }
                }
            }
            break;
         default:
			tmpOpFwdCalIndPres = si->opFwdCalInd.eh.pres;
			if (tmpOpFwdCalIndPres)
            {
               tmpClsdUGrpCaIndPres = si->opFwdCalInd.clsdUGrpCaInd.pres;
               if (tmpClsdUGrpCaIndPres)
                 tmpClsdUGrpCaIndVal = si->opFwdCalInd.clsdUGrpCaInd.val;
            }
            break;
       }
       CCDP(AIN_DBG_LEVEL_2, "Closed User Group Call Indicator: OpFwdCalInd.pres=%d,ClsdUGrpCaInd.pres=%d, ClsdUGrpCaInd.val=%d \n",tmpOpFwdCalIndPres, tmpClsdUGrpCaIndPres, tmpClsdUGrpCaIndVal);
       
       		if ((tmpOpFwdCalIndPres != NOTPRSNT) &&
       		(tmpClsdUGrpCaIndPres != NOTPRSNT) &&
       			((((tmpClsdUGrpCaIndVal) & CUG_MASK) >> CUG_OFFSET) == CUG_ACCNOTALLOW))
       		{
	 		ret = RFAILED;
	 	}
	}
	return (ret);
}
#endif /*End of CC_FID_2138_2167_2168_2169_2171 */	
   	
/* check if explicit essential UUSI service requests is present */
S16 ccCheckUUSIParam(CcConCb *con)
{
           
   S16      ret = ROK;
   SiConEvnt  *siConEvnt;

   /* check if we have sent the ACM yet */
   if (!(con->isACMSent))
   {
      ccRestoreEvntHold(con);  
      siConEvnt = &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt);
   
      if (siConEvnt->usr2UsrInd.type.pres != NOTPRSNT)
      {
	 /* check for presence of explicit non-essential service request */
         if ((siConEvnt->usr2UsrInd.serv1.val == 3) ||
           (siConEvnt->usr2UsrInd.serv2.val == 3) ||
           (siConEvnt->usr2UsrInd.serv3.val == 3))
         {
            ret = RFAILED;
         }
      }
   }

   return(ret);
}

/*
 *
 *      Fun:   ccProcessCompat() for Feature 1839 - compatibility
 *
 *      Desc:  This functions is used to collect fwdCallInd, cgPtyCat,
 *             cgPtyNum, opFwdCalInd, origCdNum, redirgNum, redirInfo
 *             and exchange type from con->icEvnt, and send the data
 *             into a new structure named "SiPudUPV". Then send CctCnStReq
 *             to ISUP with event type: CC_ET_COMPAT.
 *  
 *             ISUP will response with CC_ET_COMPAT_ACK
 *    
 *      Ret:   ROK - success, RFAILED - failed.
 *  
 *      Notes: addCallgLineID is not sent to ISUP due to no modification by GCC and FIC
 *  
 *      File:  cc_bdy2.c
 *  
 */ 
#ifdef ANSI
PRIVATE S16 ccProcessCompat
(      
CcConCb *con	/* connection */
)
#else
PRIVATE S16 ccProcessCompat(con)
CcConCb *con;	/* connection */
#endif
{
	S16		ret;
        SiOptElmnt      *pOptElmnt;     /* points to con SiOptElmnt    */
        SiConEvnt       *pUpdateConEvnt;/* Save the incoming event that could
                                           be updated after FIC/RT */
        SiPduUPV        *pOrigPduUpv;   /* Original data from ISUP     */
        SiPduUPV        *pToSiPduUpv;   /* Save SiPduUPV infor to ISUP */
    
        CcCnStEvnt      ccCnStEvnt;     /* Local CnStEvnt used to save *
                                         * exchange type and SiPduUPV  */
	FcFwdCallInd	*pFcFwdCallInd;	/* points to the FCI of ainInfo*/
#if 0 /*Bug: 66404-guanghx-03/11/2008*/
        Buffer          *uBuf;          /* Bug:62559 */
#endif
#if 1 /* BUG: 62591 */
    U8      i    = 0;
    Bool    flag = FALSE;               /* flag to indicate if any data in pToSiPduUpv */
#endif

	CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat() begins\n");

        cmMemset((Data *)&ccCnStEvnt, NOTPRSNT, sizeof(CcCnStEvnt));

        pOptElmnt = NULLP;
        pUpdateConEvnt = NULLP;
        pOrigPduUpv = NULLP;
        pToSiPduUpv = NULLP;
        pFcFwdCallInd = NULLP;

	/* get the incoming siPduUPV */
	pOrigPduUpv = &con->siPduUPV;
#if 0 /* BUG: 79022 */
        if(con->ccEvntHold == NULLP)
#else
        if(con->siPduUPV.pres == NOTPRSNT)
#endif
        {
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for con->siPduUPV==NULL\n");
                RETVALUE(RFAILED);
	}

        /* Get the ponter to incoming SiConEvnt */
        if(con->ccEvntHold == NULLP)
        {
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for con->ccEvntHold==NULL\n");
                RETVALUE(RFAILED);
	}
        pUpdateConEvnt = &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt);

        if(pUpdateConEvnt == NULLP)
        {
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for pUpdateConEvnt == NULLP\n");
                RETVALUE(RFAILED);
        }

        /* Set pToSiPduUPV */
        pToSiPduUpv = &(ccCnStEvnt.m.siCnStEvnt.optElmnt.isup.upv);
        if(pToSiPduUpv == NULLP)
        {
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for pToSiPduUpv == NULLP\n");
                RETVALUE(RFAILED);
        }

        /* These data will get from con->ccEvntHold */
        /* check and update cgPtyCat */
	if(cmMemcmp((U8*)(&pOrigPduUpv->cgPtyCat),
		(U8*)(&pUpdateConEvnt->cgPtyCat), sizeof(SiCgPtyCat)) != 0)
	{
		if(pUpdateConEvnt->cgPtyCat.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->cgPtyCat),
				(U8*)(&pUpdateConEvnt->cgPtyCat), sizeof(SiCgPtyCat));
		}
	}
#if 1 /* BUG: 52879-yex-12/22/2006 */
        /* check and update cgPtyNum */
        if ((pOrigPduUpv->cgPtyNum.eh.pres != NOTPRSNT) &&
            (pUpdateConEvnt->cgPtyNum.eh.pres != NOTPRSNT))
        {
           TknStrM origNmbDigits;
           TknStrM updateNmbDigits;

	   CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum\n");

           cmMemset ((U8 *)&origNmbDigits, 0, sizeof(TknStrM));
           cmMemset ((U8 *)&updateNmbDigits, 0, sizeof(TknStrM));

           if((ccConvertBcd2IsdnAddr(&(pOrigPduUpv->cgPtyNum.oddEven), (TknStrM *)&origNmbDigits,
                                 &(pOrigPduUpv->cgPtyNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }
           if((ccConvertBcd2IsdnAddr(&(pUpdateConEvnt->cgPtyNum.oddEven), (TknStrM *)&updateNmbDigits,
                                 &(pUpdateConEvnt->cgPtyNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }

           if( (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum.natAddrInd), (U8*)(&pUpdateConEvnt->cgPtyNum.natAddrInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum.scrnInd), (U8*)(&pUpdateConEvnt->cgPtyNum.scrnInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum.presRest), (U8*)(&pUpdateConEvnt->cgPtyNum.presRest), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum.numPlan), (U8*)(&pUpdateConEvnt->cgPtyNum.numPlan), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum.niInd), (U8*)(&pUpdateConEvnt->cgPtyNum.niInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&origNmbDigits), (U8*)(&updateNmbDigits), sizeof(TknStrM)) != 0)
             )
           {
              cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum), (U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum));
           }
        }
        /* Bug 53322 -- take into account the case
         * where the origPDU is not present but the
         * ConEvnt is present.  In that case, we need
         * to use the ConEvnt value.
         */
#if 0
        else if(pUpdateConEvnt->cgPtyNum.eh.pres == PRSNT_NODEF)
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum),
                (U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum));
        }
#else   /* bug 61130
         * origPduUpv is not present but the UpdateConEvnt has CGPN,
         * use the UpdateConEvnt value
         */
        else if ((pOrigPduUpv->cgPtyNum.eh.pres == NOTPRSNT) &&
                 (pUpdateConEvnt->cgPtyNum.eh.pres != NOTPRSNT))
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum),
                (U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum));
        }
        /* CGPN is dropped, need to notify ISUP */
        else if ((pOrigPduUpv->cgPtyNum.eh.pres != NOTPRSNT) &&
                 (pUpdateConEvnt->cgPtyNum.eh.pres == NOTPRSNT))
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum),
                (U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum));
           pToSiPduUpv->cgPtyNum.eh.pres = NOTPRSNT_DELETED;
        }
#endif

#if 1 /* BUG: 62591 */
    /* check and update genNum */
    for(i=0; i<MF_MAX_GNUM; i++)
    {
        if ((pOrigPduUpv->genNmb[i].eh.pres != NOTPRSNT) &&
                (pUpdateConEvnt->genNmb[i].eh.pres != NOTPRSNT))
        {
            TknStrM origNmbDigits;
            TknStrM updateNmbDigits;

            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update genNum[%d]\n", i);

            cmMemset ((U8 *)&origNmbDigits, 0, sizeof(TknStrM));
            cmMemset ((U8 *)&updateNmbDigits, 0, sizeof(TknStrM));

            if((ccConvertBcd2IsdnAddr(&(pOrigPduUpv->genNmb[i].oddEven), (TknStrM *)&origNmbDigits,
                            &(pOrigPduUpv->genNmb[i].addrSig), TRUE)) != ROK)
            {
                CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
                RETVALUE(RFAILED);
            }
            if((ccConvertBcd2IsdnAddr(&(pUpdateConEvnt->genNmb[i].oddEven), (TknStrM *)&updateNmbDigits,
                            &(pUpdateConEvnt->genNmb[i].addrSig), TRUE)) != ROK)
            {
                CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
                RETVALUE(RFAILED);
            }

            if( (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].nmbQual), 
                          (U8*)(&pUpdateConEvnt->genNmb[i].nmbQual),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].natAddrInd),
                          (U8*)(&pUpdateConEvnt->genNmb[i].natAddrInd),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].scrnInd),
                          (U8*)(&pUpdateConEvnt->genNmb[i].scrnInd),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].presRest),
                          (U8*)(&pUpdateConEvnt->genNmb[i].presRest),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].numPlan),
                          (U8*)(&pUpdateConEvnt->genNmb[i].numPlan),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&pOrigPduUpv->genNmb[i].niInd),
                          (U8*)(&pUpdateConEvnt->genNmb[i].niInd),
                          sizeof(TknU8)) != 0) ||
                (cmMemcmp((U8*)(&origNmbDigits),
                          (U8*)(&updateNmbDigits),
                          sizeof(TknStrM)) != 0)
              )
            {
                cmMemcpy((U8*)(&pToSiPduUpv->genNmb[i]), (U8*)(&pUpdateConEvnt->genNmb[i]), sizeof(SiGenNum));
            }
        }
        else if ((pOrigPduUpv->genNmb[i].eh.pres == NOTPRSNT) &&
                 (pUpdateConEvnt->genNmb[i].eh.pres != NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update GenNum[%d], no PDU case\n", i);
            cmMemcpy((U8*)(&pToSiPduUpv->genNmb[i]), (U8*)(&pUpdateConEvnt->genNmb[i]), sizeof(SiGenNum));
        }
        /* GenNum is dropped, need to notify ISUP */
        else if ((pOrigPduUpv->genNmb[i].eh.pres != NOTPRSNT) &&
                 (pUpdateConEvnt->genNmb[i].eh.pres == NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update GenNum[%d], no PDU case\n", i);
            cmMemcpy((U8*)(&pToSiPduUpv->genNmb[i]),
                     (U8*)(&pUpdateConEvnt->genNmb[i]),
                     sizeof(SiGenNum));
            pToSiPduUpv->genNmb[i].eh.pres = NOTPRSNT_DELETED;
        }
    }
#endif
        /* check and update origCdNum */
        if ((pOrigPduUpv->origCdNum.eh.pres != NOTPRSNT) &&
            (pUpdateConEvnt->origCdNum.eh.pres != NOTPRSNT))
        {
           TknStrM origNmbDigits;
           TknStrM updateNmbDigits;

	   CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update origCdNum\n");

           cmMemset ((U8 *)&origNmbDigits, 0, sizeof(TknStrM));
           cmMemset ((U8 *)&updateNmbDigits, 0, sizeof(TknStrM));

           if((ccConvertBcd2IsdnAddr(&(pOrigPduUpv->origCdNum.oddEven), (TknStrM *)&origNmbDigits,
                                 &(pOrigPduUpv->origCdNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }
           if((ccConvertBcd2IsdnAddr(&(pUpdateConEvnt->origCdNum.oddEven), (TknStrM *)&updateNmbDigits,
                                 &(pUpdateConEvnt->origCdNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }

           if( (cmMemcmp((U8*)(&pOrigPduUpv->origCdNum.natAddr), (U8*)(&pUpdateConEvnt->origCdNum.natAddr), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->origCdNum.scrInd), (U8*)(&pUpdateConEvnt->origCdNum.scrInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->origCdNum.presRest), (U8*)(&pUpdateConEvnt->origCdNum.presRest), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->origCdNum.numPlan), (U8*)(&pUpdateConEvnt->origCdNum.numPlan), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&origNmbDigits), (U8*)(&updateNmbDigits), sizeof(TknStrM)) != 0)
             )
           {
              cmMemcpy((U8*)(&pToSiPduUpv->origCdNum), (U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum));
           }
        }
        /* Bug 53322 */
#if 0 
        else if(pUpdateConEvnt->origCdNum.eh.pres == PRSNT_NODEF)
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update origCdNum, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->origCdNum),
                (U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum));
        }
#else   /* Bug 80059 
         * origPduUpv is not present but the UpdateConEvnt has OCN
         * use the UpdateConEvnt value
         */
        else if ((pOrigPduUpv->origCdNum.eh.pres == NOTPRSNT) &&
                 (pUpdateConEvnt->origCdNum.eh.pres != NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update origCdNum, no PDU case\n");
            cmMemcpy((U8*)(&pToSiPduUpv->origCdNum),
                    (U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum));
        }
        /* OCN is dropped, need to notify ISUP */
        else if ((pOrigPduUpv->origCdNum.eh.pres != NOTPRSNT) &&
                 (pUpdateConEvnt->origCdNum.eh.pres == NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): Drop origCdNum, notify ISUP\n");
            cmMemcpy((U8*)(&pToSiPduUpv->origCdNum),
                     (U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum));
            pToSiPduUpv->origCdNum.eh.pres = NOTPRSNT_DELETED;
        }
#endif

        /* check and update redirgNum*/
        if ((pOrigPduUpv->redirgNum.eh.pres != NOTPRSNT) &&
            (pUpdateConEvnt->redirgNum.eh.pres != NOTPRSNT))
        {
           TknStrM origNmbDigits;
           TknStrM updateNmbDigits;

	   CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update redirgNum\n");

           cmMemset ((U8 *)&origNmbDigits, 0, sizeof(TknStrM));
           cmMemset ((U8 *)&updateNmbDigits, 0, sizeof(TknStrM));

           if((ccConvertBcd2IsdnAddr(&(pOrigPduUpv->redirgNum.oddEven), (TknStrM *)&origNmbDigits,
                                 &(pOrigPduUpv->redirgNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }
           if((ccConvertBcd2IsdnAddr(&(pUpdateConEvnt->redirgNum.oddEven), (TknStrM *)&updateNmbDigits,
                                 &(pUpdateConEvnt->redirgNum.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }

           if( (cmMemcmp((U8*)(&pOrigPduUpv->redirgNum.natAddr), (U8*)(&pUpdateConEvnt->redirgNum.natAddr), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->redirgNum.scrInd), (U8*)(&pUpdateConEvnt->redirgNum.scrInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->redirgNum.presRest), (U8*)(&pUpdateConEvnt->redirgNum.presRest), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->redirgNum.numPlan), (U8*)(&pUpdateConEvnt->redirgNum.numPlan), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&origNmbDigits), (U8*)(&updateNmbDigits), sizeof(TknStrM)) != 0)
             )
           {
              cmMemcpy((U8*)(&pToSiPduUpv->redirgNum), (U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum));
           }
        }
#if 0
        /* Bug 53322 */
        else if(pUpdateConEvnt->redirgNum.eh.pres == PRSNT_NODEF)
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update redirgNum, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->redirgNum),
                (U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum));
        }
#else
        /* Bug 80059 
         * origPduUpv is not present but the UpdateConEvnt has RDN 
         * use the UpdateConEvnt value
         */
        else if ((pOrigPduUpv->redirgNum.eh.pres == NOTPRSNT) &&
                 (pUpdateConEvnt->redirgNum.eh.pres != NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update redirgNum, no PDU case\n");
            cmMemcpy((U8*)(&pToSiPduUpv->redirgNum),
                    (U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum));
        }
        /* RDN is dropped, need to notify ISUP */
        else if ((pOrigPduUpv->redirgNum.eh.pres != NOTPRSNT) &&
                 (pUpdateConEvnt->redirgNum.eh.pres == NOTPRSNT))
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): Drop redirgNum, notify ISUP \n");
            cmMemcpy((U8*)(&pToSiPduUpv->redirgNum),
                    (U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum));
            pToSiPduUpv->redirgNum.eh.pres = NOTPRSNT_DELETED;
        }
#endif

        /* Feature 1959 check and update Location Number */
        if ((pOrigPduUpv->cgPtyNum1.eh.pres != NOTPRSNT) &&
            (pUpdateConEvnt->cgPtyNum1.eh.pres != NOTPRSNT))
        {
           TknStrM origNmbDigits;
           TknStrM updateNmbDigits;

           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum1\n");

           cmMemset ((U8 *)&origNmbDigits, 0, sizeof(TknStrM));
           cmMemset ((U8 *)&updateNmbDigits, 0, sizeof(TknStrM));

           if((ccConvertBcd2IsdnAddr(&(pOrigPduUpv->cgPtyNum1.oddEven), (TknStrM *)&origNmbDigits,
                                 &(pOrigPduUpv->cgPtyNum1.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }
           if((ccConvertBcd2IsdnAddr(&(pUpdateConEvnt->cgPtyNum1.oddEven), (TknStrM *)&updateNmbDigits,
                                 &(pUpdateConEvnt->cgPtyNum1.addrSig), TRUE)) != ROK)
           {
              CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccConvertBcd2IsdnAddr()\n");
              RETVALUE(RFAILED);
           }

           if( (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1.natAddrInd), (U8*)(&pUpdateConEvnt->cgPtyNum1.natAddrInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1.scrnInd), (U8*)(&pUpdateConEvnt->cgPtyNum1.scrnInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1.presRest), (U8*)(&pUpdateConEvnt->cgPtyNum1.presRest), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1.numPlan), (U8*)(&pUpdateConEvnt->cgPtyNum1.numPlan), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1.niInd), (U8*)(&pUpdateConEvnt->cgPtyNum1.niInd), sizeof(TknU8)) != 0) ||
               (cmMemcmp((U8*)(&origNmbDigits), (U8*)(&updateNmbDigits), sizeof(TknStrM)) != 0)
             )
           {
              cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum1), (U8*)(&pUpdateConEvnt->cgPtyNum1), sizeof(SiCgPtyNum));
           }
        }
        /* Bug 53322 */
        else if(pUpdateConEvnt->cgPtyNum1.eh.pres == PRSNT_NODEF)
        {
           CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): update cgPtyNum1, no PDU case\n");
           cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum1),
                (U8*)(&pUpdateConEvnt->cgPtyNum1), sizeof(SiCgPtyNum));
        }

#else /* 52879 */
        /* check and update cgPtyNum */
	if(cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum),
		(U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum)) != 0)
	{
		if(pUpdateConEvnt->cgPtyNum.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum),
				(U8*)(&pUpdateConEvnt->cgPtyNum), sizeof(SiCgPtyNum));
		}
	}
        /* check and update origCdNum */
	if(cmMemcmp((U8*)(&pOrigPduUpv->origCdNum),
		(U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum)) != 0)
	{
		if(pUpdateConEvnt->origCdNum.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->origCdNum),
				(U8*)(&pUpdateConEvnt->origCdNum), sizeof(SiOrigCdNum));
		}
	}
        /* check and update redirgNum */
	if(cmMemcmp((U8*)(&pOrigPduUpv->redirgNum),
		(U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum)) != 0)
	{
		if(pUpdateConEvnt->redirgNum.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->redirgNum),
				(U8*)(&pUpdateConEvnt->redirgNum), sizeof(SiRedirNum));
		}
	}
#endif /* 52879 */
        /* check and update redirInfo */
	if(cmMemcmp((U8*)(&pOrigPduUpv->redirInfo),
		(U8*)(&pUpdateConEvnt->redirInfo), sizeof(SiRedirInfo)) != 0)
	{
		if(pUpdateConEvnt->redirInfo.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->redirInfo),
				(U8*)(&pUpdateConEvnt->redirInfo), sizeof(SiRedirInfo));
		}
	}
        /* check and update opFwdCalInd */
	if(cmMemcmp((U8*)(&pOrigPduUpv->opFwdCalInd),
		(U8*)(&pUpdateConEvnt->opFwdCalInd), sizeof(SiOpFwdCalInd)) != 0)
	{
		if(pUpdateConEvnt->opFwdCalInd.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->opFwdCalInd),
				(U8*)(&pUpdateConEvnt->opFwdCalInd), sizeof(SiOpFwdCalInd));
		}
	}
#if 0 /* BUG: 52879 */
        /* Feature 1959 check and update Location Number */
	if(cmMemcmp((U8*)(&pOrigPduUpv->cgPtyNum1),
		(U8*)(&pUpdateConEvnt->cgPtyNum1), sizeof(SiCgPtyNum)) != 0)
	{
		if(pUpdateConEvnt->cgPtyNum1.eh.pres == PRSNT_NODEF)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->cgPtyNum1),
				(U8*)(&pUpdateConEvnt->cgPtyNum1), sizeof(SiCgPtyNum));
		}
	}
/*End of feature 1959*/
#endif /* BUG: 52879 */
        /*Bug:42358 11--03--2005*/
        /* check and update usr2UsrInd */
        if(cmMemcmp((U8*)(&pOrigPduUpv->usr2UsrInd),
                (U8*)(&pUpdateConEvnt->usr2UsrInd), sizeof(SiUsr2UsrInd)) != 0)
        {
                if(pUpdateConEvnt->usr2UsrInd.eh.pres == PRSNT_NODEF)
                {
                        cmMemcpy((U8*)(&pToSiPduUpv->usr2UsrInd),
                                (U8*)(&pUpdateConEvnt->usr2UsrInd), sizeof(SiUsr2UsrInd));
                }
        }
        /*Bug:42358 11--03--2005*/
        /* The SiFwdCalInd need to get from con->ainInfo.fwdCallInd */
	/* since the ccExtractFwdCallInd() will update it at E37S37 */
	/* but not update con->ccEvntHold meanwhile */
	pFcFwdCallInd = &con->ainInfo.fwdCallInd;
	if(pFcFwdCallInd != NULLP && pFcFwdCallInd->eh.pres == PRSNT_NODEF)
	{
		if(cmMemcmp((U8*)(&pFcFwdCallInd->natIntCallInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.natIntCallInd), sizeof(TknU8)) != 0)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.natIntCallInd),
				(U8*)(&pFcFwdCallInd->natIntCallInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
		}
		if(cmMemcmp((U8*)(&pFcFwdCallInd->end2EndMethInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.end2EndMethInd), sizeof(TknU8)) != 0)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.end2EndMethInd),
				(U8*)(&pFcFwdCallInd->end2EndMethInd), sizeof(U8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
		}
		if(cmMemcmp((U8*)(&pFcFwdCallInd->intInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.intInd), sizeof(TknU8)) != 0)
		{
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.intInd),
				(U8*)(&pFcFwdCallInd->intInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
		}
		if(cmMemcmp((U8*)(&pFcFwdCallInd->isdnUsrPrtInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.isdnUsrPrtInd), sizeof(TknU8)) != 0)
                {
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.isdnUsrPrtInd),
				(U8*)(&pFcFwdCallInd->isdnUsrPrtInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
                }
		if(cmMemcmp((U8*)(&pFcFwdCallInd->isdnUsrPrtPrfInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.isdnUsrPrtPrfInd), sizeof(TknU8)) != 0)
                {
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.isdnUsrPrtPrfInd),
				(U8*)(&pFcFwdCallInd->isdnUsrPrtPrfInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
                }
		if(cmMemcmp((U8*)(&pFcFwdCallInd->isdnAccInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.isdnAccInd), sizeof(TknU8)) != 0)
                {
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.isdnAccInd),
				(U8*)(&pFcFwdCallInd->isdnAccInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
                }
		if(cmMemcmp((U8*)(&pFcFwdCallInd->sccpMethInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.sccpMethInd), sizeof(TknU8)) != 0)
                {
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.sccpMethInd),
				(U8*)(&pFcFwdCallInd->sccpMethInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
                }
#ifdef SI_ANSILNP
		if(cmMemcmp((U8*)(&pFcFwdCallInd->transCallNInd),
			(U8*)(&pOrigPduUpv->fwdCallInd.transCallNInd), sizeof(TknU8)) != 0)
                {
			cmMemcpy((U8*)(&pToSiPduUpv->fwdCallInd.transCallNInd),
				(U8*)(&pFcFwdCallInd->transCallNInd), sizeof(TknU8));
			pToSiPduUpv->fwdCallInd.eh.pres = PRSNT_NODEF;
                }
#endif
	}

#if 1 /* BUG: 62591 */
    for(i=0; i<MF_MAX_GNUM; i++)
    {
        if(pToSiPduUpv->genNmb[i].eh.pres)
        {
            flag = TRUE;
            break;
        }
    }
#endif
	if(pToSiPduUpv->fwdCallInd.eh.pres ||
		pToSiPduUpv->cgPtyCat.eh.pres ||
		pToSiPduUpv->cgPtyNum.eh.pres ||
		pToSiPduUpv->opFwdCalInd.eh.pres ||
		pToSiPduUpv->origCdNum.eh.pres ||
		pToSiPduUpv->redirgNum.eh.pres ||
		/*Feature 1959*/
		pToSiPduUpv->cgPtyNum1.eh.pres ||
		pToSiPduUpv->usr2UsrInd.eh.pres ||
		/*End of feature 1959*/
		pToSiPduUpv->redirInfo.eh.pres ||
        flag)
	{
		pToSiPduUpv->pres = PRSNT_NODEF;
	}

        /* Set the exchange type */
        pOptElmnt = &(ccCnStEvnt.m.siCnStEvnt.optElmnt);
        /*
         * Bug 58463: Set the con->direction to be OUTTOINC because the COMPAT
         * Event would be sent to the incoming side after
         * ccCheck&FillTypeofXchang.
         * No need to set it to be INCTOOUT when ISUP layer sends back the compatibility
         * result to GCC layer since it would be set by GCC.
         */
        con->direction = OUTTOINC;
        ret = ccCheckAndFillTypeOfXchange(con, pOptElmnt, TOINCOMING);
        if(ret != ROK)
        {
            CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): exit for failed of ccCheckAndFillTypeOfXchange()\n");
            RETVALUE(RFAILED);
        }

        CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat(): send CctCnStReq to ISUP. exch_type=[%d]\n",
                pOptElmnt->isup.typeOfXchg.val);

	/* start waiting for compatibility ACK timer */
	ccStartConTmr(CC_TMR_AWAIT_COMPAT_ACK, con, (PTR)&ccCp.genCfg);

        /* Set compat process state to COMPAT_SENDTO_ISUP */
        con->compatSt = COMPAT_SENDTO_ISUP;

#if 1 /*Bug: 66404-guanghx-03/11/2008*/
        ccDropUBuf(&con->uBuf);
        
        ret = CcLiCctCnStReq(&con->icSapCb->pst, con->icSapCb->spId,
                con->icSpConnId, con->icSuConnId,
                con->icProtType, CC_ET_COMPAT,
                &ccCnStEvnt, NULLP);
#else
        /* Bug:62559 */
        uBuf = con->uBuf;
        con->uBuf = NULLP;

        /* Send ISUP CctCnStReq */
        CcLiCctCnStReq(&con->icSapCb->pst, con->icSapCb->spId,
                        con->icSpConnId, con->icSuConnId,
                        con->icProtType, CC_ET_COMPAT,
                        &ccCnStEvnt, uBuf); /* Bug:62559 */
#endif

	CCDP(AIN_DBG_LEVEL_0, "ccProcessCompat() ends ret=%d\n", ret);

        RETVALUE(ret);
}

/*
 *
 *      Fun:   ccProcessCompatACK() for Feature 1839 - compatibility
 *
 *      Desc:  This functions is used to process CC_ET_COMPAT_ACK
 *             from ISUP that responding to CC_ET_COMPAT.
 *
 *             1: update con->ccEvntHold according to the incoming
 *                SiPduUPV in CcCnStEvnt.
 *             2: update con->ccEvntHold PCI according to SiParmCompInfo
 *                in CcCnStEvnt.
 *  
 *             ISUP will response with CC_ET_COMPAT_ACK
 *    
 *      Ret:   ROK - success, RFAILED - failed.
 *  
 *      Notes: 
 *  
 *      File:  cc_bdy2.c
 *  
 */
#ifdef ANSI
PRIVATE S16 ccProcessCompatACK
(
CcConCb *con,			/* connection */
CcCnStEvnt *ccCnStEvnt		/* connect status event */
)
#else
PRIVATE S16 ccProcessCompatACK(con, ccCnStEvnt)
CcConCb *con;			/* connection */
CcCnStEvnt *ccCnStEvnt		/* connect status event */
#endif
{
	IsupOpt		*pIsupOpt;
	SiPduUPV	*pUPV;
	SiParmCompInfo	*pPCI;
	SiConEvnt	*pToConEvnt;

	pIsupOpt = NULLP;
	pUPV = NULLP;
	pPCI = NULLP;
	pToConEvnt = NULLP;

	CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() begins\n");

    /*CID 15590*/
	if(con == NULLP || ccCnStEvnt == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() exit for con == NULLP or ccCnStEvnt == NULLP\n");
		RETVALUE(RFAILED);
	}

	/* stop compatibility timer */
	ccStopConTmr(con, CC_TMR_AWAIT_COMPAT_ACK);

        /* Set compat process state to COMPAT_ACK_RECVED */
        con->compatSt = COMPAT_ACK_RECVED;


	/* get the pointer to IsupOpt */
	pIsupOpt = &(ccCnStEvnt->m.siCnStEvnt.optElmnt.isup);
	if(pIsupOpt == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() exit for pIsupOpt == NULLP\n");
		RETVALUE(RFAILED);
	}

	/* process UPV */
	pUPV = &pIsupOpt->upv;
	if(pUPV == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() exit for isup.upv == NULLP\n");
		RETVALUE(RFAILED);
	}

	pToConEvnt = &(con->ccEvntHold->m.ccConEvnt.m.siConEvnt);
	if(pToConEvnt == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() exit for pToConEvnt == NULLP\n");
		RETVALUE(RFAILED);
	}

	/* Update the data in con->ccEvntHold */
	cmMemcpy((U8*)(&pToConEvnt->cgPtyCat),
		(U8*)(&pUPV->cgPtyCat), sizeof(SiCgPtyCat));
	cmMemcpy((U8*)(&pToConEvnt->cgPtyNum),
		(U8*)(&pUPV->cgPtyNum), sizeof(SiCgPtyNum));
	cmMemcpy((U8*)(&pToConEvnt->opFwdCalInd),
		(U8*)(&pUPV->opFwdCalInd), sizeof(SiOpFwdCalInd));
	cmMemcpy((U8*)(&pToConEvnt->origCdNum),
		(U8*)(&pUPV->origCdNum), sizeof(SiOrigCdNum));
	cmMemcpy((U8*)(&pToConEvnt->redirgNum),
		(U8*)(&pUPV->redirgNum), sizeof(SiRedirNum));
	cmMemcpy((U8*)(&pToConEvnt->redirInfo),
		(U8*)(&pUPV->redirInfo), sizeof(SiRedirInfo));
	cmMemcpy((U8*)(&pToConEvnt->fwdCallInd),
		(U8*)(&pUPV->fwdCallInd), sizeof(SiFwdCallInd));
        /*Bug:42358 11--03--2005*/
        cmMemcpy((U8*)(&pToConEvnt->usr2UsrInd),
                (U8*)(&pUPV->usr2UsrInd), sizeof(SiUsr2UsrInd));
        /*Bug:42358 11--03--2005*/
/* Feature 1959 Handle Location Number */
        cmMemcpy((U8*)(&pToConEvnt->cgPtyNum1),
                (U8*)(&pUPV->cgPtyNum1), sizeof(SiCgPtyNum));
/*End of feature 1959 */
#if 1 /* BUG: 62591 */
    cmMemcpy((U8*)(&pToConEvnt->genNmb[0]),
             (U8*)(&pUPV->genNmb[0]),
             sizeof(SiGenNum) * MF_MAX_GNUM);

#endif
#if 1 /* FID 14990.0 ETSI V3 */
    cmMemcpy((U8*)(&pToConEvnt->netMgmtControls),
             (U8*)(&pUPV->netMgmtControls),
             sizeof(SiNetMgmtControls));
#endif
	/* Also update con->ainInfo.redirInfo */
	/* BUG: 43369-pengding-12/13*/
        con->ainInfo.redirInfo.pres = pUPV->redirInfo.eh.pres;
        con->ainInfo.redirInfo.redirInd = pUPV->redirInfo.redirInd.val;
        con->ainInfo.redirInfo.origRedirReas = pUPV->redirInfo.origRedirReas.val;
        con->ainInfo.redirInfo.redirCnt = pUPV->redirInfo.redirCnt.val;
        con->ainInfo.redirInfo.redirReas = pUPV->redirInfo.redirReas.val;
        /* BUG: 43369-pengding-12/13*/
	/* process UP */
	pPCI = &ccCnStEvnt->m.siCnStEvnt.parmCom;
	if(pPCI == NULLP)
	{
		CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() exit for &ccCnStEvnt->m.siCnStEvnt.parmCom == NULLP\n");
		RETVALUE(RFAILED);
	}

	/* Update PCI in con->ccEvntHold */
	cmMemcpy((U8*)(&pToConEvnt->parmCom),
		(U8*)pPCI, sizeof(SiParmCompInfo));

    /* Update ACLI in con->ccEvntHold */
	cmMemcpy((U8*)(&pToConEvnt->addCallgLineID),
        (U8*)(&pUPV->addCallgLineID), sizeof(SiAddCallgLineID));

	CCDP(AIN_DBG_LEVEL_0, "ccProcessCompatACK() ends\n");

	RETVALUE(ROK);
}
/*
 *
 *      Fun:   ccProcessFaxModemTextDetectForCAS
 *
 *      Desc:  This function process Fax detect for CAS.
 *
 *    
 *      Ret:   Void
 *  
 *      Notes: 
 *  
 *      File:  cc_bdy2.c
 *  
 */
PUBLIC S16 ccProcessFaxModemTextDetectForCAS
(
PTR     event,
S16     ret
)
{
    AinBCM_t          *pBcm       = NULLP;
    AinBCM_t          *pCompBcm   = NULLP;
    AinBCM_t          *tmpBcm     = NULLP;
    Sdp               **rmtSdp    = NULLP;
    FaxData_t         faxData     = {0};
    CcConCb           *con        = (CcConCb *)event;
    Bool              vbdFlag       = FALSE;

    if(ccIsIPResource(&(con->icBcm)) || ccIsIPResource(&(con->ogBcm)))
    {
      if(con->icEvntType == CS_CONN_STATUS_MODEM_DETECT)
      {
        /* Bug# 79371 - Handling TDM-IP case */    
        if ((ccIsIPResource(&(con->icBcm)) && 
             CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_IC_VBD_NEGOTIATED))
            ||
            (ccIsIPResource(&(con->ogBcm)) && 
             CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_OG_VBD_NEGOTIATED)))
        {
          /* Drop the MODEM event if VBD was negotiated */
          CCDP(AIN_DBG_LEVEL_1, "Dropping MGCT_NOTIFY_KIND_MODEM_DETECT "
               "as VBD was negotiated.\n");
          RETVALUE(ROK);
        }

        CCDP(AIN_DBG_LEVEL_1, "CS_CONN_STATUS_MODEM_DETECT.\n");
        con->faxCb.faxLocalSdp |= (0x01 << AUDIO_ONLY_SHIFT_LEVEL);
        con->faxCb.faxTrigger = LOCAL_MODEM_FLAG_DETECTED;

        /* FID 15913.0 */
        if (ccNeedToSetPseudoVBD(con))
        {
          CC_SET_PSEUDO_VBD(con->flag, CC_FLAG_NEED_PSEUDO_VBD);
        }
      }
      /* FID 14844 - VBD */
      else if (con->icEvntType == CS_CONN_STATUS_TEXT_DETECT)
      {
        if (con->faxCb.faxTrigger == LOCAL_TEXT_FLAG_DETECTED)
        {
          CCDP(AIN_DBG_LEVEL_1, "Dropping CS_CONN_STATUS_TEXT_DETECT "
               "as it is being received more than once");
          RETVALUE(ROK);
        }
     
        con->faxCb.faxTrigger = LOCAL_TEXT_FLAG_DETECTED;
        /* Bug# 79371 - Handling TDM-IP case */    
        if ((ccIsIPResource(&(con->icBcm)) && 
             CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_IC_VBD_NEGOTIATED))
            ||
            (ccIsIPResource(&(con->ogBcm)) &&
             CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_OG_VBD_NEGOTIATED)))
        {
          /* Drop the TEXT event if VBD was negotiated */
          CCDP(AIN_DBG_LEVEL_1, "Dropping CS_CONN_STATUS_TEXT_DETECT "
               "as VBD was negotiated.\n");
          RETVALUE(ROK); 
        }
        CCDP(AIN_DBG_LEVEL_1, "CS_CONN_STATUS_TEXT_DETECT.\n");
        con->faxCb.faxLocalSdp = 0;
        con->faxCb.faxLocalSdp |= (0x01 << AUDIO_ONLY_SHIFT_LEVEL);

        /* FID 15913.0 */
        if (ccNeedToSetPseudoVBD(con))
        {
          CC_SET_PSEUDO_VBD(con->flag, CC_FLAG_NEED_PSEUDO_VBD);
        }
      }
      else
      {
        /* BUG86040 */
        if ((con->faxCb.faxTrigger == LOCAL_MODEM_FLAG_DETECTED) &&
            (con->icEvntType == CS_CONN_STATUS_FAX_DETECT))
        {

          if ((ccIsIPResource(&(con->icBcm)) &&
               ccIs7510MgVariant(&con->ogBcm)) ||
              (ccIsIPResource(&(con->ogBcm)) &&
               ccIs7510MgVariant(&con->icBcm)))
          {
            /* Drop the MODEM event as it is being received more than once */
            CCDP(AIN_DBG_LEVEL_1, "Dropping CS_CONN_STATUS_FAX_DETECT"
                 "as PsuedoVBD turned ON 7510 for Modem event.\n");
            RETVALUE(ROK);
          }
        }
        CCDP(AIN_DBG_LEVEL_1, "CS_CONN_STATUS_FAX_DETECT.\n");
      }

      if(ccIsIPResource(&(con->icBcm)))
      {
        /* FID 15261.0 + */
        if (CC_IS_CALL_MULTI_MG(con))
        {
          pBcm = con->ogAdjBcm;
          pCompBcm = &con->ogBcm;
          tmpBcm = &con->icBcm;
        }
        else
        {
          tmpBcm = pBcm = &con->icBcm;
          pCompBcm = &con->ogBcm;
        }
        /* FID 15261.0 - */
        /* Bug# 79371 - Handling TDM-IP case */    
        vbdFlag = (CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_IC_VBD_NEGOTIATED)?TRUE:FALSE);
      }
      else
      {
        /* FID 15261.0 + */
        if (CC_IS_CALL_MULTI_MG(con))
        {
          pBcm = con->icAdjBcm;
          pCompBcm = &con->icBcm;
          tmpBcm = &con->ogBcm;
        }
        else
        {
          tmpBcm = pBcm = &con->ogBcm;
          pCompBcm = &con->icBcm;
        }
        /* FID 15261.0 - */
        /* Bug# 79371 - Handling TDM-IP case */    
        vbdFlag = (CC_IS_VBD_NEGOTIATED(con->flag, CC_FLAG_OG_VBD_NEGOTIATED)?TRUE:FALSE);
      }

      if(ccGetFaxParams(tmpBcm, &faxData, TGP_FAX_MODEM_DET_NONE) == ROK)
      {
        /* FID 14844- Ignore FAX event if VBD was negotiated on ingress side 
           and faxAction is PASSTHRU */
        if ((con->icEvntType == CS_CONN_STATUS_FAX_DETECT) &&
            (faxData.faxAction == SDP_FAXACTION_PASSTHRU) && vbdFlag)
        {
          /* Drop the V21 event if VBD was negotiated */
           CCDP(AIN_DBG_LEVEL_1, "Dropping MGCT_NOTIFY_KIND_TEXT_DETECT "
                "as VBD was negotiated.\n");
           RETVALUE(ROK);
        }

        /* FID 14844 - Changes to pass the new argument to indicate if 
           VBD needs to send in the loca SDP */
        ccTestFaxParamsForModifyOnNotify(&faxData, con, vbdFlag);
      }

      CCDP(AIN_DBG_LEVEL_1, "Passing Empty remote to MGI.\n");
      if (pBcm->bcmType == BtOBcm)
      {
        rmtSdp = &pBcm->con->icIpParam.rmtDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->icIpParam.locBearerIpPort);
      }
      else if (pBcm->bcmType == BtTBcm)
      {
        rmtSdp = &pBcm->con->ogIpParam.rmtDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->ogIpParam.locBearerIpPort);
      }
      else if (pBcm->bcmType == BtOAdjBcm)
      {
        if (con->ccmCb.ccn == CCN_5)
          rmtSdp = &pBcm->con->icLiAdjIpParam->locDesc;
        else
          rmtSdp = &pBcm->con->ogAdjIpParam->locDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->icAdjIpParam->locBearerIpPort);
      }
      else if(pBcm->bcmType == BtTAdjBcm)
      {
        if (con->ccmCb.ccn == CCN_5)
          rmtSdp = &pBcm->con->ogLiAdjIpParam->locDesc;
        else
          rmtSdp = &pBcm->con->icAdjIpParam->locDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->ogAdjIpParam->locBearerIpPort);
      }
      else if (pBcm->bcmType == BtOLiAdjBcm)
      {
        rmtSdp = &pBcm->con->icAdjIpParam->locDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->icLiAdjIpParam->locBearerIpPort);
      }
      else /* BtTLiAdjBcm */
      {
        rmtSdp = &pBcm->con->ogAdjIpParam->locDesc;

        CC_SET_ZERO_BEARER_IP_PORT(&pBcm->con->ogLiAdjIpParam->locBearerIpPort);
      }

      if(*rmtSdp)
        cmFreeSdp(ccInit.region, ccInit.pool, rmtSdp);

      cmCreateSdp(ccInit.region, ccInit.pool, 0, 0, FALSE, 0, FALSE, 0, 0, 0, pBcm->con,
                  rmtSdp, 
                  AF_INET); /* FID 14341.0 */
      /* FID 14341.0 the above used IPV4, makes no difference, since it will be set to NOTPRSNT */
      SDP_SET_NOTPRSNT(*rmtSdp);
      (*rmtSdp)->eh.pres = PRSNT_NODEF;

      /* Initiate a switch to T.38 */
      ccCreateOnSwitchBearerWithModify(pBcm, pCompBcm, ccHandleXferRspFailure, 
                                       (PTR)con, CCS_ANSWERED, FALSE);
    }
    RETVALUE(ROKDNA);
}
/*
 *
 *      Fun:   ccSendConReqForOgIpCalls
 *
 *      Desc:  This function sends ConReq and does related processing
 *             This is called from E11S28.
 *
 *    
 *      Ret:   Void
 *  
 *      Notes: 
 *  
 *      File:  cc_bdy2.c
 *  
 */
PUBLIC Void ccSendConReqForOgIpCalls
(
CcConCb  *con
)
{
  ProtType        icProtType   = CC_GET_PROTOCOL(con->icProtType);
  ProtType        ogProtType   = CC_GET_PROTOCOL(con->ogProtType);
  CcSipPrflCb    *sipPrflPtr   = NULL;
  Buffer         *uBuf         = NULLP;
  S16             ret          = RFAILED;
  CcConEvnt       ogEvnt;
  Sdp            *ogSip = NULLP;

  /* bug 91532 */
  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));
  
  con->icEvnt = con->ccEvntHold;
  con->ogEvnt = (CcAllSdus *) &ogEvnt;
  con->direction = INCTOOUT;

  /* begin FID 14245 */
  if(con->ainInfo.cfOccur)
  {  
     CCDP(AIN_DBG_LEVEL_1,"Call forwarding happened\n");
     ccNotifyCallForward(con);
  }
  /* end FID 14245 */

  if( (con->icProtType == CC_CS_LN) ||
      (con->icProtType == CC_CS_TG) ||
      (con->icProtType == CC_MGCP_LN) ||
      (con->icProtType == CC_GR303) )
  {
     ret = ccMapEvent(con, CCE_ADDRCFM, 0);
  }
  else
  {
     ret = ccMapEvent(con, CCE_CONIND, 0);
  }
  if (ret != ROK)
  {
     CCLOGERR( "Mapping failed\n");
     ccStopConTmr(con, TMR_SETUP);
     ccStopConTmr(con, AIN_T_NO_ANS_TMR);
#if 1    /* EARLY_ACM */ 
     ccStopConTmr(con, CC_TMR_EARLYACM);
#endif
     /* STOP the AWAIT ANSWER Timer if running
      *
      * changes made to Support Configurable Answer Timer in GCC, RV Suresh, 5.0 
      */
     ccStopConTmr(con, CC_TMR_AWAITANS); 
     ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);


     /* Out going resource is valid incase of trunks */
     ccDeallocateResource(con, CC_OUTGOING);
     con->ogRscVal = FALSE;

     ccDropUBuf(&con->uBuf);

     con->direction = INCTOOUT;

     ccQSubBasedOnCcn(con);  /* FID 15261.0 */

     con->relPend = ICRELONLY;
     CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
     con->mgBlock->con = con;
   /*Bug 50893: con->icEvnt will have ccConEvnt and not ccRelEvnt, so remove the following code*/
#if 0 /* Bug 42104 - bcouto - 11/10/2005 */
     /* Stores the current causeValue */
     if ((con->icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.eh.pres == PRSNT_NODEF) &&
         (con->icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.causeVal.pres == PRSNT_NODEF) )
     {
        con->tempHolderForReleaseCause = con->icEvnt->m.ccRelEvnt.m.siRelEvnt.causeDgn.causeVal.val;
        CCDP(AIN_DBG_LEVEL_2, "Get tempHolderForReleaseCause from siRelEvnt - causeVal=%d\n", 
              con->tempHolderForReleaseCause);
     }
#endif
     ret = ccSendMgiQueue(0, con->mgBlock);
     if (ret != ROK) /* You can't help it relase inc side */
     {
       cleanUpMgQ(con);
       ccCleanUpMGCtx(con);
       CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
       ccSendRelease(con,con->icSapCb, con->icSpConnId, con->icSuConnId,
                     con->icProtType, CCTMPFAIL,NULL);
       RETVOID;
     }
     else /* wait for MGI response to release the call */
       RETVOID;
  }
  
  /* Bug 81847: Reduce SDP size in CCT */
  ogSip = ccFindSdpInBcm(&con->ogBcm);

  if (IS_MULTIMEDIA_4_BCM(&con->ogBcm)&&ogSip&&ogSip->numDecode&&
      (!CC_EGRESS_INTER_CCS_CALL(con)))
  {
    int i = 0;
    
    for (i=0;i<ogSip->numDecode;i++)
    {
      Bool          removeMs = (((ogSip->p[i].address.ip.port.pres)&&     \
                                 (ogSip->p[i].address.ip.port.val == 0)) ? \
                                  TRUE : FALSE);
      
      if ((ogSip->p[i].mediaType == SDP_MTYPE_VIDEO)&&(!removeMs))
      {
        ccCp.sts.OutVideo++;
      }
      if ((ogSip->p[i].mediaType == SDP_MTYPE_MESSAGE)&&(!removeMs))
      {
        ccCp.sts.OutMSRP++;
      }
    }
  }

  con->dgtsInCdNum = con->routeInfo->nmbDigits;
  uBuf = con->uBuf;
  con->uBuf = NULLP;
  if (ccInit.acnt == TRUE)
  {
     con->callDtlInfo.cm.tckOgConReqSent.pres = PRSNT_NODEF;
     (Void) SGetSysTime(&con->callDtlInfo.cm.tckOgConReqSent.val);
  }

  /* Increment the call attempt statistics */
  if (con->ogIntfcCb)
     con->ogIntfcCb->sts.numOgCallAttempt++;

  /* BUG 21379, kparikh */
  cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);
  con->ogSpConnId = 0;

  cmHashListInsert(&con->ogSapCb->ogConsInstTbl, (PTR)con,
                   (U8 *)&con->ogSuConnId, (U16)sizeof(UConnId));

  /* Update the ogSpConnId: We know that, ogSpConnId is same
     as og resource chan (Ds0) */
  if((con->ogProtType == CC_CS_TG) || (con->ogProtType == CC_CS_LN) )
     con->ogSpConnId = 0 /*con->ogRsc.t.ds0Rsc*/;
  if(con->ogProtType == CC_GR303)
     CC_SET_G3CONNID(con->ogSpConnId, con->ogRsc.intfc.t.intfcId, con->ogRsc.t.gr3Rsc.crv);

  UPDATE_OPIC(con, PicSendCall);
  if (con->icBcm.cc != NULLP)
  {
      if (con->icBcm.cc->ccId == CiThreePartySetup)
          con->icBcm.cc->ccId = CiPartyOnHold;
  }

   /* BUG 17114 fix - pkumar */
   if ((con->ogBcm.nel[EReqTNoAnswer] == NEL_REQUEST) &&
       (con->ainInfo.TnoAnswerTimer.pres) &&
       (con->ainInfo.TnoAnswerTimer.val == 0))
   {
     /* Don't route the call but return to FIC with
      * No_Answer trigger.
      */
     ccConE50SXX(con, CCE_TNOANSEXP, NULLP, NULLP);
     RETVOID;
   }

 if (con->ogIntfcCb && con->ogIntfcCb->ccTgCb)
 {      
    sipPrflPtr = con->ogIntfcCb->ccTgCb->tgAtt.sipPrflPtr;  
 } 
                                                         
 if ((sipPrflPtr == NULL) && (con->icIntfcCb) && (con->icIntfcCb->ccTgCb))
 {
    sipPrflPtr = con->icIntfcCb->ccTgCb->tgAtt.sipPrflPtr;    
 }

 /* Check UUSI parameter if only ISUP -> SIP IW call */   
 if ((icProtType == CC_EXT_BICC) || ((sipPrflPtr != NULL) &&    
  (sipPrflPtr->uuiIwProc == LCC_SIP_IW_PROC_Q1912_5) && (icProtType == CC_SI) && (ogProtType == CC_SIP)))
 {
    /* check if explicit essential UUSI service requests is present */
    ret = ccCheckUUSIParam(con);  
    if (ret == RFAILED)
    {
       /* BUG 41460 */
       ccProcessFailCnd(con, FC_FACREJ_UUI, CSTD_CCITT);
       RETVOID;
                                                                     
    }
  }

  CCDP(AIN_DBG_LEVEL_0, "Sending ConReq\n");

  processAnsSupervisionFraudPrflId(con);

  /* 57460 */
  ccUpdInterCcsTermPbxSubId(con);

  /* Bug#15674, rkhan */
  ccUpdSts(con->icSapCb,con->ogSapCb);

  /* FID 14457.0 + */
  if ((ccCp.getsEnabled) && (IS_THIS_CALL_GETS(con)))
  {
    ccUpdGetsSts(con->ogProtType, CC_OUTGOING);
  }
  
  /* Feature 1789 - German ISUP */
  /* for ISUP to SIP call start Toiw2 Timer */
  if(((icProtType == CC_SI) || ((icProtType == CC_EXT_BICC))) && (ogProtType == CC_SIP))
  {
     if( (!CC_INTG_ICOVERLAP(con->icIntfcCb->overlapCfg)) ||
            (con->STDigitRecd == TRUE) )
     {
         /* If en-bloc is in use or all digits are collected,
          * start the Toiw2 timer here */

         ccStartConTmr(CC_TMR_TOIW2, con, (PTR)&ccCp.genCfg);
     }
  }

#ifdef SAVE_PRFLID
  ccSaveProfileId(con); 
#endif
  ccProcessOCallSent(&con->icBcm);

  /* PreAnswer Timer is only started for CRBT Call */
  ccStartConTmr(CC_TMR_PREANM, con, (PTR)&ccCp.genCfg);

  /* SEND CONNECT REQUEST TO LOWER LAYER */
  CcLiCctConReq (&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSuConnId,
                 &con->ogRsc, con->ogProtType, &ogEvnt, uBuf, con);
  /* FID16521.0 since uuidata is allocated in gcc and sipw directly copy uuidata pointer 
   * and de-allocated them after send out conreq to sipa 
   * re-set the correlated flag in gcc to ensure no memory issue there
   */
  if((icProtType == CC_SIPT) && (ogProtType == CC_SIP))
  {
      if(CC_BOTH_SUPPORT_UUI(con))
      {
          SipConEvnt *sip = NULLP;
          sip = &(con->ogEvnt->m.ccConEvnt.m.sipConEvnt);
          CCDP(AIN_DBG_LEVEL_2, "%s(): ic SIPT,og SIP,UUI both supported\n", __FUNCTION__);
          if ((sip->sipUuiData.pres == PRSNT_NODEF) &&
               (sip->sipUuiData.len>0))
          {
             CCDP(AIN_DBG_LEVEL_2, "%s(): memory has been cleaned,set flag!\n", __FUNCTION__);
             sip->sipUuiData.pres = NOTPRSNT;
             sip->sipUuiData.len  = 0;
             sip->sipUuiData.val = NULLP;  
          }
      }
   }
  /* Bug 82292, only support overlap->enbloc for ISUP->enbloc */
  /* SENDACM can make sure the incoming is ISUP               */
  if (((!CC_INGRESS_INTER_CCS_CALL(con) && CC_EGRESS_INTER_CCS_CALL(con)) ||
       (!CC_INGRESS_INTER_CCS_CALL(con)  && !CC_EGRESS_INTER_CCS_CALL(con))) &&
      (con->EarlyACMSt != EARLY_ACM_HAS_BEEN_SENT) &&
      (CC_IS_ICOVERLAP_SENDACM(con)) &&
      (CC_IS_OGOVERLAP_DISABLED(con)))
  {
      ccStopConTmr(con, CC_TMR_EARLYACM);
      /* Directly call the early acm expire to send early acm */
      ccTmrEarlyACMExp(con);
      /* BUG 67115 */
      if (con->state == CCS_AWTMGCTCFMFOREARLYACM)
      {
         RETVOID;
      }
  }

  /* BUG93319.0 to start earlyAcm Timer for BICC inter-MG call */
  if((con->EarlyACMSt != EARLY_ACM_HAS_BEEN_SENT) &&
     (IC_EARLY_ACM_TMR_ENABLED(con)) &&
     (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
     (CC_IS_CALL_MULTI_MG(con)))
  {
    ccStartConTmr(CC_TMR_EARLYACM, con, (PTR)&ccCp.genCfg);
  }
}

/* + BUG: 83045 */
/*
 *
 *      Fun:   ccProcessReAttempt
 *
 *      Desc:  This fnctions processes the ReAttempt received from Layer 3
 *             The reason this new function is written is because we could possibly do 
 *             a MG operation and take a break.
 *
 *    
 *      Ret:   Void
 *  
 *      Notes: 
 *  
 *      File:  cc_bdy2.c
 *  
 */
PUBLIC Void ccProcessReAttempt
(
CcConCb  *con,
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
    CcStaEvnt *staEvnt = NULLP;
    CcGenSap *rmCb     = NULLP;
    CcConCb *waitingCon = NULLP;
    S16      ret        = RFAILED;
#ifdef CC_CALEA
    S16 calRet = RFAILED;
#endif

    /* Reroute */
    ccCleanAnsFraudCall(con);

    /* Feature 1789 - German ISUP */
    /* stop the Toiw2 Timer if running */
    ccStopConTmr(con, CC_TMR_TOIW2);

    staEvnt = (CcStaEvnt *) event;
    if (staEvnt != NULLP)
    {
        switch (staEvnt->siStaEvnt.optElmnt.isup.COT_flag)
        {
            case OUTGO_COT_FAILT24: /* IAM initiated COT failed on T24 expire and COT was sent out */
                CCFILLCOTSTAT(con, CC_OG_COT_FAIL, CC_ACTION_INCREMENT);
                break;
            case COT_NOTPEG_IAMGLARE: /* IAM dropped due to glare */
                CCFILLCOTSTAT(con, CC_OG_COT_ATTEMPT, CC_ACTION_DECREASE);
                /* bug 62401 - Unpeg og COT suc due to IAM glare */
                CCFILLCOTSTAT(con, CC_OG_COT_SUCCESS, CC_ACTION_DECREASE);
            default:
                break;
        }
    }

    /* Bug 79156 */
    if ((CC_GET_PROTOCOL(con->ogProtType) == CC_SI) ||
        (CC_GET_PROTOCOL(con->ogProtType) == CC_EXT_BICC))
    {
     switch (con->ogEvntType)
     {
      case CC_ET_CPG:
      case CC_ET_ACM:
      case CC_ET_FAR:
      case CC_ET_IDREQ:
      case CC_ET_INR: 
       if(!con->callDtlInfo.cm.iamRspFlag)
        con->callDtlInfo.cm.iamRspFlag = TRUE;
       break;
      default:
       break; 
     }
    }
    CCDP(AIN_DBG_LEVEL_0, "iamRspFlag=%d\n", con->callDtlInfo.cm.iamRspFlag);

    /* Set the reattemptFlag so that, it would't be attempted again */
    if (con->reattemptFlag == FALSE)
    {
       CCDP(AIN_DBG_LEVEL_0,"First Reattempt\n");
       con->reattemptFlag = TRUE;
       ccStopConTmr(con, CC_TMR_PREANM); /* Bug 71150 */
#ifdef CC_CALEA
       if (con->icProtType == CC_LOCAL_SWT_PROT)
       {
         con->caleaReattemptFlag = TRUE;
         CCDP(AIN_DBG_LEVEL_0,
              "Setting caleaReattemptFlag = TRUE, for calea: %lx\n",
              con->icSuConnId);
         calRet = ccProcessTappedLegForCaleaRel(con, con->icBcm.cc->tappedLegId, event,
                                                CCE_REATIND, sizeof(CcStaEvnt));  
         if (calRet == ROK)
         {
            /* Halt the state machine till the Resource is subtracted */
            CCDP(AIN_DBG_LEVEL_0,
                "Halt Calea State machine till the old Rsc is subtracted\n"); 
            RETVOID;
         }
       }
#endif 
    } 
    else
    {
       /* Release the call, as Reattempt is allowed only once */
       /* + BUG: 84464 */
       ccDeallocateResource(con, CC_OUTGOING);
       con->ogRscVal = FALSE;

       if (con->ccHeldSdpForCfna)
       {
          cmFreeSdp(ccInit.region, ccInit.pool, &con->ccHeldSdpForCfna);
       }
       /* - BUG: 84464 */

       CCDP(AIN_DBG_LEVEL_0,
            "Releasing the call : as the max Reattempt was reached\n");
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL); /* BUG: 83045 */
       RETVOID;
    }

    ccRestoreEvntHold(con);
    if (con->icSuConnIdOfIntGlare)
    {
        CCDP(AIN_DBG_LEVEL_0, "Re-attempted call getting processed after"
             "OG-COT was processed: 0x%lx\n", con->icSuConnIdOfIntGlare);

        ret = cmHashListFind(&ccSuInstTbl, (U8 *)&(con->icSuConnIdOfIntGlare),
                             (U16)sizeof(UConnId), 0, (PTR *)&waitingCon);

        if ((ret != ROK) || (waitingCon == NULLP))
        {
            CCLOGERR("Error: Call not found\n");
            ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
            RETVOID;
        }

        con->ogRscVal = FALSE;
        if((con->ogSapCb) && (con->ogSapCb->nmbActvConn > 0))
          con->ogSapCb->nmbActvConn--;
        else
          CCLOGERR("ERROR %s:con->ogSapCb->nmbActvConn=%d\n", __FUNCTION__,
                   (con->ogSapCb)?con->ogSapCb->nmbActvConn:0);

        if((con->ogIntfcCb) && (con->ogIntfcCb->nmbActvConn > 0))
           con->ogIntfcCb->nmbActvConn--;
        else
          CCLOGERR("ERROR %s:con->ogIntfcCb->nmbActvConn=%d\n", __FUNCTION__,
                   (con->ogIntfcCb)?con->ogIntfcCb->nmbActvConn:0);

        con->ogRscSta = RMT_RES_INVALID;
        cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);

        rmCb = con->rmSapCb;
        /* Send a resource allocation request to RM to allocate another */
        /* resource at the same interface and retry the call */
        CC_STATE_CHANGE(con, CCS_AWTRSCALLOCCFM_GLARE);
        CCDP(AIN_DBG_LEVEL_2,"Sending RscAlocReq for Reattempt\n");
        CcLiRmtAlocReq (&rmCb->pst, rmCb->spId, con->ogSuConnId,
                        con->ogProtType, RMT_MOD, &(con->ogRsc),
                        &con->tfcDsc, FALSE, NULLP, &con->icAddnlRscInfo, NULLP);

        /* con freed the ckt */

        if ((waitingCon) && (waitingCon->state == CCS_AWTROUTERSC))
        {
            ccAllocateResource(waitingCon,
                               (CcConEvnt *)(waitingCon->ccEvntHold),
                               CC_INCOMING, RMT_ALOC);
        }

        con->icSuConnIdOfIntGlare = 0;
    }
    else
    {
        con->ogRscVal = FALSE;

        if((con->ogSapCb) && (con->ogSapCb->nmbActvConn > 0))
           con->ogSapCb->nmbActvConn--;
        else
           CCLOGERR("ERROR in %s: con->ogSapCb->nmbActvConn=%d\n", __FUNCTION__,
               (con->ogSapCb)?con->ogSapCb->nmbActvConn:0);
        if((con->ogIntfcCb) && (con->ogIntfcCb->nmbActvConn > 0))
           con->ogIntfcCb->nmbActvConn--;
        else
          CCLOGERR("ERROR in %s: con->ogIntfcCb->nmbActvConn=%d\n", __FUNCTION__,
               (con->ogIntfcCb)?con->ogIntfcCb->nmbActvConn:0);
        con->ogRscSta = RMT_RES_INVALID;
        cmHashListDelete(&con->ogSapCb->ogConsInstTbl, (PTR)con);

        rmCb = con->rmSapCb;
        /* Send a resource allocation request to RM to allocate another */
        /* resource at the same interface and retry the call */
        CC_STATE_CHANGE(con, CCS_AWTRSCALLOCCFM_GLARE);
        CCDP(AIN_DBG_LEVEL_2,"Sending RscAlocReq for Reattempt\n");
        CcLiRmtAlocReq (&rmCb->pst, rmCb->spId, con->ogSuConnId, 
                        con->ogProtType, RMT_MOD, &(con->ogRsc),
                        &con->tfcDsc, FALSE, NULLP, &con->icAddnlRscInfo, NULLP);
    }
    RETVOID;
}
/* - BUG: 83045 */

PUBLIC Void ccUpdGetsSts(ProtType protType, U8 callLeg)
{
   switch (CC_GET_PROTOCOL(protType))
   {
     case CC_SIP:
     case CC_SIPT:
         if (callLeg == CC_INCOMING)
           ccCp.getsSts.sipIn++;
         else
           ccCp.getsSts.sipOut++;
     break;
    case CC_SI:
         if (callLeg == CC_INCOMING)
           ccCp.getsSts.isupIn++;
         else
           ccCp.getsSts.isupOut++;
     break;
    default:
    break;
   }
}


/*
*
*      Fun:   ccConE09S151
*
*      Desc:  Connection state function
*             event - Resource Allocation Confirmation
*             state - 151-CCS_AWTNCCFM
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE09S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt   = NULLP;
  S16            ret       = RFAILED;
  U8  index                = 0;
  BiccMsgEvnt      ogEvnt;
  rscEvnt = (RmAlocCfmEvnt *) event;
  CcbsEvntPkg_t ccbsEvntPkg;
  cmMemset((U8 *)&ccbsEvntPkg, 0, sizeof(CcbsEvntPkg_t));

  if(((rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC) ||
      (rscEvnt->rscSta1 == RMT_RES_ALOC_BUSY))
       &&(rscEvnt->ogPrtclType != NULLP))
  {
    con->ogRscVal = TRUE;
    cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, 
             sizeof(RmRsc));
    CCDP(AIN_DBG_LEVEL_2,"%s: ogRsc.intfc.intfType:%d.\n",__FUNCTION__,con->ogRsc.intfc.intfType);
    /* store outgoing sap */
    if ((ret = ccGetPsSap(&con->ogSapCb,
                          &rscEvnt->rsc1->intfc))!= ROK)
    {
      CCLOGERR("%s Failed, ccGetPsSap failed.\n",__FUNCTION__);
      ccCp.sts.fRoutUnavail++;

      RETVALUE(RFAILED);
    }
    if (con->ogSapCb)
      con->ogSapCb->nmbActvConn++;
  }
  else
  {
      CCLOGERR("%s, FAILED. rscEvnt->rscSta1 %d.\n",__FUNCTION__,rscEvnt->rscSta1);
      RETVALUE(RFAILED);
  }
  con->ccbsIsdnCallInfo->cirId = rscEvnt->rsc1->t.biccRsc.cirId;

  CCDP(AIN_DBG_LEVEL_1,"ccbsIsdnCallInfo.cirId is %ld.\n",con->ccbsIsdnCallInfo->cirId);
  
  /* Mark virtual call in order to avoid involving MG */
  con->callDtlInfo.cm.ccbsCallIndicator = LCC_CDR_CCBS_VIRTUAL_CALL;

  /* Cleaning up the NEL */
  for (index = 0; index < EReqMax; index++)
  {
      con->icBcm.nel[index] = NEL_UNARMED;
  }

  /* restore information in ccbs cb */
  con->ccbsIsdnCallInfo->ccbsIsdnMode = CCBS_ISDN_MODE_NOTIFIER;
  con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_SUB_IND;
  con->ccbsIsdnCallInfo->ccbsIsdnState = CCBS_ISDN_ST_WAIT_SUB200OK_ADD;

  ccbsIsdnStartTmr(CCBS_ISDN_SUBSCRIPTION_TMR, con, con->ccbsIsdnCallInfo->expires2xx);
    
  cmMemset((U8 *)&ogEvnt, 0, sizeof(BiccMsgEvnt));
  con->ogEvnt = (CcAllSdus *)&ogEvnt;
  con->direction = INCTOOUT;
  con->ogProtType = CC_BICCETSI;  
  con->icEvntType = SUBSCRIBE_IND;
  CC_STATE_CHANGE(con, CCS_AWTNCCFM);

  ret = ccMapEvent(con, CCE_NCIND, con->icEvntType);//ccSIP2SIMapS21M21
  if(ret != ROK)
  {
      CCDP(AIN_DBG_LEVEL_1," Mapping message indication failed\n");

      ccbsEvntPkg.pres = PRSNT_NODEF;
      ccbsEvntPkg.qNature = CCBS_Q_NATURE_YES;
      ccbsEvntPkg.denialReason.pres = PRSNT_NODEF;
      ccbsEvntPkg.denialReason.val = CCBS_DENIAL_REASON_SHORTTERM;
      ccbsIsdnSendNotReq(con, NOTIFY_SUB_STATE_TERMINATED, 0, 0, ccbsEvntPkg);

      CC_STATE_CHANGE(con,(CCS_AWTRELCFM_IC));

      RETVALUE(ROK);
  }
    

  CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId,
                con->ogSpConnId, con->ogSuConnId,
                con->ogProtType, (CcMsgEvnt *)&ogEvnt);

  CCBS_ISDN_STATE_CHANGE(con->ccbsIsdnCallInfo,
       CCBS_ISDN_ST_WAIT_FACILITY_REQUEST_RR);

  RETVALUE(ROK);
}



/*
*
*      Fun:   ccConE09S153
*
*      Desc:  Connection state function
*             event - Resource Allocation Confirmation
*             state - AWTMGICFMSUBADD
*      Ret:   ROK     - successful,
*             RFAILED - unsuccessful
*
*      Notes: None.
*
*      File:  cc_bdy2.c
*
*/
PRIVATE S16 ccConE09S153
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  RmAlocCfmEvnt *rscEvnt   = NULLP;
  U32            suCtxId   = 0;
  U32            contextId = 0;
  S16            ret       = RFAILED;

  CCDP(AIN_DBG_LEVEL_2,"Entering ccConE09S153\n");
  
  rscEvnt = (RmAlocCfmEvnt *) event;
  /* Check the status of allocated resource */
  if (rscEvnt->rscSta1 == RMT_RES_ALOC_SUCC)
  {
     con->ogRscVal = TRUE;
     cmMemcpy((U8 *) &con->ogRsc, (U8 *)rscEvnt->rsc1, 
           sizeof(RmRsc));


     /* Copy Additional Resource Information */
     if (rscEvnt->addnlRscInfo != NULLP)
     {
        cmMemcpy((U8 *) &con->icAddnlRscInfo, 
              (U8 *)rscEvnt->addnlRscInfo, 
              sizeof(RmAddnlRscInfo));   
     }
     else
        con->icAddnlRscInfo.trnkRsc.rscPres = NOTPRSNT;

     /* Copy the mBuf received from RM */
     if (con->icRscMBuf)
        SPutMsg(con->icRscMBuf);
     con->icRscMBuf = rscEvnt->mBuf;
     rscEvnt->mBuf = NULLP;


     /* Copy the modified traffic descriptor */
     cmMemcpy((U8 *) &con->tfcDsc, (U8 *)rscEvnt->tfcDesc, 
           sizeof(RmTfcDesc));
     /* Need to add the new ogRsc now */
     /* BUG:90302 */
     if(con->relPend == OUTRSCADDANDALOC)
     {
        CCDP(AIN_DBG_LEVEL_2,"ISDN call,new ogRsc allocated,do an ADD for this new resource.ccn%d!\n",
              con->ccmCb.ccn);
        if (CC_IS_CALL_MULTI_MG(con))
        {
           if(con->ogAdjBcm && con->ogAdjBcm->mgCtx)
           { 
              suCtxId   = con->ogAdjBcm->mgCtx->suCtxId;
              contextId = con->ogAdjBcm->mgCtx->contextId;
           }
           else
           {
              suCtxId   = 0;
              contextId = 0;
           }
        }
        else 
        {
           if(con->mgBlock)
           {
             suCtxId = con->mgBlock->mgCtx ? con->mgBlock->mgCtx->suCtxId : 0;
             contextId = con->mgBlock->mgCtx ? con->mgBlock->mgCtx->contextId :0;
           }
           else
           {
              suCtxId   = 0;
              contextId = 0;
           }
        }

        ccUpdateMgQForAddOrModifyRsc(MGCT_MODE_SENDRECV,
              MGCT_PACKAGE_ID_MAX,
              MGCT_ITEM_ID_CG_MAX,
              MGCT_CMD_ADD,
              &(con->ogBcm), NULLP,
              NULLP, NULLP, NULLP, NULLP,
              suCtxId,
              contextId,
              con);
        con->mgBlock->con = con;

        ret = ccSendMgiQueue(suCtxId, con->mgBlock);
        if (ret != ROK)
        {
           CCLOGERR( "Error: ccSendMgiQueue failed\n");
           cleanUpMgQ(con);
           ccCleanUpMGCtx(con);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           RETVALUE(RFAILED);
        }
        CCDP(AIN_DBG_LEVEL_2,"return to S153 for ADD response!\n");
        RETVALUE(ROK);
     }
     
  }
  else if (rscEvnt->rscSta1 == RMT_RES_ALOC_FAILURE)
  {
    CCLOGERR("Resource Allocation failed:icSu:%ld, status:%d\n",
              con->icSuConnId, rscEvnt->rscSta1);
    con->ogRsc.rscPres = FALSE;
    ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
    RETVALUE(RFAILED);
  }
  RETVALUE(ROK);
}

PRIVATE S16 ccConE03S154
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2
)
{
    ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
    ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);
    S16      ret = RFAILED;
    CcPrecndCb* precndCb = NULLP;


    CCDP(AIN_DBG_LEVEL_2,"Entering ccConE03S154\n");

    if(ogProtType==CC_SIP || ogProtType==CC_SIPT)
    {
        precndCb = con->ogPrecndCb;
    }else
    {
        precndCb = con->icPrecndCb;
    }

    if ((con->direction == OUTTOINC) && (ogProtType == CC_SIP) &&
      (((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnIdPres))
    {
      con->ogSpConnId = ((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnId;
      if ((!con->forkedCallCnt) &&
          (((CcCnStEvnt *)event)->m.sipCnStEvnt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
      {
        if(!con->forkedCallCnt)
        {
          con->forkedCallCnt++;
        }
      }
      CCDP(AIN_DBG_LEVEL_2, "%s - New SIP spConnId received, new spConnId=0x%08lx\n", __FUNCTION__, con->ogSpConnId);
    }

    if ((con->direction == OUTTOINC) && (ogProtType == CC_SIPT) &&
        (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnIdPres))
    {
      con->ogSpConnId = ((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnId;
      if (!con->forkedCallCnt &&
         (((CcCnStEvnt *)event)->m.siCnStEvnt.optElmnt.sipt.spConnIdPres == SIP_NEW_SP_CONN_ID_PRES_FORKING))
      {
        con->forkedCallCnt++;
      }
      CCDP(AIN_DBG_LEVEL_2, "%s - New SIPT spConnId received, new spConnId=0x%08lx\n", __FUNCTION__, con->ogSpConnId);
    }

    if (con->forkedCallCnt)
    {
      if (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION))
      {
        CCDP(AIN_DBG_LEVEL_0, "Releasing call as this is a forked response for precondition call\n");
        /* BUG93301 to clean up MG Queue */
        cleanUpMgQ(con);
        ccHandleCleanUpConCb(con, FALSE, CCPRECONDFAIL);
        RETVALUE(ROK);
      }
    }

    if((precndCb) && IS_PRECND_INMGACTION(precndCb->flag)) 
    {
        ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);
        RETVALUE (ROK);
    }

    ret = ccExtractSdpFromCnStInd(con, event);
    if (ret != ROK)
    {
        CCLOGERR("Error: SDP parsing failed - %d\n", ret);
        con->failCndVal = FC_PROTERR;

        if (CC_IS_CONTEXT_PRESENT(con))
        {
          ccQSubBasedOnCcn(con);  /* FID 15261.0 */

          ret = ccSendMgiQueue(0, con->mgBlock);
          if (ret != ROK)
          {
            CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
            cleanUpMgQ(con);
            ccCleanUpMGCtx(con);
          }
          else
          {
            CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDNOREL);
            con->mgBlock->con = con;
            con->relPend = ONLYINFAILCND;
            RETVALUE(ROK);
          }
        }

        ccProcessFailCnd(con, con->failCndVal, TRUE);
        RETVALUE(ROK);
    }

    if (CC_IS_CALL_MULTI_MG(con))
    {
      if (con->direction == OUTTOINC)
        con->ccmCb.state = CC_EGRESS_MG;
      else
        con->ccmCb.state = CC_INGRESS_MG;
    }

    if(con->direction == OUTTOINC)
    {
        if(ccIsRcvdSdpReliable(con, con->ogProtType,
                CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event) ||
           ccIsRcvdSdpNotReliable(con, con->ogProtType,
                CCE_CNSTIND, con->icEvntType, (CcAllSdus*)event))
        {
            ccProcessOAlertingWithSwitching(con, (PTR)event);
            RETVALUE (ROK);
        }
        if (ccIsPrackRspRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
        {
            ccProcessPrackRsp(con, icProtType, ogProtType, (CcAllSdus*)event);
            RETVALUE (ROK);
        }
    } 

    if (ccIsPrackRcvd(icProtType, ogProtType, con->icEvntType,con->direction))
    {
        ccProcessPrackOrAck (con, icProtType, ogProtType, (CcAllSdus*)event);
        RETVALUE (ROK);
    }

    if (ccIsUpdateRcvd(icProtType, ogProtType, con->icEvntType, con->direction))
    {
        if(con->direction == INCTOOUT &&
           (icProtType==CC_SIP||icProtType==CC_SIPT) &&
           (ogProtType==CC_SIP||ogProtType==CC_SIPT||ogProtType==CC_BICC) &&
            CC_OFFANS_OGOFFANS_PENDING(con))
        {
            if (ogProtType != CC_BICC)
            {
              ccSendUpdateRsp(&con->icBcm, PRSNT_NODEF, SIPCAUSE_491_REQPENDING);
              RETVALUE(ROKIGNORE);
            }
        }
        ccProcessUpdate(con, icProtType, ogProtType,(CcAllSdus*)event);
        RETVALUE (ROK);
    }

    if (ccIsUpdateRspRcvd(icProtType, ogProtType, con->icEvntType,
                          con->direction))
    {
        ccProcessUpdateRsp(con, icProtType, ogProtType,(CcAllSdus*)event);
        RETVALUE (ROK);
    }

    if ((icProtType == CC_BICC) && (con->icEvntType == CC_ET_CONNECTED))
    {
      S16  sdpRet = ROK; 

      CCDP(AIN_DBG_LEVEL_2,"EvntType:%02d received, Precondition Uncompleted,BICC APM\n", con->icEvntType);
      sdpRet = ccExtractSdpFromCnStInd(con, event);
      if (sdpRet != ROK)
      {
         CCLOGERR("Error: SDP parsing failed - %d\n", sdpRet);
         con->failCndVal = FC_PROTERR;

         if (CC_IS_CONTEXT_PRESENT(con))
         {
           ccQSubBasedOnCcn(con);  /* FID 15261.0 */

           ret = ccSendMgiQueue(0, con->mgBlock);
           if (ret != ROK)
           {
             CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
             cleanUpMgQ(con);
             ccCleanUpMGCtx(con);
           }
           else
           {
             CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
             con->mgBlock->con = con;
             con->relPend = OUTRELANDINFAILCOND; /* will be used in state 88 */
             RETVALUE(ROK);
           }
        }
        ccFreeTheRscFromCon(con, OUTTOINC);
        ccProcessFailCnd(con, con->failCndVal, TRUE);
        RETVALUE(ROK);
      }
    }
    else
    {
      CCDP(AIN_DBG_LEVEL_2,"EvntType:%02d received, Precondition Uncompleted,Giving up negotiation!\n", con->icEvntType);
      SET_PRECND_COMPLETED(precndCb->flag);
      ccClearPrecndStatus(precndCb);

      ccBufferEventToQueue(con, bcm, event, CCE_CNSTIND, sizeof(CcCnStEvnt), 0, NULLP, 0);
      CC_STATE_CHANGE(con, CCS_AWTANS);
      ccPostEventToSelf(con);
    }

    return ROK;
}

PRIVATE S16 ccConE11S154  
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2)
{
  MgctTxnCfm    *txnCfm         = NULLP;
  S16            ret            = RFAILED;
  Bool           isUpdateRcvd   = FALSE;
  Bool           isPrackRcvd    = FALSE;
  Bool           isUpdateRspRcvd    = FALSE;
  Bool           isReliableSdpRcvd  = FALSE;
  Bool           isNotReliableSdpRcvd  = FALSE;
  Bool           isPrackRspRcvd  = FALSE;
  S16            addConf        = RFAILED;
  Bool           hasConfStatus  = FALSE;
  Bool           precndCompleted= FALSE;
  U8             direction       = CC_INCOMING;
  Bool           isRmtFullfilled = FALSE;

  CCDP(AIN_DBG_LEVEL_2,"Entering ccConE11S154\n");

  ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
  ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

  txnCfm   = (MgctTxnCfm*)event;
  ret = ccHandleMgResponse(con, txnCfm);
  
  if (ret != ROK)
  {
      CCLOGERR("%s: ccHandleMgResponse : failed\n", __FUNCTION__);
      cleanUpMgQ(con);
      ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
      RETVALUE(ROK); 
  }

  isUpdateRcvd = ccIsUpdateRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->evntTypeHeld, con->direction);   
  isPrackRcvd = ccIsPrackRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->evntTypeHeld, con->direction);
  isUpdateRspRcvd = ccIsUpdateRspRcvd(CC_GET_PROTOCOL(con->icProtType),
                            CC_GET_PROTOCOL(con->ogProtType),
                            con->evntTypeHeld, con->direction);
  if(con->direction == OUTTOINC)  
  {
      isReliableSdpRcvd = ccIsRcvdSdpReliable(con, con->ogProtType, 
                                CCE_CNSTIND, con->evntTypeHeld, con->ccEvntHold);
      isNotReliableSdpRcvd = ccIsRcvdSdpNotReliable(con, con->ogProtType, 
                                CCE_CNSTIND, con->evntTypeHeld, con->ccEvntHold);
      isPrackRspRcvd = ccIsPrackRspRcvd(CC_GET_PROTOCOL(con->icProtType),
                              CC_GET_PROTOCOL(con->ogProtType),
                              con->evntTypeHeld, con->direction);
  }

  /* FID 15261.0 + */
  if (CC_IS_CALL_MULTI_MG(con))
  {
      if (!CC_OPERATING_LAST_MG(con)&&((con->ccmCb.flags & CC_IW_TDM)==0))
      {
          if (con->direction == INCTOOUT)
          {
              if ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_INGRESS_MG))
                con->ccmCb.state = CC_Y_MG;
              else
                con->ccmCb.state = CC_EGRESS_MG;
          }
          else
          {
              if ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_EGRESS_MG))
                con->ccmCb.state = CC_Y_MG;
              else
                con->ccmCb.state = CC_INGRESS_MG;
          }

          con->icEvntType = con->evntTypeHeld;
  
          if(isPrackRspRcvd)  {
              ccProcessPrackRsp(con, CC_GET_PROTOCOL(con->icProtType),
                                CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
              ret = ROKIGNORE;
          }        
          if(isReliableSdpRcvd || isNotReliableSdpRcvd) 
          {
              ccProcessOAlertingWithSwitching(con, (PTR)con->ccEvntHold);
              ret = ROKIGNORE;
          }
          if (isPrackRcvd)
          {
              ccProcessPrackOrAck(con, CC_GET_PROTOCOL(con->icProtType),
                                CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
              ret = ROKIGNORE;
          }
          if (isUpdateRcvd)
          {
              ccProcessUpdate(con, CC_GET_PROTOCOL(con->icProtType),
                                CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
              ret = ROKIGNORE;
          }else if (isUpdateRspRcvd)
          {
              ccProcessUpdateRsp(con, CC_GET_PROTOCOL(con->icProtType),
                                 CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
              ret = ROKIGNORE;
          }

          if (ret != ROK)
              RETVALUE(ROK);
      }else 
      {
          if ((con->ccmCb.flags & CC_IW_TDM) == 0)
          {
              if(isReliableSdpRcvd || isPrackRcvd || isUpdateRcvd)    
              {
                  con->ccmCb.flags |= CC_IW_TDM;
              }
          }

          if (con->ccmCb.flags&CC_IW_TDM)
          {
              con->direction = (con->direction==INCTOOUT)?OUTTOINC:INCTOOUT;

              if (!CC_OPERATING_LAST_MG(con))
              {
                  if (con->direction == INCTOOUT)
                  {
                      if ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_INGRESS_MG))
                          con->ccmCb.state = CC_Y_MG;
                      else
                          con->ccmCb.state = CC_EGRESS_MG;
                  }
                  else
                  {
                      if ((con->ccmCb.ccn == CCN_5) && (con->ccmCb.state == CC_EGRESS_MG))
                          con->ccmCb.state = CC_Y_MG;
                      else
                          con->ccmCb.state = CC_INGRESS_MG;
                  }
                  
                  ccProcessXferRsp1OnSwitchPassThru(con, CC_GET_PROTOCOL(con->icProtType),
                               CC_GET_PROTOCOL(con->ogProtType), con->ccEvntHold);
                  CC_STATE_CHANGE(con, CCS_AWT_PRECONDITION);
                  con->direction = (con->direction==INCTOOUT)?OUTTOINC:INCTOOUT;                  
                  return ROK;
              }else
              {
                  con->ccmCb.flags &= ~CC_IW_TDM;
                  con->direction =CC_GET_EVNTHOLD_DIR(con->directionHeld);
              }
          }
      }
  }
  /* FID 15261.0 - */

  /* + FID 17373.0 */
  if (isPrackRspRcvd && icProtType==CC_EXT_BICC &&
      con->ogPrecndCb && (con->cotBlock.contType == CC_IAM_INITIATED))
  {
     PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_RSP_RECVED);
    
     CCDP(AIN_DBG_LEVEL_2,"BICC2SIP received prackRsp\n");     
  }
  /* - FID 17373.0 */

  if((con->direction == INCTOOUT) &&
     (icProtType==CC_SIP || icProtType==CC_SIPT || icProtType==CC_BICC) &&  
     (ogProtType==CC_SI || ogProtType==CC_IN || ogProtType==CC_BICC || ogProtType==CC_EXT_BICC))  /* FID17373.0 */
  {
      ccSetPrecndLocalStatus(con->icPrecndCb, PRECND_DIR_SENDRECV);

      CLEAR_PRECND_INMGACTION(con->icPrecndCb->flag);
   
      if((isUpdateRspRcvd||isPrackRcvd)&&CC_OFFANS_ICRMTANS_PENDING(con)) 
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));

          isRmtFullfilled = FALSE;
          hasConfStatus = ccHasPrecndConfStatus(con->icPrecndCb);
          if(isPrackRcvd&&hasConfStatus) 
          {
              ccEnablePrecndCb(con->icPrecndCb);
              ccTryToInsertPrecndConfStatus(con->icPrecndCb);
              ccSendUpdate(&con->icBcm);
              CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_SENTOFFER,
                                   CC_OFFANS_STATE_NO_OP,
                                   CC_OFFANS_SUBSTATE_NULL,
                                   CC_OFFANS_TYPE_UPDATE);

          }else
          {
            isRmtFullfilled = ccIsPrecndFulfillRemote(con->icPrecndCb);
            if(isRmtFullfilled) 
            {
              precndCompleted = TRUE;
            }
          }
          ccClearPrecndStatus(con->icPrecndCb);
      }else if(isUpdateRcvd)  
      {
          if(ogProtType==CC_BICC && !ccIsOfferNoPrecndAttr(con,con->icPrecndCb))
          {
              ccEnablePrecndCb(con->icPrecndCb);
          }
          /* FID17373.0 */
          if (ccIsOfferNoPrecndAttr(con,con->icPrecndCb))
          {
            CCDP(AIN_DBG_LEVEL_2,"%s Offer does not include precnd attr\n", __FUNCTION__);
            ccClearPrecndStatus(con->icPrecndCb);
          }
          addConf = ccTryToInsertPrecndConfStatus(con->icPrecndCb);
          ccSendUpdateRsp(&con->icBcm, NOTPRSNT, 0);  
          if(addConf==RFAILED) precndCompleted = TRUE;
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));
      }else if(isPrackRcvd)
      {
          if(ogProtType==CC_BICC && !ccIsOfferNoPrecndAttr(con,con->icPrecndCb))
          {
              ccEnablePrecndCb(con->icPrecndCb);
          }
          /* FID17373.0 */
          if (ccIsOfferNoPrecndAttr(con,con->icPrecndCb))
          {
            CCDP(AIN_DBG_LEVEL_2,"%s Offer does not include precnd attr\n", __FUNCTION__);
            ccClearPrecndStatus(con->icPrecndCb);
          }
          addConf = ccTryToInsertPrecndConfStatus(con->icPrecndCb);
          ccSendPrackRsp(&con->icBcm, NOTPRSNT, 0);
          if(addConf==RFAILED) precndCompleted = TRUE;

          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL,
                               CC_OFFANS_STATE_NO_OP,
                               CC_OFFANS_GET_SUBSTATE(con),
                               CC_OFFANS_METHOD_USED(con));
      }

      if(precndCompleted)
      {
          CCDP(AIN_DBG_LEVEL_2,"Precondition completed, go back to normal state.\n");     
          SET_PRECND_COMPLETED(con->icPrecndCb->flag);
          ccClearPrecndStatus(con->icPrecndCb);

          if(ogProtType==CC_BICC && IS_PRECND_SIP2SIPREROUTE(con->ogPrecndCb->flag))
          {
              CCT_RESET_SIP_SUPPORTED_PRECOND_MASK(con->icSipMethodSupMask);
              CCT_RESET_SIP_REQUIRED_PRECOND_MASK(con->icSipMethodSupMask);
              CCDP(AIN_DBG_LEVEL_1, "%s: inter-ccs reset the icSipMethodSupMask 0x%lx\n",
                  __FUNCTION__, con->icSipMethodSupMask);
              ccClearPrecndStatus(con->ogPrecndCb);

              CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                     CC_OFFANS_STATE_SENTOFFER,
                                     CC_OFFANS_SUBSTATE_NULL,
                                     CC_OFFANS_TYPE_INVITE);
          }

          if(ccIsRscCfmRequired(con->ogProtType)) 
          {
              CC_STATE_CHANGE(con, CCS_AWTOGRSC);
          }else
          {
              CC_STATE_CHANGE(con, CCS_AWTANS);
          }

          if (ogProtType == CC_EXT_BICC) /* FID 17373.0 */
          {
              CCDP(AIN_DBG_LEVEL_2,"%s: contChkInd: %d.\n", __FUNCTION__, con->tfcDsc.nbTfcDesc.contChkInd.val);
              /* Send Bearer done to BICC layer to trigger COT sending out */
              if (ccIsOgContChkRqstd(con) == CONTCHK_REQ)
              {
                 CCDP(AIN_DBG_LEVEL_2,"%s: Need to send out COT for EXT BICC in precondition.\n", __FUNCTION__);

                 CcCnStEvnt biccBearerDoneCnst;
                 cmMemset((U8 *)&biccBearerDoneCnst, 0, sizeof(CcCnStEvnt));

                 con->ogEvntType = CC_ET_BICCBEARERDONE;

                 ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                              con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                              con->ogProtType, con->ogEvntType, &biccBearerDoneCnst, NULL);
              }
              else
              {
                 CC_STATE_CHANGE(con, CCS_AWTANS);
                 ccPrepareExtBiccConReq(con);
                 if (CC_IS_CALL_MULTI_MG(con))
                 {
                   CCDP(AIN_DBG_LEVEL_2,"%s: change the state to CC_EGRESS_MG\n", __FUNCTION__);
                   con->ccmCb.state = CC_EGRESS_MG;
                 }
                 ccRestoreEvntHold(con);
                 ccSendConReqForOgIpCalls(con);
              }
          }
          else if(ogProtType!=CC_SI || ccIsOgContChkRqstd(con)!=CONTCHK_REQ)  
          {
              ccRestoreEvntHold(con);
              ccSendConReqForOgIpCalls(con);
          }else 
          {
              CCDP(AIN_DBG_LEVEL_2,"Need to send out COT\n");     
              if (con->cotBlock.contType == CC_IAM_INITIATED)
              {
                CC_STATE_CHANGE(con, CCS_AWTANS);
                direction = CC_OUTGOING;
              }
              else
              {
                CC_STATE_CHANGE(con, COT_OG_DONE);
                direction = CC_INCOMING;
              }
              if (con->cotBlock.contResult != CONT_CHKABORT)
                  ccSendStaReq(con, CCE_CONTREP, con->cotBlock.contResult, direction);

              con->cotBlock.contResult = CONT_CHKABORT;
          }
      }

  }else if((con->direction == OUTTOINC) &&
      (icProtType==CC_SI || icProtType==CC_IN || icProtType==CC_EXT_BICC) && /* FID17373.0 */
      (ogProtType==CC_SIP || ogProtType==CC_SIPT))
  {
      /* FID17373.0 */
      if ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
          (con->cotBlock.contType == CC_IAM_INITIATED) &&
          (!CC_IS_COT_RCVD_EXT_BICC(con)))
      {
        CCDP(AIN_DBG_LEVEL_2,"%s BICC2SIP COT call, set the strength tag to mandatory\n", __FUNCTION__); 
        ccSetPrecndLocalStrength(con->ogPrecndCb, PRECND_STRENGTH_MANDATORY);
        ccSetPrecndLocalStatus(con->ogPrecndCb, PRECND_DIR_NONE);
      }
      else
      {
        ccSetPrecndLocalStatus(con->ogPrecndCb, PRECND_DIR_SENDRECV);
      }

      CLEAR_PRECND_INMGACTION(con->ogPrecndCb->flag);

      CCDP(AIN_DBG_LEVEL_2,"%s isReliableSdpRcvd %d con->ogPrecndCb->flag %d\n",
                             __FUNCTION__, isReliableSdpRcvd, con->ogPrecndCb->flag);
      
      if(isReliableSdpRcvd) 
      {
          if(!IS_PRECND_OG18XRCVD(con->ogPrecndCb->flag)) 
          {
             CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                   CC_OFFANS_STATE_NULL,
                                   CC_OFFANS_GET_SUBSTATE(con),
                                   CC_OFFANS_METHOD_USED(con));

              CCDP(AIN_DBG_LEVEL_2,"FID 15068.0 Rcvd first 18x, need negotiate precondition.\n");     

              SET_PRECND_OG18XRCVD(con->ogPrecndCb->flag);
              isRmtFullfilled = FALSE;
              hasConfStatus = ccHasPrecndConfStatus(con->ogPrecndCb);
              /* FID17373.0 EXT_BICC COT always sending out PRACK w/ SDP */
              if(CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION) && 
                 (con->ogPrecndCb) && (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
                 (CC_IS_COT_RCVD_EXT_BICC(con)))
              {
                if (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT) != TRUE)
                {
                  PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_NO_UPDT);
                  CCDP(AIN_DBG_LEVEL_2,"BICC2SIP received COT, set noUpdate\n");
                }
              }

              if ((hasConfStatus) ||
                  ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
                   (con->cotBlock.contType == CC_IAM_INITIATED)))
              {
                  ccTryToInsertPrecndConfStatus(con->ogPrecndCb);
                  ccSendPrack(&con->ogBcm);
                  CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                       CC_OFFANS_STATE_SENTOFFER,
                                       CC_OFFANS_SUBSTATE_NULL,
                                       CC_OFFANS_TYPE_PRACK);
              }else 
              {
                  Sdp* rmtSdp = con->ogIpParam.locDesc;
                  con->ogIpParam.locDesc = NULLP;
                  ccSendPrack(&con->ogBcm);
                  con->ogIpParam.locDesc = rmtSdp;
                  rmtSdp = NULLP;

                  isRmtFullfilled = ccIsPrecndFulfillRemote(con->ogPrecndCb);
                  if(isRmtFullfilled)
                  {
                    if ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
                        (con->cotBlock.contType == CC_IAM_INITIATED) &&
                        (!CC_IS_COT_RCVD_EXT_BICC(con)))
                    {
                      CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with COT, not mark precnd completed when COT not received\n");
                    }
                    else
                    {
                      precndCompleted = TRUE;
                    }
                  }
              }
              /* FID 17373.0 */
              if ((icProtType == CC_EXT_BICC) && (con->cotBlock.contType == CC_IAM_INITIATED))
              {
                PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT);
                
                CCDP(AIN_DBG_LEVEL_2,"BICC2SIP sent PRACK\n");
#if 0
                if (!hasConfStatus)
                {
                  PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_RSP_RECVED);
                  CCDP(AIN_DBG_LEVEL_2,"BICC2SIP received prackRsp\n");     
                }
#endif
              }
          } else
          {
              Sdp* rmtSdp = con->ogIpParam.locDesc;
              con->ogIpParam.locDesc = NULLP;
              ccSendPrack(&con->ogBcm);
              con->ogIpParam.locDesc = rmtSdp;
              rmtSdp = NULLP;
              /* FID 17373.0 */
              if (icProtType == CC_EXT_BICC)
              {
                PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT);
                CCDP(AIN_DBG_LEVEL_2,"BICC2SIP sent PRACK\n");
              }
          } 
      }else if(isUpdateRcvd)
      {
          addConf = ccTryToInsertPrecndConfStatus(con->ogPrecndCb);
          /* FID17373.0 */
          if (ccIsOfferNoPrecndAttr(con,con->ogPrecndCb))
          {
            CCDP(AIN_DBG_LEVEL_2,"%s Offer does not include precnd attr\n", __FUNCTION__);
            ccClearPrecndStatus(con->ogPrecndCb);
          }
          if ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
              (con->cotBlock.contType == CC_IAM_INITIATED) &&
              (!CC_IS_COT_RCVD_EXT_BICC(con)))
          {
            /* store the sdp into ogPrecndCb */
            Sdp *sdpPtr = NULLP;
            sdpPtr = ccFindSdpInBcm(&con->ogBcm);
            if (sdpPtr)
            {
              if (con->ogPrecndCb->ogSdp)
                cmFreeSdp(ccInit.region, ccInit.pool, &con->ogPrecndCb->ogSdp);
              cmCopySdp(ccInit.region, ccInit.pool, &(con->ogPrecndCb->ogSdp), sdpPtr);
              if (AIN_DBG_LEVEL_0>=inDbgMsk)
              {
                cmSdpPrint(con->ogSpConnId, con->ogPrecndCb->ogSdp);
              }
            }
          }

          ccSendUpdateRsp(&con->ogBcm, NOTPRSNT, 0);
          if(addConf==RFAILED) 
          {
            if ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
                (con->cotBlock.contType == CC_IAM_INITIATED) &&
                (!CC_IS_COT_RCVD_EXT_BICC(con)))
            {
              CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with COT, not mark precnd completed when COT not received\n");
            }
            else
            {
              precndCompleted = TRUE;
            }
          }
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));

      }else if(isPrackRspRcvd || isUpdateRspRcvd)
      {
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));

         /* FID 17373.0 */
         if ((icProtType == CC_EXT_BICC) && (con->ogPrecndCb) &&
             (CC_IS_COT_RCVD_EXT_BICC(con)) &&
             (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT)) &&
             (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_RSP_RECVED)) && 
             (!PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_UPDT_SENT)) &&
             (con->cotBlock.contType == CC_IAM_INITIATED) &&
             (!PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_NO_UPDT)))
         {
            CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with incoming COT. send out Update to SIP\n");
            ccEnablePrecndCb(con->ogPrecndCb);
            ccTryToInsertPrecndConfStatus(con->ogPrecndCb);
            ccSendUpdate(&con->ogBcm);
            CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL, CC_OFFANS_STATE_SENTOFFER,
                                           CC_OFFANS_SUBSTATE_NULL,
                                           CC_OFFANS_TYPE_UPDATE);
           PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_UPDT_SENT);

         }
         else if ((icProtType == CC_EXT_BICC) && (con->ogPrecndCb) &&
             (!CC_IS_COT_RCVD_EXT_BICC(con)) &&
             (con->cotBlock.contType == CC_IAM_INITIATED))
         {
           CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with COT but COT not received, waiting for COT\n");
         }
         else
         {
           isRmtFullfilled = ccIsPrecndFulfillRemote(con->ogPrecndCb);
           if(isRmtFullfilled)
           {
                    if ((CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC) &&
                        (con->cotBlock.contType == CC_IAM_INITIATED) &&
                        (!CC_IS_COT_RCVD_EXT_BICC(con)))
                    {
                      CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with COT, not mark precnd completed when COT not received\n");
                    }
                    else
                    {
                      precndCompleted = TRUE;
                    }
           }
         }
      }

      if(precndCompleted)
      {
          CCDP(AIN_DBG_LEVEL_2,"Precondition completed, go back to normal state.\n");     
          SET_PRECND_COMPLETED(con->ogPrecndCb->flag);
          ccClearPrecndStatus(con->ogPrecndCb);

          /* FID 17373.0 */
          if (!CC_OFFANS_OGOFFANS_PENDING(con) && (icProtType == CC_EXT_BICC) &&
              (con->cotBlock.contType == CC_IAM_INITIATED))
          {
            if ((con->ogIpParam.locDesc) && 
                (isUpdateRspRcvd || (isPrackRspRcvd && 
                (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_NO_UPDT)))))
            {
              cmFreeSdp(ccInit.region, ccInit.pool, &con->ogIpParam.locDesc);
              CCDP(AIN_DBG_LEVEL_2,"Precondition completed, free local sdp\n");
            }
          }

          if (!CC_OFFANS_OGOFFANS_PENDING(con) && isPrackRspRcvd)
          {     
              if (con->ogIpParam.locDesc)
              {     
                  cmFreeSdp(ccInit.region, ccInit.pool, &con->ogIpParam.locDesc);
                  CCDP(AIN_DBG_LEVEL_2,"Precondition completed, free local sdp\n");
              }     
          }
          CC_STATE_CHANGE(con, CCS_AWTANS);
      }
  }else if((con->direction == OUTTOINC) &&
     (icProtType==CC_SIP || icProtType==CC_SIPT) &&
     (ogProtType==CC_SIP || ogProtType==CC_SIPT))
  {
      CLEAR_PRECND_INMGACTION(con->ogPrecndCb->flag);
      CCDP(AIN_DBG_LEVEL_2,"SIP2SIP Reroute, negotiation outgoing precondition\n");
      if(isReliableSdpRcvd)
      {
         if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
             (icProtType == CC_SIP || icProtType==CC_SIPT) &&
             (con->icPrecndCb) &&
             (IS_PRECND_RMV_ISUP(con->icPrecndCb->flag)))
         {
           CCDP(AIN_DBG_LEVEL_2, "%s FID15068 not set isACMSent for precondtion 18x\n",__FUNCTION__);
           CLEAR_PRECND_RMV_ISUP(con->icPrecndCb->flag);
         }

         if (ccIsPrecndFulfillRemote(con->icPrecndCb) && ccIsPrecndFulfillRemote(con->ogPrecndCb))
         {
             SET_PRECND_COMPLETED(con->icPrecndCb->flag);
             SET_PRECND_COMPLETED(con->ogPrecndCb->flag);
             CCDP(AIN_DBG_LEVEL_2,"Precondition completed for ogPrecndCb & icPrecndCb \n");
         }
         else
         {
             CLEAR_PRECND_COMPLETED(con->icPrecndCb->flag);
             CLEAR_PRECND_COMPLETED(con->ogPrecndCb->flag);
             CCDP(AIN_DBG_LEVEL_2,"Precondition completed cleared ogPrecndCb & icPrecndCb \n");
         }

          if(IS_MULTIMEDIA(con))  {
              ccTryToInsertPrecndConfStatus(con->icPrecndCb);
              ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, 0x00, ccLcfUpdateNeedPRACKPrecnd, (PTR)con, CCS_AWT_PRECONDITION);
          }else if ((con->remoteSdpSentOnIcBCM) &&
                    (con->icBcm.pic < PicOActive) &&
                    !(con->isAnsIndSent) &&
                    !(CC_OFFANS_ICOFFANS_PENDING(con)) &&
                    (CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask)) &&
                    (CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask)))
          {
              ccTryToInsertPrecndConfStatus(con->icPrecndCb);
              ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, 0x00, ccLcfUpdateNeedPRACKPrecnd, (PTR)con, CCS_AWT_PRECONDITION);
          }else
          {
              ccLcfUpdateNeedPRACKPrecnd((PTR)con,ROK);
          }
      }else if(isPrackRspRcvd)
      {
          CCDP(AIN_DBG_LEVEL_2,"FID 15068.0 Rcvd PRACK RSP, for SIP-SIP WITH SDP REROUTE call.\n");
          CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NO_OP,
                                 CC_OFFANS_STATE_NULL,
                                 CC_OFFANS_GET_SUBSTATE(con),
                                 CC_OFFANS_METHOD_USED(con));
          if(ccIsPrecndFulfillRemote(con->ogPrecndCb))
          {
              CCDP(AIN_DBG_LEVEL_2,"FID 15068.0 Outgoing precondition fulfulled.\n");
              SET_PRECND_COMPLETED(con->ogPrecndCb->flag);
              ccClearPrecndStatus(con->ogPrecndCb);
          }
          CC_STATE_CHANGE(con, CCS_AWTANS);
      }
  } 

  return ROK;
}

PRIVATE S16 ccConE01S154
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2
)
{
    CcPrecndCb* precndCb = NULLP;
    ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

    CCDP(AIN_DBG_LEVEL_2,"Entering ccConE01S154\n");

    if(ogProtType==CC_SIP || ogProtType==CC_SIPT) 
    {
        precndCb = con->ogPrecndCb;
    }else
    {
        precndCb = con->icPrecndCb;
    }

    ccBufferEventToQueue(con, bcm, event, CCE_CONCFM, sizeof(CcConEvnt), 0, NULLP, 0);

    if(!IS_PRECND_INMGACTION(precndCb->flag)) 
    {
        CCDP(AIN_DBG_LEVEL_2,"ANSWER received, Precondition Uncompleted,Giving up negotiation!\n");
        SET_PRECND_COMPLETED(precndCb->flag);
        ccClearPrecndStatus(precndCb);
        CC_STATE_CHANGE(con, CCS_AWTANS);
        ccPostEventToSelf(con);
    }
    RETVALUE(ROK);
}

PRIVATE S16 ccConE04S154
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2
)
{
    CcPrecndCb* precndCb = NULLP;
    //ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
    ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

    CCDP(AIN_DBG_LEVEL_2,"Entering ccConE04S154\n");

    if(ogProtType==CC_SIP || ogProtType==CC_SIPT) 
    {
        precndCb = con->ogPrecndCb;
    }else
    {
        precndCb = con->icPrecndCb;
    }

    ccBufferEventToQueue(con, bcm, event, CCE_RELIND, sizeof(CcRelEvnt), 0,NULLP, 0);

    if(!IS_PRECND_INMGACTION(precndCb->flag)) 
    {
        CCDP(AIN_DBG_LEVEL_2,"EvntType:%02d, release indication received,go to normal procedure!\n", con->icEvntType);
        ccClearPrecndStatus(precndCb);
        SET_PRECND_COMPLETED(precndCb->flag);
        if(ccIsRscCfmRequired(con->ogProtType)) 
        {
            CC_STATE_CHANGE(con, CCS_AWTOGRSC);
        }else
        {
            CC_STATE_CHANGE(con, CCS_AWTANS);
        }
        ccPostEventToSelf(con);
    }

    RETVALUE(ROK);
}

PRIVATE S16 ccConE07S154
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2
)
{
    CcPrecndCb* precndCb = NULLP;
    ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
    ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

    CCDP(AIN_DBG_LEVEL_2,"Entering ccConE07S154\n");

    if(!((icProtType==CC_SIP||icProtType==CC_SIPT)&&(ogProtType==CC_SI||ogProtType==CC_EXT_BICC))) { /* FID17373.0 */
        return ROKDNA;
    }

    precndCb = con->icPrecndCb;

    ccBufferEventToQueue(con, bcm, event, CCE_REATIND, sizeof(CcCnStEvnt), 0,NULLP, 0);

    if(!IS_PRECND_INMGACTION(precndCb->flag) && !CC_OFFANS_ICOFFANS_PENDING(con)) 
    {
        CCDP(AIN_DBG_LEVEL_2,"EvntType:%02d, Process REATTEMPT Event!\n", con->icEvntType);
        if(ccIsRscCfmRequired(con->ogProtType)) 
        {
            CC_STATE_CHANGE(con, CCS_AWTOGRSC);
        }else
        {
            CC_STATE_CHANGE(con, CCS_AWTANS);
        }
        ccPostEventToSelf(con);
    }

    RETVALUE(ROK);
}

EXTERN S16 ccConE23S09
(
 CcConCb *con,
 PTR event, 
 AinBCM_t *bcm,
 PTR event2)
{
  CC_SET_COT_RCVD_EXT_BICC(con);

  if (con->ogPrecndCb)
  {
     CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with incoming COT. received COT flag2 0x%x\n", con->ogPrecndCb->flag2);

     if(CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC)
     {
       if (!PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT))
       {
         PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_NO_UPDT);
         con->direction = OUTTOINC;
         CCDP(AIN_DBG_LEVEL_2,"BICC2SIP revert direction to OUTTOINC\n");
       }
     }
  }
  return ROK;
}

/* + FID 17373.0: BICC-SIP call COT support */
PRIVATE S16 ccConE23S154  
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2)
{
   /* BUG93734 Buffer E23 when the call is waiting for TxnCfm from MG */
   if((con->ogPrecndCb) && IS_PRECND_INMGACTION(con->ogPrecndCb->flag))
   {
     ccBufferEventToQueue(con, bcm, event, CCE_CONTREP, sizeof(CcStaEvnt), con->icSuConnId, NULLP, 0);
     con->direction = OUTTOINC;
     RETVALUE (ROK);
   }

    /* save COT info */
    CC_SET_COT_RCVD_EXT_BICC(con);
    CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with incoming COT. received COT flag2 0x%x\n", con->ogPrecndCb->flag2);

    con->direction = OUTTOINC;

    if((con->ogPrecndCb) && 
       (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT)) &&
       (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC)) 
    {
      if (PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_RSP_RECVED))
      {
        CCDP(AIN_DBG_LEVEL_2,"BICC2SIP with incoming COT. send out Update to SIP\n");
        ccEnablePrecndCb(con->ogPrecndCb);
        ccTryToInsertPrecndConfStatus(con->ogPrecndCb);
        ccSetPrecndLocalStatus(con->ogPrecndCb, PRECND_DIR_SENDRECV);

        ccSendUpdate(&con->ogBcm);
        CC_OFFANS_STATE_CHANGE(con, CC_OFFANS_STATE_NULL, CC_OFFANS_STATE_SENTOFFER,
                                           CC_OFFANS_SUBSTATE_NULL,
                                           CC_OFFANS_TYPE_UPDATE);

        PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_UPDT_SENT);
      }
    }
    else if((con->ogPrecndCb) && (CC_GET_PROTOCOL(con->icProtType) == CC_EXT_BICC))
    {
      if (!PRECND_IS_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_PRACK_SENT))
      {
        PRECND_SET_CALL_FLAG2(con->ogPrecndCb, PRECND_FLAG_NO_UPDT);
        CCDP(AIN_DBG_LEVEL_2,"BICC2SIP revert direction to OUTTOINC\n");
      }
    }
    return ROK;
}
/* - FID 17373.0 */

PRIVATE S16 ccConEXXS154
(
CcConCb *con, 
PTR event, 
AinBCM_t *bcm, 
PTR event2
)
{
    CcPrecndCb* precndCb = NULLP;
    ProtType icProtType = CC_GET_PROTOCOL(con->icProtType);
    ProtType ogProtType = CC_GET_PROTOCOL(con->ogProtType);

    CCDP(AIN_DBG_LEVEL_2,"Entering ccConEXXS154\n");

    if(!((icProtType==CC_SIP||icProtType==CC_SIPT)&&(ogProtType==CC_SI||ogProtType==CC_EXT_BICC))) /* FID17373.0 */
    {
        return ROKDNA;
    }

    precndCb = con->icPrecndCb;

    ccBufferEventToQueue(con, bcm, event, con->evntType, ccGetSizeFromEvntType(con->evntType), 0, event2, ccGetEvent2SizeFromEvntType(con->evntType));

    if(!IS_PRECND_INMGACTION(precndCb->flag) && !CC_OFFANS_ICOFFANS_PENDING(con)) 
    {
        CCDP(AIN_DBG_LEVEL_2,"EvntType:%02d, Process REATTEMPT Event!\n", con->icEvntType);
        if(ccIsRscCfmRequired(con->ogProtType)) 
        {
            CC_STATE_CHANGE(con, CCS_AWTOGRSC);
        }else
        {
            CC_STATE_CHANGE(con, CCS_AWTANS);
        }
        ccPostEventToSelf(con);
    }

    RETVALUE(ROK);
}

PUBLIC S16 ccAnswerCallsCallBack
(
CcConCb  *con
)
{
    S16            ret            = RFAILED;
    Buffer        *uBuf           = NULLP;

    CCDP(AIN_DBG_LEVEL_2,"%s entered \n", __FUNCTION__);
#if 1 /* Bug#: 17932 */
    ccRestoreCallStateOfAssociatedCalls(&(con->ogBcm));
#endif /* 1 */

  /* For SIP INFO bypass answer call (bug:25917) */
  if ((con->ogProtType == CC_SIP) &&
      ((con->icEvntType == CCSIP_ET_SIP_INFO_DTMF_DET_ON) ||
     (con->icEvntType == CCSIP_ET_SIP_INFO_DTMF_DET_OFF)))
  {
     CC_STATE_CHANGE(con, CCS_ANSWERED);
     RETVALUE(ROK);
  }

    ccBuildAndSendEventDescriptorForCAS(con);

/*euysal - 04/21/2005 - Support for O_Answer request */
#if 1
    if (con->icIntfcCb && con->ogIntfcCb &&
        (CC_GET_PROTOCOL(con->icIntfcCb->protType) == CC_SIP) &&
        (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_IN) &&
        ((con->ogIntfcCb->sipHdrColpMap == ISDN_SIPHDRCOLPMAP_MAPSCRNORIG) ||
         (con->ogIntfcCb->sipHdrColpMap == ISDN_SIPHDRCOLPMAP_MAPSCRNTERM ))
       )
    {
      CCDP(AIN_DBG_LEVEL_1,"TAnswerReq may be armed process it!\n");
      ret = ccProcessTAnswer(&(con->ogBcm));
      if (ret == ROK)
      {
        CCDP(AIN_DBG_LEVEL_1,"TAnswerReq armed!\n");
        RETVALUE(ROK);
      }
    }
    else
       ccProcessTAnswer(&(con->ogBcm));

    ret = ccProcessOAnswer(&(con->icBcm));
    if (ret == ROK)
       RETVALUE(ROK);
    else if (ret == ROKDRSIG)
      ccAnswerCall(con, (PTR)con->ccEvntHold, uBuf);
    else if (ret == RFAILED)
    {
       /* Bug 78139 */
       if (con->keepGCCCallInfo == FALSE)
       {
        con->callDtlInfo.cm.callState = LCC_CDR_UNANSWERED;
       }

       CCLOGERR("ERROR: ccprocessOAnswer FAILED: %ld\n", con->icSuConnId);
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       RETVALUE(RFAILED);
    }
#else
    ccAnswerCall(con, (PTR)con->ccEvntHold, uBuf);
#endif
    RETVALUE(ROK);
} /* end of ccAnswerCallsCallBack*/

PUBLIC S16 ccAlertingCallsCallBack
(
CcConCb  *con
)
{
  S16                  ret     = RFAILED;
  CcCnStEvnt           ogEvnt;
  Buffer               *uBuf;
  ProtType             ogProtType = 0;

  /* FID 14840 AoC */
  CcAllSdus              apmEvnt;
  AoCInfo                *aocinfo        = NULLP;
  AoCInfo                *tmpAocInfo     = NULLP;
  SiCnStEvnt  *siOut = &(apmEvnt.m.ccCnStEvnt.m.siCnStEvnt);
  U8                     tmpEventType    = CC_ET_UMSG;
  ProtType               icProtType     = 0;
  /* End of FID 14840 AoC */
  CcCnStEvnt              ccEvntHoldBuf;
  U8                      icEvntTypeBuf = 0;
  Bool                    buffered = FALSE;
  Bool                    isAcmSent = FALSE;
  U8                      flag   = 0x00;
  Bool                    precnd = FALSE;


  cmMemset((U8 *)&ogEvnt, 0, sizeof(ogEvnt));

  ogProtType = CC_GET_PROTOCOL(con->ogProtType);
  icProtType = CC_GET_PROTOCOL(con->icProtType); /* FID 14840 AoC */

  CCDP(AIN_DBG_LEVEL_1, "%s Entered \n", __FUNCTION__);
  if (NMBRCATEGORY_NOT_IVR(con))
  {
    /* Deleted CiTransfer check and moved into interworking BUG: 86363 */

    /* FID-2575: LMSD + */
    if (!CC_OFFANS_OGOFFANS_PENDING(con))
    {
      /* Free leftover SDP */
      if (con->ogIpParam.locDesc)
        cmFreeSdp(ccInit.region, ccInit.pool, &con->ogIpParam.locDesc);
    }
    /* FID-2575: LMSD - */

    /* Bug 80364 */
    if ((con->icAdjIpParam) && (con->icAdjIpParam->locDesc))
      cmFreeSdp(ccInit.region, ccInit.pool, &con->icAdjIpParam->locDesc);
    if ((con->ogLiAdjIpParam) && (con->ogLiAdjIpParam->locDesc))
      cmFreeSdp(ccInit.region, ccInit.pool, &con->ogLiAdjIpParam->locDesc);

    /* Feature 1789 - German ISUP:
     * Added for Toiw2 Timer Supporting. when CC got the Toiw2 Timer expires
     * event, and EarlyACMSt is EARLY_ACM_TO_BE_SENT, the EarlyACMSt
     * would be set to EARLY_ACM_HAS_SENT_OUT to indicate the early ACM
     * has been sent to preceding switch if it is ISUP protocol */
    if (con->EarlyACMSt == EARLY_ACM_TO_BE_SENT)
    {
       CCDP(AIN_DBG_LEVEL_1, "ccConE11S07: Build and Send early ACM to Ingress side\n");
       ccBuildSs7ACMOrCPGMsg(con, &(con->ogEvnt->m.ccCnStEvnt.m.siCnStEvnt), FALSE);
       uBuf = NULLP;
       ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                           con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                           con->icProtType, con->ogEvntType,
                           &(con->ogEvnt->m.ccCnStEvnt), uBuf);
       con->EarlyACMSt = EARLY_ACM_HAS_BEEN_SENT;

       RETVALUE(ROK);
    }

    con->icEvnt = (CcAllSdus *)con->ccEvntHold;
    con->ogEvnt = (CcAllSdus *)&ogEvnt;

    /* bug 74612 restore the held direction */
    con->direction = CC_GET_EVNTHOLD_DIR(con->directionHeld);
    con->icEvntType = con->evntTypeHeld;

    isAcmSent = con->isACMSent;

    precnd = (!CC_IS_CALL_FLAG2(con,CC_FLAG_PRECONDITION)  &&
              ((con->icPrecndCb) && (con->ogPrecndCb) &&
              ((CC_GET_PROTOCOL(con->icProtType)== CC_SIP || CC_GET_PROTOCOL(con->icProtType)==CC_SIPT) &&
              (CC_GET_PROTOCOL(con->ogProtType)== CC_SIP || CC_GET_PROTOCOL(con->ogProtType)==CC_SIPT))));


    /* FID15068.0 */
    if ((!con->isACMSent) && (CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) || precnd))
    {
      TknStrVar *callId = NULLP;
      memset((U8 *)&ccEvntHoldBuf, 0, sizeof(CcCnStEvnt));
      memcpy((U8 *)&ccEvntHoldBuf, (U8 *)con->icEvnt, sizeof(CcCnStEvnt));
      icEvntTypeBuf = con->icEvntType;
      switch(CC_GET_PROTOCOL(con->ogProtType))
      {
          case CC_SIPT:
               callId =
               &(ccEvntHoldBuf.m.siCnStEvnt.optElmnt.sipt.callId);
               break;
          case CC_SIP :
               callId = &(ccEvntHoldBuf.m.sipCnStEvnt.callId);
               break;
      }
      if (callId != NULLP)
      {
        callId->pres = NOTPRSNT;
        callId->len  = 0;
        callId->val  = NULLP;  
      }
      buffered = TRUE;
    }

    /* FID 14677.0 ITU99 change con->icEvntType to con->evntTypeHeld); */
    ret = ccMapEvent(con, CCE_CNSTIND, con->evntTypeHeld);
    if (ret == CCIGNOREMAPPING)
    {
      /* FID 14844.1 */
      CC_CLR_CALL_FLAG(con->flag, CC_FLAG_DEFER_ANS_SDP_IC);

      ccRestoreEvntHold(con);
      ccDropUBuf(&con->uBuf);
      RETVALUE(ROK);
    }
    else if (ret != ROK)
    {
       /* FID 14844.1 */
       CC_CLR_CALL_FLAG(con->flag, CC_FLAG_DEFER_ANS_SDP_IC);

       CCLOGERR( "ERROR: Mapping failed: releasing the call\n");
       ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
       RETVALUE(RFAILED);
    }

    /* FID 14844.1 */
    CC_CLR_CALL_FLAG(con->flag, CC_FLAG_DEFER_ANS_SDP_IC);

    uBuf = con->uBuf;
    con->uBuf = NULLP;

    /* FID-2112: SIP UPDATE part 2 + */
    /* Check if we need to send UPDATE to ingress */
    if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION) || precnd) && (buffered == TRUE))
    {
      con->icEvntType = icEvntTypeBuf;
      con->icEvnt = (CcAllSdus *)&ccEvntHoldBuf;
      CCDP(AIN_DBG_LEVEL_1, "%s restore con->icEvnt 0x%lx icEvntType %d\n", __FUNCTION__, (U32 )con->icEvnt, con->icEvntType);
    }

    if ((con->remoteSdpSentOnIcBCM) &&
        (con->icBcm.pic < PicOActive) &&
        !(con->isAnsIndSent) && /* Ingress Not Answered */
        (con->direction == OUTTOINC) &&
        !(CC_OFFANS_ICOFFANS_PENDING(con)) &&  /* Bug 66779 */
        (CCT_IS_UPDATE_SUPPORTED(con->icSipMethodSupMask)) &&
        (CCT_IS_100REL_SUPPORTED(con->icSipMethodSupMask)))
    {
      TknStrVar *srcSdp = NULLP;

      /* reClaim uBuf */
      if (uBuf)
        con->uBuf = uBuf;

      /* Bug:55534: Need to copy SDP from event back to con */
      srcSdp = ccFindSdpInMsg(con->icProtType, CCE_CNSTREQ, con->ogEvntType,
                              con->ogEvnt);
      if (srcSdp && srcSdp->pres)
      {
        Sdp tmpSdp;
        memset ((char *)&tmpSdp, 0, sizeof (Sdp));

        tmpSdp.r.buf = *srcSdp;
        tmpSdp.eh.pres = PRSNT_NODEF;
        /* srcSdp not own the raw sdp pointer now */
        srcSdp->val = (U8 *)NULL;
        srcSdp->len =0;
        srcSdp->pres = NOTPRSNT;

        ret = sdp_parse(&tmpSdp, (ProtoInfo *)NULL);
        if (ret != ROK)
        {
           CCLOGERR("****%s: Src Parsing failed ret=%d ****\n", __FUNCTION__, ret);
           cmFreeRawSdp(&tmpSdp);
           ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
           RETVALUE(RFAILED);
        }
        cmStoreSdp(ccInit.region, ccInit.pool, &con->icIpParam.locDesc, &tmpSdp);
      }
      /* Bug:55534: End */

      /* Call ccUpdateSession() */
      /* Bug 74382: If egress needs PRACK after receiving response of UPDATE,
       * call ccLcfUpdateNeedPRACKFunc.*/

      /* FID15068.0 */
      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (isAcmSent == FALSE) &&
          (con->isACMSent))
      {
        CCDP(AIN_DBG_LEVEL_1, "%s reset ACM is not sent as update sent out\n", __FUNCTION__);
        ccStopConTmr(con, CC_TMR_EARLYACM);
        con->isACMSent = FALSE;
      }

      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (!con->isACMSent) &&
          (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT) &&
          ((CC_GET_PROTOCOL(con->ogProtType) == CC_SI) ||
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_SI)) ||
           (CC_GET_PROTOCOL(con->ogProtType) == CC_IN) ||
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_IN)) ||
           (CC_GET_PROTOCOL(con->ogProtType) == CC_EXT_BICC) || /* FID17373.0 */
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_EXT_BICC))) &&
          (con->ogEvntType == CC_ET_ACM) &&
          (con->icPrecndCb) &&
          (!IS_PRECND_RMV_ISUP(con->icPrecndCb->flag)))
      {
        flag |= CC_UPDSES_FLAG_SENT_ACM;
        CCDP(AIN_DBG_LEVEL_1, "%s set flag to %d\n", __FUNCTION__, flag);
      }

      if (ccIsRcvdSdpReliable(con,con->ogProtType, CCE_CNSTIND,con->icEvntType, con->icEvnt) &&
          !CC_EGRESS_INTER_CCS_CALL(con)) /* Bug 92501 */
      {
	      ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, flag, ccLcfUpdateNeedPRACKFunc, (PTR)con, CCS_AWTANS);
      }
      else
      {
        ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, flag, ccLcfUpdateCbFunc, (PTR)con, CCS_AWTANS);
      }
      RETVALUE(ROK);
    } /* BUG: 78431 + */
    else if ((con->remoteSdpSentOnIcBCM) &&
             (con->renegSdpAfterAns) && /* Got rerouted */
             (con->isAnsIndSent) && /* Ingress Answered */
             (con->icBcm.pic < PicOActive) &&
             (con->direction == OUTTOINC) &&
             !(CC_OFFANS_ICOFFANS_PENDING(con)) &&  /* Bug 66779 */
              (ccIsOgEvntProvisional(con->icProtType, con->ogEvntType)) && /*55668*/
              (ccIsRcvdSdpReliable(con, con->ogProtType, CCE_CNSTIND, con->icEvntType, con->icEvnt)))

    {
      TknStrVar *srcSdp = NULLP;

      /* reClaim uBuf */
      if (uBuf)
        con->uBuf = uBuf;

      flag |= CC_UPDSES_FLAG_ANS_SENT_CNSTIND;

      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (con->icPrecndCb) &&
          !(IS_PRECND_COMPLETED(con->icPrecndCb->flag)) &&
          (CC_GET_PROTOCOL(con->ogProtType) == CC_BICC))
      {
        CCDP(AIN_DBG_LEVEL_1, "No need for UPDATE upon 18x for precondition at this time\n");
        con->icEvnt = (CcAllSdus *)con->ccEvntHold;;
        RETVALUE(ROK);
      }
      else
      {
        CCDP(AIN_DBG_LEVEL_1, "%s reset ACM is not sent as update sent out\n", __FUNCTION__);
        /* Bug:55534: Need to copy SDP from event back to con */
        srcSdp = ccFindSdpInMsg(con->icProtType, CCE_CNSTREQ, con->ogEvntType,
                              con->ogEvnt);
        if (srcSdp && srcSdp->pres)
        {
          Sdp tmpSdp;
          memset ((char *)&tmpSdp, 0, sizeof (Sdp));

          tmpSdp.r.buf = *srcSdp;
          tmpSdp.eh.pres = PRSNT_NODEF;
          /* srcSdp not own the raw sdp pointer now */
          srcSdp->val = (U8 *)NULL;
          srcSdp->len =0;
          srcSdp->pres = NOTPRSNT;

          ret = sdp_parse(&tmpSdp, (ProtoInfo *)NULL);
          if (ret != ROK)
          {
             CCLOGERR("****%s: Src Parsing failed ret=%d ****\n", __FUNCTION__, ret);
             cmFreeRawSdp(&tmpSdp);
             ccHandleCleanUpConCb(con, TRUE, CCTMPFAIL);
             RETVALUE(RFAILED);
          }
          cmStoreSdp(ccInit.region, ccInit.pool, &con->icIpParam.locDesc, &tmpSdp);
        }
      /* Bug:55534: End */

            /* FID15068.0 */
      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (isAcmSent == FALSE) &&
          (con->isACMSent))
      {
        CCDP(AIN_DBG_LEVEL_1, "%s reset ACM is not sent as update sent out\n", __FUNCTION__);
        ccStopConTmr(con, CC_TMR_EARLYACM);
        con->isACMSent = FALSE;
      }

      /* FID15068.0 */
      if ((CC_IS_CALL_FLAG2(con, CC_FLAG_PRECONDITION)) &&
          (!con->isACMSent) &&
          (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT) &&
          ((CC_GET_PROTOCOL(con->ogProtType) == CC_SI) ||
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_SI)) ||
           (CC_GET_PROTOCOL(con->ogProtType) == CC_IN) ||
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_IN)) ||
           (CC_GET_PROTOCOL(con->ogProtType) == CC_EXT_BICC) || /* FID17373.0 */
           ((con->ogIntfcCb) && (CC_GET_PROTOCOL(con->ogIntfcCb->protType) == CC_EXT_BICC))) &&
          (con->ogEvntType == CC_ET_ACM) &&
          (con->icPrecndCb) &&
          (!IS_PRECND_RMV_ISUP(con->icPrecndCb->flag)))
      {
        flag |= CC_UPDSES_FLAG_SENT_ACM;
        CCDP(AIN_DBG_LEVEL_1, "%s set flag to %d\n", __FUNCTION__, flag);
      }

      /* Call ccUpdateSession() */
      ccUpdateSession (&con->icBcm, MGCT_MODE_MAX, flag, 
                        ccLcfUpdateCbFunc, (PTR)con, CCS_AWTANS);
      RETVALUE(ROK);
      }
    } /* BUG: 78431 + */
    else
    {
      CCDP(AIN_DBG_LEVEL_1, "No need of UPDATE at this time\n");
    }
    /* FID-2112: SIP UPDATE part 2 - */

    /* FID 14840 */
    if (((icProtType == CC_SIPT) || (icProtType == CC_SI) ||
         (icProtType == CC_BICC)) && (ogProtType == CC_SIP))
    {
       CC_SET_AOCINFO_TO(con, aocinfo);
     if (((con->ogEvntType == CC_ET_ACM) || (con->ogEvntType == CC_ET_CPG)) && (aocinfo != NULLP) &&
          (aocinfo->msgType.pres == PRSNT_NODEF))
      {
        if (!CC_INGRESS_INTER_CCS_CALL(con))
        {
           if (CC_GET_PROTOCOL(con->icProtType) == CC_SIPT)
           {
               tmpAocInfo = &(siOut->optElmnt.sipt.aocInfo);
               CCT_SET_SIP_SIPT_INFO_MASK(siOut->optElmnt.sipt.headerSupportMask);
           }
           else
           {
               tmpAocInfo = &(siOut->optElmnt.isup.aocInfo);
           }
        }
        else
        {
           tmpAocInfo = &(siOut->optElmnt.bicc.aocInfo);
        }

        memcpy(tmpAocInfo, aocinfo, sizeof(AoCInfo));
      }
    }
    /* End of FID 14840 */

    if (con->direction == INCTOOUT)
    {
      ccSendCnStReq(con, con->ogSapCb->suId, &con->ogSapCb->pst,
                    con->ogSapCb->spId, con->ogSpConnId, con->ogSuConnId,
                    con->ogProtType, con->ogEvntType, &ogEvnt, uBuf);
    }
    else
    {
      /* Save the outgoing event type */
      tmpEventType = con->ogEvntType;

      ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                    con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                    con->icProtType, con->ogEvntType, &ogEvnt, uBuf);
      /* FID 14840 AoC, send APM after ACM */
      if (((icProtType == CC_SIPT) || (icProtType == CC_SI) || (icProtType == CC_BICC)) &&
          (ogProtType == CC_SIP) &&
          ((tmpEventType == CC_ET_ACM) || (tmpEventType == CC_ET_CPG)) &&
          (tmpAocInfo != NULLP) && (tmpAocInfo->msgType.pres == PRSNT_NODEF))
      {
           CCDP(AIN_DBG_LEVEL_2, "FID 14840 is to Send con->ogEvntType=%d icProtType=%#x ogProtType=%#x \n",
                              con->ogEvntType,
                              icProtType, ogProtType);

           con->ogEvntType = CC_ET_APPTRAN;
           ccSetAppTransParam(&(apmEvnt.m.ccCnStEvnt.m.siCnStEvnt));

          ccSendCnStReq(con, con->icSapCb->suId, &con->icSapCb->pst,
                     con->icSapCb->spId, con->icSpConnId, con->icSuConnId,
                     con->icProtType, con->ogEvntType, (CcCnStEvnt *)(&(apmEvnt)), uBuf);

          tmpEventType = CC_ET_UMSG;

          CCDP(AIN_DBG_LEVEL_2, "FID 14840 sent out CC_ET_APPTRAN \n");
      }
      /* End FID 14840 AoC */
    }
    ccRestoreEvntHold(con);
    ccBuildAndSendEventDescriptorForCAS(con);
    RETVALUE(ROK);
  }
  RETVALUE(ROK);
} /* End of ccAlertingCallsCallBack */

/* FID16970.0 */
/*
 *
 *      Fun:   ccConE04S152
 *
 *      Desc:  Connection state function
 *             event -Release indication - 04
 *             state - CCS_AWTNCIND
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE04S152
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  S16 ret = ROK;
  CCDP(AIN_DBG_LEVEL_2, "Enter %s.\n",__FUNCTION__);

  CcMsgEvnt ogEvnt;
  cmMemset((U8 *)&ogEvnt, 0, sizeof(CcMsgEvnt));

  if(con->ccbsIsdnCallInfo == NULL)
  {
     ccRelCon(con);
     RETVALUE(ROK);
  }

  if(con->ccbsIsdnCallInfo->ccbsIsdnMode == CCBS_ISDN_MODE_NOTIFIER)
  {
      con->icEvnt = (CcAllSdus *) event;
      con->ogEvnt = (CcAllSdus *) &ogEvnt;
      if(CC_INGRESS_INTER_CCS_CALL(con))
      {
          CCDP(AIN_DBG_LEVEL_1, "%s:Exgress CCS received RELEASE IND.\n",__FUNCTION__);
          if(con->direction == INCTOOUT)
          {
              /*send release complete to ic BICC*/
              ccSendReleaseRsp(con);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_OG);
              /*send release to ISDN*/
              TknU8 causeVal;
              TknU8 errorType;
              causeVal.pres = PRSNT_NODEF;
              causeVal.val = CCCALLCLR;
              errorType.pres = NOTPRSNT;
              ccbsIsdnSendRelReq(con, causeVal, errorType);
          }
          else
          {
              /*send release complete to ISDN*/
              ccSendReleaseRsp(con);
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              /*send release req to internal BICC*/
              ccSendRelease(con, con->icSapCb, con->icSpConnId, con->icSuConnId,
                            con->icProtType, CCTMPFAIL, NULL);
          }
      }
      else
      {
          con->ccbsIsdnCallInfo->ccbsIsdnEvent = CCBS_ISDN_EVT_REL;
          ccbsIsdnCallStateMachine(con, event);
      }
  }
  else 
  {
      CcMsgEvnt ogEvnt;

      CCBS_ISDN_SET_IC_RELEASED_MASK(con->ccbsIsdnCallInfo->ccbsIsdnFlag);
      ccSendReleaseRsp(con);
      if (!CCBS_ISDN_IS_REFRESH_SUB_SENT(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
      {
          CCDP(AIN_DBG_LEVEL_1, "%s: need to map RELEASE to SUBSCRIBE\n",__FUNCTION__);
          con->icEvnt = (CcAllSdus *) event;
          con->ogEvnt = (CcAllSdus *) &ogEvnt;
          ret = ccMapEvent(con, CCE_NCIND, IN_RELEASE_IND);
          if(ret != ROK)
          {
              CCLOGERR(" mapping  RELEASE to SUBSCRIBE failed \n");
              ccRelCon(con);
              RETVALUE(ROK);
          }
          CC_STATE_CHANGE(con, CCS_AWTNCCFM);
          CCBS_ISDN_STATE_CHANGE(con->ccbsIsdnCallInfo,
                               CCBS_ISDN_ST_WAIT_SUB200OK_TERMINATE);
          CcLiCctMsgReq(&con->ogSapCb->pst, con->ogSapCb->spId, con->ogSpConnId,
                          con->ogSuConnId, con->ogProtType, &ogEvnt);
       }
  }
  RETVALUE(ROK);
} /* end ccConE04S152 */

/*
 *
 *      Fun:   ccConE30S151
 *
 *      Desc:  Connection state function
 *             event - Buffer timer expiry -30 
 *             state - CCS_AWTNCIND/CCS_AWTNCCFM
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE30S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  TknU8 causeVal;
  TknU8 errType;

  if(con->ccbsIsdnCallInfo == NULLP)
  {
     CCDP(AIN_DBG_LEVEL_2, "not CCBS call, returning\n");
           RETVALUE(ROK);
  }
  CCDP(AIN_DBG_LEVEL_2, "Enter %s.\n",__FUNCTION__);

  if (!CCBS_ISDN_IS_IC_RELEASED(con->ccbsIsdnCallInfo->ccbsIsdnFlag))
  {
     causeVal.pres = PRSNT_NODEF;
     causeVal.val = CCFACREJ;
     errType.pres = NOTPRSNT;
     ccCleanUpBufferedEvent(con);
     ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
     CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
     ccbsIsdnSendRelReq(con, causeVal, errType);
     RETVALUE(ROK);
  }
  ccRelCon(con);
  RETVALUE(ROK);
}

PUBLIC S16 ccPrepareExtBiccConReq (CcConCb *con)
{
   ProtType        icProtType   = CC_GET_PROTOCOL(con->icProtType);
   ProtType        ogProtType   = CC_GET_PROTOCOL(con->ogProtType);
   ProtType        icRealIcProtType = 0;
   Bool            isClearModePref = FALSE;
   Bool            isFaxSdp = FALSE;
   SiUsrServInfo *usrServInfoA = NULLP;
   BearCap       *bearCap  = NULLP;
   Sdp           *sdp = NULLP;
   MediaStream_t *msPtr = NULLP;
   BiccApmUserInfo apmUserInfo;
   U8 idx = 0;
   U8 cdcIdx = 0;
   U8 tgtCdcIdxVal;
   U8 orgId;
   U8 cdcType;
   U8 cdcTypeFlag;
   U8 tgtCdcTypeFlag = con->ogExtBiccCb->tgtCdcTypeFlag;
   CodecList *cdcLst = &con->ogExtBiccCb->apmUsrInfoData->cdcLst;
   S16            ret = ROK;

   if (con->icIntfcCb)
        icRealIcProtType = CC_GET_PROTOCOL(con->icIntfcCb->protType);

   if (con->ccHeldSdpForCfna)
   {
          isClearModePref = ccIsClearModePrefCodec(con->ccHeldSdpForCfna);
          isFaxSdp = ( ccTestSDPForFax(con->ccHeldSdpForCfna) == ROK ) ? TRUE : FALSE;
          CCDP(AIN_DBG_LEVEL_0, "isClearModePref:%d, isFaxSdp: %d\n", isClearModePref, isFaxSdp);
         cmFreeSdp(ccInit.region, ccInit.pool, &con->ccHeldSdpForCfna);
   }

   if (ogProtType == CC_EXT_BICC)
   {
          /* FID 16747.0 */
          if((icRealIcProtType == CC_SIP) ||
             (icRealIcProtType == CC_SIPT))
          {
              if(icProtType == CC_SIP)
              {
                  usrServInfoA = &con->ccEvntHold->m.ccConEvnt.m.sipConEvnt.usrServInfoA; 
              }
              else
              {
                 usrServInfoA = &con->ccEvntHold->m.ccConEvnt.m.siConEvnt.usrServInfoA;
              }
              if ( isClearModePref ) 
              {
                  usrServInfoA->eh.pres = TRUE;
                  usrServInfoA->infoTranCap.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranCap.val = ITC_UNRDIG;
                  usrServInfoA->infoTranRate0.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranRate0.val = ITR_64KBIT;
              }
              else if(con->faxCb.faxTrigger)
              {
                  usrServInfoA->eh.pres = TRUE;
                  usrServInfoA->infoTranCap.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranCap.val = ITC_A31KHZ; 
                  usrServInfoA->infoTranRate0.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranRate0.val = ITR_PKT;
                  con->t38Prsnt = T38_PRSNT_RMT;
              }
              /* Bug 83250 */
              else if((!CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb)) && 
                    ((usrServInfoA->eh.pres != PRSNT_NODEF) ||
                    (usrServInfoA->infoTranCap.val != ITC_UNRDIG)))
              {
                  usrServInfoA->eh.pres = TRUE;
                  usrServInfoA->infoTranCap.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranCap.val = ITC_SPEECH;
                  usrServInfoA->infoTranRate0.pres = PRSNT_NODEF;
                  usrServInfoA->infoTranRate0.val = ITR_PKT;
              }
          }
          else if(icProtType == CC_IN)
          {
             bearCap = &con->ccEvntHold->m.ccConEvnt.m.inConEvnt.bearCap[0];
          }

          /* populate the SiAppTrans */
          cmMemset((U8 *) &apmUserInfo, 0, sizeof(BiccApmUserInfo));
          apmUserInfo.data.actInd.pres = PRSNT_NODEF;
          apmUserInfo.data.actInd.val = AI_CONFWD;
          apmUserInfo.data.bncChar.pres = PRSNT_NODEF;
          apmUserInfo.data.bncChar.val = BC_IP_RTP;
          apmUserInfo.data.bCntrlTun.pres = PRSNT_NODEF;
          apmUserInfo.data.bCntrlTun.indicator = 1;

          if (((!isClearModePref) && (usrServInfoA) && (usrServInfoA->infoTranCap.val != ITC_UNRDIG)) ||
               (bearCap && (bearCap->infoTranCap.pres) && (bearCap->infoTranCap.val != ITC_UNRDIG) ))
          {
              /* FID 16747.0 */
              if (CC_IS_PROT_TYPE_ANSI_BICC(con->ogIntfcCb))
              {
                  apmUserInfo.data.cdcLst.cdc[0].cdcInfo.cdcType = CT_G711_64K_M;
              }
              else
              {
                  if (con->ogIpParam.locDesc)
                  {
                      sdp = con->ogIpParam.locDesc;
                      msPtr = (MediaStream_t *)&sdp->p[0];
                      orgId   = msPtr->m.voip.codecCfg[0].orgnId.val;
                      cdcType = msPtr->m.voip.codecCfg[0].codecInfo.val;
                      apmUserInfo.data.cdcLst.cdc[cdcIdx].pres = PRSNT_NODEF;
                      apmUserInfo.data.cdcLst.cdc[cdcIdx].orgId = orgId;
                      apmUserInfo.data.cdcLst.cdc[cdcIdx].cdcInfo.cdcType = cdcType;
                      
                      if (cdcType == CTE_UMTS_AMR2)
                      {
                          if (msPtr->m.voip.codecCfg[0].bitMap.pres &&
                              strlen(msPtr->m.voip.codecCfg[0].bitMap.val) == 6)
                          {
                              ccStr2Hex(apmUserInfo.data.cdcLst.cdc[cdcIdx].cdcInfo.cdcCfg, 
                                        msPtr->m.voip.codecCfg[0].bitMap.val, 3, 
                                        &apmUserInfo.data.cdcLst.cdc[cdcIdx].cdcInfo.length);
                          }
                      }

                      cdcIdx++;
                      CC_MAP_CT_FLAG(orgId, cdcType, cdcTypeFlag);
                      CC_CLR_CT_FLAG(tgtCdcTypeFlag, cdcTypeFlag);
                  }

                  while (idx < MAX_CDC_LIST && tgtCdcTypeFlag != 0)
                  {
                      tgtCdcIdxVal = con->ogExtBiccCb->tgtCdcIdx[idx++];
                      orgId   = cdcLst->cdc[tgtCdcIdxVal].orgId;
                      cdcType = cdcLst->cdc[tgtCdcIdxVal].cdcInfo.cdcType;
                      CC_MAP_CT_FLAG(orgId, cdcType, cdcTypeFlag);
                      if (CC_IS_CT_FLAG_SET(tgtCdcTypeFlag, cdcTypeFlag) != 0)
                      {
                          apmUserInfo.data.cdcLst.cdc[cdcIdx++] = cdcLst->cdc[tgtCdcIdxVal];
                          CC_CLR_CT_FLAG(tgtCdcTypeFlag, cdcTypeFlag);
                      }
                  }

                  apmUserInfo.data.cdcLst.numCdcs = cdcIdx;
                  apmUserInfo.data.cdcLst.pres = PRSNT_NODEF;
              }
          }
          else
          {
              CCDP(AIN_DBG_LEVEL_1, "%s: Unsupported TransCap\n", __FUNCTION__);
          }

          ccSetBiccAppTransParam(&con->ainInfo.appInfo);

          if ( ccEncdEncapAppInfo(&apmUserInfo, (U8 *)&con->ainInfo.appInfo.ApmUserInfo.val, 
                      (U16 *)&con->ainInfo.appInfo.ApmUserInfo.len) == ROK )
          {
              con->ainInfo.appInfo.ApmUserInfo.pres = PRSNT_NODEF;
              con->ainInfo.appInfo.eh.pres = PRSNT_NODEF;

              CC_SET_EXTBICC_BEARERSTATE(con,CC_OUTGOING,CC_BICC_STATE_SENT_CONFWD);
              CC_STATE_CHANGE(con, CCS_AWTANS);
          }
          else
          {
              /* release call */
              CCLOGERR( "encoding failed\n");
              ccStopConTmr(con, TMR_SETUP);
              ccStopConTmr(con, AIN_T_NO_ANS_TMR);
              ccDeleteBufferedEvent(con, con->ogSuConnId, CCE_TNOANSEXP);

              ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
              ccDeallocateResource(con, CC_OUTGOING);
              con->ogRscVal = FALSE;

              if (CC_IS_CONTEXT_PRESENT(con))
              {
                  ccQSubBasedOnCcn(con);
                  con->mgBlock->con = con;
                  ret = ccSendMgiQueue(0, con->mgBlock);
                  if (ret != ROK)
                  {
                      CCLOGERR( "**** ERROR: can't do ccSendMgiQueue *******\n");
                      cleanUpMgQ(con);
                      ccCleanUpMGCtx(con);
                  }
                  else 
                  {
                      con->relPend = ICRELONLY;
                      con->tempHolderForReleaseCause = CCPROTERR;
                      con->mgBlock->con = con;
                      CC_STATE_CHANGE(con, CCS_AWTSWTCFM_SENDONEREL);
                      RETVALUE(ROK);
                  }
              }
              CC_STATE_CHANGE(con, CCS_AWTRELCFM_IC);
              ccSendRelease(con,con->icSapCb, con->icSpConnId, con->icSuConnId, 
                            con->icProtType, CCPROTERR, NULL);
              RETVALUE(RFAILED);
          }
   }
   RETVALUE(ROK);
}

/*
 *
 *      Fun:   ccConE13S151
 *
 *      Desc:  Connection state function
 *             event - StatusIndication - InitRel
 *             state - CCS_AWTNCIND/CCS_AWTNCCFM
 *
 *      Ret:   ROK     - successful,
 *             RFAILED - unsuccessful
 *
 *      Notes: None.
 *
 *      File:  cc_bdy2.c
 *
*/
PRIVATE S16 ccConE13S151
(
CcConCb *con,                    /* connection */
PTR     event,                   /* event */
AinBCM_t *bcm,                    /* bcm */
PTR     event2                    /* event */
)
{
  TknU8         causeVal;
  TknU8         errorType;
  CcbsEvntPkg_t ccbsEvntPkg;

  if(con->ccbsIsdnCallInfo == NULLP)
  {
     CCDP(AIN_DBG_LEVEL_2, "not CCBS call, returning\n");
     RETVALUE(ROK);
  }
  CCDP(AIN_DBG_LEVEL_2, "Enter %s.\n",__FUNCTION__);

  ccbsIsdnStopAllTmrs(con);
  CC_STATE_CHANGE(con, CCS_AWTRELCFM_BOTH);

  cmMemset((U8 *)&causeVal, 0, sizeof(TknU8));
  cmMemset((U8 *)&errorType, 0, sizeof(TknU8));
  cmMemset((U8 *)&ccbsEvntPkg, 0, sizeof(CcbsEvntPkg_t));
  causeVal.pres = PRSNT_NODEF;
  causeVal.val = CCCALLCLR;
  ccStartConTmr(TMR_RELEASE, con, (PTR)&ccCp.genCfg);
  ccbsIsdnSendRelReq(con, causeVal, errorType);

  if(con->ccbsIsdnCallInfo->ccbsIsdnMode == CCBS_ISDN_MODE_NOTIFIER &&
		  con->direction == OUTTOINC)
  {
	  CCDP(AIN_DBG_LEVEL_2, "%s: CCBS Notifier mode\n", __FUNCTION__);
	  ccbsIsdnSendNotReq(con,(U8)NOTIFY_SUB_STATE_TERMINATED,0,(U32)0,ccbsEvntPkg);
  }
  else if(con->ccbsIsdnCallInfo->ccbsIsdnMode == CCBS_ISDN_MODE_SUBSCRIBER &&
		  con->direction == INCTOOUT)
  {
	  CCDP(AIN_DBG_LEVEL_2, "%s: CCBS SUB mode\n", __FUNCTION__);
	  ccbsIsdnStartTmr(CCBS_ISDN_GUARD_TMR, con, CCBS_ISDN_WAIT_RSP_TMR_VAL);
	  ccbsEvntPkg.pres = PRSNT_NODEF;
	  ccbsEvntPkg.qNature = CCBS_Q_NATURE_YES;
	  ccbsEvntPkg.cancelReason.pres = PRSNT_NODEF;
	  ccbsEvntPkg.cancelReason.val = SIP_CAN_REAS_OPR_SRVC_DURATION;
	  ccbsEvntPkg.caller = con->ccbsIsdnCallInfo->cgPtyNum;
	  ccbsIsdnSendSubReq(con, 0, ccbsEvntPkg);
  }

  RETVALUE(ROK);
}

/********************************************************************30**
  
End of file: cc_bdy2.c 1.5  -  12/21/99 07:10:27

*********************************************************************31*/


/********************************************************************40**

Notes:

*********************************************************************41*/

/********************************************************************50**

*********************************************************************51*/

   
/********************************************************************60**
  
Revision history:
  
*********************************************************************61*/
  
/********************************************************************90**
 
ver       pat    init                  description
------------ -------- ---- ----------------------------------------------
1.1          ---      rs   1. initial release.
1.2          ---      rs   1. Changes for the ICC release 1.2
1.3          ---      rs   1. Changes for the ICC release 1.3
1.3+         cc001.13 mg   1. Route Release Indication in CCS_ANSWERED state
                              calls an ccUnexpEvent.
             cc001.13 mg   2. icRsc and ogRsc need to be copied from the
                              RmtAlocCfm before issuing an RmtDealocCfm.
             cc001.13 mg   3. dealocPend must be set to false upon 
                              receiving one RmtDealocCfm.
1.4          ---      mg   1. Changes for ICC 1.4 release. 
  
1.5          ---      zy   1. Changes for ICC 1.5 release. 

1.5+         cc001.15 dw   1. CC_ECHO_CONTROL and CC_CONT_CHECK removed
             cc001.15 rs   1. Fixes for call reattempt scenario. Modified code 
                              to request RM to allocate a different resource
                              on the same interface.
             cc011.15 tej  1. Updated ccConIntE01SOK() to pass the right
                              parameter to the function ccGenTrcInd().
             cc019.15 tej  1. Address Indication event is dropped if 
                              routing for the call is successful (i.e. if
                              STDigitRecd is already set to TRUE).
                           2. Updated ccConE02SND() to send CALL PROCEEDING
                              message on the incoming interface if STDigitRecd
                              is set to TRUE and CALL PROCEEDING needs to be 
                              sent on the incoming interface.
                           3. Updated ccConE10SXX() to ignore the event as
                              the necessary action would have already been 
                              taken.
                           4. Updated ccConE10S21() so that the memory 
                              associated with the call is released when 
                              both the resources are deallocated.
            cc020.15 tej  1. Changes for SFT Version 3
            cc023.15 zy   1. In case of outgoing resource alocation failure for
                             ANSI ISUP to ISDN call, use cause value CCUSRBSY.
            cc024.15 zy   1. copy switching result in function ccConE11S07.
            cc025.15 zy   1. bug fix for SFT_VER_3 and add sts.answered 
                             in ccConE11S08.
            cc026.15 dw   1. Modified ccConE11S28 for solving the bug in case
                             of switching failure
                     zy   2. Update cdrStartTick when CDR timer starts or
                             restarts.
            cc028.15 zy   1. Set staticBind flag to be RM_NO_PREF in case of
                             reattemp to alocate a new resource for outgoing
                             resource.
            cc031.15 dw   1. Modified processing to correct release of switching                             resources in case of release or setup timer
                             expiry.
             ---      ak   1. Added fct.x in the include list.
             ---      ak   1. Added entries in the stateTable to 
                              support AIN.
             ---      ak   1. Changes required because of addition
                              of some states to handle release
                              when waiting for a response from
                              FIC.
                           2. Added the new states and events in the 
                              functions ccStateStr and ccEventStr respectively
             ---      ak   1. Implemented new functions for handling release
                              messages when waiting for response from FIC.
             ---      ak   1. Added new function ccConE37S37
             ---      ak   1. Implemented ccConE38S39 and also made major AIN
                              changes to ccConE09S04
             ---      ak   1. Initialization of buffers before sending message
                              to FIC.
             ---      ak   1. AIN GCC development: Added code for updating
                              the call configuration when BcmInfo is filled.
                              Also added stdlib.h for removing warning because
                              of functions used (atoi and free).
             ---      ak   1. AIN GCC development: Implemented ccConE41S39.
             ---      ak   1. AIN GCC development: Implemented ccConCleanUp.
             ---      ak   1. AIN GCC development: Made minor Changes as per
                                                   R5-241 GR1298
             ---      ak   1. AIN GCC development: Implemented OANSWER
                                                   Notification event.
             ---      ak   1. AIN GCC development: Implemented ONOANSWER
                                                   Requested Event and
                                                   T_ONO-ANSWER timer.
*ee********************************************************************91*/
