#include "tl1_common_impl.h"
#include "TimerUtils.h"
#include "db_schema_version.h"
#include "tb_sid.h"
#include "tb_m3uac.h"
#include "tb_t1.h"
#include "tb_e1.h"
#include "tb_pmt1.h"
#include "tb_tht1.h"
#include "tb_the1.h"
#include "tb_lpbkt1.h"
#include "tb_lpbk_e1.h"
#include "tb_ipfltr.h"
#include "tl1_exec.h"
#include "tl1_db.h"
#include "OalPthread.h"
#include "OalGen.h"
#include "OalIpUtils.h"
#include "tl1_advroute.h"
#include "tb_ain.h"
#ifdef ATCA
#include "tb_stgsys.h"
#include "tb_m3uastate.h"
#include "tl1_swlic.h"
#include "swlic_utils.h"
#include "tl1_radius.h"
#endif

#ifndef IPPROTO_IP
#define IPPROTO_IP   0    /* for RuleIpfltr: copied from <bsd/in.h>, can't */
#endif

#define IPPROTO_MAX  256  /* include here due to conflicts and pre-reqs    */
#define QUOTEPAIR_SIZE 2  /* Number of bytes for a pair of quotes          */

unsigned char disableforceCharMode[]={255,252,3};
unsigned char disableforceEchoMode[]={255,252,1};
extern unsigned char forceCharMode[];
extern unsigned char forceEchoMode[];

extern int CheckBackup;

/* BUG 86485 */
extern eosl_bool BootEnabled; 
extern eosl_bool HUGEnabled;

static RTRV_VERS_TL1_resp_row adapterVer[]= { {"EM_NE","0.3.4.0.0"},
                                              {NULL,NULL} };
/* If we get back a NULL string pointer, we may need to set it to a string with just two
 * double quotes.  An empty string for a parameter that is NOT optional screws up the EM. */
/*static char emptyQuotesString[] = {'\"','\"','\0'};*/
extern SccpSsnStartup MAPTL1TSMCSccpSsnSt[2];
extern SccpRouteStartup_ENUM MAPTSMCTL1SccpSsnSt[2];

extern char * LOGNAME[];

eosl_bool s_RTRV_LOG_resp( eosl_handle handle,
                           TL1_TAG ctag,
                           TL1_COMPLETION_CODE tcc,
                           TL1_BUFFER * tl1_b);

eosl_bool s_RTRV_AO_resp( eosl_handle handle,
                          TL1_TAG ctag,
                          TL1_COMPLETION_CODE tcc,
                          TL1_BUFFER * tl1_b);

eosl_bool assignDiskThreshold(eosl_handle handle, TL1_TAG ctag, int action,
        int *inDiskLow, int *inDiskMed, int *inDiskHigh, TL1_BUF_t *outCmdMsg);

typedef enum
{
    DSN_DS1,
    DSN_DS3
} DSN_TYPE_t;

#include "agc_EM_NE_req.h"

char alphaNumAddressList[]= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
char bannerList[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _-.,:#*&/\'";
char ALPHANUM_DASH_DOT_FWDSLASH_STAR_UNDERSC[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-./*_";

/**
 * (C) Copyright Lumos Technologies Inc. 1997 - 1999 - All rights
 * reserved
 *
 * Unpublished - All rights reserved under the copyright laws of the
 * United States
 *
 * This file is furnished under a license and use, duplication
 * disclosure and all other uses are restricted to the rights
 * specified in the written license agreement between the licensee
 * and Lumos Technologies Inc.
 *
 * This file contains generated code that needs to be complemented by the
 * by the user.
 * 
 * Created Wed Jun 12 18:34:01 EDT 2002
 * Filename : agc_EM_NE_impl.c
 * The current file contains request function skeleton EM_NE adapter
 */

#ifdef ATCA

/* block SIGC/D change for IBC4 */
#define BLOCK_SIGC_D_ON_IBC4                                            \
  do{                                                                   \
      if(procInfo.IsChassisIBC4) {                                         \
          tc_error_response( handle, ctag, TE_IIDT,                     \
                             "Input, SigC/D aren't allowed on IBC4." ); \
          return eosl_false;                                            \
      }                                                                 \
  }while(0)

eosl_bool validate_ATCA_AMC_ENT( char * _swVersion,                     \
                                 AtcaCardType_ENUM *_cardType,          \
                                AtcaRedundancy_ENUM * _redundancy,      \
                                 char * _poolId,                        \
                                 int * _memThreshold,                   \
                                 int * _nvMemThreshold,                 \
                                 int * _busyThreshold,                  \
                                 char * _emIPv4Fixed,                   \
                                 char * _emIPv4Floating,                \
                                 int * _emIPv4NtwkMask,                 \
                                 int * _emFailoverTmr,                  \
                                 char * _sigAIPv4Fixed,                 \
                                 char * _sigAIPv4Floating,              \
                                 int * _sigAIPv4NtwkMask,               \
                                 int * _sigAFailoverTmr,                \
                                 char * _sigBIPv4Fixed,                 \
                                 char * _sigBIPv4Floating,              \
                                 int * _sigBIPv4NtwkMask,               \
                                 int * _sigBFailoverTmr,                \
                                 char * _sigCIPv4Fixed,                 \
                                 char * _sigCIPv4Floating,              \
                                 int * _sigCIPv4NtwkMask,               \
                                 int * _sigCFailoverTmr,                \
                                 char * _sigDIPv4Fixed,                 \
                                 char * _sigDIPv4Floating,              \
                                 int * _sigDIPv4NtwkMask,               \
                                 int * _sigDFailoverTmr,                \
                                PrimaryStateIn_ENUM * _pst,             \
                                char** errmsg);

eosl_bool validate_ATCA_AMC_ED(char * _swVersion,                     \
                               AtcaRedundancy_ENUM * _redundancy,     \
                               char * _poolId,                        \
                               int * _memThreshold,                   \
                               int * _nvMemThreshold,                 \
                               int * _busyThreshold,                  \
                               char * _emIPv4Fixed,                   \
                               char * _emIPv4Floating,                \
                               int * _emIPv4NtwkMask,                 \
                               int * _emFailoverTmr,                  \
                               char * _sigAIPv4Fixed,                 \
                               char * _sigAIPv4Floating,              \
                               int * _sigAIPv4NtwkMask,               \
                               int * _sigAFailoverTmr,                \
                               char * _sigBIPv4Fixed,                 \
                               char * _sigBIPv4Floating,              \
                               int * _sigBIPv4NtwkMask,               \
                               int * _sigBFailoverTmr,                \
                               char * _sigCIPv4Fixed,                 \
                               char * _sigCIPv4Floating,              \
                               int * _sigCIPv4NtwkMask,               \
                               int * _sigCFailoverTmr,                \
                               char * _sigDIPv4Fixed,                 \
                               char * _sigDIPv4Floating,              \
                               int * _sigDIPv4NtwkMask,               \
                               int * _sigDFailoverTmr,                \
                               PrimaryStateIn_ENUM * _pst,             \
                               char** errmsg);

#endif
/**
 */
eosl_bool agc_EM_NE_ALW_MSG_USER_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid, NotificationCode_ENUM * _ntfcncde, ConditionType_ENUM * _condtype, char * _tmper)
{

    int result;
    const char * userName;
    int InhMsg=0;

    userName = tc_session_get_username(handle);
    if (strcmp(userName, _uid) != 0)
    {
        tc_error_response(handle,ctag,TE_PIUC,"ALW-MSG-USER Failed");
        return eosl_false;
    }
    
    if(_ntfcncde)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> ntfcncde" );
        return eosl_false;
    }   
    if(_condtype)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> condtype" );
        return eosl_false;
    }   
    if(_tmper)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> tmper" );
        return eosl_false;
    }   

    result=ModifyUserDb(_uid, NULL, NULL, NULL,NULL, NULL, NULL,
                        NULL, &InhMsg, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
    if(result == -1)
    {
        tc_error_response( handle, ctag, TE_SROF, "ALW-MSG-USER Failed" ); 
        return eosl_false;
    }
    else
    {     
        synchActiveSessions(_uid);
        return tc_compld_comment( handle, ctag, "ALW-MSG-USER" );
    }
}


/**
 * ALLOW-LOOPBACK permits an NE to automatically operate the loopback on a
 * specified equipment unit, facility, subscriber line, trunk, link, packet link, or
 * signaling link in the NE.
 */
eosl_bool agc_EM_NE_ALW_LPBK_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _src)
{
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "ALW-LPBK-T1";
    char            T3Comment[] = "ALW-LPBK-T3";
    char            E1Comment[] = "ALW-LPBK-E1";
    char            *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _src, (AID_PORT | AID_OC3_STS1_T1 | AID_OC12_STS1_T1 | AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            printf("agc_EM_NE_ALW_LPBK_DSnFacility_req(): buffer.DeviceMap %d\n", buffer.DeviceMap);
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ALW_LPBK_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ALW_LPBK_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _src, AID_T3,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ALW_LPBK_E1;
        p_comment = E1Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _src, AID_E1,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }

    /*
    ** Prepare response buffer
    */

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ALW_LPBK_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, p_comment );
}


/**
 * Instructs an NE to resume processing those PM reports that are inhibited. GR 833.
 */
eosl_bool agc_EM_NE_ALW_PMREPT_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id)
{
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "ALW-PMREPT-T1";
    char            T3Comment[] = "ALW-PMREPT-T3";
    char            *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ALW_PMREPT_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ALW_PMREPT_IF;
        p_comment = T3Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3), &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier - Only T1 & T3 supported at this time." );
        return eosl_false;
    }

    /*
    ** Prepare event
    */
    buffer.Tl1Cmd.Cmd = cmd;
    buffer.Tl1Cmd.SessionHandle = handle;
    buffer.Tl1Cmd.CTag = ctag;

    /*
    ** Prepare response buffer
    */

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ALW_PMREPT_TX_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, p_comment );
}


/**
 * Instructs an NE to allow automatic or manual switching of an equipment unit or facility to protection. The AID parameter is used to specify the unit being allowed
 * (either the working or the protection unit). This function is sometimes called release lockon or release lockout.
 * This command is not to be used for SONET line protection switching. For SONET line protection switching commands,
 * see EX SW, OPR PROTNSW, and RLS PROTNSW. GR 833.
 */
eosl_bool agc_EM_NE_ALW_SWTOPROTN_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sw_id)
{

    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    TL1_BUF_t                     respBuff;


#ifdef ATCA
    if(ParseAidMap(&aidInfo, _sw_id, AID_ACM, NULL))
#else
    if(ParseAidMap(&aidInfo, _sw_id, AID_IOM, NULL))
#endif
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#ifdef ATCA
    cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
#else
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ALW_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ALW_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ALW-SWTOPROTN-EQPT" );
}


/**
 * ALLOW-SWITCHING TO WORKING instructs an NE to allow
 * automatic or manual switching of an equipment unit or
 * facility back to working.
 */
eosl_bool agc_EM_NE_ALW_SWTOWKG_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;


    if(ParseAidMap(&aidInfo, _src, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;


    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ALW_SWTOWKG,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ALW_SWTOWKG,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ALW-SWTOWKG-EQPT" );
}

/**
 */
eosl_bool agc_EM_NE_ALW_EX_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
    AID_INFO_TYPE_t     aidInfo;
    TL1_BUF_t           cmdMsg;
    CMD_BUF_t           respBuff;


    memset(&cmdMsg,0x0,sizeof(TL1_BUF_t)); /* set all valid flags=0 */
    /*
    ** let's do the slot stuff first(for command ALW-EX-EQPT)
    */
#ifdef ATCA   
    if (_iomOrSp)
    { 
        if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM, NULL))
        { 
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
    }
    else        
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Missing Aid" );
        return eosl_false;
    }
#else
	if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif
    /*
    ** Prepare event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ALW_EX,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ALW_EX,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ALW-EX-EQPT" );
}

/**
 */
eosl_bool agc_EM_NE_ALW_TL1_CMD_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _tl1cmd)
{

    INHCMD_DATA_t *tl1cmdPtr;
    INHCMD_DATA_t *cmds;
    int mode=RTRV_ROW;
    int result;
    int count =0;
    int retVal;

    /* If the inhibited command array can not be dynamically allocated */
    if ((cmds = (INHCMD_DATA_t *)eosl_malloc(
        sizeof(INHCMD_DATA_t) * MAX_INH_TL1_CMD)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_ALW_TL1_CMD_req",
                    "agc_EM_NE_ALW_TL1_CMD_req malloc failure\n");
        return eosl_false;
    }
    memset(cmds, 0, (MAX_INH_TL1_CMD * sizeof(INHCMD_DATA_t)));
	
    /* make sure to enable a command that exists */
    tl1cmdPtr=RtrvTl1CmdRow(_tl1cmd, mode, &count, cmds);
	
    if ((tl1cmdPtr==NULL) || (count < 1))
    {
        tc_error_response(handle,
                          ctag,TE_IENE,
                          "Specified Object Entity Does Not Exist");
        eosl_free(cmds);
        return eosl_false;
    }

    result=DelInhTL1CmdFromDB(_tl1cmd);
    if (result != -1)
    {
        retVal=SaveInhTl1cmdsFrmDbToMem();
        if(retVal < 0)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ALW_TL1_CMD_req", 
                       "agc_EM_NE_ALW_TL1_CMD_req Failed to "
                       "refresh tl1InhCmdArray\n");
        }
        eosl_free(cmds);
        return tc_compld_comment( handle, ctag, "ALW-TL1-CMD" );
    }
    else
    {
        tc_error_response(handle,
                          ctag,TE_SROF,
                          "Failed to enable TL1 command from INH mode");
    }
    eosl_free(cmds);
    return eosl_false;
}

/**
 * COPY-MEMORY instructs an NE to copy data from a specified memory storage
 * device (internal or external) to another.
 */
eosl_bool agc_EM_NE_CPY_MEM_req( const char * modifier,\
                                 eosl_handle handle,\
                                 TL1_TAG ctag ,\
                                 TL1_AID _src,\
                                 BoolYN_ENUM * _forcedInstall, \
                                 char * _downgradeSwVersion)
{
    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;


    if(ParseAidMap(&aidInfo, _src, (AID_CPU | AID_IOM), NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
     memset(&cmdMsg, 0, sizeof(TL1_BUF_t));
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
    /* Assign the forcedInstall field in
       the API struct based on the parameter */
    
    /* If the forced install parameter was explicitly specified */
    if (_forcedInstall)
    {
        cmdMsg.CmdInfo.cpyMem.forcedInstall = (*_forcedInstall == BoolYN_Y)
           ? CPYMEM_FORCEDINSTALL_ENABLED : CPYMEM_FORCEDINSTALL_DISABLED;
    }
    else
    {
        /* Default forcrdInstall option to DISABLED */
        cmdMsg.CmdInfo.cpyMem.forcedInstall = CPYMEM_FORCEDINSTALL_DISABLED;
    }
    
    if(_downgradeSwVersion)

    {
        strncpy(cmdMsg.CmdInfo.cpyMem.downgradeSwVersion, _downgradeSwVersion, sizeof(cmdMsg.CmdInfo.cpyMem.downgradeSwVersion));
        cmdMsg.CmdInfo.cpyMem.downgradeSwVersion[sizeof(cmdMsg.CmdInfo.cpyMem.downgradeSwVersion) - 1] = '\0';
        
}

    
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_COPY_MEM,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_COPY_MEM,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "CPY-MEM" );
}

/**
 */
eosl_bool agc_EM_NE_EMFDBG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _dbgcmd)
{

	TL1_EMF_DATA_t tl1_evt_data = { 0 };
	TL1_EMF_DATA_t respBuff;

    memset(&respBuff, 0, sizeof(TL1_EMF_DATA_t));

 
    if (_dbgcmd == NULL)  /* Shouldn't happen -- mandatory parameter */
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    if (strlen(_dbgcmd) > DEBUG_EMF_COMMAND_STR_LEN)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }


    /*
    ** Prepare response buffer
    */

    /* 
    ** Send event
    */
	tl1_evt_data.EventType = TL1_EMF_DEBUG_EMF_CMD;

	strncpy(tl1_evt_data.Data.DebugEmf.CmdBuffer, _dbgcmd, DEBUG_EMF_COMMAND_STR_LEN);
	/*tl1_evt_data.Data.DebugEmf.CmdBuffer[sizeof(tl1_evt_data.Data.DebugEmf.CmdBuffer) - 1] = '\0';*/

    if (TL1SendEmfEvent(&tl1_evt_data) == SUCCESS)
	{	   	
		procLogMsg (PLOG_INFO,
                    "agc_EM_NE_EMFDBG_req",
					"agc_EM_NE_EMFDBG_req: Event type %d is sent\n", TL1_EMF_DEBUG_EMF_CMD);
	}
	else
	{
		procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_EMFDBG_req",
                    "agc_EM_NE_EMFDBG_req: ERROR - Failed TL1SendEmfEvent\n");
	}
	

    return tc_compld_comment( handle, ctag, "EMFDBG" );
}

/**
 */
eosl_bool agc_EM_NE_ENT_CALL_CAPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _trcId, char * _cgpn, char * _cdpn)
{
       
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colnCnt=0;
    int            cmd=SM_ENT_REQUEST;



    tableId = CALLTRC_CRIT_TABLE_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    /*validate AID to permit only numbers within*/
    if(!(IsInputStrInRange(_trcId,"0123456789")))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType =TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =atoi(_trcId);

    if(_cgpn)
    {
    
        /*validate string to permit only numbers within*/
        if((!(IsInputStrInRange(_cgpn,"0123456789"))) || (strlen(_cgpn) > 21))  
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid cgpn" );  
            return eosl_false;       
        }
        columns[colnCnt].columnId = TS_COL_CALLTRC_CGPN;
        columns[colnCnt].value.colType = TSSMI_OCTET_STRING;
        columns[colnCnt].value.value.stringVal.len = strlen(_cgpn);
        columns[colnCnt].value.value.stringVal.ptr = _cgpn;
        colnCnt++;
    }
    
    if(_cdpn)
    {
        /*validate string to permit only numbers within*/
        if((!(IsInputStrInRange(_cdpn,"0123456789"))) || (strlen(_cdpn) > 21))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid cdpn" );  
            return eosl_false;       
        }
        columns[colnCnt].columnId = TS_COL_CALLTRC_CDPN;
        columns[colnCnt].value.colType = TSSMI_OCTET_STRING;
        columns[colnCnt].value.value.stringVal.len = strlen(_cdpn);
        columns[colnCnt].value.value.stringVal.ptr = _cdpn;
        colnCnt++;
    }

    if((_cgpn == NULL) && (_cdpn == NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input Invalid, cgpn and cdpn Cannot Be Both Null." );  
        return eosl_false;    
    }

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_CALL_CAPT_req", "ENT_CALL_CAPT - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-CALL-CAPT" );
    }
}

eosl_bool agc_EM_NE_ENT_CALL_CAPTVERBOSE_req( const char * modifier,\
                                              eosl_handle handle,\
                                              TL1_TAG ctag ,\
                                              TL1_AID _trcId,\
                                              char * _cgpn,\
                                              char * _cdpn,\
                                              BoolYN_ENUM * _sendTl1)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colnCnt=0;
    int            cmd=SM_ENT_REQUEST;



    tableId = CALLCAPTV_CRIT_TABLE_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));


    /*validate AID to permit only numbers within*/
    if(!(IsInputStrInRange(_trcId,"0123456789")))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType =TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =atoi(_trcId);

    if(_cgpn)
    {
    
        /*validate string to permit only numbers within*/
        if((!(IsInputStrInRange(_cgpn,"0123456789"))) || (strlen(_cgpn) > 21))  
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid cgpn" );  
            return eosl_false;       
        }
        columns[colnCnt].columnId = TS_COL_CALLCAPTV_CGPN;
        columns[colnCnt].value.colType = TSSMI_OCTET_STRING;
        columns[colnCnt].value.value.stringVal.len = strlen(_cgpn);
        columns[colnCnt].value.value.stringVal.ptr = _cgpn;
        colnCnt++;
    }
    
    if(_cdpn)
    {
        /*validate string to permit only numbers within*/
        if((!(IsInputStrInRange(_cdpn,"0123456789"))) || (strlen(_cdpn) > 21))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid cdpn" );  
            return eosl_false;       
        }
        columns[colnCnt].columnId = TS_COL_CALLCAPTV_CDPN;
        columns[colnCnt].value.colType = TSSMI_OCTET_STRING;
        columns[colnCnt].value.value.stringVal.len = strlen(_cdpn);
        columns[colnCnt].value.value.stringVal.ptr = _cdpn;
        colnCnt++;
    }

    if((_cgpn == NULL) && (_cdpn == NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input Invalid, cgpn and cdpn Cannot Be Both Null." );  
        return eosl_false;    
    }

    if(_sendTl1)
    {
        columns[colnCnt].columnId            = TS_COL_CALLCAPTV_SNDTL1;
        columns[colnCnt].value.colType       = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = *_sendTl1;
        colnCnt++;

    }

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_CALL_CAPTVERBOSE_req", 
                   "ENT_CALL_CAPT_VERBOSE - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-CALL-CAPTVERBOSE" );
    }
}

/**
 */

/**
 */
eosl_bool agc_EM_NE_ENT_COUNTRY_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _countryCode, int * _minDgts, int * _maxDgts)
{
    /*Changing TL1 Code to send to PLM instead of
     *Service Manager
     */
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;
    int            countryCode;
    char           retChar;

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = TELICA_TABLE_COUNTRY_CODE;

    rowKey.numIndices = 1;

    if(_countryCode == NULL)
    {
        tc_error_response(handle, ctag, TE_IIAC, "Input, Missing Aid");
        return eosl_false;
    }

    if((sscanf(_countryCode, "%d%c[^0-9]", &countryCode, &retChar) != 1) ||
       (countryCode < 1) || countryCode > 999 || IsInputStrContainPrefix(_countryCode,"0"))
    {
        tc_error_response(handle, ctag, TE_IIAC, "Input, Invalid CountryCode");
        return eosl_false;
    }

    rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
    rowKey.rowIndex[0].value.stringVal.ptr = _countryCode;
    rowKey.rowIndex[0].value.stringVal.len = strlen(_countryCode);

    if(_minDgts)
    {
        columns[colCnt].columnId = COUNTRY_COL_MIN_DGTS;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_minDgts;
        colCnt++;
    }

    if(_maxDgts)
    {
        columns[colCnt].columnId = COUNTRY_COL_MAX_DGTS;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxDgts;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_COUNTRY_req", 
                   "ENT-COUNTRY - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);



    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ENT-COUNTRY" ); /* success */
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;

}


/**
 */
eosl_bool agc_EM_NE_ENT_IPHOST_SECU_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _com, char * _ipHosts)
{
    char         buffer[MAX_GOAHEAD_MSG_SIZE];
    DB_WRITE_t   *p_dbData  = (DB_WRITE_t *) &buffer[0];
    DB_COLUMN_t  *p_dbEntry = (DB_COLUMN_t *) &p_dbData->Columns[0];
    const char   *username;
    unsigned int ipHost;
    char         *ipHostStr;
    int          numIpHosts;

    if ((_com != NULL) && (eosl_strcasecmp(_com, "COM") !=0 ))
    {
        tc_error_response( handle,
                           ctag,
                           TE_IIAC,
                           "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_ipHosts == NULL)
    {
        tc_error_response( handle,
                           ctag,
                           TE_IIDT,
                           "Invalid IP Address." );
        return eosl_false;
    }

    strcpy(p_dbData->DBName, TL1_DB_NAME);
    strcpy(p_dbData->TableName, THOSTS_TABLE_NAME);
    p_dbData->NumColumns = 0;
    p_dbEntry = (DB_COLUMN_t *) &p_dbData->Columns[0];
    
    numIpHosts = tl1DbGetNumRows(THOSTS_TABLE_NAME);
    if (numIpHosts < 0)
    {
        tc_error_response( handle, ctag, TE_SDBE, "Error reading THosts table" );
        return eosl_false;
    }

    /* Get the first IP Address (& separates IP addrs) */
    ipHostStr = strtok(_ipHosts, "&");
    if (ipHostStr == NULL)
    {
        tc_error_response( handle,
                           ctag,
                           TE_IIDT,
                           "Invalid IP Address." );
        return eosl_false;
    }
    
    /* While still tokens in input string. */
    while (TRUE)
    {
        if ((ip_a2i(ipHostStr, &ipHost)) != 1)
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIDT,
                               "Invalid IP Address." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData,
                                        p_dbEntry,
                                        TL1_DB_IP_COL,
                                        numIpHosts,  /* 0-based row */
                                        DB_DATA_TYPE_INT,
                                        ipHost,
                                        NULL);

        if (numIpHosts++ >= MAX_TRUSTED_HOSTS)
        {
            tc_error_response( handle,
                               ctag,
                               TE_SLEM,
                               "List Exceeds Maximum" );
            return eosl_false;
        }

        ipHostStr = strtok(NULL, "&");
        if (ipHostStr == NULL)
        {
            break;
        }
    }

    if (p_dbData->NumColumns > 0)
    {
        if (sendDbWriteRequest(
            p_dbData,
            (unsigned int)p_dbEntry - (unsigned int)buffer) == FAIL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ENT_IPHOST_SECU_req",
                       "agc_EM_NE_ENT_IPHOST_SECU_req: Failed sendDbWriteRequest\n");
            tc_error_response( handle,
                               ctag,
                               TE_SDBE,
                               "Internal Data Base Error" );
            return eosl_false;
        }
    }

    username = tc_session_get_username(handle);
    AddSecEvent(handle,
                TRUSTED_HOSTS_MODIFIED,
                (char *)username,
                " Trusted Host(s) Added. ");
    return tc_compld_comment( handle,
                              ctag,
                              "ENT-IPHOST-SECU" );
}

#define MAX_ROUTE_LENGTH 128
/**
 */
eosl_bool agc_EM_NE_ENT_IPROUTE_req( const char * modifier, 
                                     eosl_handle handle, 
                                     TL1_TAG ctag , 
                                     char * _ipRouteId, 
                                     char * _gateway,
                                     EnableType_ENUM * _gatewayPing)
{

    IPROUTE_CMD_t     buffer;
#ifdef ATCA
    int errCode;
    char errMsg[TL1_IPMSG_MAX_MSG_LEN];
    char *script = EXEC_CHECK_LCP_ROUTE;
    char parameters[MAX_ROUTE_LENGTH];
    int  shelfId;
    int  slotId;
#endif

    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(IPROUTE_CMD_t));  /* sets all "valid" flags to 0 */

    /* If the AID was NOT successfully parsed and loaded into the message structure */
    if (ParseRouteAid(_ipRouteId,
                      &buffer.DeviceId,
                      &buffer.DeviceMap,
                      &buffer.Data.EntIpRoute.Dest,
#ifndef ATCA
                      &buffer.Data.EntIpRoute.SubnetMask,
#else
                      &buffer.Data.EntIpRoute.Subnet,
#endif
                      AID_IPROUTE_FULL) == FAIL)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#ifndef ATCA
    /* If specified IP address is not valid */
    if ((ip_a2i(_gateway, &buffer.Data.EntIpRoute.Route)) == 0)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address." );
        return eosl_false;
    }
#else
    /* IPv6 NETMASK should be > 0 */
    if(buffer.Data.EntIpRoute.Dest.ipVersion == AF_INET6 && 
       (buffer.Data.EntIpRoute.Subnet < 1 || buffer.Data.EntIpRoute.Subnet > 128)
      )
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    /* If IP token is invalid */
    if ((errCode = tl1ValidateIP(_gateway,
                                 NULL,
                                 (IS_IPV4(buffer.Data.EntIpRoute.Dest)) ? TL1_IPFMT_IPV4 : TL1_IPFMT_IPV6,
                                 TL1_IPVAL_IPV6_STD,
                                 NULL,
                                 &buffer.Data.EntIpRoute.Route)) != TL1_IPCDE_SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIDT,
                           tl1FormatIPErrorMessage(errCode, "gateway", errMsg));
        return eosl_false;
    }

    /* co-host chassis, should follow LCP's IPv4 route table */
    if(buffer.Data.EntIpRoute.Dest.ipVersion == AF_INET && procInfo.IsOAMCoexist) {
        char destAddr[INET6_ADDRSTRLEN], subnetAddr[INET6_ADDRSTRLEN];
	struct in_addr   IpAddress;
	int result = 0;
	IpAddress.s_addr =  htonl(OalGetSubnetMask(buffer.Data.EntIpRoute.Subnet));
	strncpy(subnetAddr, inet_ntoa(IpAddress), 16);
    strncpy(destAddr, ip_ntoa(&buffer.Data.EntIpRoute.Dest), INET6_ADDRSTRLEN);

        shelfId = GetLevel1(buffer.DeviceId);
        slotId = GetLevel2(buffer.DeviceId);
        snprintf(parameters, MAX_ROUTE_LENGTH, "%d %d %s %s %s", /* dest/mask/gwip */
                 shelfId, slotId, destAddr, subnetAddr,_gateway);
        result = runOSCommand(script, parameters, NULL);
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_LNPSCREEN_DIGITS_req", 
                  "%s %s result:%d\n", script, parameters, result);
        if (result != 0) {
            tc_error_response( handle, ctag, TE_IIDT, "Input, IPROUTE is not compatible to LCP." );
            return eosl_false;
        }
    }
#endif

    if(_gatewayPing)
    {
        switch(*_gatewayPing)
        {
        case EnableType_DISABLED:
            buffer.Data.EntIpRoute.PingEnabled = FALSE;
            break;
        case EnableType_ENABLED:
            buffer.Data.EntIpRoute.PingEnabled = TRUE;
            break;
        default:
            tc_error_response( handle, ctag, TE_IIDT, 
                               "Input, gatewayPing Invalid" );
            return eosl_false;
            break;
        }
    }
    else
    {
        buffer.Data.EntIpRoute.PingEnabled = TRUE;
    }

    /* Dispatch the message */
    if(TL1SendMsg(handle, ctag,
                  IP_ROUTE_CMD_CLASS, CMD, ENT_IPROUTE,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_IPROUTE, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ENT-IPROUTE" );
}

/**
 * Enter LIST SUIOM
 */
eosl_bool agc_EM_NE_ENT_LIST_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suListId,\
									char * _swVersion,\
									char * _appSwVersion)
{
    TL1_BUF_t         buffer;
    int               Iom;

    memset(&buffer, 0, sizeof(TL1_BUF_t));  
    
    if(_suListId)
    {
        if(parseSuListAid(_suListId, &Iom, NULL) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }

        if (eosl_strcasecmp(_suListId, "NULL") == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }
        
        strncpy(buffer.CmdInfo.EntSuList.SuListName, _suListId, SUAUTO_LIST_LEN + 1);
        buffer.CmdInfo.EntSuList.IomNum = Iom;
    }

    if(_swVersion)
    {
        strncpy(buffer.CmdInfo.EntSuList.SwVersion, _swVersion, SW_VERSION_LEN + 1);
    }

    if(_appSwVersion)
    {
        strncpy(buffer.CmdInfo.EntSuList.AppSwVersion, _appSwVersion, SW_VERSION_LEN + 1);
    }
    
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ENT_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ENT_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ENT-LIST-SUIOM" );
}

/**
 */
eosl_bool agc_EM_NE_ENT_LNPSCREEN_DIGITS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _screenDigits, char * _trigEscList, char * _rtKey)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   int            screenDigitsLen;
   int            trigEscListLen;
   char           *label;
   char           *primKey;
   char           *primValStr;
   char           *state;
   char           *rtKeyClone = NULL;
   int            primKeyEnum;

   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_LNPSCRDIGITS;

   rowKey.numIndices = 1;

   if(!(IsInputStrInRange(_screenDigits,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Input for screenDigits");
        return eosl_false;
   }
   screenDigitsLen = strlen(_screenDigits);
   if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Invalid number:must be 3 or 6-10 digits");
       return eosl_false;
   }
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);

   if(_trigEscList)
   {
	   if(eosl_strcasecmp(_trigEscList, "NULL"))
	   {
		   trigEscListLen = strlen(_trigEscList); 
		   if(trigEscListLen > 10)
		   {
			   tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid trigEscList");
			   return eosl_false;
		   } 
		   columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
		   columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
		   columns[colCnt].value.value.stringVal.ptr = _trigEscList;
		   columns[colCnt].value.value.stringVal.len = strlen(_trigEscList);
	   }
	   else
	   {
		   columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
		   columns[colCnt].value.colType             = TSSMI_RESET;
	   }
	   colCnt++;
   }

   /*
    * FID16277.0, add new parameter rtKey to the command.
    * Default value is NULL. The values of the primKey follows
    * the same range as rtKey from TREATMENT.
    * The following formats shall be allowed for the rtKey:
    * - NULL
    * - rtLbl
    * - rtLbl-primKey
    * - rtLbl-NULL (equivalent to rtLbl)
    * The following formats will be invalid:
    * - NULL-primKey
    * - NULL-NULL
    * - rtLbl-
    * - -primKey
    */
   if (_rtKey)
   {
     /* If NULL is expicitly specified */
     if (eosl_strcasecmp(_rtKey, "NULL") == 0)
     {
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTNAME;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
     }
     else
     {
       /* If first or last char is a delimeter */
       if ((_rtKey[0] == '-') || (_rtKey[strlen(_rtKey)-1] == '-'))
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid, incomplete rtKey");
         return eosl_false;
       }

       /* Clone input parameter, as strtok_r is destructive */
       rtKeyClone = eosl_malloc(strlen(_rtKey)+1);
       if (rtKeyClone == NULL)
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid, internal memory error");
         return eosl_false;
       }

       strcpy(rtKeyClone, _rtKey);

       /* Get the label */
       label = strtok_r(rtKeyClone,"-", &state);

       /* If the label is not valid */
       if ((eosl_strcasecmp(label, "NULL") == 0) || (strlen(label) > 10))
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, wrong rtLbl");
         eosl_free(rtKeyClone);
         return eosl_false;
       }

       columns[colCnt].columnId                   = LNPSCREENDIGITS_RTNAME;
       columns[colCnt].value.colType              = TSSMI_OCTET_STRING;
       columns[colCnt].value.value.stringVal.ptr  = label;
       columns[colCnt].value.value.stringVal.len  = strlen(label);
       colCnt++;

       /* If a primary key was specified */
       if ((primKey = strtok_r(NULL,"-", &state)))
       {
         /* With a given rtLbl, the primKey can be NULL */
         if (eosl_strcasecmp(primKey, "NULL") == 0)
         {
           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
           columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
         }
         else
         {
           /* The primary key can't out of range */
           if ((primKeyEnum =
               enum_lookup_no_case(&RTPrimkey_ENUM_type, primKey)) == -1)
           {
             tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, primary key out of range");
             eosl_free(rtKeyClone);
             return eosl_false;
           }

           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           columns[colCnt].value.colType       = TSSMI_LONG;
           columns[colCnt].value.value.longVal = mapTL1TSMCrtPrimkey(primKeyEnum);
           colCnt++;

           /* If some specific primary keys are set, then need the value */
           if ((primKeyEnum == RTPrimkey_GAP)     ||
               (primKeyEnum == RTPrimkey_GENDGTS) ||
               (primKeyEnum == RTPrimkey_REG)     ||
               (primKeyEnum == RTPrimkey_GP))
           {
             /* Get these primary keys' value */
             if ((primValStr = strtok_r(NULL,"-", &state)))
             {
               /* If the primary key value is not valid */
               if ((!IsInputStrInRange(primValStr,"0123456789")) ||
                   (strlen(primValStr) > 3))
               {
                 tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, primary key value wrong");
                 eosl_free(rtKeyClone);
                 return eosl_false;
               }

               columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
               columns[colCnt].value.colType       = TSSMI_LONG;
               columns[colCnt].value.value.longVal = atoi(primValStr);
               colCnt++;
             }
             else
             {
               tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, miss primary key value");
               eosl_free(rtKeyClone);
               return eosl_false;
             }
           }
         }

         /* If extraneous tokens exist */
         if (strtok_r(NULL,"-", &state) != NULL)
         {
           tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, too many arguments");
           eosl_free(rtKeyClone);
           return eosl_false;
         }
       }
     }
   }

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_LNPSCREEN_DIGITS_req", "ENT-LNPSCREEN-DIGITS - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");

        if (rtKeyClone)
        {
            /* Free dynamic memory */
            eosl_free(rtKeyClone);
        }

        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

   if (rtKeyClone)
   {
     /* Free dynamic memory */
     eosl_free(rtKeyClone);
   }

   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "ENT-LNPSCREEN-DIGITS" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
    
}

/**
 */
eosl_bool agc_EM_NE_ENT_LNPSCREEN_DIGITS_BULK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _screenDigits, char * _trigEscList, char * _rtKey)
{
   int            screenDigitsLen;
   int			  trigEscListLen;
   int            cmd     = SM_BULK_REQUEST;
   int            colCnt = 0;
   char           *label;
   char           *primKey;
   char           *primValStr;
   char           *state;
   char           *rtKeyClone = NULL;
   int            primKeyEnum;
   TsTransId      transId = ctag;
   TsTableId      tableId = TELICA_TABLE_LNPSCRDIGITS;

   bulkData.rowKey.numIndices = 1;

   if(!(IsInputStrInRange(_screenDigits,"0123456789")))
   {
       bulkData.errNo = TSSMI_BAD_INDEX;
       return eosl_false;
   }
   screenDigitsLen = strlen(_screenDigits);
   if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
   {
       bulkData.errNo = TSSMI_BAD_INDEX;
       return eosl_false;
   }
   bulkData.rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   bulkData.rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
   bulkData.rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);

   bulkData.colArray.numCols  = 0;

   if(_trigEscList)
   {
	   if(eosl_strcasecmp(_trigEscList, "NULL"))
	   {
		   trigEscListLen = strlen(_trigEscList); 
		   if(trigEscListLen > 10)
		   {
			   bulkData.errNo = TSSMI_BAD_INDEX;
			   return eosl_false;
		   } 
                   bulkData.columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
                   bulkData.columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
                   bulkData.columns[colCnt].value.value.stringVal.ptr = _trigEscList;
                   bulkData.columns[colCnt].value.value.stringVal.len = strlen(_trigEscList);
	   }
	   else
	   {
                   bulkData.columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
                   bulkData.columns[colCnt].value.colType             = TSSMI_RESET;
	   }

           colCnt++;
   }

   /*
    * FID16277.0, add new parameter rtKey to the command.
    * Default value is NULL. The values of the primKey follows
    * the same range as rtKey from TREATMENT.
    * The following formats shall be allowed for the rtKey:
    * - NULL
    * - rtLbl
    * - rtLbl-primKey
    * - rtLbl-NULL (equivalent to rtLbl)
    * The following formats will be invalid:
    * - NULL-primKey
    * - NULL-NULL
    * - rtLbl-
    * - -primKey
    */
   if (_rtKey)
   {
     /* If NULL is expicitly specified */
     if (eosl_strcasecmp(_rtKey, "NULL") == 0)
     {
       bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTNAME;
       bulkData.columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
       bulkData.columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
       bulkData.columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
     }
     else
     {
       /* If first or last char is a delimeter */
       if ((_rtKey[0] == '-') || (_rtKey[strlen(_rtKey)-1] == '-'))
       {
         bulkData.errNo = TSSMI_COL_BAD_VALUE;
         return eosl_false;
       }

       /* Clone input parameter, as strtok_r is destructive */
       rtKeyClone = eosl_malloc(strlen(_rtKey)+1);
       if (rtKeyClone == NULL)
       {
         bulkData.errNo = TSSMI_OUT_OF_RESRC;
         return eosl_false;
       }

       strcpy(rtKeyClone, _rtKey);

       /* Get the label */
       label = strtok_r(rtKeyClone,"-", &state);

       /* If the label is not valid */
       if ((eosl_strcasecmp(label, "NULL") == 0) || (strlen(label) > 10))
       {
         bulkData.errNo = TSSMI_COL_BAD_VALUE;
         eosl_free(rtKeyClone);
         return eosl_false;
       }

       bulkData.columns[colCnt].columnId                   = LNPSCREENDIGITS_RTNAME;
       bulkData.columns[colCnt].value.colType              = TSSMI_OCTET_STRING;
       bulkData.columns[colCnt].value.value.stringVal.ptr  = label;
       bulkData.columns[colCnt].value.value.stringVal.len  = strlen(label);
       colCnt++;

       /* If a primary key was specified */
       if ((primKey = strtok_r(NULL,"-", &state)))
       {
         /* With a given rtLbl, the primKey can be NULL */
         if (eosl_strcasecmp(primKey, "NULL") == 0)
         {
           bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           bulkData.columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
           bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
           bulkData.columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
         }
         else
         {
           /* The primary key can't be out of range */
           if ((primKeyEnum =
               enum_lookup_no_case(&RTPrimkey_ENUM_type, primKey)) == -1)
           {
             bulkData.errNo = TSSMI_COL_BAD_VALUE;
             eosl_free(rtKeyClone);
             return eosl_false;
           }

           bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           bulkData.columns[colCnt].value.colType       = TSSMI_LONG;
           bulkData.columns[colCnt].value.value.longVal = mapTL1TSMCrtPrimkey(primKeyEnum);
           colCnt++;

           /* If some specific primary keys are set, then need the value */
           if ((primKeyEnum == RTPrimkey_GAP)     ||
               (primKeyEnum == RTPrimkey_GENDGTS) ||
               (primKeyEnum == RTPrimkey_REG)     ||
               (primKeyEnum == RTPrimkey_GP))
           {
             /* Get the primary key's value */
             if ((primValStr = strtok_r(NULL,"-", &state)))
             {
               /* If the primary key value is not valid */
               if ((!IsInputStrInRange(primValStr,"0123456789")) ||
                   (strlen(primValStr) > 3))
               {
                 bulkData.errNo = TSSMI_COL_BAD_VALUE;
                 eosl_free(rtKeyClone);
                 return eosl_false;
               }

               bulkData.columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
               bulkData.columns[colCnt].value.colType       = TSSMI_LONG;
               bulkData.columns[colCnt].value.value.longVal = atoi(primValStr);
               colCnt++;
             }
             else
             {
               bulkData.errNo = TSSMI_COL_BAD_VALUE;
               eosl_free(rtKeyClone);
               return eosl_false;
             }
           }
         }

         /* If extraneous tokens exist */
         if (strtok_r(NULL,"-", &state) != NULL)
         {
           bulkData.errNo = TSSMI_COL_BAD_VALUE;
           eosl_free(rtKeyClone);
           return eosl_false;
         }
       }
     }
   }

   bulkData.colArray.numCols  = colCnt;

   /* If this is the first command to be packed into the buffer */
   if (bulkData.packedCmds == 0)
   {
       /* Initialize the data buffer attributes */
       bulkData.buf    = &bulkData.smCmd.Data[0];
       bulkData.bufLen = 0;
       /* If an error occurred packing the Bulk header */
       if (emfInitPkSmiBulkReq(cmd,
                               handle,
                               transId, 
                               tableId,
                               &bulkData.smCmd,
                               &bulkData.buf,
                               &bulkData.bufLen) == eosl_false)
       {
           if (rtKeyClone)
           {
             /* Free dynamic memory */
             eosl_free(rtKeyClone);
           }

           return eosl_false;
       }
   }
   
   /* Pack the command into the buffer */
   emfPkSmiBulkCmdHdr(SM_ENT_REQUEST,
                      tableId,  
                      &bulkData.smCmd,
                      &bulkData.buf,
                      &bulkData.bufLen);
   
   emfPkSmiBulkReq(&bulkData.rowKey,
                   &bulkData.colArray,  
                   &bulkData.smCmd,
                   &bulkData.buf,
                   &bulkData.bufLen);
   
   if (rtKeyClone)
   {
     /* Free dynamic memory */
     eosl_free(rtKeyClone);
   }

   return eosl_true;
   
}

/**
 */
eosl_bool agc_EM_NE_ENT_LRN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _lrn, LRN_ENUM *_lrntype, BoolYN_ENUM * _replaceCDPN)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */
    
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   char           LrnString[MAX_LRN_LEN+1];


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_OWNLRN;

   rowKey.numIndices = 1;

   if(strlen(_lrn) != 10 )
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LRN ");
        return eosl_false;
   }
   /*validate AID to permit only numbers within*/
   if(!(IsInputStrInRange(_lrn,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
   }
   
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _lrn;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_lrn);

   if(_lrntype)
   {
	   if(*_lrntype == LRN_PRI)
	   {
		   sprintf(LrnString,"PRI");
	   }
	   else
	   {
		   sprintf(LrnString,"SEC");
	   }
	   columns[colCnt].columnId                  = TS_COL_OWNLRN_LRNTYPE;
	   columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
	   columns[colCnt].value.value.stringVal.ptr = LrnString;
	   columns[colCnt].value.value.stringVal.len = strlen(LrnString);
	   colCnt++;
   }

   if(_replaceCDPN)
   {
	   columns[colCnt].columnId = TS_COL_OWNLRN_REPCDPN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_replaceCDPN)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
   }
 
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_LRN_req", "ENT-LRN - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
						   handle,
						   transId,
						   tableId,
						   &rowKey,
						   &colArray,
						   &smCmd,
						   TL1_MSG_TIMEOUT);

   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "ENT-LRN" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_ENT_LSET_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _lsetId,\
									TL1_AID _opc,\
									TL1_AID _adjDpc,\
									int * _actLnkReqd)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    char      xchr;
    int            lsetId;
    int            colCnt = 0;
    int            lsetAdjDpc;
    int            lsetOpc;
    int            i;
    SMCMD_t        smCmd;
    PointCodeFormat pcFormat = PC_INVALID;


    transId = ctag;

    tableId = MTPLSET_TAB_ID;

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_lsetId, "%d%c", &lsetId, &xchr);
    if ((i != 1) || (lsetId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LinkSetId" );
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal  = lsetId;

    columns[colCnt].columnId = MTPLSET_LSETADJDPC;
    columns[colCnt].value.colType = TSSMI_LONG;

    lsetAdjDpc = pc_atoi(_adjDpc, &pcFormat);
    if (lsetAdjDpc == -1)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, AdjPcId Invalid" );
            return eosl_false;
        }
    columns[colCnt].value.value.longVal = lsetAdjDpc;
    colCnt++;

    columns[colCnt].columnId            = MTPLSET_LSETADJPCFORMAT;
    columns[colCnt].value.colType       = TSSMI_LONG;
    columns[colCnt].value.value.longVal = pcFormat;
    colCnt++;

    columns[colCnt].columnId = MTPLSET_LSETOPC;
    columns[colCnt].value.colType = TSSMI_LONG;
    lsetOpc = pc_atoi(_opc, &pcFormat);
    if (lsetOpc == -1)
    {
         tc_error_response( handle, ctag, TE_IIDT, "Input, Opc Invalid" );
         return eosl_false;
    }
    columns[colCnt].value.value.longVal = lsetOpc;
    colCnt++;

    columns[colCnt].columnId            = MTPLSET_LSETOPCFORMAT;
    columns[colCnt].value.colType       = TSSMI_LONG;
    columns[colCnt].value.value.longVal = pcFormat;
    colCnt++;

    if(_actLnkReqd)
    {
        if (*_actLnkReqd < 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid actLnkReqd." );
            return eosl_false;
        }
        columns[colCnt].columnId = MTPLSET_NMBACTLNKREQD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_actLnkReqd;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_LSET_req", "ENT_LSET - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);
    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-LSET" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ENT_EQPT_req( const char * modifier,\
                                    eosl_handle handle,\
                                     TL1_TAG ctag ,\
                                    TL1_AID _ioModule,\
                                    char * _ioModuleType,\
                                    Redundancy_ENUM _rn,\
                                    int _spMemThreshold,\
                                    int _spNVMemThreshold,\
                                    int _diskMajorThreshold,\
                                    int _diskCriticalThreshold,\
                                    int _spBusyThreshold,\
                                    char * _swVersion,\
                                    PrimaryStateIn_ENUM _pst)
{
    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask = 0;
    char                         * primaryState;
    int             i, len;
    eosl_bool       ret = eosl_false;


    memset(&cmdMsg, 0x0, sizeof(TL1_BUF_t)); /* set all valid flags=0 */


    /*
    **  Fill slot data structure
    */
    if(ParseAidMap(&aidInfo, _ioModule, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.Buf.Cmd = EQMCMD_ENT_EQPT;
    cmdMsg.Buf.SessionHandle = handle;
    cmdMsg.Buf.CTag = ctag;
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;

    strncpy(cmdMsg.CmdInfo.EntParams.Redundancy.strValue, enum_lookup_name(&Redundancy_ENUM_type, _rn),
            sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue));
    cmdMsg.CmdInfo.EntParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue) - 1] = '\0';
    cmdMsg.CmdInfo.EntParams.Redundancy.valid = VALID_VALUE;

    primaryState=enum_lookup_name( &PrimaryStateIn_ENUM_type, _pst);
    SetStateMask( primaryState, primaryState , NULL, &stateMask, NULL);
    cmdMsg.CmdInfo.EntParams.State.value=stateMask;
    cmdMsg.CmdInfo.EntParams.State.valid= (OPTIONAL_PARM_VALID) stateMask;

    if (_ioModuleType == NULL)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );
        return eosl_false;
    }

    len = strlen(_ioModuleType);
    if (len >= (int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue))
    {
        len = (unsigned int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue) - 1;
    }
    for (i = 0; i < len; i++)
    {
        cmdMsg.CmdInfo.EntParams.Type.strValue[i] = (char) toupper((int) _ioModuleType[i]);
    }
    cmdMsg.CmdInfo.EntParams.Type.strValue[len] = '\0';
    cmdMsg.CmdInfo.EntParams.Type.valid = VALID_VALUE;

    strncpy(cmdMsg.CmdInfo.EntParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EntParams.SWVersion.strValue));

    cmdMsg.CmdInfo.EntParams.SWVersion.valid = VALID_VALUE;

    cmdMsg.CmdInfo.EntParams.MemUtilThresh.value = _spMemThreshold;
    cmdMsg.CmdInfo.EntParams.MemUtilThresh.valid = VALID_VALUE;

    ret = assignDiskThreshold(handle, ctag, 1, &_spNVMemThreshold, &_diskMajorThreshold, &_diskCriticalThreshold, &cmdMsg);
    if (eosl_false == ret) /* error response is set in function */
    {
        return eosl_false;
    }

    cmdMsg.CmdInfo.EntParams.CpuUtilThresh.value = _spBusyThreshold;
    cmdMsg.CmdInfo.EntParams.CpuUtilThresh.valid = VALID_VALUE;

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "ENT-EQPT" );
}


/**
 * Enter OSUSER Security
 */
eosl_bool agc_EM_NE_ENT_OSUSER_SECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid,\
									char * _pid,\
									UserPrivilege_ENUM _uap,\
									int * _page,\
									int * _pcnd,\
									int * _actTmout,\
									int * _maxSes,\
									PrimaryStateIn_ENUM * _pst)
{
    int            result;
#define optName(opt)     "--" #opt " "
#define optLen(opt, len) (strlen(optName(opt))+ len + 1)
#define OSUSER_PARAMLEN   (optLen(page, 3) + optLen(pcnd, 3) + optLen(actTmout, 3) + optLen(maxSes, 3) + \
                    optLen(pst, 3) + optLen(uid, MAX_OSUSER_NAME_SIZE + 1) + \
                    optLen(pid, MAX_OSPASSWORD_SIZE + 1) + optLen(uap, 6))
    char           parameters[OSUSER_PARAMLEN];
    unsigned int   state = 1;
    char*          script = OSCMD_ENT_OSUSER_SECU_PATH;
    char tempPid[150];
    memset(parameters, 0, sizeof(parameters));

    if ( IsUserNameValid(_uid, MIN_OSUSER_NAME_SIZE, MAX_OSUSER_NAME_SIZE) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID's must have a length of 1-32 alphanumeric characters");
        return  eosl_false;
        /* send event */
    }

    if (_pid != NULL)
    {
        if ((strchr(_pid, '-') != NULL)||(strchr(_pid, '\'') !=NULL))
        {
            tc_error_response(handle,ctag,TE_PIUI,"Password shouldn't contain - or ' ");
            return  eosl_false;
        }
        /* 82803 */
        tranStrtoBash(_pid,tempPid,strlen(_pid));
        /* 82803*/

    }

    if (_uap == UserPrivilege_NSA || _uap == UserPrivilege_SA || _uap == UserPrivilege_VIEW || _uap == UserPrivilege_ADMIN)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid uap" );
        return eosl_false;
    }

    sprintf(parameters, "%s %s %s %s %s %d", optName(uid), _uid, optName(pid), tempPid, optName(uap), (int)_uap);
    
    if (_page != NULL)
    {
        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(page), *_page);
    }

    if (_pcnd != NULL)
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(pcnd), *_pcnd);
    }

    if (_actTmout != NULL)
    {
        if ((*_actTmout < 0) || (*_actTmout > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid actTmout" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(actTmout), *_actTmout);
    }

    if (_maxSes != NULL)
    {
        if ((*_maxSes < 0) || (*_maxSes > 20))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid maxSes" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(maxSes), *_maxSes);
    }

    /* If the new account is to be administratively managed Out-Of_service */
    if ((_pst) && (*_pst == PrimaryStateIn_OOS))
    {
        state = 0;
    }

    sprintf(parameters, "%s %s %d", parameters, optName(pst), state);

    result = runOSCommand(script, parameters, NULL);

    procLogMsg(PLOG_DEBUG, "agc_EM_NE_ENT_OSUSER_SECU_req",
               "agc_EM_NE_ENT_OSUSER_SECU_req return value %d parameters %s\n", result, parameters);
        
    if (result == 0)
    {
        return tc_compld_comment( handle, ctag, "ENT-OSUSER-SECU" );
    }
    else
    {
        if (result == -2)
        {
            tc_error_response(handle,ctag,TE_PIUI,"Username is not unique");
        }
        else
        {
            tc_error_response(handle,ctag,TE_SROF,"Unable to add user"); /* need to get correct err code */
        }
        return  eosl_false;
    }
}

/**
 * Enter PLAN SUIOM
 */
eosl_bool agc_EM_NE_ENT_PLAN_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suPlanName,\
									char * _list1,\
									char * _list2,\
									char * _list3,\
									char * _list4,\
									char * _list5)
{
    TL1_BUF_t         buffer;
    int               i;
    int               j;

    memset(&buffer, 0, sizeof(TL1_BUF_t));  
    
    if(_suPlanName)
    {
        if(strlen(_suPlanName) > SUAUTO_PLAN_LEN)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SUPLANNAME" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EntSuPlan.SuPlanName, _suPlanName, SUAUTO_PLAN_LEN + 1);
    }

    if(_list1)
    {
        if (strlen(_list1) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST1" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list1, "NULL") == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid LIST1" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EntSuPlan.SuListName[0], _list1, SUAUTO_LIST_LEN + 1);
    }

    if(_list2)
    {
        if (strlen(_list2) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST2" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list2, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EntSuPlan.SuListName[1], _list2, SUAUTO_LIST_LEN + 1);
        }
    }

    if(_list3)
    {
        if (strlen(_list3) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST3" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list3, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EntSuPlan.SuListName[2], _list3, SUAUTO_LIST_LEN + 1);
        }
    }

    if(_list4)
    {
        if (strlen(_list4) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST4" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list4, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EntSuPlan.SuListName[3], _list4, SUAUTO_LIST_LEN + 1);
        }
    }

    if(_list5)
    {
        if (strlen(_list5) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST5" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list5, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EntSuPlan.SuListName[4], _list5, SUAUTO_LIST_LEN + 1);
        }
    }
   
    for(i = 0; i != MAX_NUM_SULIST_IN_PLAN; ++i)
    {
        for(j = i + 1; j < MAX_NUM_SULIST_IN_PLAN; ++j)
        {
            if(strlen(buffer.CmdInfo.EntSuPlan.SuListName[i]) != 0 &&
               strncmp(buffer.CmdInfo.EntSuPlan.SuListName[i],
                       buffer.CmdInfo.EntSuPlan.SuListName[j], SUAUTO_LIST_LEN) == 0)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, Duplicate LIST" );
                return eosl_false;
            }
        }
    }
 
    for(i = MAX_NUM_SULIST_IN_PLAN - 1; i > 0; --i)
    {
        for(j = 0; j < i; ++j)
        {
            if(strlen(buffer.CmdInfo.EntSuPlan.SuListName[i]) != 0 &&
               strlen(buffer.CmdInfo.EntSuPlan.SuListName[j]) == 0)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, Gap LIST" );
                return eosl_false;
            }
        }
    } 
 
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ENT_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ENT_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ENT-PLAN-SUIOM" );
}


/**
 */
eosl_bool agc_EM_NE_ENT_PRFL_CIC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _cicPrflId, char * _isupT12, char * _isupT13, char * _isupT14, char * _isupT15, char * _isupT16, char * _isupT17, char * _isupTCVT, char * _isupT24, char * _isupT25, char * _isupT26, char * _isupTCOTD, char * _isupTTBLOM, int * _guardTmr, BoolYN_ENUM * _oliFlag, char * _hopCntr)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    char           hopXchr=0;
    int            hopCntr=0;
    int            colnCnt=0;
    int            cicPrflId;
    int            timerTenths;
    int            cmd=SM_ENT_REQUEST;
    int            i;
    int            j;


    /* tableId = TS_TABLE_ID_CIC_PRFL; change Bugzilla 6603 */
    tableId = TELICA_TABLE_SS7TRKPRFL_CFG;
    transId = ctag;
    memset(&smCmd , 0x0,sizeof(SMCMD_t));

    i = sscanf(_cicPrflId, "%d%c", &cicPrflId, &xchr); 
    if ((i != 1) || (cicPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> cicPrflId" );
        return eosl_false;
    }

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =cicPrflId;


    if (_isupT12)
    {
        columns[colnCnt].columnId = SS7CICT12;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT12, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT13)
    {
        columns[colnCnt].columnId = SS7CICT13;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT13, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT14)
    {
        columns[colnCnt].columnId = SS7CICT14;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT14, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT15)
    {
        columns[colnCnt].columnId = SS7CICT15;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT15, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT16)
    {
        columns[colnCnt].columnId = SS7CICT16;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT16, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT17)
    {
        columns[colnCnt].columnId = SS7CICT17;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT17, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupTCVT)
    {
        columns[colnCnt].columnId = SS7CICTVAL;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTCVT, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT24)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T24;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT24, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT25)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T25;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT25, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT26)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T26;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT26, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupTCOTD)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_TCOT_D;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTCOTD, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupTTBLOM)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_TBLO;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTTBLOM, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_hopCntr)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_HOPCOUNTER;
        columns[colnCnt].value.colType = TSSMI_LONG;
        j = sscanf(_hopCntr, "%d%c", &hopCntr, &hopXchr);
        if ((j != 1) || ( hopCntr < 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, hopCntr Invalid" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal = hopCntr;
        colnCnt++;       
    }
    /*Telica prakash Bugfix 6917*/ 
    if(_guardTmr)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_TIMERTGAURD;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = *_guardTmr;
        colnCnt++;  
    }
    if(_oliFlag)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_OLIFLAG;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = *_oliFlag;
        colnCnt++;  
    }
    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_PRFL_CIC_req", "ENT_PRFL_CIC - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);




    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ENT-PRFL-CIC" );
}


/**
 */
eosl_bool agc_EM_NE_ENT_PRFL_SGPC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcPrflId, char * _mtp3T6, char * _mtp3T8, char * _mtp3T10, char * _mtp3T11, char * _mtp3T18, char * _mtp3ITUT19, char * _mtp3ITUT21, char * _mtp3T25, char * _mtp3T28, char * _mtp3T29)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            pcPrflId;
    int            colCnt = 0;
    int            timerTenths;
    int            i;
    char           xchr;

    transId = ctag;

    tableId = MTPPC_PRFL_TAB_ID;

    memset(&smCmd,0x0,sizeof(SMCMD_t));
    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_pcPrflId,"%d%c", &pcPrflId, &xchr);
    if ((i != 1) || (pcPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid PcPrflId" );
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = pcPrflId;

    if(_mtp3T6)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT6;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T6, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T8)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT8;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T8, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T10)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT10;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T10, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T11)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT11;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T11, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T18)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT18;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T18, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT19)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRITUT19;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT19, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT21)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRITUT21;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT21, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T25)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT25;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T25, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T28)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT28;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T28, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T29)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT29;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T29, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_PRFL_SGPC_req", "ENT_PRFL_SGPC - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-PRFL-SGPC" );
    }
}

/**
 * Enter PRFL PFP
 */
eosl_bool agc_EM_NE_ENT_PRFL_PFP_req( const char * modifier,\
									  eosl_handle handle,\
									  TL1_TAG ctag ,\
									  TL1_AID _pfpPrflId,\
									  PfpType_ENUM * _pfpType,\
									  int * _alarmThresh,\
									  int * _dropThresh,\
									  int * _pollFreq,\
									  PrimaryStateIn_ENUM * _pst)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = PRFLPFP_TAB_ID;

   if(!IsInputStrInRange(_pfpPrflId,"0123456789"))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
       return eosl_false;
   }
   rowKey.rowIndex[0].colType = TSSMI_LONG;
   rowKey.rowIndex[0].value.longVal = atoi(_pfpPrflId);
   rowKey.numIndices = 1;
	
   if(_pfpType)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_PFPTYPE;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_pfpType)
	   {
	   case PfpType_ALARMONLY:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMONLY;
		   break;
	   case PfpType_ALARMDROP:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMDROP;
		   break;
	   case PfpType_ALARMDROPLOG:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMDROPLOG;
		   break;
	   default:
		   break;
	   }
	   colCnt++;
   }
   if(_alarmThresh)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_ALARM_THRESH;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_alarmThresh;
	   colCnt++;
   }				
   if(_dropThresh)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_DROP_THRESH;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_dropThresh;
	   colCnt++;
	}				
   if(_pollFreq)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_POLLFREQ;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_pollFreq;
	   colCnt++;
   }				
   if(_pst)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_PST;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch (*_pst) 
	   {
	   case PrimaryStateIn_IS:
		   columns[colCnt].value.value.longVal = PRFLPFP_PST_IS;
		   break;
	   case PrimaryStateIn_OOS:
		   columns[colCnt].value.value.longVal = PRFLPFP_PST_OOS;
		   break;
	   default:
		   break;
	   }
	   colCnt++;
   }
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_PRFL_PFP", "ENT-PRFL-PFP - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "ENT-PRFL-PFP" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_ENT_PRFL_SLKL2_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp2PrflId, char * _mtp2T1, char * _mtp2T2, char * _mtp2T3, char * _mtp2T5, char * _mtp2T6, char * _mtp2T7, char * _mtp2ProvEmrgcy, char * _mtp2ProvNormal, int * _congAbate1, int * _congOnset1, int * _congDiscard1, int * _congAbate2, int * _congOnset2, int * _congDiscard2, int * _congAbate3, int * _congOnset3, int * _congDiscard3, int * _maxBufferCnt,BoolYN_ENUM * _multiCongLvl, int * _mtp2AA, PcrErrType_ENUM * _errtype, int * _maxPcrMsu, int * _maxPcrMsuOct, BoolYN_ENUM * _hwm1MinCfg, BoolYN_ENUM * _hwm5MinCfg, BoolYN_ENUM * _hwm15MinCfg, int * _hwmLTL1, int * _hwmHTL1, int * _hwmLTL2, int * _hwmHTL2, int * _hwmLTL3, int * _hwmHTL3)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            mtp2Prfl;
    int            colCnt = 0;
    int            timerTenths;
    int            i;


    transId = ctag;
    tableId = MTPLY2_PRFL_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_mtp2PrflId, "%d%c", &mtp2Prfl, &xchr);
    if ((i != 1) || (mtp2Prfl < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Mtp2PrflId" );
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = mtp2Prfl;

    if (_mtp2T1)
    {
        columns[colCnt].columnId = MTPLY2_TMRT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T1" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T2)
    {
        columns[colCnt].columnId = MTPLY2_TMRT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T2" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T3)
    {
        columns[colCnt].columnId = MTPLY2_TMRT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T3, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T3" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T5)
    {
        columns[colCnt].columnId = MTPLY2_TMRT5;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T5, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T5" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T6)
    {
        columns[colCnt].columnId = MTPLY2_TMRT6;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T6, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T6" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T7)
    {
        columns[colCnt].columnId = MTPLY2_TMRT7;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T7, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T7" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2ProvEmrgcy)
    {
        columns[colCnt].columnId =  MTPLY2_PROVEMRGCY;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2ProvEmrgcy, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value for ProvEmrgcy" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2ProvNormal)
    {
        columns[colCnt].columnId = MTPLY2_PROVNORMAL;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2ProvNormal, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value for ProvNormal" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }
    if (_congAbate1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate1;
        colCnt++;
    }
    if (_congOnset1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset1;
        colCnt++;
    }
    if (_congDiscard1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard1;
        colCnt++;
    }
    if (_congAbate2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate2;
        colCnt++;
    }
    if (_congOnset2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset2;
        colCnt++;
    }
    if (_congDiscard2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard2;
        colCnt++;
    }
    if (_congAbate3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate3;
        colCnt++;
    }
    if (_congOnset3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset3;
        colCnt++;
    }
    if (_congDiscard3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard3;
        colCnt++;
    }
    if (_maxBufferCnt)
    {
        columns[colCnt].columnId = MTPLY2_MAX_BUFFER_CNT;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxBufferCnt;
        colCnt++;
    }

    if(_multiCongLvl)
    {
	   columns[colCnt].columnId = MTPLY2_MULTI_CONG_LVL;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_multiCongLvl)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }

    if (_mtp2AA)
    {
        if (*_mtp2AA < 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid mtp2AA." );
            return eosl_false;
        }
        columns[colCnt].columnId = MTPLY2_SDCP;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_mtp2AA;
        colCnt++;
    }
    if (_errtype)
    {
        columns[colCnt].columnId = MTPLY2_ERRTYPE;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_errtype)
        {
            case PcrErrType_CYCLICAL:
                columns[colCnt].value.value.longVal = SD_ERR_CYC;
                break;
            case PcrErrType_NORMAL:
                columns[colCnt].value.value.longVal = SD_ERR_NRM;
                break;
            case PcrErrType_ALL:
                tc_error_response( handle, ctag, TE_IIDT, "Input, _errType Invalid" );
                return eosl_false;
                break;
        }
                TL1LOGP(PLOG_ERROR, "MTPLY2_ERRTYPE=%d\n",
                        columns[colCnt].value.value.longVal);
        colCnt++;
    }
    if (_maxPcrMsu)
    {
        columns[colCnt].columnId = MTPLY2_SDN1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxPcrMsu;
                TL1LOGP(PLOG_ERROR, "MTPLY2_SDN1=%d\n",
                        columns[colCnt].value.value.longVal);
        colCnt++;
    }
    if (_maxPcrMsuOct)
    {
        columns[colCnt].columnId = MTPLY2_SDN2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxPcrMsuOct;
                TL1LOGP(PLOG_ERROR, "MTPLY2_SDN2=%d\n",
                        columns[colCnt].value.value.longVal);
        colCnt++;
    }

    if(_hwm1MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM1MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm1MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if(_hwm5MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM5MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm5MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if(_hwm15MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM15MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm15MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if (_hwmLTL1)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL1;
        colCnt++;
    }
    if (_hwmHTL1)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL1;
        colCnt++;
    }
    if (_hwmLTL2)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL2;
        colCnt++;
    }
    if (_hwmHTL2)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL2;
        colCnt++;
    }
    if (_hwmLTL3)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL3;
        colCnt++;
    }
    if (_hwmHTL3)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL3;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_PRFL_SLKL2_req", "ENT_PRFL_SLKL2 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-PRFL-SLKL2" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ENT_PRFL_SLKL3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp3PrflId, char * _mtp3T1, char * _mtp3T2, char * _mtp3T3, char * _mtp3T4, char * _mtp3T5, char * _mtp3T7, char * _mtp3T12, char * _mtp3T13, char * _mtp3T14, char * _mtp3T17, char * _mtp3T19, char * _mtp3T20, char * _mtp3T21, char * _mtp3ITUT22, char * _mtp3ITUT23, char * _mtp3TstT1, char * _mtp3TstT2, char * _mtp3T31, char * _mtp3T33, char * _mtp3T34)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            mtp3PrflId;
    int            colCnt=0;
    int            timerTenths;
    int            cmd=SM_ENT_REQUEST;
    int            i;



    memset(&smCmd,0x0,sizeof(SMCMD_t));

    i = sscanf(_mtp3PrflId, "%d%c", &mtp3PrflId, &xchr);
    if ((i != 1) || (mtp3PrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> mtp3PrflId" );
        return eosl_false;
    }


    tableId = MTPLY3_PRFL_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal= mtp3PrflId;

    if(_mtp3T1)
    {
        columns[colCnt].columnId =MTPLY3_TMRT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T2)
    {
        columns[colCnt].columnId =MTPLY3_TMRT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T3)
    {
        columns[colCnt].columnId =MTPLY3_TMRT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T3, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T4)
    {
        columns[colCnt].columnId = MTPLY3_TMRT4;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T4, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T5)
    {
        columns[colCnt].columnId = MTPLY3_TMRT5;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T5, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T7)
    {
        columns[colCnt].columnId = MTPLY3_TMRT7;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T7, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T12)
    {
        columns[colCnt].columnId =MTPLY3_TMRT12;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T12, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T13)
    {
        columns[colCnt].columnId = MTPLY3_TMRT13;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T13, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T14)
    {
        columns[colCnt].columnId = MTPLY3_TMRT14;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T14, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T17)
    {
        columns[colCnt].columnId = MTPLY3_TMRT17;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T17, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T19)
    {
        columns[colCnt].columnId = MTPLY3_TMRTCRFT;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T19, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T20)
    {
        columns[colCnt].columnId = MTPLY3_TMRT20;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T20, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T21)
    {
        columns[colCnt].columnId =MTPLY3_TMRT21;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T21, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT22)
    {
        columns[colCnt].columnId =MTPLY3_TMRITUT22;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT22, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT23)
    {
        columns[colCnt].columnId =MTPLY3_TMRITUT23;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT23, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3TstT1)
    {
        columns[colCnt].columnId =MTPLY3_TMRT32;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3TstT1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }


    if(_mtp3TstT2)
    {
        columns[colCnt].columnId = MTPLY3_TMRT34;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3TstT2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T31)
    {
        columns[colCnt].columnId = MTPLY3_TMRT35;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T31, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T33)
    {
        columns[colCnt].columnId = MTPLY3_TMRT36;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T33, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T34)
    {
        columns[colCnt].columnId = MTPLY3_TMRT37;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T34, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }

        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_PRFL_SLKL3_req", "ENT_PRFL_SLK3 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-PRFL-SLKL3" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ENT_ROUTE_SS7_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _routeSs7, char * _lsetPriority)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            cmd=SM_ENT_REQUEST;
    int            colnCnt=0;
    int            pc, pcFormat;
    int            lset;
    int            lsetPriority;
    int            i;

    tableId = MTPROUT_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 3;
    if (ParsePcPlusIntAid(_routeSs7, &pc, &pcFormat, &lset) == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
        return eosl_false;
    }
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = pc;

    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = pcFormat;

    if (lset < 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
        return eosl_false;
    }
    rowKey.rowIndex[2].colType = TSSMI_LONG;
    rowKey.rowIndex[2].value.longVal = lset;

    if(_lsetPriority)
    {
        i = sscanf(_lsetPriority, "%d%c", &lsetPriority,&xchr);
        if ((i != 1) || (lsetPriority < 0))
        {
            tc_error_response( handle, ctag, TE_IDNV, "Input, Data Not Valid-> lsetPriority" );
            return eosl_false;
        }

        columns[colnCnt].columnId = MTPROUT_LSETPRIO;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = lsetPriority;
        colnCnt++;
    }

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_ROUTE_SS7_req", "ENT_ROUTE_SS7 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-ROUTE-SS7" );
    }

}

/**
 * Enter RULE IPFLTR
 */
eosl_bool agc_EM_NE_ENT_RULE_IPFLTR_req( const char * modifier,\
                                         eosl_handle handle,\
                                         TL1_TAG ctag ,\
                                         TL1_AID _ruleId,\
                                         TL1_AID _srcIp,\
                                         char * _srcPortStart,\
                                         char * _srcPortEnd,\
                                         TL1_AID _destIp,\
                                         char * _destPortStart,\
                                         char * _destPortEnd,\
                                         char * _ipHdrPrtcl,\
                                         AppType_ENUM * _app,\
                                         SrcType_ENUM * _src,\
                                         RuleType_ENUM * _ruleType,\
                                         int * _rank,\
                                         IPVersion_ENUM * _IPVersion,\
                                         PrimaryStateIn_ENUM * _pst)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;
    char           sp[RULE_IPFLTR_SPLEN_MAX+1];
    int            ruleNum;
    int            spEnum;
    char           *ipToken    = NULL;
    char           *mskToken   = NULL;
    ip_addr_t      ip;
    char           errMsg[TL1_IPMSG_MAX_MSG_LEN];
    int            errCode;
    int            ipFormats;
    int            ipValidation = 0;
    char           srcIpAddr[INET6_ADDRSTRLEN];
    char           dstIpAddr[INET6_ADDRSTRLEN];
    int            cardType    = RULE_IPFLTR_CARDTYPE_UNK;

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = RULE_IPFLTR_TAB_ID;
    
#ifdef ATCA
    if(parseATCAIpFilterAid(_ruleId, &cardType,&sp[0], &ruleNum, &spEnum,AID_IPFLTR_FULL) != SUCCESS)
    {
	tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
	return eosl_false;
    }
#else
    if(parseIpFilterAid(_ruleId, &sp[0], &ruleNum, &spEnum,
			AID_IPFLTR_FULL) != SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
        return eosl_false;
    }

    if(
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_MGT]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGC]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGD]) == 0)
    )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCM;
    }
    else if ((strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGA]) == 0) ||
             (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGB]) == 0)
            )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCS;
    }
    else 
    {
        cardType = RULE_IPFLTR_CARDTYPE_ALL;
    }
#endif

    if(ruleNum < RULE_IPFLTR_USERRNUM_MIN || ruleNum > RULE_IPFLTR_USERRNUM_MAX)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
        return eosl_false;
    }

    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = cardType;	
    rowKey.rowIndex[1].colType = TSSMI_OCTET_STRING;
    rowKey.rowIndex[1].value.stringVal.ptr = sp;
    rowKey.rowIndex[1].value.stringVal.len = strlen(sp);
    rowKey.rowIndex[2].colType = TSSMI_LONG;
    rowKey.rowIndex[2].value.longVal = ruleNum;
    rowKey.numIndices = 3;
    
    columns[colCnt].columnId = RULE_IPFLTR_COL_SP_ENUM;
    columns[colCnt].value.colType = TSSMI_LONG;
    columns[colCnt].value.value.longVal = spEnum;
    colCnt++;
    
    if(_srcIp)
    {
        /* If NULL was explicitly specified for the IP or IP/mask */
        if((eosl_strcasecmp(_srcIp, "NULL"     ) == 0) ||
           (eosl_strcasecmp(_srcIp, "NULL-NULL") == 0))
        {
            columns[colCnt].columnId       = RULE_IPFLTR_COL_SRC_IPADDR;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
            
            columns[colCnt].columnId       = RULE_IPFLTR_COL_SRC_NETMASK;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            /* If the _srcIp was NOT successfully split into an IP and mask token */
            if ((splitToken(_srcIp, &ipToken, &mskToken, 1, SPLIT_L2R) == FAIL)
		|| (ipToken  == NULL)
		|| (mskToken == NULL))
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ENT_RULE_IPFLTR_req",
                            "agc_EM_NE_ENT_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _srcIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid srcIp");
                return eosl_false;
            }
            
            /* Set allowed IP versions and validation tests to perform */
            ipFormats  = TL1_IPFMT_IPV4;
#ifdef ATCA
            ipFormats |= TL1_IPFMT_IPV6;
#endif
            /* If IP token is invalid */
            if ((errCode = tl1ValidateIP(ipToken,
                                         srcIpAddr,
                                         ipFormats,
                                         ipValidation,
                                         NULL,
                                         &ip)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "srcIp", errMsg));
                return eosl_false;
            }

#ifndef ATCA
            /* If the specified mask is invalid */
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > 32))
#else
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > (IS_IPV6(ip) ? 128 : 32)))
#endif
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ENT_RULE_IPFLTR_req",
                            "agc_EM_NE_ENT_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _srcIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid mask in srcIp");
                return eosl_false;
            }
            
            columns[colCnt].columnId                  = RULE_IPFLTR_COL_SRC_IPADDR;
            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(srcIpAddr);
            columns[colCnt].value.value.stringVal.ptr = srcIpAddr;
            colCnt++;

            columns[colCnt].columnId            = RULE_IPFLTR_COL_SRC_NETMASK;
            columns[colCnt].value.colType       = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(mskToken);
            colCnt++;
        }
    }
    if(_srcPortStart)
    {       
        if(eosl_strcasecmp(_srcPortStart, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_START;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_srcPortStart,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid srcPortStart");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_START;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_srcPortStart);
            colCnt++;
        }
    }
    if(_srcPortEnd)
    {       
        if(eosl_strcasecmp(_srcPortEnd, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_END;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_srcPortEnd,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid srcPortEnd");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_END;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_srcPortEnd);
            colCnt++;
        }
    }
    if(_destIp)
    {
        /* If NULL was explicitly specified for the IP or IP/mask */
        if((eosl_strcasecmp(_destIp, "NULL"     ) == 0) ||
           (eosl_strcasecmp(_destIp, "NULL-NULL") == 0))
        {
            columns[colCnt].columnId       = RULE_IPFLTR_COL_DEST_IPADDR;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
            
            columns[colCnt].columnId       = RULE_IPFLTR_COL_DEST_NETMASK;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            /* If the _destIp was NOT successfully split into an IP and mask token */
            if ((splitToken(_destIp, &ipToken, &mskToken, 1, SPLIT_L2R) == FAIL)
		|| (ipToken  == NULL)
		|| (mskToken == NULL))
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ENT_RULE_IPFLTR_req",
                            "agc_EM_NE_ENT_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _destIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid destIp");
                return eosl_false;
            }
            
            /* Set allowed IP versions and validation tests to perform */
            ipFormats  = TL1_IPFMT_IPV4;
#ifdef ATCA
            ipFormats |= TL1_IPFMT_IPV6;
#endif
            /* If IP token is invalid */
            if ((errCode = tl1ValidateIP(ipToken,
                                         dstIpAddr,
                                         ipFormats,
                                         ipValidation,
                                         NULL,
                                         &ip)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "destIp", errMsg));
                return eosl_false;
            }

#ifndef ATCA
            /* If the specified mask is invalid */
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > 32))
#else
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > (IS_IPV6(ip) ? 128 : 32)))
#endif
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ENT_RULE_IPFLTR_req",
                            "agc_EM_NE_ENT_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _destIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid mask in destIp");
                return eosl_false;
            }
            
            columns[colCnt].columnId                  = RULE_IPFLTR_COL_DEST_IPADDR;
            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(dstIpAddr);
            columns[colCnt].value.value.stringVal.ptr = dstIpAddr;
            colCnt++;

            columns[colCnt].columnId            = RULE_IPFLTR_COL_DEST_NETMASK;
            columns[colCnt].value.colType       = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(mskToken);
            colCnt++;
        }
    }
    if(_destPortStart)
    {       
        if(eosl_strcasecmp(_destPortStart, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_START;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_destPortStart,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid destPortStart");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_START;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_destPortStart);
            colCnt++;
        }
    }
    if(_destPortEnd)
    {       
        if(eosl_strcasecmp(_destPortEnd, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_END;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_destPortEnd,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid destPortEnd");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_END;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_destPortEnd);
            colCnt++;
        }
    }
    if(_ipHdrPrtcl)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_IPHDR_PRTCL;
        if(strlen(_ipHdrPrtcl) > RULE_IPFLTR_IPHDRPRTCLLEN_MAX)
        {
            tc_error_response(handle, ctag, TE_IIDT,
                              "Input, Invalid Input -> ipHdrPrtcl");
            return eosl_false;
        }

        /* if it's NULL, that's valid */
        if (!eosl_strcasecmp(_ipHdrPrtcl,"NULL"))
        {
            columns[colCnt].value.colType             = TSSMI_RESET;
        }         

        else
        {
            /* validate integer string input */
            if(IsInputStrInRange(_ipHdrPrtcl, "0123456789"))
            {
                int val = atoi(_ipHdrPrtcl);

                if (val < IPPROTO_IP || val >= IPPROTO_MAX)
                {
                    tc_error_response(handle, ctag, TE_IIDT,
                                      "Input, Invalid Input -> ipHdrPrtcl");
                    return eosl_false;
                }
            }

            /* validate any other string input */
            else
            {
                int ival = ruleIpFltr_ipHdrPrtcl2enum(_ipHdrPrtcl);

                if (ival <= RULE_IPFLTR_IHP_MIN || ival >= RULE_IPFLTR_IHP_MAX)
                {
                    tc_error_response(handle, ctag, TE_IIDT,
                                      "Input, Invalid Input -> ipHdrPrtcl");
                    return eosl_false;
                }

                /* must fit, since validator matched the string */
                strcpy(_ipHdrPrtcl, RuleIpFltr_ipHdrPrtcl_vals[ival]);
            }

            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(_ipHdrPrtcl);
            columns[colCnt].value.value.stringVal.ptr = _ipHdrPrtcl;
        }

        colCnt++;
    }
    if(_app)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_APP;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_app)
        {
          case AppType_NONE:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_APP_NONE;
              break;
          default:
                tc_error_response(handle, ctag, TE_IIDT,
                                  "Input, Invalid app. Only NONE is "
                                  "supported for user defined rules");
                return eosl_false;
              break;
        }
        colCnt++;
    }    
    if(_src)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_SRC;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_src)
        {
          case SrcType_PROTOCOL:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_PROTOCOL;
              break;
          case SrcType_SYSTEM:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_SYSTEM;
              break;
          case SrcType_USER:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_USER;
              break;
          default:
              break;
        }
        colCnt++;
    }
    if(_ruleType)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_RULE_TYPE;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_ruleType)
        {
          case RuleType_BLOCK:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_RULETYPE_BLOCK;
              break;
          case RuleType_PASS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_RULETYPE_PASS;
              break;
          default:
	      tc_error_response(handle, ctag, TE_IIDT,
			      "Input, Invalid ruleType");
	      return eosl_false;
              break;
        }
#ifdef ATCA
        if (*_ruleType == RuleType_POLICE)
	{
              tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid ruleType -> POLICE not supported in ATCA");
	      return eosl_false;
	}
#endif	
        colCnt++;
    }

    if(_rank)
    {
        if((*_rank < RULE_IPFLTR_USERRANK_MIN) || (*_rank > RULE_IPFLTR_USERRANK_MAX))
        {
	      tc_error_response(handle, ctag, TE_IIDT,
			      "Input, Invalid rank");
	      return eosl_false;
        }
        columns[colCnt].columnId = RULE_IPFLTR_COL_RANK;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_rank;
        colCnt++;
    }                            
#if 1  /* FID 14341.0 - enable this code when platform is ready for this parameter */
    if(_IPVersion)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_IPVERSION;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_IPVersion)
        {
            case IPVersion_BOTH:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_BOTH;
                break;

            case IPVersion_IPV4:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_V4;
                break;

            case IPVersion_IPV6:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_V6;
                break;

            default:
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid IPVersion");
                break;
        }

        colCnt++;
    }
#endif
    if(_pst)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_pst) 
        {
          case PrimaryStateIn_IS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_PST_IS;
              break;
          case PrimaryStateIn_OOS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_PST_OOS;
              break;
          default:
              break;
        }
        colCnt++;
    }
    colArray.numCols  = colCnt;
    colArray.colArray = columns;
    
    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_RULE_IPFLTR", "ENT-RULE-IPFLTR - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    
    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ENT-RULE-IPFLTR" );
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
    
}

eosl_bool agc_EM_NE_ENT_SCCP_ROUTE_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _pcId,\
									char * _asId,\
									char * _routeCtxt)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    int            dpc;
    short          length;
    int            colCnt = 0;
    PointCodeFormat pcFormat = PC_INVALID;

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = SCCPROUTE_TAB_ID;

#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif


    /* AID string format, LGP: <pc> */
    /* AID string format, ATCA: <netId>-DPC-<pc> */

#ifndef ATCA
    p_commonStr = _pcId;
#else
    if (ParseNetIdKey((char *)_pcId, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid pcId");
       return eosl_false;
    }
#endif

    /*bug90192*/
#ifdef ATCA
    if((eosl_strcasecmp(p_commonStr, "DEF_ANSI") == 0 )
            ||(eosl_strcasecmp(p_commonStr, "DEF_ITU") == 0 ))
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, PC Invalid");
        return eosl_false;
    }
#endif

    dpc = pc_atoi(p_commonStr, &pcFormat);
    if(dpc == -1)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, PC Invalid");
        return eosl_false;
    }

    rowKey.rowIndex[SCCPROUTE_PC].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPROUTE_PC].value.longVal = dpc;
    rowKey.rowIndex[SCCPROUTE_PCFORMAT].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPROUTE_PCFORMAT].value.longVal = pcFormat;
#ifndef ATCA
    rowKey.numIndices = 2;
#else
    rowKey.rowIndex[SCCPROUTE_NETID].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPROUTE_NETID].value.longVal = netId;
    rowKey.numIndices = 3;
#endif

#ifndef ATCA

    /* _asId must be NULL, ignore _routeCtxt */
    if ((_asId != NULL) && (eosl_strcasecmp(_asId, "NULL") != 0))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid asId" );
        return eosl_false;
    }

#else

    if ((_asId) && (IsInputStrInRange(_asId, "0123456789")))
    {
	columns[colCnt].columnId = SCCPROUTE_ASID;
	columns[colCnt].value.colType = TSSMI_LONG;
	columns[colCnt].value.value.longVal = atoi(_asId);
    }
    else
    {
	tc_error_response( handle, ctag, TE_IIDT, "Invalid Input asId" );
	return eosl_false;
    }
    colCnt++;

    if (_routeCtxt)
    {
	if (IsInputStrInRange(_routeCtxt, "0123456789"))
	{
	    columns[colCnt].columnId = SCCPROUTE_ROUTECTXT;
	    columns[colCnt].value.colType = TSSMI_LONG;
	    columns[colCnt].value.value.longVal = strtoul(_routeCtxt, (char **)NULL, 10);
	}
	else if (eosl_strcasecmp(_routeCtxt, "NULL") == 0)
	{
	    columns[colCnt].columnId = SCCPROUTE_ROUTECTXT;
	    columns[colCnt].value.colType = TSSMI_RESET;
	}
	else
	{
	    tc_error_response( handle, ctag, TE_IIDT, "Invalid Input routeCtxt" );
	    return eosl_false;
	}
	colCnt++;
    }
#endif

    TL1LOGP(PLOG_INFO, "colCnt is %d\n", colCnt);

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_SCCP_ROUTE_req", "ENT_SCCP_ROUTE - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);



    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ENT-SCCP-ROUTE" );
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

eosl_bool agc_EM_NE_ENT_SCCP_SSN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sccpSsnAid, SccpSsnStartup_ENUM * _startMode, nind_ENUM * _nind)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;
    int            pc;
    int            ssn;
    int            status;
    PointCodeFormat pcFormat = PC_INVALID;
#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif


    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = SCCPSSN_TAB_ID;

    /* AID string format, LGP: <pc>-<ssn> */
    /* AID string format, ATCA: <netId>-DPC-<pc>-<ssn> */

#ifndef ATCA
    p_commonStr = _sccpSsnAid;
#else
    if (ParseNetIdKey((char *)_sccpSsnAid, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
    }
#endif

    status = convertSccpSsnAid(p_commonStr, &pc, &pcFormat, &ssn);
    if(status == -1)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
    }
    rowKey.rowIndex[SCCPSSN_PC].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPSSN_PC].value.longVal = pc;
    rowKey.rowIndex[SCCPSSN_PCFORMAT].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPSSN_PCFORMAT].value.longVal = pcFormat;
    rowKey.rowIndex[SCCPSSN_SSN].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPSSN_SSN].value.longVal = ssn;
#ifndef ATCA
    rowKey.numIndices = 3;
#else
    rowKey.rowIndex[SCCPSSN_NETID].colType = TSSMI_LONG;
    rowKey.rowIndex[SCCPSSN_NETID].value.longVal = netId;
    rowKey.numIndices = 4;
#endif
    
    if(_startMode)
    {
        columns[colCnt].columnId = SCCPSSN_STARTUP;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = MAPTL1TSMCSccpSsnSt[*_startMode];
        colCnt++;

    }
    if(_nind)
    {
        columns[colCnt].columnId = SCCPSSN_NIND;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_nind;
        colCnt++;

    }
 
 
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_SCCP_SSN_req", "ENT-SCCP-SSN - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ENT-SCCP-SSN" );
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 * Sets up parameters associated with a DS 1, DS1C, DS2, or DS3 facility. GR 199.
 */
eosl_bool agc_EM_NE_ENT_T1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id, char * _eqlz, FormatSignal_ENUM * _fmt, LineCode_ENUM * _linecde, DSMode_ENUM * _omode, TimingReference_ENUM * _tmgref, Side_Network_ENUM * _iftype, PrimaryStateIn_ENUM * _pst)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = T1_TAB_ID;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[MAX_TSM_COLS];
    SMCMD_t           smCmd;
    int               cmd = SM_ENT_REQUEST;
    int               colCnt = 0, tenths = 0;

    TL1LOGP (PLOG_ERROR, "T1 aid:%s\n", _ds_id);
    TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);
    
    if(ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7PORT, NULL) == SUCCESS)
    {
        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    
    }
    else if (ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7, NULL) == SUCCESS)
    {
        TL1LOGP (PLOG_ERROR, "shelf:%d, atcaSlot:%d, amcSlot:%d \n",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3);
      
            rowKey.numIndices = 3;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
       
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if(_eqlz)
    {
        columns[colCnt].columnId            = T1_EQLZ;
        columns[colCnt].value.colType       = TSSMI_LONG;
        if (StringToDecimal2(_eqlz, &tenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid eqlz Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = tenths;
        colCnt++;
    }

    if(_fmt)
    {
        columns[colCnt].columnId            = T1_FMT;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_fmt)
        {
          case FormatSignal_ESF:
              columns[colCnt].value.value.longVal = T1_FMT_ESF;
              break;
          case FormatSignal_SF:
              columns[colCnt].value.value.longVal = T1_FMT_SF;
              break;
          case FormatSignal_ESF_NOFDL:
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid fmt Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_linecde)
    {
        columns[colCnt].columnId            = T1_LINECDE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_linecde)
        {
          case LineCode_AMI:
              columns[colCnt].value.value.longVal = T1_LINECDE_AMI;
              break;
          case LineCode_B8ZS:
              columns[colCnt].value.value.longVal = T1_LINECDE_B8ZS;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid lineCde Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_omode)
    {
        columns[colCnt].columnId            = T1_OMODE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_omode)
        {
          case DSMode_AIS:
              columns[colCnt].value.value.longVal = T1_OMODE_AIS;
              break;
          case DSMode_NORM:
              columns[colCnt].value.value.longVal = T1_OMODE_NORM;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid oMode Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_tmgref)
    {
        columns[colCnt].columnId            = T1_TMGREF;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_tmgref)
        {
          case TimingReference_NONE:
              columns[colCnt].value.value.longVal = T1_TMGREF_NONE;
              break;
          case TimingReference_PRI:
          case TimingReference_SEC:
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmgRef Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_iftype)
    {
        columns[colCnt].columnId            = T1_IFTYPE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_iftype)
        {
          case Side_Network_NETWORKSIDE:
              columns[colCnt].value.value.longVal = T1_IFTYPE_NETWORK;
              break;
          case Side_Network_USERSIDE:
              columns[colCnt].value.value.longVal = T1_IFTYPE_USER;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid ifType Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_pst)
    {
        columns[colCnt].columnId = T1_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_pst)
        {
          case PrimaryStateIn_IS:
              columns[colCnt].value.value.longVal = T1_PST_IS;
              break;
          case PrimaryStateIn_OOS:
              columns[colCnt].value.value.longVal = T1_PST_OOS;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pst Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }


    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                       &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ENT-T1" );
#else
    DSX_CMD_BUF_t       buffer;
    char                *cmdClass;
    unsigned int        cmd;


    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_PORT_ENTER);

    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id,
                             (AID_IOM | AID_T3 | AID_TUG3 | AID_AU3 | AID_PORT | AID_STS1 |
                              AID_OC3_STS1 | AID_OC3_STS1_T1 | AID_AU3TUG3_T1), &buffer.DeviceMap))
    {
        tc_error_response(handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
        return eosl_false;
    }

    /* Handle wildcard DeviceMap ambiguities here */
    switch(buffer.DeviceMap)
    {
    case DEVICE_MAP_IOM_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
        break;
    case DEVICE_MAP_IOM_OC3_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
        break;
    case DEVICE_MAP_IOM_OC12_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
        break;
    case DEVICE_MAP_IOM_T3:
        buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
        break;
    case DEVICE_MAP_IOM:
        buffer.DeviceMap = DEVICE_MAP_IOM_T1;
        break;
    case DEVICE_MAP_IOM_STM1_TUG3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
        break;
    case DEVICE_MAP_IOM_STM4_TUG3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
        break;
    case DEVICE_MAP_IOM_STM1_AU3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
        break;
    case DEVICE_MAP_IOM_STM4_AU3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
        break;
    }

    cmdClass = DS3_CMD_CLASS;
    cmd = DS3CMD_ENT_T1;

    if (_eqlz)
    {
        if(!IsInputStrInRange(_eqlz ,"0123456789"))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid eqlz" );
            return eosl_false;
        }
        buffer.Data.T1Enter.Eqlz.value = atoi(_eqlz);
        buffer.Data.T1Enter.Eqlz.valid = VALID_VALUE;
    }

    if (_fmt)
    {
        buffer.Data.T1Enter.Fmt.value = *_fmt;
        buffer.Data.T1Enter.Fmt.valid = VALID_VALUE;
    }

    if (_linecde)
    {
        buffer.Data.T1Enter.Linecde.value = *_linecde;
        buffer.Data.T1Enter.Linecde.valid = VALID_VALUE;
    }

    if (_omode)
    {
        buffer.Data.T1Enter.Omode.value = *_omode;
        buffer.Data.T1Enter.Omode.valid = VALID_VALUE;
    }

    if (_tmgref)
    {
        buffer.Data.T1Enter.Tmgref.value = *_tmgref;
        buffer.Data.T1Enter.Tmgref.valid = VALID_VALUE;
    }

    if (_iftype)
    {
        buffer.Data.T1Enter.Side.value = *_iftype;
        buffer.Data.T1Enter.Side.valid = VALID_VALUE;
    }

    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.T1Enter.State.value |= PST_IS_BIT;
            buffer.Data.T1Enter.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.T1Enter.State.value |= PST_OOS_BIT;
            buffer.Data.T1Enter.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIDT, "Invalid PrimaryState" );
            return eosl_false;
        }
    }


    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_PORT_ENTER,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ENT_T1_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ENT-T1" );
#endif
}


/**
 */
eosl_bool agc_EM_NE_ENT_T3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id, char * _aisc, AlarmIndicationSignal_ENUM * _aist, FMT_ENUM * _fmt, ON_OFF_ENUM * _idle, int * _lbo, T3LineCode_ENUM * _linecde, char * _map, DSMode_ENUM * _omode, ON_OFF_ENUM * _pbit, XBit_ENUM * _xbit, XBitReceive_ENUM * _xbitrcv, XBitPolarity_ENUM * _xpol, PrimaryStateIn_ENUM * _pst, SecondaryState_ENUM * _sst)
{
    DSX_CMD_BUF_t        buffer;
    int          enumBits1;
    int          enumBits2;  /* Assuming for now bits 32 - 63 are not needed */
    int          t3EnumBits;

    /*
    ** prepare t3 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_ENT_T3);
    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id, (AID_IOM | AID_T3),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /* Handle wildcard DeviceMap ambiguities here */
    switch(buffer.DeviceMap)
    {
    case DEVICE_MAP_IOM:
        buffer.DeviceMap = DEVICE_MAP_IOM_T3;
        break;
    }

    if (_aisc)
    {
        /* Create a bit map containing all specified AISC values */
        if (enumStringListToBitMap(_aisc,
                                   &AISC_ENUM_type,
                                   &enumBits1,
                                   &enumBits2) == eosl_false)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid AISC Value" );
            return eosl_false;
        }

        /* If "NONE" is the only AISC value specified */
        if ((enumBits1 & (1 << AISC_NONE)) == enumBits1)
        {
            /* Clear bitmap to indicate no values */
            enumBits1 = 0;
        }
        else
        {
            /* Design Note: AISC is not supported at this time, so reject this
             *     command unless AISC=NONE
             */
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid AISC Value" );
            return eosl_false;
        }

        buffer.Data.T3Enter.Aisc.value = enumBits1;
        buffer.Data.T3Enter.Aisc.valid = VALID_VALUE;
    }

    if (_aist)
    {
        buffer.Data.T3Enter.Aist.value = *_aist;
        buffer.Data.T3Enter.Aist.valid = VALID_VALUE;
    }

    if (_fmt)
    {
        if ((*_fmt != FMT_ASYNC) && (*_fmt != FMT_CBIT))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid FMT Value" );
            return eosl_false;
        }
        buffer.Data.T3Enter.Fmt.value = *_fmt;
        buffer.Data.T3Enter.Fmt.valid = VALID_VALUE;
    }

    if (_idle)
    {
        if (*_idle == ON_OFF_ON)
        {
            buffer.Data.T3Enter.Idle.value = TRUE;
        }
        else
        {
            buffer.Data.T3Enter.Idle.value = FALSE;
        }
        buffer.Data.T3Enter.Idle.valid = VALID_VALUE;
    }

    if (_lbo)
    {
        buffer.Data.T3Enter.Lbo.value = *_lbo;
        buffer.Data.T3Enter.Lbo.valid = VALID_VALUE;
    }

    if (_linecde)
    {
        if (*_linecde != T3LineCode_B3ZS)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid LINECDE Value" );
            return eosl_false;
        }
        buffer.Data.T3Enter.Linecde.value = *_linecde;
        buffer.Data.T3Enter.Linecde.valid = VALID_VALUE;
    }

    if (_map)
    {
        if (enumStringListToBitMap(_map, &T3Map_ENUM_type, &enumBits1, &enumBits2) == eosl_false)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Map Value" );
            return eosl_false;
        }

        /* Map Lumos enums to DS3 enums. */
        t3EnumBits = 0;
        if (enumBits1 & (1 << T3Map_NA))
        {
            t3EnumBits = 0;
        }
        else
        {
            if (enumBits1 & (1 << T3Map_ASYNC))
            {
                t3EnumBits |= (1 << T3MAP_ASYNC);  /* Defined in dsx_cmds.h */
            }
            if (enumBits1 & (1 << T3Map_DL))
            {
                t3EnumBits |= (1 << T3MAP_DL);
            }
            if (enumBits1 & (1 << T3Map_SYNC))
            {
                t3EnumBits |= (1 << T3MAP_SYNC);
            }
        }

        buffer.Data.T3Enter.Map.value = t3EnumBits;
        buffer.Data.T3Enter.Map.valid = VALID_VALUE;
    }

    if (_omode)
    {
        buffer.Data.T3Enter.Omode.value = *_omode;
        buffer.Data.T3Enter.Omode.valid = VALID_VALUE;
    }

    if (_pbit)
    {
        if (*_pbit == ON_OFF_ON)
        {
            buffer.Data.T3Enter.Pbit.value = TRUE;
        }
        else
        {
            buffer.Data.T3Enter.Pbit.value = FALSE;
        }
        buffer.Data.T3Enter.Pbit.valid = VALID_VALUE;
    }

    if (_xbit)
    {
        buffer.Data.T3Enter.Xbit.value = *_xbit;
        buffer.Data.T3Enter.Xbit.valid = VALID_VALUE;
    }

    if (_xbitrcv)
    {
        buffer.Data.T3Enter.Xbitrcv.value = *_xbitrcv;
        buffer.Data.T3Enter.Xbitrcv.valid = VALID_VALUE;
    }

    if (_xpol)
    {
        buffer.Data.T3Enter.Xpol.value = *_xpol;
        buffer.Data.T3Enter.Xpol.valid = VALID_VALUE;
    }

    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.T3Enter.State.value |= PST_IS_BIT;
            buffer.Data.T3Enter.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.T3Enter.State.value |= PST_OOS_BIT;
            buffer.Data.T3Enter.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIDT, "Invalid PrimaryState" );
            return eosl_false;
        }
    }

    if (_sst)
    {
        switch (*_sst)
        {
        case SecondaryState_AINS:
            buffer.Data.T3Enter.State.value |= SST_AINS_BIT;
            buffer.Data.T3Enter.State.valid |= SST_AINS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIDT, "Invalid SecondaryState" );
            return eosl_false;
        }
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_ENT_IF,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_ENT_T3,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ENT_T3_req","We have a bad response \n");
       /* ??? Change to CMD_T3 when T3 error codes are in TL1ErrorResp. */
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ENT-T3" );
}


/**
 */
eosl_bool agc_EM_NE_ENT_TOLLFREE_NPA_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _CcNpa)
{
    int            cCode;
    int            npa;
    char           retChar;
    char           tollfreeNPA[MAX_NPA_LENGTH + 1];
    char           countrycode_id[MAX_COUNTRYCODE_ID_LENGTH + 1];
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colCnt = 0;
    

    tableId = TELICA_TABLE_TOLLFREE_NPA;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 0;
    
   /*
    * Validate the Entry.Entry should be CountryCode-Npa where countrycode and npa 
    * are integer values ranging in between 1 to 99999
    */

    if (sscanf(_CcNpa,"%d-%d%c[^0-9]", &cCode,&npa,&retChar) != 2)
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid Input  Enter Countrycode-NPA ");
       return eosl_false;
    }
    
    if((cCode<1||cCode>99999)||(npa<1||npa>99999))
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid range");
       return eosl_false;
    }

    sprintf(countrycode_id,"%d",cCode);
    sprintf(tollfreeNPA, "%d" , npa);


    rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
    rowKey.rowIndex[0].value.stringVal.len = strlen(countrycode_id);
    rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) countrycode_id;

    rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
    rowKey.rowIndex[1].value.stringVal.len = strlen(tollfreeNPA);
    rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) tollfreeNPA;

    rowKey.numIndices = 2;
    
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_TOLLFREE_NPA_req", "ENT-TOLLFREE-NPA - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ENT-TOLLFREE-NPA" ); /* success */
    }
    
}

/**
 * Enter User LISECU
 */
eosl_bool agc_EM_NE_ENT_USER_LISECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid,\
									char * _pid,\
									char * _cid,\
									UserPrivilege_ENUM _uap,\
									int * _page,\
									int * _pcnd,\
									int * _tmout,\
									BoolYN_ENUM * _freezable,\
									PrimaryStateIn_ENUM * _pst)
{
    
    int status;
    int etsili = 1;
    int                    result;
    USER_DATA_t            userData;
    char                   errorMsg[256];
    char                   tl1Owner[33]   = {0};
#ifdef ATCA
    SWLIC_RETCODE          retcode;
 
    /*check if has licence key*/
    retcode = swLicMgrFeatureCheck(SWLIC_RTUTAG_MGC8_C4_LAWFUL_INT);
   
    if ( retcode == SWLIC_ERR_LIC_INV_KEY )
    {
        tc_error_response(handle, ctag, TE_FRNR, "RTU Does Not Reply");
        return  eosl_false;
    }
    else if (retcode == SWLIC_ERR_FAIL)
    {
        tc_error_response(handle, ctag, TE_ERNS, "RTU Does Not Support Command");
        return  eosl_false;
    }
#endif

    memset(&userData, 0, sizeof(userData));
    userData.maxSes = TL1_DEFAULT_SESSIONS_PER_USER;

    if ( IsUserNameValid(_uid, MIN_USER_NAME_SIZE, MAX_USER_NAME_SIZE)
         == eosl_false)
    {
        tc_error_response(handle,ctag,TE_PIUI,
                          "User ID's must have a length of"
                          "8-16 alphanumeric characters");
        return  eosl_false;
    }
    else
    {
        strcpy(userData.username,_uid);
    }

    /* If the password is invalid based on the password complexity level */
    if ( IsPasswordValid(getMemPasswdComplx(),
                         _uid,
                         _pid,
                         NULL,
                         NULL,
                         getMemPasswdMaxReuse(),
                         errorMsg)  == eosl_false )
    {
        tc_error_response(handle, ctag, TE_PIUI, errorMsg);
        return  eosl_false;
        /* send event */
    }
    else
    {
        strcpy(userData.password,_pid);
    }

    if(_uap!=UserPrivilege_ADMIN)
    {
          tc_error_response(handle,ctag, TE_PIUI, "UAP must be ADMIN");
          return eosl_false;
    }


    if (_cid==NULL)
    {
        strcpy(userData.cid,"SERIAL");
    }
    else
    {
        if (strlen(_cid) > MAX_CID_SIZE)
        {
            sprintf(errorMsg,"Input, Invalid cid - "
                    "CID length exceeds %d characters",MAX_CID_SIZE);
            tc_error_response( handle, ctag, TE_IIDT, errorMsg );
            return eosl_false;
        }
        else
        {
            strcpy( userData.cid,_cid);
        }
    }

    if (_page==NULL)
    {
        userData.page=DEFAULT_PAGE;
    }
    else
    {
        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
        userData.page=*_page;
    }

    if (_pcnd==NULL)
    {
        userData.pcnd=DEFAULT_PCND;
    }
    else
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
        userData.pcnd=*_pcnd;
    }

    if (_tmout==NULL)
    {
        userData.tmout=getTMOUT();
    }
    else
    {
        if ((*_tmout < 0) || (*_tmout > 99))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmout" );
            return eosl_false;
        }
        userData.tmout=*_tmout;
    }

    userData.calea = 0;

    if (_freezable==NULL)
    {
      userData.freezeInh = 0; /*set default value*/
    }
    else
    {
      /* Design Note: The attribute "Freeze inhibit" is
      **   stored in the GoAhead database,
      **   which requires the input value _freezable to be inverted.
      */
      userData.freezeInh = (*_freezable == BoolYN_Y) ? 0 : 1;
    }

    userData.etsiLi = 0;
    userData.state = 0;
    userData.actTmout = 0;
    userData.accLevel = UserPrivilege_ADMIN;
    userData.authType = UserAuthType_LOCAL;

    /* If the new account is to be administratively managed Out-Of_service */
    if ((_pst) && (*_pst == PrimaryStateIn_OOS))
    {
        /* Update the user state to indicate administratively OOS */
        userData.state |= USR_MNG_BIT;
    }
    else
    {
        /* Update the user state to indicate IS and expired
        ** but in grace period
        */
        userData.state |= USR_SVC_BIT;
        userData.state |= USR_EXP_BIT;
        userData.state |= USR_GRC_BIT;
    }

    /* FID15737.0 START */
    if (getTL1UserOwnerName(handle, tl1Owner) != eosl_true)
    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ENT_USER_LISECU_req",
                   "agc_EM_NE_ENT_USER_LISECU_req get TL1 OWNER NAME failed!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    else
    {
	strncpy(userData.ownername, tl1Owner, strlen(tl1Owner)+1);
    }
    /* FID15737.0 END */

    result = SecAddUser(handle, &userData);

    if (result < 0)
    {
        if (result == -2)
        {
            tc_error_response(handle,ctag,TE_PIUI,"Username is not unique");
        }
        else
        {
            tc_error_response(handle,ctag,TE_SROF,"Unable to add user");
        }
        return eosl_false;
    }

    status = ModifyUserDb(_uid, NULL, NULL, NULL, NULL, NULL, NULL,
                          NULL, NULL, NULL,NULL,NULL,NULL, NULL, &etsili, NULL, NULL, NULL, NULL, NULL);

    if (status == 0)
    {
        /* need to get correct err code */
        tc_error_response(handle,ctag,TE_SROF,"Unable to add user");
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ENT-USER-LISECU" );
}

/**
 * Add a user account. Only administrators may do this. The
 * AID block contains the user identifier.
 *
 * Defined in TR-835
 */
eosl_bool agc_EM_NE_ENT_USER_SECU_req( const char * modifier,\
                                       eosl_handle handle,\
                                       TL1_TAG ctag ,\
                                       char * _uid,\
                                       char * _pid,\
                                       char * _cid,\
                                       UserPrivilege_ENUM _uap,\
                                       int * _page,\
                                       int * _pcnd,\
                                       int * _tmout,\
                                       BoolYN_ENUM * _calea,\
                                       BoolYN_ENUM * _freezable,\
                                       int * _maxSes,\
                                       int * _actTmout,\
                                       UserAuthType_ENUM * _authType,\
                                       PrimaryStateIn_ENUM * _pst)
{
    int                    result;
    USER_DATA_t            userData;
    char                   errorMsg[256];

    memset(&userData, 0, sizeof(userData));

    if ( IsUserNameValid(_uid, MIN_USER_NAME_SIZE, MAX_USER_NAME_SIZE) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID's must have a length of 8-16 alphanumeric characters");
        return  eosl_false;
        /* send event */
    }
    else
    {
        strcpy(userData.username,_uid);
    }

    /* FID 16687.1 adds authType([LOCAL], REMOTE) to a user; and changes the _pid field to an optional field.
       On ATCA:
         When a user is added with authType=LOCAL, the pid is a MUST;
         when a user is added with authType=REMOTE, the password of it will be maintained on a Radius Server remotely;
              thus the pid can be empty, or be ignored if provisioned.
       On LGP:
         pid is always a MUST.
         Field of authType is not applied.
    */
#ifdef ATCA
    if (_authType == NULL || *_authType == UserAuthType_LOCAL)
    {
#endif
        if (_pid == NULL)
        {
            tc_error_response( handle, ctag, TE_IIDT, "ERROR, PID must be provisioned" ); 
            return eosl_false;
        }
        /* If the password is invalid based on the password complexity level */
        if ( IsPasswordValid(getMemPasswdComplx(),
                             _uid,
                             _pid,
                             NULL,
                             NULL,
                             getMemPasswdMaxReuse(),
                             errorMsg)  == eosl_false )
        {
            tc_error_response(handle, ctag, TE_PIUI, errorMsg);
            return  eosl_false;
            /* send event */
        }
        else
        {
            strcpy(userData.password,_pid);
        }
#ifdef ATCA
    }
    else
    {
        userData.password[0] = '\0';
    }
#endif

         userData.accLevel=_uap;
    /* Move validation checking to here */

    if (_cid==NULL)
    {
        strcpy(userData.cid,"SERIAL");
    }
    else
    {
        if (strlen(_cid) > MAX_CID_SIZE)
        {
            sprintf(errorMsg,"Input, Invalid cid - CID length exceeds %d characters",MAX_CID_SIZE);
            tc_error_response( handle, ctag, TE_IIDT, errorMsg );
            return eosl_false;
        }
        else
        {
            strcpy( userData.cid,_cid);
        }
    }

    strcpy(userData.cid,"NULL");

    if (_page==NULL)
    {
        userData.page=DEFAULT_PAGE;
#ifdef ATCA
        /* FID 16687.1 */
        if (_authType && (*_authType == UserAuthType_REMOTE))
        {
            userData.page = 0;
        }
#endif
    }
    else
    {
        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
#ifdef ATCA
        /* FID 16687.1 */
        if (_authType && (*_authType == UserAuthType_REMOTE) && (*_page != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, page should be '0' for REMOTE user." );
            return eosl_false;
        }
#endif
        userData.page=*_page;
    }

    if (_pcnd==NULL)
    {
        userData.pcnd=DEFAULT_PCND;
    }
    else
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
        userData.pcnd=*_pcnd;
    }

    if (_tmout==NULL)
    {
        userData.tmout=getTMOUT();
    }
    else
    {
        if ((*_tmout < 0) || (*_tmout > 99))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmout" );
            return eosl_false;
        }
        userData.tmout=*_tmout;
    }

    if (_calea==NULL)
    {
      userData.calea = 0; /*set default value*/
    }
    else
    {
      userData.calea = (*_calea == BoolYN_Y) ? 1 : 0;
    }


    if (_freezable==NULL)
    {
      userData.freezeInh = 0; /*set default value*/
    }
    else
    {
      /* Design Note: The attribute "Freeze inhibit" is stored in the GoAhead database,
       *     which requires the input value _freezable to be inverted.
       */
      userData.freezeInh = (*_freezable == BoolYN_Y) ? 0 : 1;
    }

    if (_maxSes == NULL)
    {
        userData.maxSes = TL1_DEFAULT_SESSIONS_PER_USER; /*set default value*/
    }
    else
    {
        if ((*_maxSes < TL1_MIN_SESSIONS_PER_USER) || (*_maxSes > TL1_MAX_SESSIONS_PER_USER))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid maxSes");
            return eosl_false;
        }
        userData.maxSes = *_maxSes;
    }

    if (_actTmout == NULL)
    {
        userData.actTmout = getMemActTmout();
    }
    else
    {
        if (*_actTmout < 0 || *_actTmout > 99)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid user activity timeout" );
            return eosl_false;
        }
        userData.actTmout = *_actTmout;

    }
    
    userData.etsiLi = 0;
    userData.state = 0;

#ifdef ATCA
    /* FID 16687.1 */
    if (_authType == NULL)
    {
        userData.authType = DEFAULT_AUTH_TYPE;
    }
    else
    {
        switch (*_authType)
        {
            case UserAuthType_LOCAL:
                userData.authType = AUTH_TYPE_LOCAL;
                break;
            case UserAuthType_REMOTE:
                userData.authType = AUTH_TYPE_REMOTE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid authType" );
                break;
        }
    } 
#else
    if (_authType && (*_authType != UserAuthPolicyType_LOCAL))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid authType" );
        return eosl_false;
    }
    userData.authType = UserAuthType_LOCAL;
#endif

    /* If the new account is to be administratively managed Out-Of_service */
    if ((_pst) && (*_pst == PrimaryStateIn_OOS))
    {
        /* Update the user state to indicate administratively OOS */
        userData.state |= USR_MNG_BIT;
    }
    else
    {
#ifdef ATCA
        if (userData.authType == AUTH_TYPE_REMOTE) 
        {
            userData.state |= USR_SVC_BIT;
        }
        else
        {
#endif
        /* Update the user state to indicate IS and expired but in grace period */
        userData.state |= USR_SVC_BIT;
        userData.state |= USR_EXP_BIT;
        userData.state |= USR_GRC_BIT;
#ifdef ATCA
        }
#endif
    }

    userData.LastAct = time(NULL);

    result=SecAddUser(handle, &userData);
    if (result >= 0)
    {
        return tc_compld_comment( handle, ctag, "ENT-USER-SECU" );
    }
    else
    {
        if (result == -2)
        {
            tc_error_response(handle,ctag,TE_PIUI,"Username is not unique");
        }
        else
        {
            tc_error_response(handle,ctag,TE_SROF,"Unable to add user"); /* need to get correct err code */
        }
        return  eosl_false;
    }
}

/**
 */
eosl_bool agc_EM_NE_DLT_CALL_CAPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _trcId)
{
        
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colnCnt=0;
    int            cmd=SM_DLT_REQUEST;



    tableId = CALLTRC_CRIT_TABLE_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    /*validate AID to permit only numbers within*/
    if(!(IsInputStrInRange(_trcId,"0123456789")))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType =TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =atoi(_trcId);

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;


    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-CALL-CAPT" );
    }
}

eosl_bool agc_EM_NE_DLT_CALL_CAPTVERBOSE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _trcId)
{
 
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colnCnt=0;
    int            cmd=SM_DLT_REQUEST;


    tableId = CALLCAPTV_CRIT_TABLE_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    /*validate AID to permit only numbers within*/
    if(!(IsInputStrInRange(_trcId,"0123456789")))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType =TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =atoi(_trcId);

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;


    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-CALL-CAPTVERBOSE" );
    }

}

/**
 */
eosl_bool agc_EM_NE_DLT_CHANGED_NUMBER_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _oldNumber)
{
    
    SUBMSGBUF_t msgBuf;
    SUBCMD_t    *subCmdMsg;

    subCmdMsg = &msgBuf.Buf.subCmd;
    memset(subCmdMsg, 0, sizeof(SUBCMD_t));

/* Prepare event  */
    subCmdMsg->Tl1Cmd.Cmd           = SUBCMD_DLT_CHANGED_NUMBER;
    subCmdMsg->Tl1Cmd.SessionHandle     = handle;
    subCmdMsg->Tl1Cmd.CTag          = ctag;

/* Prepare Message Content */
    strncpy(subCmdMsg->Data.DltChangeNumber.old_phone_number, _oldNumber, MAX_PHONE_NUM_LENGTH + 1);
    subCmdMsg->Data.DltChangeNumber.old_phone_number[MAX_PHONE_NUM_LENGTH] = '\0';

/* Prepare Response Buffer */
    if(strlen(_oldNumber)>21)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid entry for subscriber id");
        return eosl_false;
    }
/* Send Event */
    if(TL1SendMsg(handle, ctag,
                  SUB_CMD_CLASS, CMD, EQMCMD_ALW_SWTOWKG,
                  (TL1_CMD_BUF_t *)&subCmdMsg, sizeof(SUBCMD_t),
                  (TL1_CMD_BUF_t *)&subCmdMsg, sizeof(SUBCMD_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_SUB, subCmdMsg->Tl1Cmd.Error );
        return eosl_false; /* failure */
    }

    return tc_compld_comment( handle, ctag, "DLT-CHANGED-NUMBER" );
}

eosl_bool agc_EM_NE_DLT_COUNTRY_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _countryCode)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_COUNTRY_CODE;

   rowKey.numIndices = 1;

   if(!IsInputStrInRange(_countryCode,"0123456789") || IsInputStrContainPrefix(_countryCode,"0"))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid CountryCode");
        return eosl_false;
    
   }

   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _countryCode;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_countryCode);

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_COUNTRY_req", "DLT-COUNTRY - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "DLT-COUNTRY" ); /* success */
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;

}


/**
 */
eosl_bool agc_EM_NE_DLT_IPHOST_SECU_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _com, char * _ipHosts)
{
    int            retVal;
    const char     *username;
    unsigned int   ipHost;
    char           *ipHostStr;
    int            rowNum;
    int            ipAddrs[MAX_TRUSTED_HOSTS];
    int            numHosts = 0;
    int            i;


    if ((_com != NULL) && (eosl_strcasecmp(_com, "COM") != 0 ))
    {
        tc_error_response( handle,
                           ctag,
                           TE_IIAC,
                           "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_ipHosts == NULL)
    {
        tc_error_response( handle,
                           ctag,
                           TE_IPNV,
                           "Input, Parameter Not Valid" );
        return eosl_false;
    }

    /* Get the first IP Address (& separates IP addrs) */
    ipHostStr = strtok(_ipHosts, "&");
    if (ipHostStr == NULL)
    {
        tc_error_response( handle,
                           ctag,
                           TE_IPNV,
                           "Input, Parameter Not Valid" );
        return eosl_false;
    }

    /* Build array of ipHosts to delete -- DB library uses strtok! */
    /* While still tokens in input string. */
    while (TRUE)
    {
        if ((ip_a2i(ipHostStr, &ipHost)) != 1)
        {
            tc_error_response( handle,
                               ctag,
                               TE_IPNV,
                               "Input, Parameter Not Valid" );
            return eosl_false;
        }
        
        ipAddrs[numHosts] = ipHost;
        numHosts++;

        ipHostStr = strtok(NULL, "&");
        if (ipHostStr == NULL)
        {
            break;
        }
    }

    for (i = 0; i < numHosts; i++)
    {
        rowNum = tl1DbSearchInt(THOSTS_TABLE_NAME,
                                TL1_DB_IP_COL,
                                ipAddrs[i]);
        if (rowNum == -1)
        {
            tc_error_response( handle,
                               ctag,
                               TE_IPNV,
                               "Input, Parameter Not Valid" );
            return eosl_false;
        }

        retVal = tl1DbDeleteRow(THOSTS_TABLE_NAME, rowNum);
        if (retVal == -1)
        {
            tc_error_response( handle,
                               ctag,
                               TE_SDBE,
                               "Internal Data Base Error" );
            return eosl_false;
        }
    }

    username = tc_session_get_username(handle);
    AddSecEvent(handle,
                TRUSTED_HOSTS_MODIFIED,
                (char *)username,
                " Trusted Host(s) Deleted. ");
    return tc_compld_comment( handle,
                              ctag,
                              "DLT-IPHOST-SECU" );
}


/**
 */
eosl_bool agc_EM_NE_DLT_IPROUTE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _ipRouteId)
{

    IPROUTE_CMD_t     buffer;

    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(IPROUTE_CMD_t));  /* sets all "valid" flags to 0 */

    /* If the AID was NOT successfully parsed and loaded into the message structure */
    if (ParseRouteAid(_ipRouteId,
                      &buffer.DeviceId,
                      &buffer.DeviceMap,
                      &buffer.Data.DltIpRoute.Dest,
#ifndef ATCA
                      &buffer.Data.DltIpRoute.SubnetMask,
#else
                      &buffer.Data.DltIpRoute.Subnet,
#endif
                      AID_IPROUTE_FULL) == FAIL)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /* Dispatch the message */
    if(TL1SendMsg(handle, ctag,
                  IP_ROUTE_CMD_CLASS, CMD, DLT_IPROUTE,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_IPROUTE, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "DLT-IPROUTE" );

}

/**
 * Delete LIST SUIOM
 */
eosl_bool agc_EM_NE_DLT_LIST_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suListId)
{
    TL1_BUF_t         buffer;
    int               IomLow  = 0;
    int               IomHigh = 0;

    if(_suListId)
    {
        if(parseSuListAid(_suListId, &IomLow, &IomHigh) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }

        if(IomLow == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }
        
        strncpy(buffer.CmdInfo.DltSuList.SuListName, _suListId, SUAUTO_LIST_LEN + 1);
        buffer.CmdInfo.DltSuList.IomLowNum = IomLow;
        buffer.CmdInfo.DltSuList.IomHighNum = IomHigh;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_DLT_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_DLT_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-LIST-SUIOM" );
}

/**
 */
eosl_bool agc_EM_NE_DLT_LNPSCREEN_DIGITS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _screenDigits)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   int            screenDigitsLen;

   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_LNPSCRDIGITS;

   rowKey.numIndices = 1;

   if(!(IsInputStrInRange(_screenDigits,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Input for screenDigits");
        return eosl_false;
   }
   screenDigitsLen = strlen(_screenDigits);
   if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Invalid number:must be 3 or 6-10 digits");
       return eosl_false;
   }
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);

   
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_LNPSCREEN_DIGITS_req", "DLT-LNPSCREEN-DIGITS - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "DLT-LNPSCREEN-DIGITS" );
   }
   /* Now report the TSM error to the operator */
   TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
   return eosl_false;
    
}

/**
 */
eosl_bool agc_EM_NE_DLT_LNPSCREEN_DIGITS_BULK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _screenDigits)
{
   int            screenDigitsLen;
   int            cmd     = SM_BULK_REQUEST;
   TsTransId      transId = ctag;
   TsTableId      tableId = TELICA_TABLE_LNPSCRDIGITS;

   bulkData.rowKey.numIndices = 1;

   if(!(IsInputStrInRange(_screenDigits,"0123456789")))
   {
       bulkData.errNo = TSSMI_BAD_INDEX;
       return eosl_false;
   }
   screenDigitsLen = strlen(_screenDigits);
   if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
   {
       bulkData.errNo = TSSMI_BAD_INDEX;
       return eosl_false;
   }
   bulkData.rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   bulkData.rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
   bulkData.rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);

   bulkData.colArray.numCols  = 0;

   /* If this is the first command to be packed into the buffer */
   if (bulkData.packedCmds == 0)
   {
       /* Initialize the data buffer attributes */
       bulkData.buf    = &bulkData.smCmd.Data[0];
       bulkData.bufLen = 0;
       /* If an error occurred packing the Bulk header */
       if (emfInitPkSmiBulkReq(cmd,
                               handle,
                               transId, 
                               tableId,
                               &bulkData.smCmd,
                               &bulkData.buf,
                               &bulkData.bufLen) == eosl_false)
       {
           return eosl_false;
       }
   }
   
   /* Pack the command into the buffer */
   emfPkSmiBulkCmdHdr(SM_DLT_REQUEST,
                      tableId,  
                      &bulkData.smCmd,
                      &bulkData.buf,
                      &bulkData.bufLen);
   
   emfPkSmiBulkReq(&bulkData.rowKey,
                   &bulkData.colArray,  
                   &bulkData.smCmd,
                   &bulkData.buf,
                   &bulkData.bufLen);
   
   return eosl_true;
}

/**
 */
eosl_bool agc_EM_NE_DLT_LRN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _lrn)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_OWNLRN;

   rowKey.numIndices = 1;

   if(strlen(_lrn) != 10 )
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LRN ");
        return eosl_false;
    
   }
   /*validate AID to permit only numbers within*/
   if(!(IsInputStrInRange(_lrn,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
   }
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _lrn;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_lrn);

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_LRN_req", "DLT-LRN - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "DLT-LRN" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
  
}


/**
 */
eosl_bool agc_EM_NE_DLT_LSET_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _lsetId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr;
    int            lsetId;
    int            i;

    transId = ctag;
    tableId = MTPLSET_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_lsetId, "%d%c", &lsetId, &xchr);
    if ((i != 1) || (lsetId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LinkSetId" );  
        return eosl_false;
    } 
    rowKey.rowIndex[0].value.longVal  = lsetId;

    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-LSET" );
    }
}


/**
 * Delete Alarm
 */
eosl_bool agc_EM_NE_DLT_MessageType_req( const char * modifier,\
                                         eosl_handle handle,\
                                         TL1_TAG ctag ,\
                                         char * _id,\
                                         char * _password)
{
    FAMRSP_t respBuff;
    FAMCMD_t  famCmd;
    int  i_alarmId;
    int  i;

    memset(&famCmd, 0x0, sizeof(famCmd));

    i = sscanf(_id, "%d", &i_alarmId);
    if ((i != 1) || (i_alarmId <= 0) || (i_alarmId > 9999))  /* range is 1 - 9999 */
    {
	tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid alarmId" );  
	return eosl_false;
    }

    if ( (_password[0] != 'r') ||
	 (_password[1] != 'u') ||
	 (_password[2] != 'S') ||
	 (_password[3] != 'u') ||
	 (_password[4] != 'r') ||
	 (_password[5] != 'e') ||
	 (_password[6] != '!') ||
	 (_password[7] != '\0') )
    {
	tc_error_response(handle, ctag, TE_EANS, "Password is incorrect."); 
	return eosl_false;
    }

    famCmd.Tl1Cmd.Cmd = FAMCMD_DLT_ALM;
    famCmd.Tl1Cmd.SessionHandle = handle;
    famCmd.Tl1Cmd.CTag =ctag; 
 
    famCmd.Data.DltAlm.AlarmId = i_alarmId;

    if(TL1SendMsg(handle, ctag,
                  FAM_CMD_CLASS, CMD, FAMCMD_DLT_ALM,
                  (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(FAMRSP_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {      
	TL1ErrorResp( handle, ctag, CMD_FAM, respBuff.Tl1Cmd.Error );
	return eosl_false;
    }    

    return tc_compld_comment( handle, ctag, "DLT-ALM" );
}

/**
 */
eosl_bool agc_EM_NE_DLT_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ioModule)
{
    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    TL1_BUF_t                     respBuff;

    if(ParseAidMap(&aidInfo, _ioModule, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;


    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "DLT-EQPT" );
}


/**
 * Delete OSUSER Security
 */
eosl_bool agc_EM_NE_DLT_OSUSER_SECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid)
{
    int     result;
    char*   script = OSCMD_DLT_OSUSER_SECU_PATH;
    char    parameters[MAX_OSUSER_NAME_SIZE * 2] = "";

    if (strlen(_uid) < MIN_OSUSER_NAME_SIZE || strlen(_uid) > MAX_OSUSER_NAME_SIZE)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
        return eosl_false;
    }

    strncpy(parameters, _uid, strlen(_uid) + 1);
    result = runOSCommand(script, parameters, NULL);
    
    if (result == 0)
    {
        return tc_compld_comment( handle, ctag, "DLT-OSUSER-SECU" );
    }
    else
    {
        /* exit code 6 stand for specified user does not exist*/
        if(WEXITSTATUS(result) == 6)
        {
            tc_error_response(handle,ctag,TE_EANS,"Specific osuser doesn't exist");
        }
        else
        {
            tc_error_response(handle,ctag,TE_EANS,"Failed to delete user");
        }
        return eosl_false;
    }
}

/**
 * Delete PLAN SUIOM
 */
eosl_bool agc_EM_NE_DLT_PLAN_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suPlanName)
{
    TL1_BUF_t          buffer;

    if(_suPlanName)
    {
        strncpy(buffer.CmdInfo.DltSuPlan.SuPlanName, _suPlanName, SUAUTO_PLAN_LEN + 1);
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_DLT_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_DLT_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-PLAN-SUIOM" );
}


/**
 */
eosl_bool agc_EM_NE_DLT_PRFL_CIC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _cicPrflId)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            cicPrflId;
    int            cmd=SM_DLT_REQUEST;
    int            i;
    SUBCMD_t       subCmdMsg;  /* For sending data to Services Manager */


    tableId = TELICA_TABLE_SS7TRKPRFL_CFG;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    i = sscanf(_cicPrflId, "%d%c", &cicPrflId, &xchr); 
    if ((i != 1) || (cicPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> cicPrflId" );
        return eosl_false;
    }


    memset(&subCmdMsg, 0, sizeof(SUBCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =cicPrflId;

    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "DLT-PRFL-CIC" );

}

/**
 * Delete PRFL IPATKLOG
 */
eosl_bool agc_EM_NE_DLT_PRFL_IPATKLOG_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkLogPrflId)
{
    TL1_EMF_IPATK_DATA_t      buffer;
    SMCMD_t                   smCmd;

    /* Prepare data structure */
    memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
    memset(&smCmd, 0, sizeof(SMCMD_t));
    if(_ipAtkLogPrflId)
    {
	    if(!(IsInputStrInRange(_ipAtkLogPrflId,"0123456789")))
	    {
		    tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid ipAtkLogPrflId");
		    return eosl_false;
	    }
	    buffer.Data.DltPrfl.LogPrflId = atoi(_ipAtkLogPrflId);
	    if((buffer.Data.DltPrfl.LogPrflId >32)||( buffer.Data.DltPrfl.LogPrflId < 2))
	    {
	           tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid ipAtkLogPrflId");
		   return eosl_false;
	    }
    }
    /*
    ** Send event
    */
    if (TL1SendMsg(handle, ctag,
		   TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		   CMD_DLT_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_DLT_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&smCmd, sizeof(SMCMD_t),
		   TL1_MSG_TIMEOUT) == FAIL)
    {
	    procLogMsg(PLOG_ERROR,
			    "agc_EM_NE_DLT_PRFL_IPATKLOG_req",
			    "agc_EM_NE_DLT_PRFL_IPATKLOG_req: bad response \n");
	    TL1ErrorResp(handle, ctag, CMD_EQM, smCmd.Tl1Cmd.Error);
       return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "DLT-PRFL-IPATKLOG" );
}

/**
 */
eosl_bool agc_EM_NE_DLT_PRFL_SGPC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcPrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr;
    int            pcPrflId;
    int            i;

    transId = ctag;
    tableId = MTPPC_PRFL_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_pcPrflId,"%d%c", &pcPrflId, &xchr);
    if ((i != 1) || (pcPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid PcPrflId" );  
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = pcPrflId;

    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-PRFL-SGPC" );
    }
}

/**
 * Delete PRFL PFP
 */
eosl_bool agc_EM_NE_DLT_PRFL_PFP_req( const char * modifier,\
									  eosl_handle handle,\
									  TL1_TAG ctag ,\
									  TL1_AID _pfpPrflId)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = PRFLPFP_TAB_ID;
   
   rowKey.numIndices = 0;

   if(_pfpPrflId)
   {
	   if(!IsInputStrInRange(_pfpPrflId,"0123456789"))
	   {
		   tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
		   return eosl_false;
	   }
	   rowKey.rowIndex[0].colType = TSSMI_LONG;
	   rowKey.rowIndex[0].value.longVal = atoi(_pfpPrflId);
	   rowKey.numIndices = 1;
   }

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_PRFL_PFP", "DLT-PRFL-PFP - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "DLT-PRFL-PFP" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_DLT_PRFL_SLKL2_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp2PrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            mtp2Prfl;
    int            i;

    transId = ctag;
    tableId = MTPLY2_PRFL_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_mtp2PrflId, "%d%c", &mtp2Prfl, &xchr);
    if ((i != 1) || (mtp2Prfl < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Mtp2PrflId" );  
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = mtp2Prfl;

    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-PRFL-SLKL2" );
    }
}


/**
 */
eosl_bool agc_EM_NE_DLT_PRFL_SLKL3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp3PrflId)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            mtp3PrflId;
    int            cmd=SM_DLT_REQUEST;
    int            i;
    
    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_mtp3PrflId, "%d%c", &mtp3PrflId, &xchr);
    if ((i != 1) || (mtp3PrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> mtp3PrflId" );
        return eosl_false;
    }

    tableId = MTPLY3_PRFL_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal= mtp3PrflId;


    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-PRFL-SLKL3" );
    }

}



/**
 */
eosl_bool agc_EM_NE_DLT_ROUTE_SS7_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _routeSs7)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    s16            retVal;
    SMCMD_t        smCmd;
    int            cmd=SM_DLT_REQUEST;
    int            pc, pcFormat;
    int            lset;

    tableId = MTPROUT_TAB_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

	if (strchr(_routeSs7, '-') != NULL)
	{
    rowKey.numIndices = 3;
    if (ParsePcPlusIntAid(_routeSs7, &pc, &pcFormat, &lset) == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
        return eosl_false;
    }
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = pc;
    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = pcFormat;

    if (lset < 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
        return eosl_false;
    }
    rowKey.rowIndex[2].colType = TSSMI_LONG;
    rowKey.rowIndex[2].value.longVal = lset;
	}
	else if (eosl_strcasecmp(_routeSs7, "DEFAULT") != 0 )
	{
		if (IsInputStrInRange(_routeSs7, "0123456789"))
		{
			rowKey.numIndices = 1;
			rowKey.rowIndex[0].colType = TSSMI_LONG;
			rowKey.rowIndex[0].value.longVal = atoi(_routeSs7);
		}
		else
		{
			tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
			return eosl_false;
		}
	}
	else
	{
		rowKey.numIndices = 0; 
	}
    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-ROUTE-SS7" );
    }
}

/**
 * Delete RULE IPFLTR
 */
eosl_bool agc_EM_NE_DLT_RULE_IPFLTR_req( const char * modifier,\
										 eosl_handle handle,\
										 TL1_TAG ctag ,\
										 TL1_AID _ruleId)
{

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   char		  sp[RULE_IPFLTR_SPLEN_MAX+1];
   int            ruleNum;
   int            spEnum;
   int            cardType = RULE_IPFLTR_CARDTYPE_UNK;
   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = RULE_IPFLTR_TAB_ID;

#ifdef ATCA
    if(parseATCAIpFilterAid(_ruleId, &cardType,&sp[0], &ruleNum, &spEnum,AID_IPFLTR_FULL) != SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
        return eosl_false;
    }
#else
   if(parseIpFilterAid(_ruleId, &sp[0], &ruleNum, &spEnum,
		       AID_IPFLTR_FULL) != SUCCESS)
   {
       tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
       return eosl_false;
   }
    if(
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_MGT]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGC]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGD]) == 0)
    )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCM;
    }
    else if ((strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGA]) == 0) ||
             (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGB]) == 0)
            )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCS;
    }
    else 
    {
        cardType = RULE_IPFLTR_CARDTYPE_ALL;
    }

#endif

   rowKey.rowIndex[0].colType = TSSMI_LONG;
   rowKey.rowIndex[0].value.longVal = cardType;
   rowKey.rowIndex[1].colType = TSSMI_OCTET_STRING;
   rowKey.rowIndex[1].value.stringVal.ptr = sp;
   rowKey.rowIndex[1].value.stringVal.len = strlen(sp);
   rowKey.rowIndex[2].colType = TSSMI_LONG;
   rowKey.rowIndex[2].value.longVal = ruleNum;
   rowKey.numIndices = 3;
#if 0   
   columns[colCnt].columnId = RULE_IPFLTR_COL_SP_ENUM;
   columns[colCnt].value.colType = TSSMI_LONG;
   columns[colCnt].value.value.longVal = spEnum;
   colCnt++;
#endif   
   colArray.numCols  = colCnt;
   colArray.colArray = columns;
   
   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_RULE_IPFLTR", "DLT-RULE-IPFLTR - TOO MANY COLUMNS FOR ARRAY!\n");
       tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
       return eosl_false;
   }
   
   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "DLT-RULE-IPFLTR" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

eosl_bool agc_EM_NE_DLT_SCCP_ROUTE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcId)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   int            dpc;
   short          length;
   int            colCnt = 0;
   PointCodeFormat pcFormat = PC_INVALID;

   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = SCCPROUTE_TAB_ID;

#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif

    /* AID string format, LGP: <pc> */
    /* AID string format, ATCA: <netId>-DPC-<pc> */

#ifndef ATCA
    p_commonStr = _pcId;
#else
    if (ParseNetIdKey((char *)_pcId, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid pcId");
       return eosl_false;
    }

#endif

   dpc = pc_atoi(p_commonStr, &pcFormat);
   if(dpc == -1)
   {
       tc_error_response(handle, ctag, TE_IIDT, "Input, PC Invalid");
       return eosl_false;
   }

   rowKey.rowIndex[SCCPROUTE_PC].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPROUTE_PC].value.longVal = dpc;
   rowKey.rowIndex[SCCPROUTE_PCFORMAT].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPROUTE_PCFORMAT].value.longVal = pcFormat;
#ifndef ATCA
   rowKey.numIndices = 2;
#else
   rowKey.rowIndex[SCCPROUTE_NETID].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPROUTE_NETID].value.longVal = netId;
   rowKey.numIndices = 3;
#endif
   
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_SCCP_ROUTE_req", "DLT-SCCP-ROUTE - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "DLT-SCCP-ROUTE" );
   }
   /* Now report the TSM error to the operator */
   TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
   return eosl_false;
}

eosl_bool agc_EM_NE_DLT_SCCP_SSN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sccpSsnAid)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   int            pc;
   int            ssn;
   int            status;
   PointCodeFormat pcFormat = PC_INVALID;
#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = SCCPSSN_TAB_ID;

    /* AID string format, LGP: <pc>-<ssn> */
    /* AID string format, ATCA: <netId>-DPC-<pc>-<ssn> */


#ifndef ATCA
    p_commonStr = _sccpSsnAid;
#else
    if (ParseNetIdKey((char *)_sccpSsnAid, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
    }
#endif


   status = convertSccpSsnAid(p_commonStr, &pc, &pcFormat, &ssn);
   if(status == -1)
   {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
   }
   rowKey.rowIndex[SCCPSSN_PC].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_PC].value.longVal = pc;
   rowKey.rowIndex[SCCPSSN_PCFORMAT].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_PCFORMAT].value.longVal = pcFormat;
   rowKey.rowIndex[SCCPSSN_SSN].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_SSN].value.longVal = ssn;
#ifndef ATCA
   rowKey.numIndices = 3;
#else
   rowKey.rowIndex[SCCPSSN_NETID].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_NETID].value.longVal = netId;
   rowKey.numIndices = 4;
#endif
    
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_SCCP_SSN_req", "ENT-SCCP-SSN - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "DLT-SCCP-SSN" );
   }
   /* Now report the TSM error to the operator */
   TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
   return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_DLT_SLK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7LnkId)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            lnkId;
    int            cmd=SM_DLT_REQUEST;
    int            i;



    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_ss7LnkId, "%d%c", &lnkId, &xchr);
    if ((i != 1) || (lnkId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> lnkId" );
        return eosl_false;
    }

    tableId = MTPLNK_TAB_ID;
    transId = ctag;

    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=lnkId;


    colArray.colArray = columns;
    colArray.numCols  = 0;

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-SLK" );
    }


}


/**
 * This command provides for disconnecting a Tn object entity.
 */
eosl_bool agc_EM_NE_DLT_T1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = T1_TAB_ID;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[0];
    SMCMD_t           smCmd;
    int               cmd = SM_DLT_REQUEST;

    TL1LOGP (PLOG_ERROR, "T1 aid:%s\n", _ds_id);
    TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

    memset(&rowKey, 0, sizeof(rowKey));
    memset(&colArray, 0, sizeof(colArray));
    colArray.colArray = columns;

    if(ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7PORT, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                         (aidInfo.devicemap == T1)?"T1":"E1",
                         aidInfo.lvl1, aidInfo.lvl2,
                         aidInfo.lvl3, aidInfo.lvl4);
    if (aidInfo.devicemap == T1)
    {
        rowKey.numIndices = 4;
        rowKey.rowIndex[0].colType          = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
        rowKey.rowIndex[1].colType          = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
        rowKey.rowIndex[2].colType          = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
        rowKey.rowIndex[3].colType          = TSSMI_LONG;
        rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    colArray.numCols = 0;

    if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                       &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-T1" );
#else
    DSX_CMD_BUF_t      buffer;
    char               *cmdClass;
    unsigned int       cmd;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id,
                             (AID_PORT | AID_STS1 | AID_OC3_STS1_T1|AID_AU3TUG3_T1),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdClass = DS3_CMD_CLASS;
    cmd = DS3CMD_DLT_T1;

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {

        procLogMsg (PLOG_ERROR, "agc_EM_NE_DLT_T1_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "DLT-T1" );
#endif
}


/**
 */
eosl_bool agc_EM_NE_DLT_T3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id)
{
    DSX_CMD_BUF_t       buffer;

    /*
    ** prepare t3 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);
    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id, AID_T3,
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_DLT_IF,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {

        procLogMsg (PLOG_ERROR, "agc_EM_NE_DLT_T3_req","We have a bad response \n");
        /* ??? Change to CMD_T3 when T3 error codes are in TL1ErrorResp. */
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "DLT-T3" );
}


/**
 */
eosl_bool agc_EM_NE_DLT_TOLLFREE_NPA_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _CcNpa)
{
    int            cCode;
    int            npa;
    char           retChar;
    char           tollfreeNPA[MAX_NPA_LENGTH + 1];
    char           countrycode_id[MAX_COUNTRYCODE_ID_LENGTH + 1];
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colCnt = 0;
    

    tableId = TELICA_TABLE_TOLLFREE_NPA;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 0;
    
   /*
    * Validate the Entry.Entry should be CountryCode-Npa where countrycode and npa 
    * are integer values ranging in between 1 to 99999
    */

    if (sscanf(_CcNpa,"%d-%d%c[^0-9]", &cCode,&npa,&retChar) != 2)
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid Input  Enter Countrycode-NPA ");
       return eosl_false;
    }
    
    if((cCode<1||cCode>99999)||(npa<1||npa>99999))
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid range");
       return eosl_false;
    }

    sprintf(countrycode_id,"%d",cCode);
    sprintf(tollfreeNPA, "%d" , npa);


    rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
    rowKey.rowIndex[0].value.stringVal.len = strlen(countrycode_id);
    rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) countrycode_id;

    rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
    rowKey.rowIndex[1].value.stringVal.len = strlen(tollfreeNPA);
    rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) tollfreeNPA;

    rowKey.numIndices = 2;
    
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_TOLLFREE_NPA_req", "DLT-TOLLFREE-NPA - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-TOLLFREE-NPA" ); /* success */
    }
}

/**
 * Delete User LISECU
 */
eosl_bool agc_EM_NE_DLT_USER_LISECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid)
{
    int result;
    USER_DATA_t             *userDataPtr;

    if (strlen(_uid) > MAX_USER_NAME_SIZE)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
        return eosl_false;
    }

    if (etsiLiValidate(handle, _uid) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
        return eosl_false;
    }

    if (eosl_strcasecmp(_uid, "etsili") == 0)
    {
        tc_error_response(handle,ctag,TE_EANS,
                          "Can not delete the default ETSILI user");
        return eosl_false;
    }

    userDataPtr = GetUserDataFromDb(_uid);
    if(userDataPtr && 
      (userDataPtr->etsiLi == 1) &&
      (strcmp(userDataPtr->username,userDataPtr->ownername) == 0)) 
    {
        tc_error_response(handle,ctag,TE_EANS,
                          "Can not delete the default LI user");
        eosl_free(userDataPtr);
        return eosl_false;
    }
    eosl_free(userDataPtr);

    result=SecDelUser(handle, _uid);

    if (result == USR_ERR_DOES_NOT_EXIST)
    {
        tc_error_response(handle,ctag,TE_EANS,"User does not exist");
        return eosl_false;
    }
    else if (result == USR_ERR_ACCT_NOT_OOS)
    {
        tc_error_response(handle,ctag,TE_EANS,
                          "Account must be administratively placed Out-Of-Service before deletion");
        return eosl_false;
    }
    else if (result == USR_ERR_DELETION_FAILURE)
    {
        tc_error_response(handle,ctag,TE_EANS,"Failed to delete user");
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-USER-LISECU" );
}

/**
 * Remove a user. Only an administrator may do this. The AID
 * block contains the user identifier.
 *
 * Defined in TR-835
 */
eosl_bool agc_EM_NE_DLT_USER_SECU_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid)
{
    int result;

    /* Design Note: The check to prevent deletion of an account that has active sessions
     *     has been removed due to new FID 14510 requirements that prevent this scenario
     *     from occurring, thus rendering the check obsolete.
     *     New requirements prevent an account from being deleted until it's first
     *     administratively placed Out-Of-Service, and since an account that is
     *     administratively Out-Of-Service can not have active sessions, the active
     *     session check is unnecessary.
     */

    if (strlen(_uid) > MAX_USER_NAME_SIZE)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
        return eosl_false;
    }

    if (etsiLiValidate(handle, _uid) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
        return eosl_false;
    }

    result=SecDelUser(handle, _uid);

    if (result == USR_ERR_ACCT_NOT_OOS)
    {
        tc_error_response(handle,ctag,TE_EANS,
                          "Account must be administratively placed Out-Of-Service before deletion");
        return eosl_false;
    }
    else if (result == USR_ERR_DOES_NOT_EXIST)
    {
        tc_error_response(handle,ctag,TE_EANS,"User does not exist");
        return eosl_false;
    }
    else if (result == USR_ERR_DELETION_FAILURE)
    {
        tc_error_response(handle,ctag,TE_EANS,"Failed to delete user");
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-USER-SECU" );

}

/**
 */
eosl_bool agc_EM_NE_DS3DBG_req( const char * modifier,\
                                eosl_handle handle,\
                                TL1_TAG ctag ,\
                                char * _dbgcmd)
{
    TL1_DS3HM_DEBUG_DATA_t tl1Ds3HmDebugData;
    TL1_DS3HM_DEBUG_DATA_t respBuff;
    
    memset(&respBuff, 0, sizeof(TL1_DS3HM_DEBUG_DATA_t));
    
    if (_dbgcmd == NULL)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    if (strlen(_dbgcmd) > DS3HM_DEBUG_COMMAND_STR_LEN)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    tl1Ds3HmDebugData.EventType = TL1_DS3HM_DEBUG_DS3HM_CMD;

	strncpy(tl1Ds3HmDebugData.Data.Ds3HmDebug.CmdBuffer, _dbgcmd, DS3HM_DEBUG_COMMAND_STR_LEN);
	    
    /* 
    ** Send event to DS3
    */
    if (TL1SendDs3Event(&tl1Ds3HmDebugData) == SUCCESS)
	{	   	
		procLogMsg (PLOG_INFO,
                    "agc_EM_NE_DS3DBG_req",
					"agc_EM_NE_DS3DBG_req: Event type %d is sent\n", TL1_DS3HM_DEBUG_DS3HM_CMD);
	}
	else
	{
		procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_DS3DBG_req",
                    "agc_EM_NE_EMFDBG_req: ERROR - Failed TL1SendDs3Event\n");
	}

    return tc_compld_comment( handle, ctag, "DS3DBG" );
}

/**
 */
eosl_bool agc_EM_NE_DLT_ALMQ_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _almqSessionId)
{
    TL1_ASESSION *as = NULL;
    TELICA_SESSION_DATA_t *ts = NULL;
    unsigned long ipaddr = 0;
    char msg[1024] = DEFAULT_WARN_MSG;
    char fnbuf[64];
    char ipbuf[16];


    if (!_almqSessionId)
    {
        tc_error_response(handle, ctag, TE_IIAC,
                          "Invalid Access Identifier (AID)");
        return eosl_false;
    }

    /* validate ip addr - do we have an ASESSION for this IP address? */
    sscanf(_almqSessionId, "%x", (int *)&ipaddr);

    if ((!ipaddr) || (!_almqSessionId) ||
        !(as = as_lookup_session_byaddr(ipaddr,
                                        !ctag ? UserAccessPort_ALARMQUEUEPORT : ctag)))
    {
        tc_error_response(handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
        return eosl_false;
    }

    if ((ts = as->ts))
    {
        if (ts->handle)
        {
            tms_logout(ts->handle);
        }
    }

    /* remove Aomsg_<ipaddr>.log
     */

    /* Aomsg_<ipaddr>.log filename */
    ip_i2a(as->sin_addr, ipbuf);
    eosl_sprintf(fnbuf, "%s_%s_%d.log", ALMQ_MESSAGE_LOG_PREFIX, ipbuf, as->UserAccessPortType);

    eosl_sprintf(msg, "%s %s-%d", "Alarm Queueing Timeout (AlmqTmo) expired for IP Address",
                 ipbuf, as->UserAccessPortType);

    /* Remove the file entry from the directory before we
     * delete the TL1_ASESSION instance
     */
    if(as->almqState == ALMQ_STATE_QUEUE)
    {
        if(unlink(fnbuf) < 0)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_ALMQ_req",
                       "unlink error, tid="PRTFMT_THREADID_T" socket=%d errno= %d(%s)\n",
                       OalGetShortThreadId(), as->handle, errno, (char *)strerror(errno));
        }
        /* remove the remote file
         */
        ClearTL1ALog(fnbuf);
    }

    /* Remove ASESSION instance by address from GoAhead Tl1ASessions database
     */
    if (!as_session_exit_byaddr(ipaddr, UserAccessPort_ALARMQUEUEPORT))
    {
        DelASession(ipaddr);
        tc_error_response(handle,ctag,TE_EANS,"Failed to delete almqSessionId");

        return eosl_false;
    }

    /* clean up database redundancy, replication
     */

    /* Remove it from GoAhead Tl1ASessions database
     * clean up TELICA_SESSION_DATA_t, TL1_SESSION, etc resources
     * delete GA row if exists for this ipaddr
     */
    DelASession(ipaddr);

    return tc_compld_comment( handle, ctag, "DLT-ALMQ" );
#if ALMQOLD	
    TL1_ASESSION *as = NULL;
    TL1_SESSION *ts = NULL;
    unsigned long ipaddr = 0;
    char msg[1024] = DEFAULT_WARN_MSG;
    char fnbuf[64];
    char ipbuf[16];


    if (!_almqSessionId)
    {
        tc_error_response(handle, ctag, TE_IIAC,
                          "Invalid Access Identifier (AID)");
        return eosl_false;
    }

    /* validate ip addr - do we have an ASESSION for this IP address? */
    sscanf(_almqSessionId, "%x", (int *)&ipaddr);

    if ((!ipaddr) || (!_almqSessionId) ||
        !(as = as_lookup_session_byaddr(ipaddr)))
    {
        tc_error_response(handle, ctag, TE_IIAC,
                          "Invalid Access Identifier (AID)");
        return eosl_false;
    }

    /* we could have a user session going on as well... shut it off 
     * TODO: investigate LogOutSession(handle), tms_logout(handle),
     * s_logout_ok(), closeSession_ASession()... for now use tms_logout().
     */
    if ((ts = as->ts))
    {
        if (ts->handle)
        {
            /* like CANC-USER but SecLogout(), tms_mark_session_for_logout()
             * handles no name user and marks session for logout()
             */
            tms_logout(ts->handle);
        }
    }

    /* remove Aomsg_<ipaddr>.log
     */

    /* Aomsg_<ipaddr>.log filename */
    ip_i2a(as->sin_addr, ipbuf);
    eosl_sprintf(fnbuf, "%s_%s.log", ALMQ_MESSAGE_LOG_PREFIX, ipbuf);

    eosl_sprintf(msg, "%s %s",
                 "Alarm Queueing Timeout (AlmqTmo) expired for IP Address", ipbuf);

    /* Remove the file entry from the directory before we
     * delete the TL1_ASESSION instance
     */
    if(as->almqState == ALMQ_STATE_QUEUE)
    {
        if(unlink(fnbuf) < 0)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_DLT_ALMQ_req",
                       "unlink error, tid=%d socket=%d errno= %d(%s)\n",
                       getstid(), as->handle, errno, (char *)strerror(errno));
        }
    }

    /* Remove ASESSION instance by address from GoAhead Tl1ASessions database
     */
    if (!as_session_exit_byaddr(ipaddr, UserAccessPort_ALARMQUEUEPORT))
    {
        DelASession(ipaddr);
        tc_error_response(handle,ctag,TE_EANS,"Failed to delete almqSessionId");

        return eosl_false;
    }

    /* clean up database redundancy, replication
     */

    /* Remove it from GoAhead Tl1ASessions database
     * clean up TELICA_SESSION_DATA_t, TL1_SESSION, etc resources
     * delete GA row if exists for this ipaddr
     */
    DelASession(ipaddr);

    return tc_compld_comment( handle, ctag, "DLT-ALMQ" );
#endif    
}


eosl_bool agc_EM_NE_DLT_CRS_T0_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _t0From, TL1_AID _t0To)
{
	TsTransId      	transId;
    TsTableId      	tableId;
    TsSmiRowKey    	rowKey;
    TsSmiColArray  	colArray;
    TsSmiColObj    	columns[MAX_TSM_COLS];
    short		    retVal;
    char		    fromIomToPort[64]; /*1st half of the aid except the range "from" num*/
    char		    toIomToPort[64]; /*1st half of the aid except the range "to" num*/
    char			secondHalfFrom[64]; /*1st half of the aid except the range "from" num*/
    char			secondHalfTo[64]; /*1st half of the aid except the range "from" num*/
    SMCMD_t         smCmd;
    int            	cmd=SM_DLT_REQUEST;
    int 		    numPart=0;
    int			    totParts=0;
    int            	colnCnt=0;
    int             rangePresentFrom=0;
    int             rangePresentTo=0;

 
    /*
    ** !!!!!This command is implemented for communication to Signaling only.
    */

    tableId = CRS_TAB_ID;
    transId = ctag;
 
    /*
    ** prepare tp data structure
    */
    if(!parseAidT0RngCk(_t0From, fromIomToPort, secondHalfFrom, &numPart,&rangePresentFrom))
    {
	tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> _crsFrom" );  
        return eosl_false;
    }

    totParts = numPart; /*numPart = 2 if aid is range other wise 1*/

    if(_t0To)
    {
	if(!parseAidT0RngCk(_t0To, toIomToPort, secondHalfTo, &numPart,&rangePresentTo))
	{
	    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> _crsT0" );  
	    return eosl_false;
	}
	totParts += numPart;
    }
    
    /*
    **validate different combination of AIDs
    */
    if((totParts != 1) && (totParts != 2) && (totParts != 4))
    {
	tc_error_response( handle, ctag, TE_IIAC, 
			   "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }

    if (totParts == 1)
    {
	rowKey.numIndices =1;

	rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
	rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
	rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;
    }
    
    if ((totParts == 2) && (_t0To == NULL))
    {
	rowKey.numIndices =2;

	rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
	rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
	rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;

    rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
    rowKey.rowIndex[1].value.stringVal.len = strlen(secondHalfFrom);
    rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) secondHalfFrom;
    }
    else if(totParts == 2)
    {
	rowKey.numIndices =2;

	rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
	rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
	rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;

	rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
	rowKey.rowIndex[1].value.stringVal.len = strlen(toIomToPort);
	rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) toIomToPort;
    }

    /*both from and to DSO are in range*/
    if (totParts == 4)
    {
     	rowKey.numIndices =4;
       
		rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
		rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;
       
		rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[1].value.stringVal.len = strlen(secondHalfFrom);
		rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) secondHalfFrom;

		rowKey.rowIndex[2].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[2].value.stringVal.len = strlen(toIomToPort);
		rowKey.rowIndex[2].value.stringVal.ptr = (u8 *) toIomToPort;

		rowKey.rowIndex[3].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[3].value.stringVal.len = strlen(secondHalfTo);
		rowKey.rowIndex[3].value.stringVal.ptr = (u8 *) secondHalfTo;
  
    }
    if(rangePresentFrom || rangePresentTo)
    {
        columns[colnCnt].columnId = CRS_RANGE;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = rangePresentFrom|rangePresentTo;
        colnCnt++;
    }
    colArray.numCols  = colnCnt;
    colArray.colArray = columns;
  
    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 60);



    if(retVal == FALSE)
    {
		TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
		return eosl_false;
    }
    else
    {
		return tc_compld_comment( handle, ctag, "DLT-CRS-T0" );
    }
    return tc_compld_comment( handle, ctag, "DLT-CRS-T0" );
}


eosl_bool agc_EM_NE_ENT_CRS_T0_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _t0From, TL1_AID _t0To, CrsType_ENUM * _crsBlk, char * _specBlk, PrimaryStateIn_ENUM * _pst)
{

	TsTransId      	transId;
    TsTableId      	tableId;
    TsSmiRowKey    	rowKey;
    TsSmiColArray  	colArray;
    TsSmiColObj    	columns[MAX_TSM_COLS];
    short			retVal;
    char			fromIomToPort[64]; /*1st half of the aid except the range "from" num*/
    char			secondHalfFrom[64]; /*1st half of the aid except the range "from" num*/
    char			toIomToPort[64]; /*1st half of the aid except the range "to" num*/
    char			secondHalfTo[64]; /*1st half of the aid except the range "from" num*/
    SMCMD_t         smCmd;
    int            	cmd=SM_ENT_REQUEST;
    int 			numPart=0;
    int				totParts=0;
    int            	colnCnt=0;
    int             rangePresentFrom =0;
    int             rangePresentTo =0;

    
    /*
    ** !!!!!This command is implemented for communication to Signaling only.
    */

    tableId = CRS_TAB_ID;
    transId = ctag;
 
    /*
    ** prepare tp data structure
    */
 
    if(!parseAidT0RngCk(_t0From, fromIomToPort, secondHalfFrom, &numPart,&rangePresentFrom))
    {
		tc_error_response( handle, ctag, TE_IIAC, 
						   "Invalid Access Identifier (AID) -> _crsFrom" );  
        return eosl_false;
    }

    totParts = numPart; /*numPart = 2 if aid is range other wise 1*/

    if (eosl_strncasecmp(_t0To, "TP-", 3) == 0)
    {
		tc_error_response( handle, ctag, TE_IIAC, \
               "Invalid Access Identifier (AID) -> Testport isn't supported in ENTER");  
		return eosl_false;
    }

    if(!parseAidT0RngCk(_t0To, toIomToPort, secondHalfTo, &numPart,&rangePresentTo))
    {
		tc_error_response( handle, ctag, TE_IIAC, 
						   "Invalid Access Identifier (AID) -> _crsT0" );  
		return eosl_false;
    }
      
    totParts += numPart;
    
    if((totParts != 2) && (totParts != 4))
    {
		tc_error_response( handle, ctag, TE_IIAC, 
						   "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }

    /*no ranges in either the from and to DSO*/
    if(totParts == 2)
    {
		rowKey.numIndices =2;

		rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
		rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;

		rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[1].value.stringVal.len = strlen(toIomToPort);
		rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) toIomToPort;
    }	

    /*both from and to DSO are in range*/
    if (totParts == 4)
    {
		rowKey.numIndices =4;
       
		rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
		rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;
       
		rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[1].value.stringVal.len = strlen(secondHalfFrom);
		rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) secondHalfFrom;

		rowKey.rowIndex[2].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[2].value.stringVal.len = strlen(toIomToPort);
		rowKey.rowIndex[2].value.stringVal.ptr = (u8 *) toIomToPort;

		rowKey.rowIndex[3].colType =TSSMI_OCTET_STRING;
		rowKey.rowIndex[3].value.stringVal.len = strlen(secondHalfTo);
		rowKey.rowIndex[3].value.stringVal.ptr = (u8 *) secondHalfTo;
    }

    if(_crsBlk)
    {
		tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> crsBlk" );
		return eosl_false;
    }
   
    if(_specBlk)
    {
		tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> specBlk" );
		return eosl_false;
    }
    if(rangePresentFrom || rangePresentTo)
    {
        columns[colnCnt].columnId = CRS_RANGE;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = rangePresentFrom|rangePresentTo;
        colnCnt++;
    }
    if(_pst)
    {
		tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> pst" );
		return eosl_false;

		/*this column actually isn't supported now by Sig. It's just for consistency sake
		columns[colnCnt].columnId = CRS_STATE;
		columns[colnCnt].value.colType = TSSMI_LONG;
		columns[colnCnt].value.value.longVal = *_pst;	
		colnCnt++;*/
    }
  
    colArray.numCols  = colnCnt;
    colArray.colArray = columns;
  
    if (colArray.numCols > MAX_TSM_COLS)
    {
		procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_CRS_T0_req", "ENT_CRS_T0 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    
    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);




    if(retVal == FALSE)
    {
		TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
		return eosl_false;
    }
    else
    {
		return tc_compld_comment( handle, ctag, "ENT-CRS-T0" );
    }


    return tc_compld_comment( handle, ctag, "ENT-CRS-T0" );
}
/**
 */
eosl_bool agc_EM_NE_ED_CRS_T0_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _t0From, TL1_AID _t0To, CrsType_ENUM * _crsBlk, char * _specBlk, PrimaryStateIn_ENUM * _pst)
{
    
    BITS_CMD_BUF_t      buffer;
    char        xchr;
    int         tmpTpNum;
    int         i;

    /*
    ** prepare tp data structure
    */

    memset(&buffer, 0, SIZEOF_BITSCMD_TEST_PORT_EDIT);


    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _t0From, (AID_T0 | AID_STS1),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> t0Type" );  
        return eosl_false;
    }

    if (eosl_strncasecmp(_t0To, "TP-", 3) != 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> tpNum" );  
        return eosl_false;
    }

    if (CheckTokenValue(2, STS1,_t0From) == TRUE)
    {
        buffer.Data.CrsEdit.TypeIsT3Flag=0;
    } else {
        buffer.Data.CrsEdit.TypeIsT3Flag=1;
    }
   
    i = sscanf(&(_t0To[3]),"%d%c", &tmpTpNum, &xchr);
    if ((i != 1) || (tmpTpNum < 0))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, tpNum Invalid" );  
        return eosl_false;
    }
    buffer.Data.CrsEdit.TestPort = tmpTpNum;

    if(_crsBlk)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> crsBlk" );
        return eosl_false;
    }
   
    if(_specBlk)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> specBlk" );
        return eosl_false;
    }

    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.CrsEdit.State.value |= PST_IS_BIT;
            buffer.Data.CrsEdit.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.CrsEdit.State.value |= PST_OOS_BIT;
            buffer.Data.CrsEdit.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIAC, "Invalid PrimaryState" );  
            return eosl_false;
        }
    }

    /* 
    ** Send event
    */
     if(TL1SendMsg(handle, ctag,
                  BITS_CMD_CLASS, CMD, BITSCMD_CRS_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_BITSCMD_CRS_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_CRS_T0_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error ); 
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-CRS-T0" );
}

/**
 * Edit the date and/or time of the NE
 *
 * Defined in GR-199.
 */
eosl_bool agc_EM_NE_ED_DAT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _date, char * _time)
{
#ifndef WIN32
#include <time.h>
#endif

    int i=0;
    int yr,mon,day;
    int hr,min,sec;
    char xdate;
    char xtime;

    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;


    memset(&cmdMsg,0x0,sizeof(TL1_BUF_t)); /* set all valid flags=0 */



    /*
    ** Put in new date if available
    */
    if (_date)
    {
		i = sscanf(_date, "%d-%d-%d%c", &yr, &mon, &day, &xdate);
		if ((i != 3) || (!validateDate(mon, day)))
		{
            tc_error_response( handle, ctag, TE_INUP, "Invalid Payload block.  Invalid Positional Field (MONTH/DAY)" );
			return eosl_false;
		}

        /* Unix Time functions fail during  the year 2038,
           check to make sure the  date is not set beyond that time  */

        if ( yr < 0  || yr > 37)
        {
            /* tc_error_response( handle, ctag, TE_IDRG, "Input, Data Range (YEAR)" ); */
            tc_error_response( handle, ctag, TE_INUP, "Invalid Payload block.  Invalid Positional Field (YEAR)" );
            return eosl_false;
        }
        strncpy(cmdMsg.CmdInfo.EdtParams.SysDate.strValue, _date, sizeof(cmdMsg.CmdInfo.EdtParams.SysDate.strValue));
        cmdMsg.CmdInfo.EdtParams.SysDate.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.SysDate.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.SysDate.valid= VALID_VALUE;
    }

    /*
    ** Put in new time if available
    */
    if (_time)
    {
		i = sscanf(_time, "%d-%d-%d%c", &hr, &min, &sec, &xtime);
		if ((i != 3) || (hr < 0) || (hr > 23) || 
		   (min < 0) || (min > 59) || (sec < 0) || (sec > 59))
		{
            tc_error_response( handle, ctag, TE_INUP, "Invalid Payload block.  Invalid Positional Field (TIME)" );
			return eosl_false;
		}

        strncpy(cmdMsg.CmdInfo.EdtParams.SysTime.strValue, _time, sizeof(cmdMsg.CmdInfo.EdtParams.SysTime.strValue));
        cmdMsg.CmdInfo.EdtParams.SysTime.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.SysTime.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.SysTime.valid= VALID_VALUE;
	}

    /*
    ** Prepare event
    */

#ifdef ATCA
    cmdMsg.CmdInfo.AtcaSlot.shelfId = procInfo.ShelfId;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = procInfo.PhySlotNum;
#else
    if (procInfo.SlotNum == 26)
    {
        cmdMsg.CmdInfo.SlotNum = 26;
    }
    else
    {
        cmdMsg.CmdInfo.SlotNum = 27;
    }
#endif
    
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-DAT" );
}
#ifdef ATCA
u32 mapTL1TSMCATCAPortType (u32 value)
{
    switch (value)
    {
      case AtcaPortType_FRONT_GE0:
          return MALBAN_PORT_FRONT_GE0;
          break;
      case AtcaPortType_FRONT_GE1:
          return MALBAN_PORT_FRONT_GE1;
          break;
      case AtcaPortType_FRONT_GE3:
          return MALBAN_PORT_FRONT_GE3;
          break;
      case AtcaPortType_REAR_GE0:
          return MALBAN_PORT_RTM_GE0;
          break;
      case AtcaPortType_REAR_GE1:
          return MALBAN_PORT_RTM_GE1;
          break;
       case AtcaPortType_REAR_GE2:
          return MALBAN_PORT_RTM_GE2;
          break;
      case AtcaPortType_REAR_GE3:
          return MALBAN_PORT_RTM_GE3;
          break;
       case AtcaPortType_REAR_GE4:
          return MALBAN_PORT_RTM_GE4;
          break;
       case AtcaPortType_REAR_GE6:
          return MALBAN_PORT_RTM_GE6;
          break;
       case AtcaPortType_REAR_GE7:
          return MALBAN_PORT_RTM_GE7;
          break;
       case AtcaPortType_REAR_GE8:
          return MALBAN_PORT_RTM_GE8;
          break;

      default:
          break;
    }
    return 0xffff;
}
char* mapTL1TSMCATCAPortTypeString (u32 value)
{
    switch (value)
    {
      case AtcaPortType_FRONT_GE0: return "FRONT_GE0";  break;
      case AtcaPortType_FRONT_GE1: return "FRONT_GE1";  break;
      case AtcaPortType_FRONT_GE3: return "FRONT_GE3";  break;
      case AtcaPortType_REAR_GE0:  return "REAR_GE0" ;  break;
      case AtcaPortType_REAR_GE1:  return "REAR_GE1" ;  break;
      case AtcaPortType_REAR_GE2:  return "REAR_GE2" ;  break;
      case AtcaPortType_REAR_GE3:  return "REAR_GE3" ;  break;
      case AtcaPortType_REAR_GE4:  return "REAR_GE4" ;  break;
      case AtcaPortType_REAR_GE6:  return "REAR_GE6" ;  break;
      case AtcaPortType_REAR_GE7:  return "REAR_GE7" ;  break;
      case AtcaPortType_REAR_GE8:  return "REAR_GE8" ;  break;
      default:
          break;
    }
    return "NULL";
}
u32 mapTSMCTL1ATCAPortType (u32 value)
{
    switch (value)
    {
      case MALBAN_PORT_FRONT_GE0:
          return AtcaPortType_FRONT_GE0;
          break;
      case MALBAN_PORT_FRONT_GE1:
          return AtcaPortType_FRONT_GE1;
          break;
      case MALBAN_PORT_FRONT_GE3:
          return AtcaPortType_FRONT_GE3;
          break;
      case MALBAN_PORT_RTM_GE0:
          return AtcaPortType_REAR_GE0;
          break;
      case MALBAN_PORT_RTM_GE1:
          return AtcaPortType_REAR_GE1;
          break;
      case MALBAN_PORT_RTM_GE2:
          return AtcaPortType_REAR_GE2;
          break;
      case MALBAN_PORT_RTM_GE3:
          return AtcaPortType_REAR_GE3;
          break;
      case MALBAN_PORT_RTM_GE4:
          return AtcaPortType_REAR_GE4;
          break;
      case MALBAN_PORT_RTM_GE6:
          return AtcaPortType_REAR_GE6;
          break;
      case MALBAN_PORT_RTM_GE7:
          return AtcaPortType_REAR_GE7;
          break;
      case MALBAN_PORT_RTM_GE8:
          return AtcaPortType_REAR_GE8;
          break;

      default:
          break;
    }
    return 0xffff;
}
#endif
/**
 * Edit  ATCA CHASSIS
 */
eosl_bool agc_EM_NE_ED_ATCA_CHASSIS_req( const char * modifier,\
									eosl_handle handle,\
									TL1_TAG ctag ,\
									TL1_AID _src,\
									ChassisType_ENUM * _chassisType,\
									char * _clli,\
									char * _loc,\
									AtcaPortType_ENUM * _sigaPort,\
									AtcaPortType_ENUM * _sigbPort,\
								    AtcaPortType_ENUM * _sigcPort,\
									AtcaPortType_ENUM * _sigdPort,\
									AtcaPortType_ENUM * _emPort,\
									char * _dnsIp1,\
									char * _dnsIp2,\
                                    char * _dnsName,\
									char * _emtos,\
									char * _sigatos,\
									char * _sigbtos,\
									char * _sigctos,\
									char * _sigdtos,\
                                    upgradeState_ENUM * _upgradeState,\
                                    BoolYN_ENUM * _internalBTS,\
                                    char * _sigAIPv4DfltGw,\
                                    dfltGateWay_ENUM * _sigAIPv4GwPing,\
                                    char * _sigAIPv6DfltGw,\
                                    dfltGateWay_ENUM * _sigAIPv6GwPing,\
                                    char * _sigBIPv4DfltGw,\
                                    dfltGateWay_ENUM * _sigBIPv4GwPing,\
                                    char * _sigBIPv6DfltGw,\
                                    dfltGateWay_ENUM * _sigBIPv6GwPing,\
                                    char * _sigCIPv4DfltGw,\
                                    dfltGateWay_ENUM * _sigCIPv4GwPing,\
                                    char * _sigDIPv4DfltGw,\
                                    dfltGateWay_ENUM * _sigDIPv4GwPing,\
                                    char * _emIPv4DfltGw,\
                                    dfltGateWay_ENUM * _emIPv4GwPing)
                                    
{
#ifdef ATCA
#define MAX_PORT_LENGTH 64
    TL1_BUF_t         buffer;
    int               msgLen;
    unsigned int      tmpIp;
    int               chassisType;
    int               upgradeStateValue;
    char*             script = EXEC_CHECK_LCP_PORT;
    char              parameters[MAX_PORT_LENGTH];
    int     errCode =0;
     char errMsg[TL1_IPMSG_MAX_MSG_LEN];
    char formattedIp[INET6_ADDRSTRLEN];
    ip_addr_t genIP;

    /* If AID is explicitly specified as something other than "COM" */
    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") != 0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
	return eosl_false;
    }
    /*
    ** prepare data structure
    */
    msgLen = sizeof(TL1_CMD_BUF_t) + sizeof(ED_CHASSIS_EQPT_t);
    memset(&buffer, 0, msgLen);  /* sets all "valid" flags to 0 */
    
    /*
    **  Fill data structure
    */

    if (_chassisType)
    {
	switch(*_chassisType)
	{
	    case ChassisType_ATCA_MGC:
		chassisType = CHASSIS_TYPE_ATCA_MGC;
		break;
            case ChassisType_ATCA_VSG:
		chassisType = CHASSIS_TYPE_ATCA_SG;
      tc_error_response( handle, ctag, TE_IIDT, "Input, ATCA_VSG currently not supported");
      return eosl_false;
		break;
            case ChassisType_ATCA_VSG_MGC:
		chassisType = CHASSIS_TYPE_ATCA_SG_MGC;
		break;
	    default:
		tc_error_response( handle, ctag, TE_IIDT,
				   "Unsupported chassis type." );
		return eosl_false;
		break;

	}
	buffer.CmdInfo.EdtChassisParams.ChassisType.value = chassisType;
	buffer.CmdInfo.EdtChassisParams.ChassisType.valid = VALID_VALUE;
    }

    /* If CLLI (Common Language Location Identified code specified) */
    if (_clli)
    {
        if(strlen(_clli) > CHASSIS_CLLI_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid CLLI Length." );
            return eosl_false;
        }

        if (!(IsInputStrInRange(_clli, alphaNumAddressList)))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Clli" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdtChassisParams.CLLI.strValue, _clli, CHASSIS_CLLI_LEN);
        buffer.CmdInfo.EdtChassisParams.CLLI.strValue[CHASSIS_CLLI_LEN] = '\0';
        buffer.CmdInfo.EdtChassisParams.CLLI.valid = VALID_VALUE;
    }

    /* If Location specified */
    if (_loc)
    {
        if(strlen(_loc) > sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid LOC Length." );
            return eosl_false;
        }
        if (!(IsInputStrInRange(_loc, alphaNumAddressList)))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Loc" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdtChassisParams.Location.strValue,
                _loc,
                sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1);
        buffer.CmdInfo.EdtChassisParams.Location.strValue[
            sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1] = '\0';
        buffer.CmdInfo.EdtChassisParams.Location.valid = VALID_VALUE;
    }
    
    if(_sigaPort)
    {
        if((buffer.CmdInfo.EdtChassisParams.MalbanPortForSigA.value = mapTL1TSMCATCAPortType(*_sigaPort)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input,Invalid sigaPort." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MalbanPortForSigA.valid = VALID_VALUE;
    }

    if(_sigbPort)
    {
        if((buffer.CmdInfo.EdtChassisParams.MalbanPortForSigB.value = mapTL1TSMCATCAPortType(*_sigbPort)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input,Invalid sigbPort." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MalbanPortForSigB.valid = VALID_VALUE;
    }
	    if(_sigcPort)
    {
     if((buffer.CmdInfo.EdtChassisParams.MalbanPortForSigC.value = mapTL1TSMCATCAPortType(*_sigcPort)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input,Invalid sigcPort." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MalbanPortForSigC.valid = VALID_VALUE;
    }
    if(_sigdPort)
    {
        if((buffer.CmdInfo.EdtChassisParams.MalbanPortForSigD.value = mapTL1TSMCATCAPortType(*_sigdPort)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input,Invalid sigdPort." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MalbanPortForSigD.valid = VALID_VALUE;
    }
    if(_emPort)
    {
        if((buffer.CmdInfo.EdtChassisParams.MalbanPortForMgmt.value = mapTL1TSMCATCAPortType(*_emPort)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input,Invalid emPort." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MalbanPortForMgmt.valid = VALID_VALUE;
    }

    /* on IBC4, transport is hardcode, and not allowed to change. */
    if(procInfo.IsChassisIBC4 && (_sigaPort||_sigbPort||_sigcPort||_sigdPort||_emPort)) {
        tc_error_response( handle, ctag, TE_IIDT, "Input, transport is not allowed to edit on IBC4." );
        return eosl_false;
    }

    /* for co-host chassis, check the transport with LCP's */
    if(procInfo.IsOAMCoexist && _emPort) {
	int result = 0;
        strncpy(parameters, mapTL1TSMCATCAPortTypeString(*_emPort),MAX_PORT_LENGTH);
        result = runOSCommand(script, parameters, NULL);
        if (result == 1) {
            tc_error_response( handle, ctag, TE_IIDT, "Input, transport is not compatible to LCP." );
            return eosl_false;
        }
    }

    
    /* If the primary DNS IP address was specified */
    if (_dnsIp1)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_dnsIp1, "NULL") != 0) &&
            (ip_a2i(_dnsIp1, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, dnsIp1." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.DnsIP1.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.DnsIP1.value = tmpIp;
    }

    /* If the secondary DNS IP address was specified */
    if (_dnsIp2)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_dnsIp2, "NULL") != 0) &&
            (ip_a2i(_dnsIp2, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, dnsIp2." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.DnsIP2.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.DnsIP2.value = tmpIp;
    }

    /* If the DNS name was specified */
    if (_dnsName)
    {
        if (strstr(_dnsName, "&"))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid input, dnsName." );
            return eosl_false;
        }

        if(strlen(_dnsName) >= DNS_NAME_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, dnsName." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_dnsName, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EdtChassisParams.DnsName.strValue,
                    _dnsName,
                    DNS_NAME_LEN-1);
            buffer.CmdInfo.EdtChassisParams.DnsName.strValue[DNS_NAME_LEN-1] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.DnsName.valid = VALID_VALUE;
    }

    /* If upgradeState type specified */
    if (_upgradeState)
    {
        switch(*_upgradeState)
        {
          case upgradeState_NORMAL:
              upgradeStateValue = CHASSIS_STATE_NORMAL;
              break;
          case upgradeState_UPGRADE:
              upgradeStateValue = CHASSIS_STATE_UPGRADE;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT,
                                 "Unsupported upgradeState." );
              return eosl_false;
              break;
        }
        buffer.CmdInfo.EdtChassisParams.ChassisState.value = upgradeStateValue;
        buffer.CmdInfo.EdtChassisParams.ChassisState.valid = VALID_VALUE;
    }


    /* If the EMTOS was specified */
    if (_emtos)
    {
        if((!(IsInputStrInRange(_emtos,"01"))) && (eosl_strcasecmp(_emtos, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, emTOS." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_emtos, "NULL") != 0)
        {
            if(strlen(_emtos) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, EMTOS." );
                return eosl_false;
            }

            strncpy(buffer.CmdInfo.EdtChassisParams.MgmtTos.strValue, _emtos, TOS_BITS_STR_LEN);
            buffer.CmdInfo.EdtChassisParams.MgmtTos.strValue[TOS_BITS_STR_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.MgmtTos.valid = VALID_VALUE;
    }

    /* If the SIGATOS was specified */
    if (_sigatos)
    {
        if((!(IsInputStrInRange(_sigatos,"01"))) && (eosl_strcasecmp(_sigatos, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, SIGATOS." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_sigatos, "NULL") != 0)
        {
            if(strlen(_sigatos) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, SIGATOS." );
                return eosl_false;
            }

            strncpy(buffer.CmdInfo.EdtChassisParams.SigATos.strValue, _sigatos, TOS_BITS_STR_LEN);
            buffer.CmdInfo.EdtChassisParams.SigATos.strValue[TOS_BITS_STR_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.SigATos.valid = VALID_VALUE;
    }

    /* If the SIGBTOS was specified */
    if (_sigbtos)
    {
        if((!(IsInputStrInRange(_sigbtos,"01"))) && (eosl_strcasecmp(_sigbtos, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, SIGBTOS." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_sigbtos, "NULL") != 0)
        {
            if(strlen(_sigbtos) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, SIGBTOS." );
                return eosl_false;
            }

            strncpy(buffer.CmdInfo.EdtChassisParams.SigBTos.strValue, _sigbtos, TOS_BITS_STR_LEN);
            buffer.CmdInfo.EdtChassisParams.SigBTos.strValue[TOS_BITS_STR_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.SigBTos.valid = VALID_VALUE;
    }


    /* If the SIGCTOS was specified */
    if (_sigctos)
    {
        if((!(IsInputStrInRange(_sigctos,"01"))) && (eosl_strcasecmp(_sigctos, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, SIGCTOS." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_sigctos, "NULL") != 0)
        {
            if(strlen(_sigctos) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, SIGCTOS." );
                return eosl_false;
            }

            strncpy(buffer.CmdInfo.EdtChassisParams.SigCTos.strValue, _sigctos, TOS_BITS_STR_LEN);
            buffer.CmdInfo.EdtChassisParams.SigCTos.strValue[TOS_BITS_STR_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.SigCTos.valid = VALID_VALUE;
    }

    /* If the SIGDTOS was specified */
    if (_sigdtos)
    {
        if((!(IsInputStrInRange(_sigdtos,"01"))) && (eosl_strcasecmp(_sigdtos, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, SIGDTOS." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_sigdtos, "NULL") != 0)
        {
            if(strlen(_sigdtos) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, SIGDTOS." );
                return eosl_false;
            }

            strncpy(buffer.CmdInfo.EdtChassisParams.SigDTos.strValue, _sigdtos, TOS_BITS_STR_LEN);
            buffer.CmdInfo.EdtChassisParams.SigDTos.strValue[TOS_BITS_STR_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.SigDTos.valid = VALID_VALUE;
    }

    /* If upgradeState type specified */
    if (_internalBTS)
    {
        switch(*_internalBTS)
        {
        case BoolYN_Y:
            buffer.CmdInfo.EdtChassisParams.EnableBTS.value = TRUE;
            break;
        case BoolYN_N:
            buffer.CmdInfo.EdtChassisParams.EnableBTS.value = FALSE;
            break;
        default:
            tc_error_response( handle, ctag, TE_IIDT, "Unsupported internalBTS." );
            return eosl_false;
            break;
        }
        buffer.CmdInfo.EdtChassisParams.EnableBTS.valid = VALID_VALUE;
    }
    if(_sigAIPv4DfltGw)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigAIPv4DfltGw, "NULL") != 0) &&
                (ip_parse(_sigAIPv4DfltGw, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, _sigAIPv4DfltGw Invalid." );
                return eosl_false;
            }
             buffer.CmdInfo.EdtChassisParams.SigAIpv4DfltGw.valid = VALID_VALUE;
             buffer.CmdInfo.EdtChassisParams.SigAIpv4DfltGw.value = tmpIp;

           
        }
        else
        {
            buffer.CmdInfo.EdtChassisParams.SigAIpv4DfltGw.valid = INVALID_VALUE;
        }

     if(_sigAIPv4GwPing)
    {
        switch(*_sigAIPv4GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigAIpv4GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigAIpv4GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigAIpv4GwPing Invalid" );
                return eosl_false;
                break;
        }
         buffer.CmdInfo.EdtChassisParams.SigAIpv4GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigAIpv4GwPing.value = FALSE;
    }

        
     if(_sigAIPv6DfltGw)
    {
        /* If specified parameter is invalid */
        if ((errCode = tl1ValidateIP(_sigAIPv6DfltGw,
                                     formattedIp,
                                     TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                     TL1_IPVAL_IPV6_STD,
                                     NULL,
                                     &genIP)) != TL1_IPCDE_SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIDT,
                               tl1FormatIPErrorMessage(errCode, "_sigAIPv6DfltGw", errMsg));
            return eosl_false;
        }
        else
        {
            buffer.CmdInfo.EdtChassisParams.SigAIpv6DfltGw.valid = VALID_VALUE;
            buffer.CmdInfo.EdtChassisParams.SigAIpv6DfltGw.value = genIP.ip;
          
            IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                  buffer.CmdInfo.EdtChassisParams.SigAIpv6DfltGw.value, "_sigAIPv6DfltGw = ");
        }
    }
     if(_sigAIPv6GwPing)
    {
        switch(*_sigAIPv6GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigAIpv6GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigAIpv6GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigAIpv6GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.SigAIpv6GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigAIpv6GwPing.value = FALSE;
    }
    
    /*sigB*/
    if(_sigBIPv4DfltGw)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigBIPv4DfltGw, "NULL") != 0) &&
            (ip_parse(_sigBIPv4DfltGw, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, _sigBIPv4DfltGw Invalid." );
            return eosl_false;
        }
         buffer.CmdInfo.EdtChassisParams.SigBIpv4DfltGw.valid = VALID_VALUE;
         buffer.CmdInfo.EdtChassisParams.SigBIpv4DfltGw.value = tmpIp;

       
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigBIpv4DfltGw.valid = INVALID_VALUE;
    }

     if(_sigBIPv4GwPing)
    {
        switch(*_sigBIPv4GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigBIpv4GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigBIpv4GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigBIpv4GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.SigBIpv4GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigBIpv4GwPing.value = FALSE;
    }

        
    if(_sigBIPv6DfltGw)
    {
        /* If specified parameter is invalid */
        if ((errCode = tl1ValidateIP(_sigBIPv6DfltGw,
                                     formattedIp,
                                     TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                     TL1_IPVAL_IPV6_STD,
                                     NULL,
                                     &genIP)) != TL1_IPCDE_SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIDT,
                               tl1FormatIPErrorMessage(errCode, "_sigBIPv6DfltGw", errMsg));
            return eosl_false;
        }
        else
        {
            buffer.CmdInfo.EdtChassisParams.SigBIpv6DfltGw.valid = VALID_VALUE;
            buffer.CmdInfo.EdtChassisParams.SigBIpv6DfltGw.value = genIP.ip;
          
            IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                  buffer.CmdInfo.EdtChassisParams.SigBIpv6DfltGw.value, "_sigBIPv6DfltGw = ");
        }
    }
    if(_sigBIPv6GwPing)
    {
        switch(*_sigBIPv6GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigBIpv6GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigBIpv6GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigBIpv6GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.SigBIpv6GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigBIpv6GwPing.value = FALSE;
    }
    
    /*sigC*/
    
    if(_sigCIPv4DfltGw)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigCIPv4DfltGw, "NULL") != 0) &&
            (ip_parse(_sigCIPv4DfltGw, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, _sigCIPv4DfltGw Invalid." );
            return eosl_false;
        }
         buffer.CmdInfo.EdtChassisParams.SigCIpv4DfltGw.valid = VALID_VALUE;
         buffer.CmdInfo.EdtChassisParams.SigCIpv4DfltGw.value = tmpIp;

       
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigCIpv4DfltGw.valid = INVALID_VALUE;
    }

     if(_sigCIPv4GwPing)
    {
        switch(*_sigCIPv4GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigCIpv4GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigCIpv4GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigCIpv4GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.SigCIpv4GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigCIpv4GwPing.value = FALSE;
    }
    /*sigd*/
    if(_sigDIPv4DfltGw)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigDIPv4DfltGw, "NULL") != 0) &&
            (ip_parse(_sigDIPv4DfltGw, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, _sigDIPv4DfltGw Invalid." );
            return eosl_false;
        }
         buffer.CmdInfo.EdtChassisParams.SigDIpv4DfltGw.valid = VALID_VALUE;
         buffer.CmdInfo.EdtChassisParams.SigDIpv4DfltGw.value = tmpIp;

       
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigDIpv4DfltGw.valid = INVALID_VALUE;
    }

    if(_sigDIPv4GwPing)
    {
        switch(*_sigDIPv4GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.SigDIpv4GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.SigDIpv4GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, SigDIpv4GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.SigDIpv4GwPing.valid = VALID_VALUE;
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.SigDIpv4GwPing.value = FALSE;
    }
    /*em*/
    if(_emIPv4DfltGw)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_emIPv4DfltGw, "NULL") != 0) &&
            (ip_parse(_emIPv4DfltGw, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, _emIPv4DfltGw Invalid." );
            return eosl_false;
        }
         buffer.CmdInfo.EdtChassisParams.EmIpv4DfltGw.valid = VALID_VALUE;
         buffer.CmdInfo.EdtChassisParams.EmIpv4DfltGw.value = tmpIp;

       
    }
    else
    {
        buffer.CmdInfo.EdtChassisParams.EmIpv4DfltGw.valid = INVALID_VALUE;
    }

    if(_emIPv4GwPing)
    {
        switch(*_emIPv4GwPing)
        {
            case dfltGateWay_DISABLED:
                buffer.CmdInfo.EdtChassisParams.EmIpv4GwPing.value = FALSE;
                break;
            case dfltGateWay_ENABLED:
                buffer.CmdInfo.EdtChassisParams.EmIpv4GwPing.value = TRUE;
                break;
            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, EmIpv4GwPing Invalid" );
                return eosl_false;
                break;
        }
        buffer.CmdInfo.EdtChassisParams.EmIpv4GwPing.valid = VALID_VALUE;
   }
   else
   {
        buffer.CmdInfo.EdtChassisParams.EmIpv4GwPing.value = FALSE;
   }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ED_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }
#endif
    return tc_compld_comment( handle, ctag, "ED-ATCA-CHASSIS" );

}
/**
 * Edit the properties of equipment. By definition, a generic 
 * version of this message will have no NE specific 
 * properties. This is not surprising as the properties will 
 * vary from piece of equipment to piece of equipment. 
 * Therefore for a particular NE, the template entry 
 * pname=pvalue must be replaced by a definer with the actual 
 * properties of that box's equipment. 
 * 
 * Defined in GR-199 as part of the generic 
 * ED-modifier-modifier message.
 */

u32 mapTL1TSMCPortMode (u32 value)
{
    switch (value)
    {
      case PortMode_1000FULLDUPLEX:
#ifdef PLEXUS_SP4
          return ENET_PORT_MODE_1000_FULL;  /* Only supported for Plexus SP4 modules */
#endif
          break;
      case PortMode_1000HALFDUPLEX:
          /* Not currently supported */
          break;
      case PortMode_100FULLDUPLEX:
          return ENET_PORT_MODE_100_FULL;
          break;
      case PortMode_100HALFDUPLEX:
          return ENET_PORT_MODE_100_HALF;
          break;
      case PortMode_10FULLDUPLEX:
          return ENET_PORT_MODE_10_FULL;
          break;
      case PortMode_10HALFDUPLEX:
          return ENET_PORT_MODE_10_HALF;
          break;
      case PortMode_AUTONEG:
          return ENET_PORT_MODE_AUTO;
          break;
      default:
          break;
    }
    return 0xffff;
}

u32 mapTSMCTL1PortMode (u32 value)
{
    switch (value)
    {
#ifdef PLEXUS_SP4
      case ENET_PORT_MODE_1000_FULL:
          return PortMode_1000FULLDUPLEX;
          break;
      case ENET_PORT_MODE_1000_HALF:
          return PortMode_1000HALFDUPLEX;
          break;
#endif
      case ENET_PORT_MODE_100_FULL:
          return PortMode_100FULLDUPLEX;
          break;
      case ENET_PORT_MODE_100_HALF:
          return PortMode_100HALFDUPLEX;
          break;
      case ENET_PORT_MODE_10_FULL:
          return PortMode_10FULLDUPLEX;
          break;
      case ENET_PORT_MODE_10_HALF:
          return PortMode_10HALFDUPLEX;
          break;
      case ENET_PORT_MODE_AUTO:
          return PortMode_AUTONEG;
          break;
      default:
          break;
    }
    return PortMode_ALL;
}

eosl_bool agc_EM_NE_ED_CHASSIS_EQPT_req( const char * modifier,\
                                         eosl_handle handle,\
                                         TL1_TAG ctag ,\
                                         TL1_AID _com,\
                                         Shelf_PATTERNED_ENUM _shelfId,\
                                         ChassisType_ENUM * _chassisType,\
                                         MgType_ENUM * _mgType,\
                                         SgType_ENUM * _sgType,\
                                         char * _clli,\
                                         char * _loc,\
                                         char * _craftIPSPA,\
                                         char * _craftIPSPB,\
                                         char * _emIPSPA,\
                                         char * _emIPSPB,\
                                         char * _emIPChassis,\
                                         char * _sigAIPSPA,\
                                         char * _sigAIPSPB,\
                                         char * _sigBIPSPA,\
                                         char * _sigBIPSPB,\
                                         char * _sigCIPSPA,\
                                         char * _sigCIPSPB,\
                                         char * _sigDIPSPA,\
                                         char * _sigDIPSPB,\
                                         char * _sigAIPChassis,\
                                         char * _sigBIPChassis,\
                                         char * _sigCIPChassis,\
                                         char * _sigDIPChassis,\
                                         char * _craftIPMask,\
                                         char * _emIPMask,\
                                         char * _sigAIPMask,\
                                         char * _sigBIPMask,\
                                         char * _sigCIPMask,\
                                         char * _sigDIPMask,\
                                         PortMode_ENUM * _emPortMode,\
                                         PortMode_ENUM * _sigAPortMode,\
                                         PortMode_ENUM * _sigBPortMode,\
                                         PortMode_ENUM * _sigCPortMode,\
                                         PortMode_ENUM * _sigDPortMode,\
                                         int * _emFailOverTmr,\
                                         int * _sigFailOverTmr,\
                                         char * _emTOS,\
                                         char * _sigATOS,\
                                         char * _sigBTOS,\
                                         char * _sigCTOS,\
                                         char * _sigDTOS,\
                                         char * _dnsIP1,\
                                         char * _dnsIP2,\
                                         char * _ntpServIP1,\
                                         char * _ntpServIP2,\
                                         char * _dnsName,\
                                         char * _emHostnameSPA,\
                                         char * _emHostnameSPB,\
                                         ChassisCellFormat_ENUM * _chassisCellFormat)
{
#ifndef ATCA
    TL1_BUF_t         buffer;
    int               msgLen;
    int               shelfId;
    unsigned int      tmpIp;
    int               i;
    char              xchr        = 0;
    int               chassisType;
    int               mgType;
    int               sgType;


    /* If AID is explicitly specified as something other than "COM" */
    if ((_com != NULL) && (eosl_strcasecmp(_com, "COM") != 0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /*
    ** prepare data structure
    */
    msgLen = sizeof(TL1_CMD_BUF_t) + sizeof(ED_CHASSIS_EQPT_t);
    memset(&buffer, 0, msgLen);  /* sets all "valid" flags to 0 */

    /*
    **  Fill data structure
    */

    /* If shelfId specified */
    if (_shelfId)
    {
        i = sscanf(_shelfId, "%d%c", &shelfId, &xchr);
        if (i != 1)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid ShelfId" );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.ShelfId.value = shelfId;
        buffer.CmdInfo.EdtChassisParams.ShelfId.valid = VALID_VALUE;
    }
    
    /* If chassis type specified */
    if (_chassisType)
    {
        switch(*_chassisType)
        {   
          case ChassisType_MG:
              chassisType = CHASSIS_TYPE_MG;
              break;
          case ChassisType_MGC:
              chassisType = CHASSIS_TYPE_MGC;
              break;
          case ChassisType_SG:
              chassisType = CHASSIS_TYPE_SG;
              break;
          case ChassisType_SG_MG:
              chassisType = CHASSIS_TYPE_SG_MG;
              break;
          case ChassisType_SG_MGC:
              chassisType = CHASSIS_TYPE_SG_MGC;
              break;
          case ChassisType_SG_MGC_MG:
              chassisType = CHASSIS_TYPE_SG_MGC_MG;
              break;

#ifdef ATCA_RHEL5
#if 0 /* EVAN: comment out to pass build */
          case ChassisType_ATCA_MGC:
              chassisType = CHASSIS_TYPE_ATCA_MGC;
              break;  
          case ChassisType_ATCA_SG:
              chassisType = CHASSIS_TYPE_ATCA_SG;
              break;  
          case ChassisType_ATCA_SG_MGC:
              chassisType = CHASSIS_TYPE_ATCA_SG_MGC;
              break;  
#endif
#endif

          default:
              tc_error_response( handle, ctag, TE_IIAC,
                                 "Unsupported chassis type." );
              return eosl_false;
              break;
        }
        buffer.CmdInfo.EdtChassisParams.ChassisType.value = chassisType;
        buffer.CmdInfo.EdtChassisParams.ChassisType.valid = VALID_VALUE;
    }
    
    /* If MG type specified */
    if (_mgType)
    {
        switch(*_mgType)
        {   
          case MgType_PG:
              mgType = EMF_MG_TYPE_PG;
              break;
          case MgType_TDMIP:
              mgType = EMF_MG_TYPE_TDMIP;
              break;
          case MgType_UMTS:
              mgType = EMF_MG_TYPE_UMTS;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIAC,
                                 "Unsupported mgType." );
              return eosl_false;
              break;
        }
        buffer.CmdInfo.EdtChassisParams.MgType.value = mgType;
        buffer.CmdInfo.EdtChassisParams.MgType.valid = VALID_VALUE;
    }
    
    /* If SG type specified */
    if (_sgType)
    {
        switch(*_sgType)
        {   
          case SgType_DSG:
              sgType = EMF_SG_TYPE_DSG;
              break;
          case SgType_ISG:
              sgType = EMF_SG_TYPE_ISG;
              break;
          case SgType_PSG:
              sgType = EMF_SG_TYPE_PSG;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIAC,
                                 "Unsupported sgType." );
              return eosl_false;
              break;
        }
        buffer.CmdInfo.EdtChassisParams.SgType.value = sgType;
        buffer.CmdInfo.EdtChassisParams.SgType.valid = VALID_VALUE;
    }

    /* If CLLI (Common Language Location Identified code specified) */
    if (_clli)
    {
        if(strlen(_clli) > CHASSIS_CLLI_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid CLLI Length." );
            return eosl_false;
        }

        if (!(IsInputStrInRange(_clli, alphaNumAddressList)))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Clli" );
            return eosl_false;
        }



        strncpy(buffer.CmdInfo.EdtChassisParams.CLLI.strValue, _clli, CHASSIS_CLLI_LEN);
        buffer.CmdInfo.EdtChassisParams.CLLI.strValue[CHASSIS_CLLI_LEN] = '\0';
        buffer.CmdInfo.EdtChassisParams.CLLI.valid = VALID_VALUE;
    }

    /* If Location specified */
    if (_loc)
    {
        if(strlen(_loc) > sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid LOC Length." );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdtChassisParams.Location.strValue,
                _loc,
                sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1);
        buffer.CmdInfo.EdtChassisParams.Location.strValue[
            sizeof(buffer.CmdInfo.EdtChassisParams.Location.strValue)-1] = '\0';
        buffer.CmdInfo.EdtChassisParams.Location.valid = VALID_VALUE;
    }
    
    /* If the CRAFT management IP for SP-A was specified */
    if (_craftIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_craftIPSPA, "NULL") != 0) &&
            (ip_a2i(_craftIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, craftIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.CraftIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.CraftIpSPA.value = tmpIp;
    }
    
    /* If the CRAFT management IP for SP-B was specified */
    if (_craftIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_craftIPSPB, "NULL") != 0) &&
            (ip_a2i(_craftIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, craftIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.CraftIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.CraftIpSPB.value = tmpIp;
    }

    /* If the EM management IP for SP-A was specified */
    if (_emIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_emIPSPA, "NULL") != 0) &&
            (ip_a2i(_emIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, emIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MgmtIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.MgmtIpSPA.value = tmpIp;
    }

    /* If the EM management IP for SP-A was specified */
    if (_emIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_emIPSPB, "NULL") != 0) &&
            (ip_a2i(_emIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, emIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MgmtIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.MgmtIpSPB.value = tmpIp;
    }

    /* If the chassis wide EM management IP was specified */
    if (_emIPChassis)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_emIPChassis, "NULL") != 0) &&
            (ip_a2i(_emIPChassis, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, emIPChassis." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MgmtChassisIp.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.MgmtChassisIp.value = tmpIp;
    }

    /* If the sig A IP on SP-A was specified */
    if (_sigAIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigAIPSPA, "NULL") != 0) &&
            (ip_a2i(_sigAIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigAIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingAIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingAIpSPA.value = tmpIp;
    }

    /* If the sig A IP on SP-B was specified */
    if (_sigAIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigAIPSPB, "NULL") != 0) &&
            (ip_a2i(_sigAIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigAIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingAIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingAIpSPB.value = tmpIp;
    }

    /* If the sig B IP on SP-A was specified */
    if (_sigBIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigBIPSPA, "NULL") != 0) &&
            (ip_a2i(_sigBIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigBIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingBIpSPA.value = tmpIp;
    }

    /* If the sig B IP on SP-B was specified */
    if (_sigBIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigBIPSPB, "NULL") != 0) &&
            (ip_a2i(_sigBIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigBIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingBIpSPB.value = tmpIp;
    }

    /* If the sig C IP on SP-A was specified */
    if (_sigCIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigCIPSPA, "NULL") != 0) &&
            (ip_a2i(_sigCIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigCIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingCIpSPA.value = tmpIp;
    }

    /* If the sig C IP on SP-B was specified */
    if (_sigCIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigCIPSPB, "NULL") != 0) &&
            (ip_a2i(_sigCIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigCIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingCIpSPB.value = tmpIp;
    }

    /* If the sig D IP on SP-A was specified */
    if (_sigDIPSPA)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigDIPSPA, "NULL") != 0) &&
            (ip_a2i(_sigDIPSPA, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigDIPSPA." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDIpSPA.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingDIpSPA.value = tmpIp;
    }

    /* If the sig D IP on SP-B was specified */
    if (_sigDIPSPB)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigDIPSPB, "NULL") != 0) &&
            (ip_a2i(_sigDIPSPB, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigDIPSPB." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDIpSPB.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingDIpSPB.value = tmpIp;
    }

    /* If the sig A alias IP was specified */
    if (_sigAIPChassis)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigAIPChassis, "NULL") != 0) &&
            (ip_a2i(_sigAIPChassis, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigAIPChassis." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingAIpChassis.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingAIpChassis.value = tmpIp;
    }

    /* If the sig B alias IP was specified */
    if (_sigBIPChassis)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigBIPChassis, "NULL") != 0) &&
            (ip_a2i(_sigBIPChassis, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigBIPChassis." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBIpChassis.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingBIpChassis.value = tmpIp;
    }

    /* If the sig C alias IP was specified */
    if (_sigCIPChassis)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigCIPChassis, "NULL") != 0) &&
            (ip_a2i(_sigCIPChassis, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigCIPChassis." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCIpChassis.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingCIpChassis.value = tmpIp;
    }

    /* If the sig D alias IP was specified */
    if (_sigDIPChassis)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigDIPChassis, "NULL") != 0) &&
            (ip_a2i(_sigDIPChassis, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, sigDIPChassis." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDIpChassis.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingDIpChassis.value = tmpIp;
    }

    /* If the craft management IP subnet mask was specified */
    if (_craftIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_craftIPMask, "NULL") != 0) &&
            (ip_a2i(_craftIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, craftIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.CraftMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.CraftMask.value = tmpIp;
    }

    /* If the EM management IP subnet mask was specified */
    if (_emIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_emIPMask, "NULL") != 0) &&
            (ip_a2i(_emIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, emIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MgmtMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.MgmtMask.value = tmpIp;
    }

    /* If the sig A IP subnet mask was specified */
    if (_sigAIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigAIPMask, "NULL") != 0) &&
            (ip_a2i(_sigAIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, sigAIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingAMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingAMask.value = tmpIp;
    }

    /* If the sig B IP subnet mask was specified */
    if (_sigBIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigBIPMask, "NULL") != 0) &&
            (ip_a2i(_sigBIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, sigBIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingBMask.value = tmpIp;
    }

    /* If the sig C IP subnet mask was specified */
    if (_sigCIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigCIPMask, "NULL") != 0) &&
            (ip_a2i(_sigCIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, sigCIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingCMask.value = tmpIp;
    }

    /* If the sig D IP subnet mask was specified */
    if (_sigDIPMask)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_sigDIPMask, "NULL") != 0) &&
            (ip_a2i(_sigDIPMask, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Mask, sigDIPMask." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDMask.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingDMask.value = tmpIp;
    }

    /* If the EM management port mode was specified */
    if(_emPortMode)
    {
        if ((buffer.CmdInfo.EdtChassisParams.MgmtPortMode.value =
             mapTL1TSMCPortMode(*_emPortMode)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Port Mode, emPortMode." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.MgmtPortMode.valid = VALID_VALUE;
    }

    /* If the sig A port mode was specified */
    if(_sigAPortMode)
    {
        if ((buffer.CmdInfo.EdtChassisParams.SignalingAPortMode.value =
             mapTL1TSMCPortMode(*_sigAPortMode)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Port Mode, sigAPortMode." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingAPortMode.valid = VALID_VALUE;
    }

    /* If the sig B port mode was specified */
    if(_sigBPortMode)
    {
        if ((buffer.CmdInfo.EdtChassisParams.SignalingBPortMode.value =
             mapTL1TSMCPortMode(*_sigBPortMode)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Port Mode, sigBPortMode." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBPortMode.valid = VALID_VALUE;
    }

    /* If the sig C port mode was specified */
    if(_sigCPortMode)
    {
        if ((buffer.CmdInfo.EdtChassisParams.SignalingCPortMode.value =
             mapTL1TSMCPortMode(*_sigCPortMode)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Port Mode, sigCPortMode." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCPortMode.valid = VALID_VALUE;
    }

    /* If the sig D port mode was specified */
    if(_sigDPortMode)
    {
        if ((buffer.CmdInfo.EdtChassisParams.SignalingDPortMode.value =
             mapTL1TSMCPortMode(*_sigDPortMode)) == 0xffff)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Port Mode, sigDPortMode." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDPortMode.valid = VALID_VALUE;
    }

    /* If the EM management port failover timer was specified */
    if(_emFailOverTmr)
    {
        buffer.CmdInfo.EdtChassisParams.MgmtFoTmr.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.MgmtFoTmr.value = *_emFailOverTmr;
    }

    /* If the EM management port failover timer was specified */
    if(_sigFailOverTmr)
    {
        buffer.CmdInfo.EdtChassisParams.SignalingFoTmr.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.SignalingFoTmr.value = *_sigFailOverTmr;
    }

    /* If the EM management DSCP bitmask was specified */
    if(_emTOS)
    {
        if((!(IsInputStrInRange(_emTOS,"01"))) &&
	   (eosl_strcasecmp(_emTOS, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, emTOS." );
            return eosl_false;
        }
        
	if(eosl_strcasecmp(_emTOS, "NULL") != 0)
        {
            if(strlen(_emTOS) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Invalid DSCP bitmask length, emTOS." );
                return eosl_false;
            }
            strcpy(buffer.CmdInfo.EdtChassisParams.MgmtTos.strValue,
                   _emTOS);
        }
        buffer.CmdInfo.EdtChassisParams.MgmtTos.valid = VALID_VALUE;
    }

    /* If the sig A DSCP bitmask was specified */
    if(_sigATOS)
    {
        if((!(IsInputStrInRange(_sigATOS,"01"))) &&
	   (eosl_strcasecmp(_sigATOS, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, sigATOS." );
            return eosl_false;
        }
        
	if(eosl_strcasecmp(_sigATOS, "NULL") != 0)
        {
            if(strlen(_sigATOS) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Invalid DSCP bitmask length, sigATOS." );
                return eosl_false;
            }
            strcpy(buffer.CmdInfo.EdtChassisParams.SignalingATos.strValue,
                   _sigATOS);
        }
        buffer.CmdInfo.EdtChassisParams.SignalingATos.valid = VALID_VALUE;
    }

    /* If the sig B DSCP bitmask was specified */
    if(_sigBTOS)
    {
        if((!(IsInputStrInRange(_sigBTOS,"01"))) &&
	   (eosl_strcasecmp(_sigBTOS, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, sigBTOS." );
            return eosl_false;
        }
        
	if(eosl_strcasecmp(_sigBTOS, "NULL") != 0)
        {
            if(strlen(_sigBTOS) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Invalid DSCP bitmask length, sigBTOS." );
                return eosl_false;
            }
            strcpy(buffer.CmdInfo.EdtChassisParams.SignalingBTos.strValue,
                   _sigBTOS);
        }
        buffer.CmdInfo.EdtChassisParams.SignalingBTos.valid = VALID_VALUE;
    }

    /* If the sig C DSCP bitmask was specified */
    if(_sigCTOS)
    {
        if((!(IsInputStrInRange(_sigCTOS,"01"))) &&
	   (eosl_strcasecmp(_sigCTOS, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, sigCTOS." );
            return eosl_false;
        }
        
	if(eosl_strcasecmp(_sigCTOS, "NULL") != 0)
        {
            if(strlen(_sigCTOS) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Invalid DSCP bitmask length, sigCTOS." );
                return eosl_false;
            }
            strcpy(buffer.CmdInfo.EdtChassisParams.SignalingCTos.strValue,
                   _sigCTOS);
        }
        buffer.CmdInfo.EdtChassisParams.SignalingCTos.valid = VALID_VALUE;
    }

    /* If the sig D DSCP bitmask was specified */
    if(_sigDTOS)
    {
        if((!(IsInputStrInRange(_sigDTOS,"01"))) &&
	   (eosl_strcasecmp(_sigDTOS, "NULL") != 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid DSCP bitmask, sigDTOS." );
            return eosl_false;
        }
        
	if(eosl_strcasecmp(_sigDTOS, "NULL") != 0)
        {
            if(strlen(_sigDTOS) != TOS_BITS_STR_LEN)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Invalid DSCP bitmask length, sigDTOS." );
                return eosl_false;
            }
            strcpy(buffer.CmdInfo.EdtChassisParams.SignalingDTos.strValue,
                   _sigDTOS);
        }
        buffer.CmdInfo.EdtChassisParams.SignalingDTos.valid = VALID_VALUE;
    }

    /* If the primary DNS IP address was specified */
    if (_dnsIP1)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_dnsIP1, "NULL") != 0) &&
            (ip_a2i(_dnsIP1, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, dnsIP." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.DnsIP1.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.DnsIP1.value = tmpIp;

    }

    /* If the secondary DNS IP address was specified */
    if (_dnsIP2)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_dnsIP2, "NULL") != 0) &&
            (ip_a2i(_dnsIP2, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, dnsIP2." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.DnsIP2.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.DnsIP2.value = tmpIp;

    }

    /* If the primary NTP server IP address was specified */
    if (_ntpServIP1)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_ntpServIP1, "NULL") != 0) &&
            (ip_a2i(_ntpServIP1, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, ntpServIP1." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.NTPServer1IP.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.NTPServer1IP.value = tmpIp;

    }

    /* If the secondary DNS IP address was specified */
    if (_ntpServIP2)
    {
        tmpIp = 0;
        if ((eosl_strcasecmp(_ntpServIP2, "NULL") != 0) &&
            (ip_a2i(_ntpServIP2, &tmpIp) == 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, ntpServIP2." );
            return eosl_false;
        }
        buffer.CmdInfo.EdtChassisParams.NTPServer2IP.valid = VALID_VALUE;
        buffer.CmdInfo.EdtChassisParams.NTPServer2IP.value = tmpIp;
    }

    /* If the DNS name was specified */
    if (_dnsName)
    {
        if (strstr(_dnsName, "&"))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid input, dnsName." );
            return eosl_false;
        }
        
        if(strlen(_dnsName) > DNS_NAME_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid input length, dnsName." );
            return eosl_false;
        }

        if (eosl_strcasecmp(_dnsName, "NULL") != 0)
        {
            strncpy(buffer.CmdInfo.EdtChassisParams.DnsName.strValue,
                    _dnsName,
                    DNS_NAME_LEN);
            buffer.CmdInfo.EdtChassisParams.DnsName.strValue[DNS_NAME_LEN] = '\0';
        }
        buffer.CmdInfo.EdtChassisParams.DnsName.valid = VALID_VALUE;
    }
    
    /* If the Hostname of management interface on SPA specified */
    if (_emHostnameSPA)
    {
        if(strlen(_emHostnameSPA) > HOST_NAME_SP-1)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid emHostnameSPA Length." );
            return eosl_false;
        }
       if(strcasecmp(_emHostnameSPA,"NULL")==0) 
       {
          tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid emHostnameSPA");
          return eosl_false;
       }
        if (!(IsInputStrInRange(_emHostnameSPA, alphaNumCharDashDotUndsc)))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid emHostnameSPA" );
            return eosl_false;
        }
        
        strncpy(buffer.CmdInfo.EdtChassisParams.EmHostnameSPA.strValue, _emHostnameSPA, HOST_NAME_SP-1);
        buffer.CmdInfo.EdtChassisParams.EmHostnameSPA.strValue[HOST_NAME_SP-1] = '\0';
        buffer.CmdInfo.EdtChassisParams.EmHostnameSPA.valid = VALID_VALUE;
    }
    
    /* If the Hostname of management interface on SPB specified */
    if (_emHostnameSPB)
    {
        if(strlen(_emHostnameSPB) > HOST_NAME_SP-1)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid emHostnameSPB Length." );
            return eosl_false;
        }
        if(strcasecmp(_emHostnameSPB,"NULL")==0)
          {
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid emHostnameSPB");
              return eosl_false;
          }
                                                
        
        if (!(IsInputStrInRange(_emHostnameSPB, alphaNumCharDashDotUndsc)))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid emHostnameSPB" );
            return eosl_false;
        }
        
        strncpy(buffer.CmdInfo.EdtChassisParams.EmHostnameSPB.strValue, _emHostnameSPB, HOST_NAME_SP-1);
        buffer.CmdInfo.EdtChassisParams.EmHostnameSPB.strValue[HOST_NAME_SP-1] = '\0';
        buffer.CmdInfo.EdtChassisParams.EmHostnameSPB.valid = VALID_VALUE;
    }
    
    /*If both Hostnames specified at the same time*/
    if (_emHostnameSPA && _emHostnameSPB)
    {
        if (strcmp(_emHostnameSPA, _emHostnameSPB) == 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "emHostnameSPA can't equal emHostnameSPB" );
            return eosl_false;
        }
    }

    if (_chassisCellFormat)
    {
        switch (*_chassisCellFormat)
        {
        case ChassisCellFormat_EXTENDED:
            buffer.CmdInfo.EdtChassisParams.ChassisCellFormat.valid = VALID_VALUE;
            buffer.CmdInfo.EdtChassisParams.ChassisCellFormat.value = CHASSIS_CELL_FORMAT_NEW;
            break;
        case ChassisCellFormat_NORMAL:
            buffer.CmdInfo.EdtChassisParams.ChassisCellFormat.valid = VALID_VALUE;
            buffer.CmdInfo.EdtChassisParams.ChassisCellFormat.value = CHASSIS_CELL_FORMAT_OLD;
            break;
        default:
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid chassisCellFormat" );
            return eosl_false;
        }
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ED_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }
#endif
    return tc_compld_comment( handle, ctag, "ED-CHASSIS-EQPT" );
}

/**
 * Edit  COUNTRY
 */
eosl_bool agc_EM_NE_ED_COUNTRY_req( const char * modifier,\
                                    eosl_handle handle,\
                                    TL1_TAG ctag ,\
                                    TL1_AID _countryCode,\
                                    int * _minDgts,\
                                    int * _maxDgts)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;
    int            countryCode;
    char           retChar;

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = TELICA_TABLE_COUNTRY_CODE;

    rowKey.numIndices = 1;

    if(_countryCode == NULL)
    {
        tc_error_response(handle, ctag, TE_IIAC, "Input, Missing Aid");
        return eosl_false;
    }

    if((sscanf(_countryCode, "%d%c[^0-9]", &countryCode, &retChar) != 1) ||
       (countryCode < 1) || countryCode > 999 ||IsInputStrContainPrefix(_countryCode,"0"))
    {
        tc_error_response(handle, ctag, TE_IIAC, "Input, Invalid CountryCode");
        return eosl_false;
    }

    rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
    rowKey.rowIndex[0].value.stringVal.ptr = _countryCode;
    rowKey.rowIndex[0].value.stringVal.len = strlen(_countryCode);

    if(_minDgts)
    {
        columns[colCnt].columnId = COUNTRY_COL_MIN_DGTS;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_minDgts;
        colCnt++;
    }

    if(_maxDgts)
    {
        columns[colCnt].columnId = COUNTRY_COL_MAX_DGTS;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxDgts;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_COUNTRY_req", 
                   "ED-COUNTRY - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);



    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ED-COUNTRY" ); /* success */
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 * Allow a user to change their own password. Other user
 * identification and access changes may only be made by
 * priviliged/super-users.
 *
 * Defined in TR-835.
 */
eosl_bool agc_EM_NE_ED_PID_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid, char * _oldpid, char * _newpid)
{
    char * encryptPasswd;
    const char *username;
    time_t today;
    unsigned int passwdExp;
    char encryptOldPasswd[MAX_ENCRYPTED_PASSWORD_SIZE+1];
    PASSWORD_HISTORY_t passwdData;
    int tmpPasswdChFreq;
    USER_DATA_t * userDataPtr = NULL;
    char     errorMsg[256];

    /* Design Note: ED-PID is only used for changing own password, which is enforced below */
    username = tc_session_get_username(handle);
    if (strcmp(username, _uid) != 0)
    {
        tc_error_response(handle,ctag,TE_EANS,
                          "Invalid uid. ED-PID is only for changing own password.");
        return eosl_false;
    }
   
    /* If the password history can not be retrieved */
    if (getUserPasswordHistory(_uid, &passwdData) == FAIL)
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_PID_req","Unable to read password history.\n");
        tc_error_response(handle,ctag,TE_EANS,"Error reading password history.");
        return eosl_false;
    }

    encryptPasswd = TL1Crypt(_oldpid);
    strcpy(encryptOldPasswd, encryptPasswd);
    if( strcmp(passwdData.currentPasswd, encryptPasswd ) != 0)
    {
        tc_error_response(handle,ctag,TE_EANS,"Edit Password Failed: old password is incorrect");
        return eosl_false;
    }

    /* If the password is invalid based on the password complexity level */
    if ( IsPasswordValid(getMemPasswdComplx(),
                         _uid,
                         _newpid,
                         _oldpid,
                         &passwdData,
                         getMemPasswdMaxReuse(),
                         errorMsg)  == eosl_false )
    {
        tc_error_response(handle,ctag, TE_PIUI, errorMsg);
        return  eosl_false;
        /* send event */
    }

    encryptPasswd = TL1Crypt(_newpid);

    today = time(NULL);
    /* today = normalizeDate(today); */

    /* Prevent changing too often. */
    tmpPasswdChFreq = getPasswdChFreq();
    if (tmpPasswdChFreq > 0)
    {
        if (((unsigned int)today - passwdData.passwdChg) < (unsigned int)(tmpPasswdChFreq * 60 * 60))
        {
            tc_error_response(handle,ctag,TE_PIUI,"Edit Password Failed: Too soon after last password change.");
            return eosl_false;
        }
    }

    passwdExp = (unsigned int)today + (passwdData.page) * 24 * 60 * 60; /* convert days to seconds */

    if (ModifyUserDb(_uid, _newpid, NULL, NULL,
                     NULL, NULL, &passwdExp,
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == -1)
    {
        tc_error_response(handle,ctag,TE_EANS,"Edit Password Failed: unable to change password");
        return eosl_false;
    }

    /* Log the password change event to the security log */
    AddSecEvent(handle, PASSWORD_CHANGED, _uid, " Password Changed by User ");

    setTelicaSessionState(handle, PASSWD_OK);
    passwdData.passwdChg = (unsigned int)today;
    if (updateUserPasswordHistory(&passwdData, encryptOldPasswd) == FAIL)
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_PID_req","Unable to update password history.\n");
    }

    if ((userDataPtr = GetUserDataFromDb(_uid)) != NULL)
    {
       setTelicaSessionDataIdleTime(handle, userDataPtr->tmout * 60, eosl_false);
       procLogMsg(PLOG_ERROR, "","%s sets fresh IdleTIMEOUT=%d\n",
                  username,userDataPtr->tmout*60);
    }
    else
    {
       setTelicaSessionDataIdleTime(handle, (getTMOUT() * 60), eosl_true);
       procLogMsg(PLOG_ERROR, "","%s NOT FOUND in DB sets system IdleTIMEOUT=%d\n",
                  username,getTMOUT()*60);
    }
    tc_compld_comment( handle, ctag, "ED-PID" );
    return eosl_true;
}

/**
 * Edit  User Security
 */
eosl_bool agc_EM_NE_ED_USER_LISECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid,\
									char * _pid,\
									char * _cid,\
									UserPrivilege_ENUM * _uap,\
									int * _page,\
									int * _pcnd,\
									int * _tmout,\
									BoolYN_ENUM * _freezable,\
									PrimaryStateIn_ENUM * _pst)
{
    time_t todaysDate;
    unsigned int tmpPasswdExp;
    unsigned int *p_tmpPasswdExp = NULL;
    USER_DATA_t * userDataPtr    = NULL;
    int calea;
    int *calea_p     = NULL;
    int userState;
    char     errorMsg[256];
    char currentEncryptPasswd[MAX_ENCRYPTED_PASSWORD_SIZE+1];
    PASSWORD_HISTORY_t passwdData;
    const char  *userName = tc_session_get_username(handle);
#ifdef ATCA
    SWLIC_RETCODE          retcode;

    /*check if has licence key*/
    retcode = swLicMgrFeatureCheck(SWLIC_RTUTAG_MGC8_C4_LAWFUL_INT);
    if ( retcode == SWLIC_ERR_LIC_INV_KEY )
    {
        tc_error_response(handle, ctag, TE_FRNR, "RTU Does Not Reply");
        return  eosl_false;
    }
    else if (retcode == SWLIC_ERR_FAIL)
    {
        tc_error_response(handle, ctag, TE_ERNS, "RTU Does Not Support Command");
        return  eosl_false;
    }

    #endif

    memset(currentEncryptPasswd, 0, MAX_ENCRYPTED_PASSWORD_SIZE+1);

    if (userName == NULL)
    {
        tc_error_response(handle,ctag,TE_EANS,"Unable to obtain username associated with this session");
        return eosl_false;
    }

    if (etsiLiValidate(handle, _uid) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
        return eosl_false;
    }
    
    if (_pid != NULL)
    {
        /* If the password history can not be retrieved */
        if (getUserPasswordHistory(_uid, &passwdData) == FAIL)
        {
            procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_LISECU_req","Unable to read password history.\n");
            tc_error_response(handle,ctag,TE_EANS, "Error reading password history.");
            return eosl_false;
        }

        /* If the account attributes can not be retrieved */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_LISECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS, "Failed to obtain user account data.");
            return eosl_false;
        }

        /* Save off the current password in encrypted form */
        strcpy(currentEncryptPasswd, userDataPtr->password);

        /* Get the current state of this account */
        userState = getUserState(userDataPtr);
        
        eosl_free(userDataPtr);
        userDataPtr = NULL;

        /* Design Note: Need to test for immediate password reuse case separately
         *     instead of within function IsPasswordValid for ADMIN password reset
         *     case (this case).  This is because, unlike the user password
         *     change via ED-PID, the current password in clear text is not
         *     available for ADMIN password reset via ED-USERLI-SECU. For this
         *     reason, the test below compares the current and new password is
         *     encrypted form, whereas the test in function IsPasswordValid
         *     compares the current and new password in clear text form.
         */

        /* Prevent immediate password reuse if password reuse checks are enabled */
        if ((strcmp(TL1Crypt(_pid), currentEncryptPasswd) == 0) && (getMemPasswdMaxReuse() > 0))
        {
            tc_error_response(handle,ctag, TE_PIUI, "Password error: Cannot reuse previous password");
            return eosl_false;
        }

        /* If the password is invalid based on the password complexity level */
        if ( IsPasswordValid(getMemPasswdComplx(),
                             _uid,
                             _pid,
                             NULL,  /* ADMIN PW reset - prev PW N/A */
                             &passwdData,
                             getMemPasswdMaxReuse(),
                             errorMsg)  == eosl_false )
        {
            tc_error_response(handle,ctag, TE_PIUI, errorMsg);
            return  eosl_false;
            /* send event */
        }
    }

    if(_uap)
    {
        if(*_uap!=UserPrivilege_ADMIN)
        {
            tc_error_response(handle, ctag, TE_PIUI, "UAP must be ADMIN!");
            return  eosl_false;
        }
    }


    if (_page != NULL )
    {
        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
    }

    if (_pcnd != NULL)
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
    }

    if (_tmout != NULL)
    {
        if ((*_tmout < 0) || (*_tmout > 99))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmout");
            return eosl_false;
        }
    }

    if ((_cid != NULL) && (strlen(_cid) > MAX_CID_SIZE))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid cid" );
        return eosl_false;
    }

    calea = 0;

    if (_freezable && *_freezable == BoolYN_Y)
    {
        /* Design Note: The attribute "Freeze inhibit"
        **   is stored in the GoAhead database,
        **   which requires the input value _freezable to be inverted.
        */
        tc_error_response( handle, ctag, TE_IIDT, "Account freezing can not be enabled for account etsili" );
        return eosl_false;
    }

    /* If deactivating/reactivating account */
    if (_pst)
    {
        /* Get account attributes */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_LISECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS,
                              "Failed to obtain user account data.");
            return eosl_false;
        }

        /* Get the current state of this account */
        userState = getUserState(userDataPtr);

        /* If reactivating account */
        if (*_pst == PrimaryStateIn_IS)
        {
            /* If the user account is currently OOS */
            if ((userState & USR_SVC_BIT) == 0)
            {
                /* Design Note: Factory default user accounts exempt from having
                **     to change password when reactivated.
                ** If new password not supplied and not factory default account
                */
                if ((!_pid) && (!isFactoryDefaultUserAccount(userDataPtr)))
                {
                    tc_error_response(handle,ctag,TE_PIUI,
                                      "Password must be specified when "
                                      "administratively placing an account "
                                      "In-Service.");
                    eosl_free(userDataPtr);
                    return eosl_false;
                }

                /* If account reactivation failed */
                if ((reactivateUser(handle, userDataPtr)) == eosl_false)
                {
                    procLogMsg (PLOG_ERROR,
                                "agc_EM_NE_ED_USER_LISECU_req",
                                "Failed to reactivate ADMIN account.\n");
                    tc_error_response(handle, ctag, TE_EANS,
                                      "Failed to administratively place "
                                      "account In-Service");
                    eosl_free(userDataPtr);
                    return eosl_false;
                }
            }
        }
        else /* Deactivating account */
        {
            /* If the user account is not currently managed OOS */
            if ((userState & USR_MNG_BIT) == 0)
            {
                /* If ADMIN is attempting to place own account OOS */
                if (eosl_strcmp(userName, _uid) == 0)
                {
                    procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_LISECU_req", "Can not deactivate own account.\n");
                    tc_error_response(handle, ctag, TE_EANS,
                                      "ADMIN can not place own account administratively Out-Of-Service");
                    eosl_free(userDataPtr);
                    return eosl_false;
                }
                else
                {
                    if ((deactivateUser(handle, userDataPtr)) == eosl_false)
                    {
                        procLogMsg (PLOG_ERROR,
                                    "agc_EM_NE_ED_USER_LISECU_req",
                                    "Failed to deactivate ADMIN account.\n");
                        tc_error_response(handle, ctag, TE_EANS,
                                          "Failed to administratively place "
                                          "account Out-Of-Service");
                        eosl_free(userDataPtr);
                        return eosl_false;
                    }
                }
            }
        }
        eosl_free(userDataPtr);
    }

    /* Commit password updates only after entire command is validated */
    if (_pid != NULL)
    {
        todaysDate     = time(NULL);
        todaysDate     = normalizeDate(todaysDate);
        tmpPasswdExp   = (int)todaysDate;
        p_tmpPasswdExp = &tmpPasswdExp;
        passwdData.passwdChg = (unsigned int)todaysDate;

        /* In the follow two scenarios user state change to IS,EXP&GRC&TMP:
         * 1) when PST=IS is explicitly set and PW changed
         * 2) when PST is already IS and PW changed
         * 3) when current state OOS-AU,EXP and PW changed. */

        if ((_pst && *_pst == PrimaryStateIn_IS) ||
            ((userState & USR_SVC_BIT) != 0 && !_pst) ||
            ((userState & USR_SVC_BIT) == 0 && (userState & USR_MNG_BIT) == 0 && (userState & USR_EXP_BIT) != 0))
        {
            passwdData.passwdChg = 0;
        }
    }

    if ( ModifyUserDb(_uid, _pid, UserPrivilege_ADMIN, _cid, _page, _pcnd,
                      (unsigned int *)p_tmpPasswdExp,
                      NULL, NULL, NULL,_tmout, calea_p,
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) != 1)
    {
        tc_error_response(handle, ctag, TE_EANS,
                          " Unable to Modify User Security");
        return eosl_false;
    }

    /* Update password history only if password was reset and after new password is saved (above) */
    if (_pid != NULL)
    {
        if (updateUserPasswordHistory(&passwdData, currentEncryptPasswd) == FAIL)
        {
            procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_LISECU_req","Unable to update password history.\n");
        }
    }

    /* Synchronize active sessions for this user with user account updates
     * (note: for select attributes only - certain attribute updates require
     *  the user to log out and back in again to pick up the change).
     */
    synchActiveSessions(_uid);
    resetIdleTimeoutHandle(handle);

    return tc_compld_comment( handle, ctag, "ED-USER-LISECU" );
}

/**
 * Edit a user's privileges or password or id. Only an
 * administrator may do this. Some NEs allow other parameters
 * like a time that a password lasts for to be specified in
 * parameters that follow the user privilege value. The AID
 * block contains the user identifier.
 *
 * Defined in TR-835
 */
eosl_bool agc_EM_NE_ED_USER_SECU_req( const char * modifier,\
                                      eosl_handle handle,\
                                      TL1_TAG ctag ,\
                                      char * _uid,\
                                      char * _pid,\
                                      char * _cid,\
                                      UserPrivilege_ENUM * _uap,\
                                      int * _page,\
                                      int * _pcnd,\
                                      int * _tmout,\
                                      BoolYN_ENUM * _calea,\
                                      BoolYN_ENUM * _freezable,\
                                      int * _maxSes,\
                                      int * _actTmout,\
                                      PrimaryStateIn_ENUM * _pst)
{

    time_t todaysDate;
    unsigned int tmpPasswdExp;
    unsigned int *p_tmpPasswdExp = NULL;
    USER_DATA_t * userDataPtr    = NULL;
    int freezeInh;
    int *freezeInh_p = NULL;
    int calea;
    int *calea_p     = NULL;
    int userState;
    char     errorMsg[256];
    char currentEncryptPasswd[MAX_ENCRYPTED_PASSWORD_SIZE+1];
    PASSWORD_HISTORY_t passwdData;
#if 0    
    char secMsg[MAX_USER_NAME_SIZE + 64];
#endif    
    const char  *userName = tc_session_get_username(handle);
    int  lastAct = time(NULL);

    const char *admin = tc_session_get_username(handle);
    char usrStateOld[USR_PST_LEN+USR_SST_LEN];
    char usrStateNew[USR_PST_LEN+USR_SST_LEN];
    char sstOld[USR_SST_LEN];
    char sstNew[USR_SST_LEN];
    char secMsg[MAX_SEC_BUF_SIZE];
    eosl_bool userStateChgIs  = eosl_false;
    eosl_bool userStateChgOos = eosl_false;

    memset(currentEncryptPasswd, 0, MAX_ENCRYPTED_PASSWORD_SIZE+1);

    if (userName == NULL)
    {
        tc_error_response(handle,ctag,TE_EANS,"Unable to obtain username associated with this session");
        return eosl_false;
    }

    if (etsiLiValidate(handle, _uid) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
        return eosl_false;
    }
    
    if (_pid != NULL)
    {
        /* If the password history can not be retrieved */
        if (getUserPasswordHistory(_uid, &passwdData) == FAIL)
        {
            procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_SECU_req","Unable to read password history.\n");
            tc_error_response(handle,ctag,TE_EANS, "Error reading password history.");
            return eosl_false;
        }

        /* If the account attributes can not be retrieved */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS, "Failed to obtain user account data.");
            return eosl_false;
        }

#ifdef ATCA 
        /* FID 16687.1 */
        if (userDataPtr->authType == AUTH_TYPE_REMOTE)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Password can not be changed for a REMOTE user.\n");
            tc_error_response(handle, ctag, TE_EANS, "Password can not be changed for a REMOTE user.");
            eosl_free(userDataPtr);
            return eosl_false;

        }
#endif

        /* Save off the current password in encrypted form */
        strcpy(currentEncryptPasswd, userDataPtr->password);
        
        /* Get the current state of this account */
        userState = getUserState(userDataPtr);
        
        eosl_free(userDataPtr);
        userDataPtr = NULL;

        /* Design Note: Need to test for immediate password reuse case separately
         *     instead of within function IsPasswordValid for ADMIN password reset
         *     case (this case).  This is because, unlike the user password
         *     change via ED-PID, the current password in clear text is not
         *     available for ADMIN password reset via ED-USER-SECU. For this
         *     reason, the test below compares the current and new password is
         *     encrypted form, whereas the test in function IsPasswordValid
         *     compares the current and new password in clear text form.
         */

        /* Prevent immediate password reuse if password reuse checks are enabled */
        if ((strcmp(TL1Crypt(_pid), currentEncryptPasswd) == 0) && (getMemPasswdMaxReuse() > 0))
        {
            tc_error_response(handle,ctag, TE_PIUI, "Password error: Cannot reuse previous password");
            return eosl_false;
        }

        /* If the password is invalid based on the password complexity level */
        if ( IsPasswordValid(getMemPasswdComplx(),
                             _uid,
                             _pid,
                             NULL,  /* ADMIN PW reset - prev PW N/A */
                             &passwdData,
                             getMemPasswdMaxReuse(),
                             errorMsg)  == eosl_false )
        {
            tc_error_response(handle,ctag, TE_PIUI, errorMsg);
            return  eosl_false;
            /* send event */
        }
    }

    if (_page != NULL )
    {
#ifdef ATCA
        /* Get account attributes */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS, "Failed to obtain user account data.");
            return eosl_false;
        }

        /* FID 16687.1 */
        if ((userDataPtr->authType == AUTH_TYPE_REMOTE) && (*_page != 0))
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Page can not be changed for a REMOTE user.\n");
            tc_error_response(handle, ctag, TE_EANS, "Page can not be changed for a REMOTE user.");
            eosl_free(userDataPtr);
            return eosl_false;

        }

        eosl_free(userDataPtr);
        userDataPtr = NULL;
#endif

        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
    }

    if (_pcnd != NULL)
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
    }

    if (_tmout != NULL)
    {
        if ((*_tmout < 0) || (*_tmout > 99))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmout");
            return eosl_false;
        }
    }

    if ((_cid != NULL) && (strlen(_cid) > MAX_CID_SIZE))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid cid" );
        return eosl_false;
    }

    if (_calea)
    {
        calea = (*_calea == BoolYN_Y) ? 1 : 0;
        calea_p = &calea;
    }

    if (_freezable)
    {
        /* Design Note: The attribute "Freeze inhibit" is stored in the GoAhead database,
         *     which requires the input value _freezable to be inverted.
         */
        freezeInh = (*_freezable == BoolYN_Y) ? 0 : 1;
        freezeInh_p = &freezeInh;
    }

    if (_maxSes)
    {
        if ((*_maxSes < TL1_MIN_SESSIONS_PER_USER) || (*_maxSes > TL1_MAX_SESSIONS_PER_USER))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid maxSes");
            return eosl_false;
        }
    }

    if (_actTmout != NULL)
    {
        if (*_actTmout < 0 || *_actTmout > 99)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid user activity timeout");
            return eosl_false;
        }
    }

    /* If deactivating/reactivating account */
    if (_pst)
    {
        /* Get account attributes */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS, "Failed to obtain user account data.");
            return eosl_false;
        }

        /* Get the current state of this account */
        userState = getUserState(userDataPtr);

        /* Format the current state of the user account */
        formatUserState(getUserState(userDataPtr), usrStateOld, sstOld);
        if (strlen(sstOld))
        {
            strcat(usrStateOld, ",");
            strcat(usrStateOld, sstOld);
        }

        /* If reactivating account */
        if (*_pst == PrimaryStateIn_IS)
        {
            /* If the user account is currently OOS */
            if ((userState & USR_SVC_BIT) == 0)
            {
                userStateChgIs = eosl_true;
                
                /* Design Note: Factory default user accounts exempt from having
                 *     to change password when reactivated.
                 */
                /* If new password not supplied and not a factory default account */
                if ((!_pid) && (!isFactoryDefaultUserAccount(userDataPtr)))
                {
#ifdef ATCA
                    /* FID 16687.1 */
                    if (userDataPtr->authType == AUTH_TYPE_LOCAL)
                    {
#endif
                    tc_error_response(handle,ctag,TE_PIUI,
                                      "Password must be specified when administratively placing an account In-Service.");
                    eosl_free(userDataPtr);
                    return eosl_false;
#ifdef ATCA
                    }
#endif
                }
                
                /* If account reactivation failed */
                if ((reactivateUser(handle, userDataPtr)) == eosl_false)
                {
                    procLogMsg (PLOG_ERROR,
                                "agc_EM_NE_ED_USER_SECU_req",
                                "Failed to reactivate ADMIN account.\n");
                    tc_error_response(handle, ctag, TE_EANS,
                                      "Failed to administratively place account In-Service");
                    eosl_free(userDataPtr);
                    return eosl_false;
                }
            }
        }
        else /* Deactivating account */
        {
            userStateChgOos = eosl_true;
            
            /* If the user account is not currently managed OOS */
            if ((userState & USR_MNG_BIT) == 0)
            {
                /* If ADMIN is attempting to place own account OOS */
                if (eosl_strcmp(userName, _uid) == 0)
                {
                    procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_SECU_req", "Can not deactivate own account.\n");
                    tc_error_response(handle, ctag, TE_EANS,
                                      "ADMIN can not place own account administratively Out-Of-Service");
                    eosl_free(userDataPtr);
                    return eosl_false;
                }
                else
                {
                    if ((deactivateUser(handle, userDataPtr)) == eosl_false)
                    {
                        procLogMsg (PLOG_ERROR,
                                    "agc_EM_NE_ED_USER_SECU_req",
                                    "Failed to deactivate ADMIN account.\n");
                        tc_error_response(handle, ctag, TE_EANS,
                                          "Failed to administratively place account Out-Of-Service");
                        eosl_free(userDataPtr);
                        return eosl_false;
                    }
                }
            }
        }
        eosl_free(userDataPtr);
    }

    /* Commit password updates only after entire command is validated */
    if (_pid != NULL)
    {
        todaysDate     = time(NULL);
        todaysDate     = normalizeDate(todaysDate); 
        tmpPasswdExp   = (int)todaysDate;
        p_tmpPasswdExp = &tmpPasswdExp;
        passwdData.passwdChg = (unsigned int)todaysDate;

        if (ModifyUserDb(_uid, NULL, NULL, NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL, &lastAct, NULL) != 1)
        {
            tc_error_response(handle, ctag, TE_EANS," Unable to Modify User Security.");
            return eosl_false;
        }

        /* In the follow two scenarios user state change to IS,EXP&GRC&TMP:
         * 1) when PST=IS is explicitly set and PW changed
         * 2) when PST is already IS and PW changed
         * 3) when current state OOS-AU,EXP and PW changed. */

        if ((_pst && *_pst == PrimaryStateIn_IS) ||
            ((userState & USR_SVC_BIT) != 0 && !_pst) ||
            ((userState & USR_SVC_BIT) == 0 && (userState & USR_MNG_BIT) == 0 && (userState & USR_EXP_BIT) != 0))
        {
            passwdData.passwdChg = 0;
        }
    }

    if ( ModifyUserDb(_uid, _pid, _uap, "NULL", _page, _pcnd, (unsigned int *)p_tmpPasswdExp,
                      NULL, NULL, NULL,_tmout, calea_p, freezeInh_p, NULL, NULL, _maxSes, NULL, _actTmout, NULL, NULL) != 1)
    {
        tc_error_response(handle, ctag, TE_EANS," Unable to Modify User Security");
        return eosl_false;
    }

    /* Update password history only if password was reset and after new password is saved (above) */
    if (_pid != NULL)
    {
        /* Log the password reset event to the security log */
        sprintf(secMsg, " Password reset for user [%s] ", _uid);
        AddSecEvent(handle, PASSWORD_RESET, (char *)userName, secMsg);

        if (updateUserPasswordHistory(&passwdData, currentEncryptPasswd) == FAIL)
        {
            procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_USER_SECU_req","Unable to update password history.\n");
        }
    }

    if (userStateChgIs || userStateChgOos)
    {
        /* Get account attributes */
        if ((userDataPtr = GetUserDataFromDb(_uid)) == NULL)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_ED_USER_SECU_req",
                        "Failed to obtain user account data.\n");
            tc_error_response(handle, ctag, TE_EANS, "Failed to obtain user account data.");
            return eosl_false;
        }
        
        /* Format the current state of the user account */
        formatUserState(getUserState(userDataPtr), usrStateNew, sstNew);
        if (strlen(sstNew))
        {
            strcat(usrStateNew, ",");
            strcat(usrStateNew, sstNew);
        }

        /* log the event to the security log */
        if (userStateChgIs)
        {
            sprintf(secMsg,
                    "User account [%s] administratively placed In-Service by "
                    "ADMIN user %s.  Current state: [%s] Previous state: [%s]",
                    userDataPtr->username, admin, usrStateNew, usrStateOld);
        }
        else
        {
            sprintf(secMsg,
                    "User account [%s] administratively placed  Out-Of-Service by "
                    "ADMIN user %s.  Current state: [%s] Previous state: [%s]",
                    userDataPtr->username, admin, usrStateNew, usrStateOld);
        }
        
        AddSecEvent(handle, ADMIN_SET_IS, (char *)admin, secMsg);
        eosl_free(userDataPtr);
    }
 
    /* Synchronize active sessions for this user with user account updates
     * (note: for select attributes only - certain attribute updates require
     *  the user to log out and back in again to pick up the change).
     */
    synchActiveSessions(_uid);
    resetIdleTimeoutHandle(handle);

    return tc_compld_comment( handle, ctag, "ED-USER-SECU" );
}


/**
 */
eosl_bool agc_EM_NE_ED_TESTPORT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, char * _iom, TestPortMonitor_ENUM _tpMonitor, PrimaryStateIn_ENUM * _pst)
{
    
    BITS_CMD_BUF_t      buffer;

    /*
    ** prepare tp data structure
    */

    memset(&buffer, 0, SIZEOF_BITSCMD_TEST_PORT_EDIT);

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }
 
    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _iom, AID_IOM,
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }

    buffer.Data.TpEdit.Mode.value = _tpMonitor;
    buffer.Data.TpEdit.Mode.valid = VALID_VALUE;


    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.TpEdit.State.value |= PST_IS_BIT;
            buffer.Data.TpEdit.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.TpEdit.State.value |= PST_OOS_BIT;
            buffer.Data.TpEdit.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIAC, "Invalid PrimaryState" );  
            return eosl_false;
        }
    }

    /* 
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  BITS_CMD_CLASS, CMD, BITSCMD_TEST_PORT_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_BITSCMD_TEST_PORT_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_TESTPORT_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error ); 
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-TESTPORT" );
}

/**
 * Edit  IPATK PARAMS
 */
eosl_bool agc_EM_NE_ED_IPATK_PARAMS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkType,\
									int _ipAtkLogPrflId)
{
   
    TL1_EMF_IPATK_DATA_t      buffer;
    SMCMD_t                   smCmd;    

    /* Prepare data structure */
    memset(&buffer, 0,sizeof(TL1_EMF_IPATK_DATA_t));
    memset(&smCmd, 0, sizeof(SMCMD_t));
    
    if (eosl_strcasecmp(_ipAtkType,"SMURF")==0)
    {
	    buffer.Data.EdParams.MonType = IPATK_SMURF;
    }
    else if (eosl_strcasecmp(_ipAtkType,"INV_TCPFLAG")==0)
    {
	    buffer.Data.EdParams.MonType = IPATK_INV_TCPFLAG;
    }
    else if (eosl_strcasecmp(_ipAtkType,"ICMP_REDIRECT")==0)
    {
	    buffer.Data.EdParams.MonType = IPATK_ICMP_REDIRECT;
    }
    else
    {
	    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;				    
    }
    if(_ipAtkLogPrflId < 1||_ipAtkLogPrflId > 32)
    {
	    tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> ipAtkPrfl" );
	    return eosl_false;
    }
    buffer.Data.EdParams.LogPrflId = _ipAtkLogPrflId;
    /*
     ** Send event
    */
    if (TL1SendMsg(handle, ctag,
                   TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
                   CMD_ED_IPATK_PARAMS,
                   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_ED_IPATK_PARAMS,
                   (TL1_CMD_BUF_t *)&smCmd, sizeof(SMCMD_t),
                   TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ED_IPATK_PARAMS_req",
                   "agc_EM_NE_ED_IPATK_PARAMS_req: bad response \n");
        TL1ErrorResp(handle, ctag, CMD_EQM, smCmd.Tl1Cmd.Error);
        return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "ED-IPATK-PARAMS" );
}

/**
 */
eosl_bool agc_EM_NE_ED_TMGREF_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, PrimarySrcType_ENUM _primarySrcType)
{
    BITS_CMD_BUF_t  buffer;
    int             tmpTmg = 0;

    /*
    ** prepare data structure
    */
    memset(&buffer, 0, SIZEOF_BITSCMD);

    if (_src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    
    switch (_primarySrcType)
    {
    case PrimarySrcType_IOM_1:  
        tmpTmg = 1;
        break;
    case PrimarySrcType_IOM_10:
        tmpTmg = 10;
        break;
    case PrimarySrcType_IOM_2:
        tmpTmg = 2;
        break;
    case PrimarySrcType_IOM_3:
        tmpTmg = 3;
        break;
    case PrimarySrcType_IOM_8:
        tmpTmg = 8;
        break;
    case PrimarySrcType_TMG_T1:
        tmpTmg = 25;
        break;
    case PrimarySrcType_TMG_E1:
        tmpTmg = 26;
        break;
    default:
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid primarySrcType" );
        return eosl_false;   
    }
    
    SetLevel1(buffer.DeviceId, tmpTmg);

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  BITS_CMD_CLASS, CMD, BITSCMD_TMGREF_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_BITSCMD,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_TMGREF_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ED-TMGREF" );
    
}

/**
 * Retrieves parameters associated with a DS entity.
 */
eosl_bool agc_EM_NE_RTRV_T1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = T1_TAB_ID;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[0];
    SMCMD_t           smCmd;
    u8                *smCmdPtr = (u8 *)&smCmd;
    short             length = sizeof(SMCMD_t);
    int               cmd = SM_GETNEXTMULTI_REQUEST;

    TL1LOGP (PLOG_ERROR, "T1 aid:%s\n", _ds_id);
    TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

    memset(&rowKey, 0, sizeof(rowKey));
    memset(&colArray, 0, sizeof(colArray));
    colArray.colArray = columns;

    if(ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7PORT, NULL) == SUCCESS)
    {
        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    
    }
    else if (ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7, NULL) == SUCCESS)
    {
        TL1LOGP (PLOG_ERROR, "shelf:%d, atcaSlot:%d, amcSlot:%d \n",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3);
      
            rowKey.numIndices = 3;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
       
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    colArray.numCols = 0;

    if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                       &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    if (emfUnpkSmiGetMultiResp(rtrvT1MultiTsmResp, &smCmdPtr, &length, handle) == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }

    return eosl_true;
#else
    DSX_CMD_BUF_t       buffer;
    DSX_ACK_BUF_t       response;
    RTRV_T1_resp_row    result[MAX_T1S_PER_T3];
    int                 i;
    int                 resultRows = 0;
    char                aidStrings[MAX_T1S_PER_T3][32];
    char                tmpPrimaryState[32];
    char                tmpPrimaryQualifier[32];
    char                primaryState[MAX_T1S_PER_T3][32];
    char                secondaryState[MAX_T1S_PER_T3][32];
    char                eqlz[MAX_T1S_PER_T3][32];
    char                *cmdClass;
    unsigned int        cmd;
    int                 tmpT1;

    /*
    ** set up t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);
    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id,
                             (AID_IOM | AID_T3 | AID_BITS | AID_PORT |
                              AID_STS1 | AID_OC3_STS1 | AID_OC3_STS1_T1|AID_AU3|AID_TUG3|AID_AU3TUG3_T1),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /* Handle wildcard DeviceMap ambiguities here */
    switch(buffer.DeviceMap)
    {
    case DEVICE_MAP_IOM_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
        break;
    case DEVICE_MAP_IOM_OC3_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
        break;
    case DEVICE_MAP_IOM_OC12_STS1:
        buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
        break;
    case DEVICE_MAP_IOM_T3:
        buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
        break;
    case DEVICE_MAP_IOM:
        buffer.DeviceMap = DEVICE_MAP_IOM_T1;
        break;
    case DEVICE_MAP_IOM_STM1_TUG3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
        break;
    case DEVICE_MAP_IOM_STM4_TUG3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
        break;
    case DEVICE_MAP_IOM_STM1_AU3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
        break;
    case DEVICE_MAP_IOM_STM4_AU3:
        buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
        break;
    }

    if ((GetLevel1(buffer.DeviceId) == AID_BITS_SLOT_MAPPING) ||
        (GetLevel1(buffer.DeviceId) == (AID_BITS_SLOT_MAPPING + 1)))
    {
        /* TBD * We should be using a BITS_CMD_BUF_t structure, not a DSX_CMD_BUF_t !!! */
        /* TBD * We should be using a BITS_ACK_BUF_t structure, not a DSX_ACK_BUF_t !!! */
        /* TBD * Size should be: SIZEOF_BITSCMD */
        cmdClass = BITS_CMD_CLASS;
        cmd = BITSCMD_PORT_RTRV;
    }
    else
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_T1;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&response, sizeof(response),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_T1_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
        return eosl_false;
    }

    /* modify our copy of device id if we are handling wildcard L3, L4 */
    if (response.Data.T1BulkRtrvResp.NumEntries != 1)
    {
        switch(response.DeviceMap)
        {
        case DEVICE_MAP_IOM_T1: /* IOM-x-PORT-z */
            SetLevel2(response.DeviceId, 1);
            break;                
        case DEVICE_MAP_IOM_STS1_T1: /* IOM-x-STS1-y-PORT-z */
        case DEVICE_MAP_IOM_T3_T1: /* IOM-x-T3-y-PORT-z */
            SetLevel3(response.DeviceId, 1);
            break;
        case DEVICE_MAP_IOM_OC3_STS1_T1: /* IOM-x-OC3-y-STS1-z-PORT-a */
        case DEVICE_MAP_IOM_OC12_STS1_T1:
        case DEVICE_MAP_IOM_STM1_TUG3_T1:
        case DEVICE_MAP_IOM_STM4_TUG3_T1:
        case DEVICE_MAP_IOM_STM1_AU3_T1:
        case DEVICE_MAP_IOM_STM4_AU3_T1:
            SetLevel4(response.DeviceId, 1);
            break;
        }
    }

    for (i = 0; i <  response.Data.T1BulkRtrvResp.NumEntries; i++)
    {
        procLogMsg (PLOG_HIGH, __FUNCTION__,
                    "Loop %d - ValidData:%d\n", i, response.Data.T1BulkRtrvResp.Data[i].ValidData);
        
        /* skip over interfaces assigned as not ValidData
         */
        if(response.Data.T1BulkRtrvResp.Data[i].ValidData)
        {
            DeviceIdMapToAid(response.DeviceId, response.DeviceMap, aidStrings[resultRows]);
            result[resultRows]._ds_id = (TL1_AID)&(aidStrings[resultRows][0]);
            sprintf(&(eqlz[resultRows][0]), "%d", response.Data.T1BulkRtrvResp.Data[i].Eqlz);
            result[resultRows]._eqlz = &(eqlz[resultRows][0]);
            result[resultRows]._fmt = (FormatSignal_ENUM)response.Data.T1BulkRtrvResp.Data[i].Fmt;
            result[resultRows]._linecde = (LineCode_ENUM)response.Data.T1BulkRtrvResp.Data[i].Linecde;
            result[resultRows]._omode = (DSMode_ENUM)response.Data.T1BulkRtrvResp.Data[i].Omode;
            result[resultRows]._tmgref = (TimingReference_ENUM)response.Data.T1BulkRtrvResp.Data[i].Tmgref;
            result[resultRows]._iftype = (Side_Network_ENUM)response.Data.T1BulkRtrvResp.Data[i].Side;

            SetStateNames(response.Data.T1BulkRtrvResp.Data[i].State,
                          response.Data.T1BulkRtrvResp.Data[i].State2,
                          tmpPrimaryState,
                          tmpPrimaryQualifier,
                          &(secondaryState[resultRows][0]));
            if (strlen(tmpPrimaryQualifier) > 0)
            {
                sprintf(&(primaryState[resultRows][0]), "%s-%s", tmpPrimaryState, tmpPrimaryQualifier);
            }
            else
            {
                strcpy(&(primaryState[resultRows][0]), tmpPrimaryState);
            }

            result[resultRows]._pst = &(primaryState[resultRows][0]);
            if (strlen(secondaryState[resultRows]) > 0)
            {
                result[resultRows]._sst = &(secondaryState[resultRows][0]);
            }
            else
            {
                result[resultRows]._sst = NULL;
            }

            resultRows++;
        }

        switch(response.DeviceMap)
        {
        case DEVICE_MAP_IOM_T1: /* IOM-x-PORT-z */
            tmpT1 = GetLevel2(response.DeviceId);
            SetLevel2(response.DeviceId, (tmpT1 + 1)); /* for next T1 */
            break;
        case DEVICE_MAP_IOM_STS1_T1: /* IOM-x-STS1-y-PORT-z */
        case DEVICE_MAP_IOM_T3_T1: /* IOM-x-T3-y-PORT-z */
            tmpT1 = GetLevel3(response.DeviceId);
            SetLevel3(response.DeviceId, (tmpT1 + 1)); /* for next T1 */
            break;
        case DEVICE_MAP_IOM_OC3_STS1_T1: /* IOM-x-OC3-y-STS1-z-PORT-a */
        case DEVICE_MAP_IOM_OC12_STS1_T1:
        case DEVICE_MAP_IOM_STM1_TUG3_T1:
        case DEVICE_MAP_IOM_STM4_TUG3_T1:
        case DEVICE_MAP_IOM_STM1_AU3_T1:
        case DEVICE_MAP_IOM_STM4_AU3_T1:
            tmpT1 = GetLevel4(response.DeviceId);
            SetLevel4(response.DeviceId, (tmpT1 + 1)); /* for next T1 */
            break;
        }
    }


    return agc_EM_NE_RTRV_T1_resp( modifier,
                                   handle,
                                   ctag,
                                   TCC_COMPLD,
                                   result,
                                   resultRows,
                                   "RTRV-T1",
                                   NULL);
#endif
}


/**
 * Use the RTRV-ALM  commands to generate a report on the
 * current state of alarm conditions within the Network
 * Element (NE). (The RTRV-COND command generates a
 * report on both alarms and conditions.)
 *
 * Essential to NMA. GR-833.
 */
eosl_bool agc_EM_NE_RTRV_ALM_AIDType_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _alm_id, NotificationCode_ENUM * _ntfcncde, char * _condtype, ServiceEffect_ENUM * _srveff, char * _ocrdat, char * _ocrtm, char * _desc)
{

    NotificationCode_ENUM ntCode = NotificationCode_ALL;
    
    FAMCMD_t    famCmd;
    TL1_ALARMRSP_t  tl1AlmRsp;
    eosl_bool  status;
    char comment[16];

    famCmd.Tl1Cmd.Cmd = FAMCMD_RTRV_ALM;
    famCmd.Tl1Cmd.SessionHandle = handle;
    famCmd.Tl1Cmd.CTag =ctag; 
    famCmd.Data.RtrvAlm.AidType=enum_lookup_no_case( &AIDType_ENUM_type,modifier);
    

    if (CheckMultiRespMode( famCmd.Tl1Cmd.Cmd,handle,ctag)==MULTI_RESP_MODE_ON )
    {
        tc_error_response( handle, ctag,TE_SRCI,"Busy responding to previous RTRV-ALM-{ReptAid} message");
    }   
    
    if (_alm_id )
    {
        if (eosl_strcasecmp(_alm_id, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
            return eosl_false;
        }
    }

    if(_ntfcncde)
    {
        ntCode= *_ntfcncde;
    }
    famCmd.Data.RtrvAlm.AlmType = ntCode;

    if(_condtype)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> condtype" );
        return eosl_false;
    }
    
    if(_srveff)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> srveff " );
        return eosl_false;
    }
    
    if(_ocrdat)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> ocrdat" );
        return eosl_false;
    }
    
    if(_ocrtm)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> ocrtm" );
        return eosl_false;
    }
    
    if(_desc)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> desc" );
        return eosl_false;
    }    


    if(TL1SendMsg(handle, ctag,
                  FAM_CMD_CLASS, CMD, FAMCMD_RTRV_ALM,
                  (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                  (TL1_CMD_BUF_t *)&tl1AlmRsp, sizeof(tl1AlmRsp),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_FAM, tl1AlmRsp.tl1FamResp.Tl1Cmd.Error );
        return eosl_false;
    }    

    status=RtrvAlmResp ((FAMRSP_t *)&tl1AlmRsp);

    
    if (status == eosl_false)
    {
        sprintf(comment,"RTRV-ALM-%s Failed",modifier);
        tc_error_response(handle,ctag,TE_SDNR,comment);
    }   
    return status;
}


/**
 * Retrieve  ATCA INFOEQPT
 */
eosl_bool agc_EM_NE_RTRV_ATCA_INFOEQPT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _ioModule)
{
#ifdef ATCA    
    AID_INFO_TYPE_t             aidInfo;
    TL1_BUF_t                   cmdMsg;
    int                         slotCount;
    int                         retVal;
    CMD_BUF_t                   respBuff;

    memset(&cmdMsg, 0, sizeof(TL1_BUF_t));
    
    cmdMsg.Buf.Cmd = EQMCMD_RTRV_ATCA_INFOEQPT;
    cmdMsg.Buf.SessionHandle = handle;
    cmdMsg.Buf.CTag =ctag;
    
    if (_ioModule)
    {
        if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdMsg.CmdInfo.AtcaSlot.shelfId  = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
        cmdMsg.CmdInfo.AtcaSlot.amcSlot  = aidInfo.lvl3;
    }
    else        /* No AID given -- default to ALL. */
    {
        slotCount = NUM_IOMS;
        cmdMsg.CmdInfo.AtcaSlot.shelfId  = ALL_SHELFS;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = ALL_SLOTS;
    }

    procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_ATCA_INFOEQPT_req", "shelfId = %d, slot = %d,amcslot:%d\n",cmdMsg.CmdInfo.AtcaSlot.shelfId, cmdMsg.CmdInfo.AtcaSlot.atcaSlot,cmdMsg.CmdInfo.AtcaSlot.amcSlot);

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_ATCA_INFOEQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ATCA_INFOEQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    /*
     ** send tl1 response
     */
    retVal = rtrvAtcaInfoEqptResp(&respBuff);
    if (retVal == eosl_false)
    {
        tc_error_response(handle, ctag, TE_SDNR,"RTRV-ATCA-EQPT" );
    }

    return retVal;
#else /* #ifdef ATCA */
    return eosl_true;
#endif    
}

/**
 * Instructs an NE to retrieve the current attributes for an
 * existing log. It may be used to review these attributes
 * prior to making changes with the SET ATTR LOG command.
 * These attributes govern what kinds, how long, and how many
 * messages are logged.
 */
eosl_bool agc_EM_NE_RTRV_ATTR_LOG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _log_id, LogName_ENUM * _lognm)
{
    RTRV_ATTR_LOG_resp_row result[7];
    FAMRSP_t respBuff;
    FAMCMD_t  famCmd;
    int count=0;
    int logSize;
    int msgLogSize;
    int secLogSize;
    int aoLogSize;
    int bulkLogSize;
#ifdef ATCA /* FID 15827.0 */
    int cpuRsrcLogSize;
#endif /* ATCA */
#ifndef ATCA
    TL1_BUF_t    cmdMsg;
    CMD_BUF_t    respBuf;
#endif

	/*   int callcaptLogSize;*/

    famCmd.Tl1Cmd.Cmd = FAMCMD_RTRV_ATTR_LOG;
    famCmd.Tl1Cmd.SessionHandle = handle;
    famCmd.Tl1Cmd.CTag =ctag;
    famCmd.Data.RtrvLog.LogType = SYS_LOG;

#ifndef ATCA
    cmdMsg.Buf.Cmd           = EQMCMD_RTRV_ATTR_LOG;
    cmdMsg.Buf.SessionHandle = handle;
    cmdMsg.Buf.CTag          = ctag;
#endif

    if (_log_id)
    {
        if(eosl_strcasecmp(_log_id, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    if(_lognm)
    {
        switch (*_lognm)
        {
        case (LogName_SYSLOGS):
            if(TL1SendMsg(handle, ctag,
                  FAM_CMD_CLASS, CMD, FAMCMD_RTRV_ATTR_LOG,
                  (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

            {
                TL1ErrorResp( handle, ctag, CMD_FAM, respBuff.Tl1Cmd.Error );
                return eosl_false;
            }
            result[count]._log_id = "COM";
            result[count]._lognm =*_lognm;
            result[count]._maxmsg =&(respBuff.Data.RtrvAttrLog.LogSize);
            count++;
            break;

        case LogName_MESSAGELOGS:
            result[count]._log_id = "COM";
            result[count]._lognm =*_lognm;
            logSize= getMaxMsgLogSize();
            result[count]._maxmsg=&logSize;
            count++;
            break;

        case (LogName_AOLOGS):
            result[count]._log_id = "COM";
            result[count]._lognm =*_lognm; ;
            logSize=getMaxAoLogSize();
            result[count]._maxmsg=&logSize;
            count++;
            break;

        case (LogName_SECURITYLOGS):
            result[count]._log_id = "COM";
            result[count]._lognm =*_lognm;
            logSize=getMaxSecLogSize();
            result[count]._maxmsg=&logSize;
            count++;
            break;

#ifndef ATCA
        case (LogName_OSSECURITYLOGS):
            if(TL1SendMsg(handle, ctag,
                EQM_CMD_CLASS, CMD, EQMCMD_RTRV_ATTR_LOG,
                (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_ATTRLOG,
                (TL1_CMD_BUF_t *)&respBuf, sizeof(respBuf),
                TL1_MSG_TIMEOUT) == FAIL)
           {
                TL1ErrorResp( handle, ctag, CMD_FAM, respBuf.Buf.Error );
                return eosl_false;
           }
           result[count]._log_id = "COM";
           result[count]._lognm = *_lognm;
           result[count]._maxmsg = &(respBuf.CmdInfo.RtrvAttrLog.MaxMsg);
           count++;
           break;
#endif

        case (LogName_PATCHLOGS):
            tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported");
            return eosl_false;
            break;

        case (LogName_BULKLOGS):
            result[count]._log_id = "COM";
            result[count]._lognm =*_lognm;
            logSize=getMaxBulkLogSize();
            result[count]._maxmsg=&logSize;
            count++;
            break;
#if 0
        case (LogName_CALLCAPTLOGS):
            result[count]._lognm =*_lognm;
            logSize= getMaxCallcaptLogSize();
            result[count]._maxmsg=&logSize;
            count++;
            break;
#endif

#ifdef ATCA /* FID 15827.0 */
        case LogName_CPURSRC:
            result[count]._log_id = "COM";
            result[count]._lognm = *_lognm;
            logSize = getMaxCpuRsrcLogSize();
            result[count]._maxmsg = &logSize;
            count++;
            break;
#endif /* ATCA */

        default:
            tc_error_response( handle, ctag, TE_SROF, "Invalid Log Type" );
            return eosl_false;
        }
    }
    else
    {
        /* Retrieve ATTRs for  all Logs */
        if(TL1SendMsg(handle, ctag,
                  FAM_CMD_CLASS, CMD, FAMCMD_RTRV_ATTR_LOG,
                  (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

        {
            TL1ErrorResp( handle, ctag, CMD_FAM, respBuff.Tl1Cmd.Error );
            return eosl_false;
        }
        result[count]._log_id = "COM";
        result[count]._lognm =LogName_SYSLOGS;
        result[count]._maxmsg =&(respBuff.Data.RtrvAttrLog.LogSize);
        count++;

#ifndef ATCA
        if(TL1SendMsg(handle, ctag,
                EQM_CMD_CLASS, CMD, EQMCMD_RTRV_ATTR_LOG,
                (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_ATTRLOG,
                (TL1_CMD_BUF_t *)&respBuf, sizeof(respBuf),
                TL1_MSG_TIMEOUT) == FAIL)
        {
               TL1ErrorResp( handle, ctag, CMD_EQM, respBuf.Buf.Error );
               return eosl_false;
        }
        result[count]._log_id = "COM";
        result[count]._lognm = LogName_OSSECURITYLOGS;
        result[count]._maxmsg = &(respBuf.CmdInfo.RtrvAttrLog.MaxMsg);
        count++;
#endif

        result[count]._log_id = "COM";
        result[count]._lognm =LogName_MESSAGELOGS;
        msgLogSize= getMaxMsgLogSize();
        result[count]._maxmsg=&msgLogSize;
        count++;

        result[count]._log_id = "COM";
        result[count]._lognm =LogName_AOLOGS ;
        aoLogSize=getMaxAoLogSize();
        result[count]._maxmsg=&aoLogSize;
        count++;

        result[count]._log_id = "COM";
        result[count]._lognm =LogName_SECURITYLOGS;
        secLogSize=getMaxSecLogSize();
        result[count]._maxmsg=&secLogSize;
        count++;

        result[count]._log_id = "COM";
        result[count]._lognm =LogName_BULKLOGS;
        bulkLogSize=getMaxBulkLogSize();
        result[count]._maxmsg=&bulkLogSize;
        count++;

#if 0
        result[count]._lognm =LogName_CALLCAPTLOGS;
        callcaptLogSize= getMaxCallcaptLogSize();
        result[count]._maxmsg=&callcaptLogSize;
        count++;
#endif

#ifdef ATCA /* FID 15827.0 */
        result[count]._log_id = "COM";
        result[count]._lognm = LogName_CPURSRC;
        cpuRsrcLogSize = getMaxCpuRsrcLogSize();
        result[count]._maxmsg = &cpuRsrcLogSize;
        count++;
#endif /* ATCA */

    }

    return agc_EM_NE_RTRV_ATTR_LOG_resp( modifier,handle, ctag,TCC_COMPLD,
                                         result,count, "RTRV-ATTR-LOG", NULL );

}

/**
 * Edit  PRFL IPATKLOG
 */
eosl_bool agc_EM_NE_ED_PRFL_IPATKLOG_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkLogPrflId,\
									int * _atkLogInterval,\
									int * _maxPktStreams)
{
    TL1_EMF_IPATK_DATA_t      buffer;	
    SMCMD_t                   smCmd;

    /* Prepare data structure */
    memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
    memset(&smCmd, 0, sizeof(SMCMD_t));
    if(_ipAtkLogPrflId)
    {
	if(!(IsInputStrInRange(_ipAtkLogPrflId,"0123456789"))) 
	{
		tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid ipAtkLogPrflId");
		return eosl_false;
	}	
	buffer.Data.EdPrfl.LogPrflId = atoi(_ipAtkLogPrflId); 
        if((buffer.Data.EdPrfl.LogPrflId < 1)||(buffer.Data.EdPrfl.LogPrflId > 32) )
        {
	        tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> ipAtkLogPrflId");
	        return eosl_false;
        }
    }
    if(_atkLogInterval)
    {
	    if((*_atkLogInterval > 60)||(*_atkLogInterval < 10 ))
	    {
		    tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> atkLogInterval");
		    return eosl_false;
		    
	    }
	    buffer.Data.EdPrfl.LogInterval = *_atkLogInterval;
    }
    else
    {
	    buffer.Data.EdPrfl.LogInterval = -1;
    }
    
    if(_maxPktStreams)
    {
	     if ((*_maxPktStreams < 0)||*_maxPktStreams > 50)
	     {
		     tc_error_response( handle, ctag, TE_IIDT, "Invalid Data Range -> maxPktStreams");
		     return eosl_false;
	     }
	     buffer.Data.EdPrfl.MaxPackets = *_maxPktStreams;
    }
    else
    {
	    buffer.Data.EdPrfl.MaxPackets = -1;
    }
    
    /*
    ** Send event
    */
    if (TL1SendMsg(handle, ctag,
	           TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		   CMD_ED_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_ED_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&smCmd, sizeof(SMCMD_t),
		   TL1_MSG_TIMEOUT) == FAIL)
    {
	    procLogMsg(PLOG_ERROR,
			    "agc_EM_NE_ED_PRFL_IPATKLOG_req",
			    "agc_EM_NE_ED_PRFL_IPATKLOG_req: bad response \n");
	    TL1ErrorResp(handle, ctag, CMD_EQM, smCmd.Tl1Cmd.Error);
	    return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "ED-PRFL-IPATKLOG" );
}

/**
 */
eosl_bool agc_EM_NE_RTRV_CALL_CAPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _trcId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;

    length = sizeof(SMCMD_t);

    tableId = CALLTRC_CRIT_TABLE_ID;
    transId = ctag;
    colArray.numCols  = 0;

    if(_trcId)
    {
        /*validate AID to permit only numbers within*/
        if(!(IsInputStrInRange(_trcId,"0123456789")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        rowKey.numIndices =1;
        rowKey.rowIndex[0].colType =TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal =atoi(_trcId);
    }
    else
    {
        rowKey.numIndices =0;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvCallCaptMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

eosl_bool agc_EM_NE_RTRV_CALL_CAPTVERBOSE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _trcId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;

    length = sizeof(SMCMD_t);

    tableId = CALLCAPTV_CRIT_TABLE_ID;
    transId = ctag;
    colArray.numCols  = 0;

    if(_trcId)
    {
        /*validate AID to permit only numbers within*/
        if(!(IsInputStrInRange(_trcId,"0123456789")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        rowKey.numIndices =1;
        rowKey.rowIndex[0].colType =TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal =atoi(_trcId);
    }
    else
    {
        rowKey.numIndices =0;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvCallCaptVerboseMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}





/**
 */
eosl_bool agc_EM_NE_RTRV_INFO_CHASSIS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _com)
{
    RTRV_INFO_CHASSIS_resp_row  result;
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;


 
    if(_com)
    {
        if(eosl_strcasecmp(_com, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_INFO_CHASSIS,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_INFO_CHASSIS,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    result._com = "COM";
#ifndef ATCA
    result._hwVersion = respBuff.CmdInfo.RtrvInfoChassis.HWVersion;
    result._clei = respBuff.CmdInfo.RtrvInfoChassis.CLEI;
#else
    result._hwVersion = "NULL";
    result._clei = "NULL";
#endif
    if (respBuff.CmdInfo.RtrvInfoChassis.SerialNum[0] == 0)
    {
        result._serialNumber = "NULL";
    }
    else
    {
        result._serialNumber = respBuff.CmdInfo.RtrvInfoChassis.SerialNum;
    }
    result._neType = NEType_ISDNSWITCH;
    result._slotCount = respBuff.CmdInfo.RtrvInfoChassis.SlotCount;
    result._criticalFaults = respBuff.CmdInfo.RtrvInfoChassis.Critical;
    result._majorFaults = respBuff.CmdInfo.RtrvInfoChassis.Major;
    result._minorFaults = respBuff.CmdInfo.RtrvInfoChassis.Minor;
#ifndef ATCA
    if (respBuff.CmdInfo.RtrvInfoChassis.TempFault)
    {
        result._tempFault = OkayFail_FAIL;
    }
    else
    {
        result._tempFault = OkayFail_OKAY;
    }
#else
    result._tempFault = OkayFail_NULL;
#endif
    result._tempFaultCount = respBuff.CmdInfo.RtrvInfoChassis.TempFaultCount;

#ifndef ATCA
    if (respBuff.CmdInfo.RtrvInfoChassis.PowerAGood)
    {
        result._powerA = OkayFail_OKAY;
    }
    else
    {
        result._powerA = OkayFail_FAIL;
    }
    if (respBuff.CmdInfo.RtrvInfoChassis.PowerBGood)
    {
        result._powerB = OkayFail_OKAY;
    }
    else
    {
        result._powerB = OkayFail_FAIL;
    }
#else
    result._powerA = OkayFail_NULL;
    result._powerB = OkayFail_NULL;
#endif

    result._dbSchemaVersion = CURRENT_SCHEMA_VERSION;

    /*
    ** Clear response buffer pointer
    */

    return agc_EM_NE_RTRV_INFO_CHASSIS_resp( modifier, handle, ctag, TCC_COMPLD,
                                             &result, 1, "RTRV-INFO-CHASSIS", NULL);
}


/**
 */
eosl_bool agc_EM_NE_RTRV_ATTR_SECULOG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, int * _wrnLn)
{
    RTRV_ATTR_SECULOG_resp_row resultTL1[USER_BANNER_MAXLIN];
#ifndef ATCA
    RTRV_ATTR_SECULOG_resp_row resultOS[USER_BANNER_MAXLIN];
    eosl_bool   found = eosl_false;
    FILE        *fp;
    char        lines[USER_BANNER_MAXLIN][USER_BANNER_MAXLINLEN + 1];
#endif
    int         j;
    eosl_bool   result;
    int         numWrnTx = -1;
    int         wrnIndex = 0;
    DB_RW_HDR_t *p_dbReadBuf;

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ) &&
        (eosl_strcasecmp(_src, "TL1") !=0 ) && (eosl_strcasecmp(_src, "OS") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#ifdef ATCA
    if (_src == NULL)
    {
        _src = "TL1";
    }
    
    if (eosl_strcasecmp(_src, "OS") == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
#endif    

#ifndef ATCA
    if (_src == NULL)
    {
        _src = "COM";
    }
#endif

    if ((numWrnTx = tl1DbGetNumRows(TL1_WRNTX_TABLE_NAME)) < 0)
    {
        tc_error_response(handle, ctag, TE_SDBE,
                          "Error reading TL1WrnTx table");
        return eosl_false;
    }
    else if (numWrnTx == 0)
    {
        return tc_compld_comment( handle, ctag, "RTRV-ATTR-SECULOG" );
    }

    if(_wrnLn)
    {
        if ((*_wrnLn < 1) || (*_wrnLn > USER_BANNER_MAXLIN) ||
            (*_wrnLn > numWrnTx))
        {
            tc_error_response(handle, ctag, TE_IIDT,
                              "Invalid warning message line number");
            return eosl_false;
        }
        if (*_wrnLn)
        {
            wrnIndex = *_wrnLn - 1;
            numWrnTx = 1;
        }
    }
    else
    {
        wrnIndex = 0;
    }
    
    if (eosl_strcasecmp(_src, "TL1") == 0 || eosl_strcasecmp(_src, "COM") == 0)
    {
        TL1_COMPLETION_CODE   cmpCode = TCC_RTRV;
        memset(&resultTL1, 0, sizeof(resultTL1));
        /* Create/initialize request/response object */
        if ((p_dbReadBuf = createDbReadWrnTx()) == NULL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_RTRV_ATTR_SECULOG_req",
                       "agc_EM_NE_RTRV_ATTR_SECULOG_req: Unable to malloc DB read buffer\n");
            return FAIL;
        }

        p_dbReadBuf->StartRow = wrnIndex;
        p_dbReadBuf->NumRows = numWrnTx;

        if (sendDbReadRequest(p_dbReadBuf, DB_READ_ROW)  == FAIL)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_RTRV_ATTR_SECULOG_req",
                       "RTRV_ATTR_SECULOG Unable to read Warning Message table from TL1 database\n");
            return eosl_false;
        }

        for (j = 0; j < p_dbReadBuf->NumRows; j++)
        {
            if (DbGetColStr(p_dbReadBuf, wrnIndex + j, TL1_DB_WRNTX_COL,
                            &TELICA_USER_BANNER[wrnIndex + j][0]) == FAIL)
            {
                procLogMsg(PLOG_ERROR, "agc_EM_NE_RTRV_ATTR_SECULOG_req",
                           "RTRV_ATTR_SECULOG Unable to read Warning Message entry from TL1 database.\n");
                return eosl_false;
            }

        
            resultTL1[j]._src = "TL1";
            resultTL1[j]._wrnLn = wrnIndex + j + 1;
            resultTL1[j]._wrnTx = &(TELICA_USER_BANNER[wrnIndex + j][0]);
        }

        if (!p_dbReadBuf->NumRows)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_RTRV_ATTR_SECULOG_req",
                       "RTRV_ATTR_SECULOG No Warning Message entries from TL1 database.\n");
            return eosl_false;
        }

        if (eosl_strcasecmp(_src, "TL1") == 0)
        {
            cmpCode = TCC_COMPLD;
        }
        
        result = agc_EM_NE_RTRV_ATTR_SECULOG_resp(modifier,
                                            handle,
                                            ctag,
                                            cmpCode,
                                            resultTL1,
                                            numWrnTx,
                                            "RTRV-ATTR-SECULOG",
                                            NULL);
    }

#ifndef ATCA
    if (eosl_strcasecmp(_src, "OS") == 0 || eosl_strcasecmp(_src, "COM") == 0)
    {
        memset(&resultOS, 0, sizeof(resultOS));
        if ((fp = fopen("/etc/motd", "r")) == NULL)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_RTRV_ATTR_SECULOG_req",
                       "RTRV_ATTR_SECULOG Unable to read Warning Message from OS\n");
            tc_error_response(handle,ctag,TE_SROF,"Unable to get attr seculog");
            return eosl_false;
        }
        if (numWrnTx == 1)
        {
            resultOS[0]._src = "OS";
  
            for (j = 0; fgets(lines[j], USER_BANNER_MAXLINLEN + 1, fp) != NULL && j < USER_BANNER_MAXLIN; j++)
            {
                if (j == wrnIndex)
                {
                    resultOS[0]._wrnLn = j + 1;
                    lines[j][strlen(lines[j]) - 1] = '\0';
                    resultOS[0]._wrnTx = &(lines[j][0]);
                    found = eosl_true;
                }
            }

            if (found == eosl_false)
            {
                resultOS[0]._wrnLn = *_wrnLn;
                resultOS[0]._wrnTx = "";
            }
        }
        else
        {
            for (j = 0; fgets(lines[j], USER_BANNER_MAXLINLEN + 1, fp) != NULL && j < USER_BANNER_MAXLIN; j++)
            {
                resultOS[j]._src = "OS";
                resultOS[j]._wrnLn = wrnIndex + j + 1;
                lines[j][strlen(lines[j]) - 1] = '\0';
                resultOS[j]._wrnTx = &(lines[j][0]);
            }

            for (; j < USER_BANNER_MAXLIN; j++)
            {
                resultOS[j]._src = "OS";
                resultOS[j]._wrnLn = wrnIndex + j + 1;
                resultOS[j]._wrnTx = "";
            }
        }
        result = agc_EM_NE_RTRV_ATTR_SECULOG_resp(modifier,
                                            handle,
                                            ctag,
                                            TCC_COMPLD,
                                            resultOS,
                                            numWrnTx,
                                            "RTRV-ATTR-SECULOG",
                                            NULL);
        fclose(fp);
    }
#endif
    return result;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_COUNTRY_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _countryCode)
{ 
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   short          retVal;
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   short          length;

   length = sizeof(SMCMD_t);

   tableId = TELICA_TABLE_COUNTRY_CODE;
   transId = ctag;

   colArray.numCols = 0;
   colArray.colArray = columns;

   if(_countryCode)
   {
     if(!IsInputStrInRange(_countryCode,"0123456789") || IsInputStrContainPrefix(_countryCode,"0"))
     {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid CountryCode");
        return eosl_false;
 
}
     rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
     rowKey.rowIndex[0].value.stringVal.ptr = _countryCode;
     rowKey.rowIndex[0].value.stringVal.len = strlen(_countryCode);
     rowKey.numIndices = 1;
   }
   else
   {
      rowKey.numIndices = 0;
   }
   retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   retVal=emfUnpkSmiGetMultiResp(rtrvCountryMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}


/**
 */
eosl_bool agc_EM_NE_RTRV_DATASERVER_HOSTCFG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _COM)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   short          retVal;
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   short          length;
  
   length = sizeof(SMCMD_t);

   tableId = TELICA_TABLE_BILLING_DATASERVE;
   transId = ctag;

   rowKey.numIndices = 0;
   colArray.numCols = 0;
   colArray.colArray = columns;

   if(_COM)
   {
           if(eosl_strncasecmp(_COM,"COM",3))
           {
              tc_error_response( handle, ctag, TE_IIAC, "Invalid Aid");
              return eosl_false;
           }
   }
   retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   retVal=emfUnpkSmiGetMultiResp(rtrvDataserverHostCfgMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}


/**
 * As per Bellcore's spec, states are separate from other
 * properties. You enter the name of one or more properties
 * required and they are returned as name-value pairs -
 * Bellcore allows for positional definition but that is
 * rarely used in these messages so we avoided it. A user must
 * fill in real properties instead of "pname".
 *
 * Defined in GR-199 very generically as part of
 * RTRV-{modifier}-[{modifier}]
 */
eosl_bool agc_EM_NE_RTRV_CHASSIS_EQPT_req( const char * modifier,\
                                           eosl_handle handle,\
                                           TL1_TAG ctag ,\
                                           TL1_AID _com)
{
#ifndef ATCA
    CMD_BUF_t                   buffer;
    RTRV_CHASSIS_EQPT_resp_row  result;

    char              s_shelfId[8];
    char              s_craftIPSPA[16];
    char              s_craftIPSPB[16];
    char              s_emIPSPA[16];
    char              s_emIPSPB[16];
    char              s_emIPChassis[16];
    char              s_sigAIPSPA[16];
    char              s_sigAIPSPB[16];
    char              s_sigBIPSPA[16];
    char              s_sigBIPSPB[16];
    char              s_sigCIPSPA[16];
    char              s_sigCIPSPB[16];
    char              s_sigDIPSPA[16];
    char              s_sigDIPSPB[16];
    char              s_sigAIPChassis[16];
    char              s_sigBIPChassis[16];
    char              s_sigCIPChassis[16];
    char              s_sigDIPChassis[16];
    char              s_craftIPMask[16];
    char              s_emIPMask[16];
    char              s_sigAIPMask[16];
    char              s_sigBIPMask[16];
    char              s_sigCIPMask[16];
    char              s_sigDIPMask[16];
    char              s_dnsIP1[16];
    char              s_dnsIP2[16];
    char              s_ntpServIP1[16];
    char              s_ntpServIP2[16];

    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(CMD_BUF_t));  /* sets all "valid" flags to 0 */

    if (_com)
    {
        if(eosl_strcasecmp(_com, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    result._com = "COM";
    sprintf(s_shelfId, "%d", buffer.CmdInfo.RtrvChassis.ShelfId);
    result._shelfId = s_shelfId;

    switch(buffer.CmdInfo.RtrvChassis.ChassisType)
    {   
      case CHASSIS_TYPE_MG:
          result._chassisType = ChassisType_MG;
          break;
      case CHASSIS_TYPE_MGC:
          result._chassisType = ChassisType_MGC;
          break;
      case CHASSIS_TYPE_SG:
          result._chassisType = ChassisType_SG;
          break;
      case CHASSIS_TYPE_SG_MG:
          result._chassisType = ChassisType_SG_MG;
          break;
      case CHASSIS_TYPE_SG_MGC:
          result._chassisType = ChassisType_SG_MGC;
          break;
      case CHASSIS_TYPE_SG_MGC_MG:
          result._chassisType = ChassisType_SG_MGC_MG;
          break;

#ifdef ATCA
	  	 
      case CHASSIS_TYPE_ATCA_SG: 	  	 
        result._chassisType = ChassisType_ATCA_VSG; 	  	 
        break; 	  	 
      case CHASSIS_TYPE_ATCA_MGC: 	  	 
        result._chassisType = ChassisType_ATCA_MGC; 	  	 
        break; 	  	 
      case CHASSIS_TYPE_ATCA_SG_MGC: 	  	 
        result._chassisType = ChassisType_ATCA_VSG_MGC;	  	 
        break; 	  	 
#endif
          
      default:
          result._chassisType = ChassisType_ALL;
          break;
    }

    switch(buffer.CmdInfo.RtrvChassis.MgType)
    {   
      case EMF_MG_TYPE_PG:
          result._mgType = MgType_PG;
          break;
      case EMF_MG_TYPE_TDMIP:
          result._mgType = MgType_TDMIP;
          break;
      case EMF_MG_TYPE_UMTS:
          result._mgType = MgType_UMTS;
          break;
          
      default:
          result._mgType = MgType_ALL;
          break;
    }

    switch(buffer.CmdInfo.RtrvChassis.SgType)
    {   
      case EMF_SG_TYPE_DSG:
          result._sgType = SgType_DSG;
          break;
      case EMF_SG_TYPE_ISG:
          result._sgType = SgType_ISG;
          break;
      case EMF_SG_TYPE_PSG:
          result._sgType = SgType_PSG;
          break;
          
      default:
          result._sgType = SgType_ALL;
          break;
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.CLLI) > 0)
    {
        result._clli = buffer.CmdInfo.RtrvChassis.CLLI;
    }
    else
    {
        result._clli = "NULL";
    }
    
    if(strlen(buffer.CmdInfo.RtrvChassis.Location) > 0)
    {
        result._loc  = buffer.CmdInfo.RtrvChassis.Location;
    }
    else
    {
        result._loc = "NULL";
    }
        
    if (buffer.CmdInfo.RtrvChassis.CraftIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.CraftIpSPA, s_craftIPSPA);
        result._craftIPSPA = s_craftIPSPA;
    }
    else
    {
        result._craftIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.CraftIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.CraftIpSPB, s_craftIPSPB);
        result._craftIPSPB = s_craftIPSPB;
    }
    else
    {
        result._craftIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.MgmtIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.MgmtIpSPA, s_emIPSPA);
        result._emIPSPA = s_emIPSPA;
    }
    else
    {
        result._emIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.MgmtIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.MgmtIpSPB, s_emIPSPB);
        result._emIPSPB = s_emIPSPB;
    }
    else
    {
        result._emIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.MgmtChassisIp)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.MgmtChassisIp, s_emIPChassis);
        result._emIPChassis = s_emIPChassis;
    }
    else
    {
        result._emIPChassis = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingAIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingAIpSPA, s_sigAIPSPA);
        result._sigAIPSPA = s_sigAIPSPA;
    }
    else
    {
        result._sigAIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingAIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingAIpSPB, s_sigAIPSPB);
        result._sigAIPSPB = s_sigAIPSPB;
    }
    else
    {
        result._sigAIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingBIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingBIpSPA, s_sigBIPSPA);
        result._sigBIPSPA = s_sigBIPSPA;
    }
    else
    {
        result._sigBIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingBIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingBIpSPB, s_sigBIPSPB);
        result._sigBIPSPB = s_sigBIPSPB;
    }
    else
    {
        result._sigBIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingCIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingCIpSPA, s_sigCIPSPA);
        result._sigCIPSPA = s_sigCIPSPA;
    }
    else
    {
        result._sigCIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingCIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingCIpSPB, s_sigCIPSPB);
        result._sigCIPSPB = s_sigCIPSPB;
    }
    else
    {
        result._sigCIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingDIpSPA)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingDIpSPA, s_sigDIPSPA);
        result._sigDIPSPA = s_sigDIPSPA;
    }
    else
    {
        result._sigDIPSPA = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingDIpSPB)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingDIpSPB, s_sigDIPSPB);
        result._sigDIPSPB = s_sigDIPSPB;
    }
    else
    {
        result._sigDIPSPB = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingAIpChassis)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingAIpChassis, s_sigAIPChassis);
        result._sigAIPChassis = s_sigAIPChassis;
    }
    else
    {
        result._sigAIPChassis = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingBIpChassis)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingBIpChassis, s_sigBIPChassis);
        result._sigBIPChassis = s_sigBIPChassis;
    }
    else
    {
        result._sigBIPChassis = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingCIpChassis)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingCIpChassis, s_sigCIPChassis);
        result._sigCIPChassis = s_sigCIPChassis;
    }
    else
    {
        result._sigCIPChassis = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingDIpChassis)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingDIpChassis, s_sigDIPChassis);
        result._sigDIPChassis = s_sigDIPChassis;
    }
    else
    {
        result._sigDIPChassis = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.CraftMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.CraftMask, s_craftIPMask);
        result._craftIPMask = s_craftIPMask;
    }
    else
    {
        result._craftIPMask = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.MgmtMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.MgmtMask, s_emIPMask);
        result._emIPMask = s_emIPMask;
    }
    else
    {
        result._emIPMask = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingAMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingAMask, s_sigAIPMask);
        result._sigAIPMask = s_sigAIPMask;
    }
    else
    {
        result._sigAIPMask = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingBMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingBMask, s_sigBIPMask);
        result._sigBIPMask = s_sigBIPMask;
    }
    else
    {
        result._sigBIPMask = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingCMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingCMask, s_sigCIPMask);
        result._sigCIPMask = s_sigCIPMask;
    }
    else
    {
        result._sigCIPMask = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.SignalingDMask)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SignalingDMask, s_sigDIPMask);
        result._sigDIPMask = s_sigDIPMask;
    }
    else
    {
        result._sigDIPMask = "NULL";
    }

    result._emPortMode = mapTSMCTL1PortMode(buffer.CmdInfo.RtrvChassis.MgmtPortMode);
    result._sigAPortMode = mapTSMCTL1PortMode(buffer.CmdInfo.RtrvChassis.SignalingAPortMode);
    result._sigBPortMode = mapTSMCTL1PortMode(buffer.CmdInfo.RtrvChassis.SignalingBPortMode);
    result._sigCPortMode = mapTSMCTL1PortMode(buffer.CmdInfo.RtrvChassis.SignalingCPortMode);
    result._sigDPortMode = mapTSMCTL1PortMode(buffer.CmdInfo.RtrvChassis.SignalingDPortMode);

    result._emFailOverTmr  = buffer.CmdInfo.RtrvChassis.MgmtFoTmr;
    result._sigFailOverTmr = buffer.CmdInfo.RtrvChassis.SignalingFoTmr;

    if(strlen(buffer.CmdInfo.RtrvChassis.MgmtTos) == TOS_BITS_STR_LEN)
    {
        result._emTOS = buffer.CmdInfo.RtrvChassis.MgmtTos;
    }
    else
    {
        result._emTOS = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.SignalingATos) == TOS_BITS_STR_LEN)
    {
        result._sigATOS = buffer.CmdInfo.RtrvChassis.SignalingATos;
    }
    else
    {
        result._sigATOS = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.SignalingBTos) == TOS_BITS_STR_LEN)
    {
        result._sigBTOS = buffer.CmdInfo.RtrvChassis.SignalingBTos;
    }
    else
    {
        result._sigBTOS = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.SignalingCTos) == TOS_BITS_STR_LEN)
    {
        result._sigCTOS = buffer.CmdInfo.RtrvChassis.SignalingCTos;
    }
    else
    {
        result._sigCTOS = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.SignalingDTos) == TOS_BITS_STR_LEN)
    {
        result._sigDTOS = buffer.CmdInfo.RtrvChassis.SignalingDTos;
    }
    else
    {
        result._sigDTOS = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.DnsIP1)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.DnsIP1, s_dnsIP1);
        result._dnsIP1 = s_dnsIP1;
    }
    else
    {
        result._dnsIP1 = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.DnsIP2)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.DnsIP2, s_dnsIP2);
        result._dnsIP2 = s_dnsIP2;
    }
    else
    {
        result._dnsIP2 = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.NTPServer1IP)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.NTPServer1IP, s_ntpServIP1);
        result._ntpServIP1 = s_ntpServIP1;
    }
    else
    {
        result._ntpServIP1 = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.NTPServer2IP)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.NTPServer2IP, s_ntpServIP2);
        result._ntpServIP2 = s_ntpServIP2;
    }
    else
    {
        result._ntpServIP2 = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.DnsName) > 0)
    {
        result._dnsName = buffer.CmdInfo.RtrvChassis.DnsName;
    }
    else
    {
        result._dnsName = "NULL";
    }
    
    if(strlen(buffer.CmdInfo.RtrvChassis.EmHostnameSPA) > 0)
    {
        result._emHostnameSPA  = buffer.CmdInfo.RtrvChassis.EmHostnameSPA;
    }
    else
    {
        result._emHostnameSPA = "NULL";
    }
    
    if(strlen(buffer.CmdInfo.RtrvChassis.EmHostnameSPB) > 0)
    {
        result._emHostnameSPB  = buffer.CmdInfo.RtrvChassis.EmHostnameSPB;
    }
    else
    {
        result._emHostnameSPB = "NULL";
    }
	
    switch(buffer.CmdInfo.RtrvChassis.ChassisCellFormat)
    {
    case CHASSIS_CELL_FORMAT_NEW:
        result._chassisCellFormat = ChassisCellFormat_EXTENDED;
        break;
    case CHASSIS_CELL_FORMAT_OLD:
        result._chassisCellFormat = ChassisCellFormat_NORMAL;
        break;
    default:
        break;
    }
    /*
    **  Send off Response
    */

    return agc_EM_NE_RTRV_CHASSIS_EQPT_resp( modifier,
                                             handle,
                                             ctag,
                                             TCC_COMPLD,
                                             &result,
                                             1,
                                             "RTRV-CHASSIS-EQPT",
                                             NULL );
#endif
    return eosl_true;
}


/**
 */
#define MAX_MSG_USER_ROWS (8)
eosl_bool agc_EM_NE_RTRV_MSG_USER_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid)
{

    USER_DATA_t            *userDataPtr;
    RTRV_MSG_USER_resp_row rows[MAX_USERS];
    TL1_BUFFER             *tl1_b           = NULL;
    TL1_COMPLETION_CODE    tcc;
    int                    count            = 0;
    int                    lumosRowIndex    = 0;
    int                    i;
    char                   uidArray[MAX_MSG_USER_ROWS][MAX_USER_NAME_SIZE+1];

    /* If a user ID has not been specified */
    if ( _uid == NULL)
    {
        count = tl1DbGetNumRows(TL1_USER_TABLE_NAME);
        count = (count > MAX_USERS) ? MAX_USERS : count;
        /* Has to be at least one user to issue this command */
        if (count == 0)
        {
            tc_error_response(handle,ctag,TE_EANS, "Failed RTRV-MSG-USER");
            return eosl_false;
        }
    }
    else
    {
        if (strlen(_uid) > MAX_USER_NAME_SIZE)
        {
            tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
            return eosl_false;
        }
        count = 1;
    }

    /* For each user */
    for (  i=0; i < count; i++)
    {
        /* If a specific user ID was specified */
        if (_uid)
        {
            /* Get user data for specified user ID */
            userDataPtr = GetUserDataFromDb(_uid);
            if (userDataPtr == NULL)
            {
                tc_error_response(handle,ctag,TE_EANS, "Input, Specified user does not exist");
                return eosl_false;
            }
            if (userDataPtr->etsiLi == 1)
            {
                tc_error_response(handle,ctag,TE_EANS, "Input, Specified user does not exist");
                eosl_free(userDataPtr);
                return eosl_false;
            }
        }
        else
        {
            /* Get user data for specified table row */
            userDataPtr = GetUserDataByRow(i);
        }
        
        if (userDataPtr)
        {
            if (userDataPtr->etsiLi != 1)
            {
                strcpy(&uidArray[lumosRowIndex][0], userDataPtr->username);
                rows[lumosRowIndex]._uid    = &uidArray[lumosRowIndex][0];
                rows[lumosRowIndex]._status = userDataPtr->InhMsg;

                lumosRowIndex++;
            }
            eosl_free(userDataPtr);
            
            /* If the max number of output rows has been reached or no more entries */
            if ((lumosRowIndex >= MAX_MSG_USER_ROWS) || (i == count-1))
            {
                /* Assign the TL1 completion code for TL1 header output */
                tcc = (i == count-1) ? TCC_COMPLD : TCC_RTRV;
                /* Output the current batch of entries */
                agc_EM_NE_RTRV_MSG_USER_resp( modifier,
                                              handle,
                                              ctag,
                                              tcc,
                                              rows,
                                              lumosRowIndex,
                                              "RTRV-MSG-USER",
                                              tl1_b);
                lumosRowIndex = 0;
                usleep(100000); /* 100 ms - throttle output */
            }
        }
    }
    return eosl_true;
}

/**
 */
eosl_bool agc_EM_NE_RTRV_FAN_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _fan)
{
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    RTRV_FAN_EQPT_resp_row  result;

    if (eosl_strcasecmp(_fan, "FAN") != 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_FAN_INFO,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_FAN_INFO,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    if (!respBuff.CmdInfo.RtrvFanParams.FanPresent)
    {
        tc_error_response( handle, ctag, TE_ENEQ, "FAN is not present." );
        return eosl_false;
    }

    result._fan = "FAN";

    if (respBuff.CmdInfo.RtrvFanParams.FanFault)
    {
        result._status = OkayFail_FAIL;
    }
    else
    {
        result._status = OkayFail_OKAY;
    }

    result._failures = respBuff.CmdInfo.RtrvFanParams.FanFaultCount;

    return agc_EM_NE_RTRV_FAN_EQPT_resp( modifier,
                                         handle,
                                         ctag,
                                         TCC_COMPLD,
                                         &result,
                                         1,
                                         "RTRV-FAN-EQPT",
                                         NULL );

}


eosl_bool agc_EM_NE_RTRV_INSYS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   short          retVal;
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   short          length;

   length = sizeof(SMCMD_t);

   tableId = SPGENCFG_TAB_ID;   /* BUG: 40346 */
   transId = ctag;

   rowKey.numIndices = 0;
   colArray.numCols = 0;
   colArray.colArray = columns;

    if ((_src!= NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
       TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
       return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvInSysMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
    }
    else
    {
       return eosl_true;
    }
}

/**
 */
eosl_bool agc_EM_NE_RTRV_INFO_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
#ifndef ATCA    
    RTRV_INFO_EQPT_resp_row     result[MAX_RTRV_INFO_EQPT_TL1_ENTRIES];
    AID_INFO_TYPE_t             aidInfo;
    int                         slotCount;
    char                        slotNum[MAX_RTRV_INFO_EQPT_TL1_ENTRIES][8];
    char                        prtgSlotNum[MAX_RTRV_INFO_EQPT_TL1_ENTRIES][8];
    CMD_BUF_t                   respBuff;
    TL1_BUF_t                   cmdMsg;
    PassFail_ENUM               selfTestStatusArray[MAX_RTRV_INFO_EQPT_TL1_ENTRIES];
    PortType_ENUM               portTypeArray[MAX_RTRV_INFO_EQPT_TL1_ENTRIES];
    char                        rearDesc[MAX_RTRV_INFO_EQPT_TL1_ENTRIES][IDPROM_DESC_LEN + 5];
    int                         retVal;
    int                         tsmcRowIndex=0;
    int                         lumosRowIndex=0;

    
    memset(result,0, sizeof(result));
    memset(slotNum,0, sizeof(slotNum));
    memset(prtgSlotNum,0, sizeof(prtgSlotNum));
    memset(selfTestStatusArray,0, sizeof(selfTestStatusArray));
    memset(portTypeArray,0, sizeof(portTypeArray));
    memset(rearDesc,0, sizeof(rearDesc));

    if (_iomOrSp)
    {
        if (ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM | AID_SF), NULL))
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        slotCount=1;
        cmdMsg.CmdInfo.SlotNum=aidInfo.lvl1;
    }
    else
        /* No AID given -- default to ALL. */
    {
        slotCount = MAX_IOMS + NUM_SCS + NUM_SF;
        cmdMsg.CmdInfo.SlotNum=ALL_SLOTS;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_INFO_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_INFO_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    
    for ( tsmcRowIndex=0;  tsmcRowIndex < slotCount; tsmcRowIndex++)
    {
        SlotToAid(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].SlotNum, slotNum[lumosRowIndex]);
        result[lumosRowIndex]._iomOrSp = slotNum[lumosRowIndex];

        result[lumosRowIndex]._clei = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].CLEI;

        result[lumosRowIndex]._desc = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Description;
        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Description[0] == '\0')
        {
            /*  Not necessary to pass a space -- pass a NULL ptr
                respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Description[0] = ' ';
                respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Description[1] = '\0';
            */
            result[lumosRowIndex]._desc = NULL;
        }

        result[lumosRowIndex]._hwVersion = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].HWVersion;

        result[lumosRowIndex]._swVersion = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].SWVersion;

        result[lumosRowIndex]._serialNumber = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].SerialNumber;

        selfTestStatusArray[lumosRowIndex] = (PassFail_ENUM) enum_lookup_no_case(&PassFail_ENUM_type,
                                                                     respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].SelftestStatus);
        result[lumosRowIndex]._selfTestStatus = &selfTestStatusArray[lumosRowIndex];

        /* result[lumosRowIndex]._lastTimeChanged = eqptLastTimeChanged; */
        result[lumosRowIndex]._portCount = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].PortCount;

        portTypeArray[lumosRowIndex] = (PortType_ENUM) enum_lookup_no_case(&PortType_ENUM_type,
                                                               respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].PortType);
        result[lumosRowIndex]._portType = &portTypeArray[lumosRowIndex];

        /* result[lumosRowIndex]._ledStatus = atoi(respBuff.CmdInfo.SlotRtrvRsp[tsmcRowIndex].ledStatus);  */
        result[lumosRowIndex]._externalFaults = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].ExternalFaultLed;
        result[lumosRowIndex]._internalFaults = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].InternalFaultLed;
        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].InServiceLed)
        {
            result[lumosRowIndex]._inService = BoolYN_Y;
        }
        else
        {
            result[lumosRowIndex]._inService = BoolYN_N;
        }

        result[lumosRowIndex]._nvMemFree = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].FreeDiskSpace;
        result[lumosRowIndex]._nvMemUsed = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].UsedDiskSpace;
        result[lumosRowIndex]._memFree = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].FreeMemory;
        result[lumosRowIndex]._memUsed = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].UsedMemory;
        result[lumosRowIndex]._spAveBusy = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].AveCpuUtilization;

#if 0 /* Done on 11/14 H. Garcia */
/* ??? INITIALIZE REAR CARD INFO UNTIL EQM INITIALIZES STRINGS */
        strcpy(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearCLEI, "RearClei");
        strcpy(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearDescription, "RearDesc");
        strcpy(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearHWVersion, "RearHWVer");
        strcpy(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearSerialNumber, "RearSN");
/* ??? END OF TEMPORARY CLEARING OF REAR CARD INFO */
#endif

        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearCLEI[0] == '\0')
        {
            result[lumosRowIndex]._rearClei = NULL;
        }
        else
        {
            result[lumosRowIndex]._rearClei = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearCLEI;
        }

        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearDescription[0] == '\0')
        {
            /* Not necessary to pass a space -- just pass a NULL ptr
               respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearDescription[0] = ' ';
               respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearDescription[1] = '\0';
            */
            result[lumosRowIndex]._rearDesc = NULL;
        }
        else
        {
            sprintf(rearDesc[lumosRowIndex], "\\\"%s\\\"", respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearDescription);
            result[lumosRowIndex]._rearDesc = rearDesc[lumosRowIndex];
        }

        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearHWVersion[0] == '\0')
        {
            result[lumosRowIndex]._rearHwVersion = NULL;
        }
        else
        {
            result[lumosRowIndex]._rearHwVersion = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearHWVersion;
        }

        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearSerialNumber[0] == '\0')
        {
            result[lumosRowIndex]._rearSerialNumber = NULL;
        }
        else
        {
            result[lumosRowIndex]._rearSerialNumber = respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].RearSerialNumber;
        }
        
        if (respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Protecting == 0)
        {
            result[lumosRowIndex]._prtg = NULL;
        }
        else
        {   
            SlotToAid(respBuff.CmdInfo.RtrvInfoEqpt[tsmcRowIndex].Protecting, prtgSlotNum[lumosRowIndex]);
            result[lumosRowIndex]._prtg = prtgSlotNum[lumosRowIndex];
        }


        lumosRowIndex++;
        if ((lumosRowIndex >= MAX_RTRV_INFO_EQPT_TL1_ENTRIES) && ((tsmcRowIndex + 1) < slotCount))
        {
            retVal =  agc_EM_NE_RTRV_INFO_EQPT_resp ( modifier,
                                                    handle,
                                                    ctag,
                                                    TCC_RTRV,
                                                    result,
                                                    lumosRowIndex,
                                                    "RTRV-INFO-EQPT",
                                                    NULL );
            if (retVal == eosl_false)
            {
                return eosl_false;
            }

            lumosRowIndex = 0;
            memset(result,0, sizeof(result));
            memset(slotNum,0, sizeof(slotNum));
            memset(prtgSlotNum,0, sizeof(prtgSlotNum));
            memset(selfTestStatusArray,0, sizeof(selfTestStatusArray));
            memset(portTypeArray,0, sizeof(portTypeArray));
            memset(rearDesc,0, sizeof(rearDesc));
        }

    }

    /*
    ** Clear response buffer pointer
    */

    return agc_EM_NE_RTRV_INFO_EQPT_resp ( modifier,
                                           handle,
                                           ctag,
                                           TCC_COMPLD,
                                           result,
                                           lumosRowIndex,
                                           "RTRV-INFO-EQPT",
                                           NULL );
#endif
    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_IPHOST_SECU_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _com)
{
#define IPADDRS_PER_ROW 8
    RTRV_IPHOST_SECU_resp_row result[MAX_TRUSTED_HOSTS];
    DB_RW_HDR_t               *p_dbReadBuf;

    int     ipAddr[MAX_TRUSTED_HOSTS];
    char    ipAddrStr[(MAX_TRUSTED_HOSTS / IPADDRS_PER_ROW) + 1][20 * IPADDRS_PER_ROW];
    int     numIpAddrs;
    int     numResultRows;
    int     leftOvers;
    int     i;
    int     ipIndex;
    int     rowIndex;
    char    tmpIpString[20];
    int     remainingIps = 0;
    int     requestedIps = 0;

    if ((_com != NULL) && (eosl_strcasecmp(_com, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    numIpAddrs = tl1DbGetNumRows(THOSTS_TABLE_NAME);
    if (numIpAddrs < 0)
    {
        tc_error_response( handle,
                           ctag,
                           TE_SDBE,
                           "Error reading THosts table" );
        return eosl_false;
    }

    if (numIpAddrs > MAX_TRUSTED_HOSTS)
    {
        numIpAddrs = MAX_TRUSTED_HOSTS;
    }

    ipIndex = 0;
    while (ipIndex < numIpAddrs)
    {
        remainingIps = numIpAddrs - ipIndex;
        requestedIps = remainingIps % TL1_THOST_DB_MAX_ROWS;
        /* Create/initialize request/response object */
        if ((p_dbReadBuf = createDbReadTHosts()) == NULL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_RTRV_IPHOST_SECU_req",
                       "agc_EM_NE_RTRV_IPHOST_SECU_req: "
                       "Unable to malloc DB read buffer\n");
            return FAIL;
        }
        p_dbReadBuf->StartRow = ipIndex;
        p_dbReadBuf->NumRows = requestedIps;
        if (sendDbReadRequest(p_dbReadBuf, DB_READ_ROW)  == FAIL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_RTRV_IPHOST_SECU_req",
                       "Unable to read trusted host table from TL1 database\n");
            eosl_free(p_dbReadBuf);
            return FAIL;
        }

        for (i = 0; i < p_dbReadBuf->NumRows; i++)
        {
            if (DbGetColInt(p_dbReadBuf,
                            ipIndex,
                            TL1_DB_IP_COL,
                            &ipAddr[ipIndex]) == FAIL)
            {
                procLogMsg(PLOG_ERROR,
                           "agc_EM_NE_RTRV_IPHOST_SECU_req",
                           "Unable to read trusted host entry from TL1 database.\n");
                eosl_free(p_dbReadBuf);
                return FAIL;
            }
            ipIndex++;
        }
        eosl_free(p_dbReadBuf);
    }

    shellSort(ipAddr, numIpAddrs);

    numResultRows = numIpAddrs / IPADDRS_PER_ROW;
    leftOvers = numIpAddrs % IPADDRS_PER_ROW;

    memset(&result, 0, sizeof(result));
    memset(ipAddrStr, 0, sizeof(ipAddrStr));
    ipIndex = 0;
    for (rowIndex = 0; rowIndex < numResultRows; rowIndex++)
    {
        result[rowIndex]._com = "COM";

        for (i = 0; i < IPADDRS_PER_ROW; i++)
        {
            ip_i2a(ipAddr[ipIndex], tmpIpString);
            ipIndex++;
            if (i > 0)
            {
                strcat(ipAddrStr[rowIndex], "&");
            }
            strcat(ipAddrStr[rowIndex], tmpIpString);
        }
        result[rowIndex]._ipHosts = &(ipAddrStr[rowIndex][0]);
    }

    if (leftOvers > 0)
    {
        numResultRows++;
        rowIndex = numResultRows - 1;
        result[rowIndex]._com = "COM";

        for (i = 0; i < leftOvers; i++)
        {
            ip_i2a(ipAddr[ipIndex], tmpIpString);
            ipIndex++;
            if (i > 0)
            {
                strcat(ipAddrStr[rowIndex], "&");
            }
            strcat(ipAddrStr[rowIndex], tmpIpString);
        }
        result[rowIndex]._ipHosts = &(ipAddrStr[rowIndex][0]);
    }

    return agc_EM_NE_RTRV_IPHOST_SECU_resp(modifier,
                                           handle,
                                           ctag,
                                           TCC_COMPLD,
                                           result,
                                           numResultRows,
                                           "RTRV-IPHOST-SECU",
                                           NULL);
}

/**
 */
#ifndef ATCA
#define MAX_IPROUTE_ROWS (8)
#endif
eosl_bool agc_EM_NE_RTRV_IPROUTE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _ipRouteId)
{

    IPROUTE_CMD_t           buffer;
    char                    upperAid [80];
    int                     i;
#ifndef ATCA
    RTRV_IPROUTE_resp_row   result   [MAX_IPROUTE_ROWS];
    char                    routeAid [MAX_IPROUTE_ROWS][80];
    char                    routeIp  [MAX_IPROUTE_ROWS][INET6_ADDRSTRLEN];
    EnableType_ENUM         routePing[MAX_IPROUTE_ROWS];
    char                    destIp   [INET6_ADDRSTRLEN];
    int                     lumosRowIndex =  0;
    TL1_COMPLETION_CODE     tcc;
#endif

    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(IPROUTE_CMD_t));

    /* If the AID was NOT successfully parsed and loaded into the message structure */
    if (ParseRouteAid(_ipRouteId,
                      &buffer.DeviceId,
                      &buffer.DeviceMap,
                      &buffer.Data.RtrvIpRoute.RouteInfo[0].Dest,
#ifndef ATCA
                      &buffer.Data.RtrvIpRoute.RouteInfo[0].SubnetMask,
#else
                      &buffer.Data.RtrvIpRoute.RouteInfo[0].Subnet,
#endif
                      AID_IPROUTE_PARTIAL) == FAIL)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }


    /* Convert AID to upper case */
    for (i = 0; i <= strlen(_ipRouteId); i++)
    {
        upperAid[i] = (char)eosl_toupper((int)_ipRouteId[i]);
    }

    /* Dispatch the message */
    if(TL1SendMsg(handle, ctag,
                  IP_ROUTE_CMD_CLASS, CMD, RTRV_IPROUTE,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_IPROUTE, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

#ifndef ATCA
    if (buffer.Data.RtrvIpRoute.NRoutes == 0)
    {
        return agc_EM_NE_RTRV_IPROUTE_resp( modifier,
                                            handle,
                                            ctag,
                                            TCC_COMPLD,
                                            result,
                                            buffer.Data.RtrvIpRoute.NRoutes,
                                            "RTRV-IPROUTE",
                                            NULL );    
    }

    /* For each entry retrieved from the message */
    for (i = 0; i <  buffer.Data.RtrvIpRoute.NRoutes; i++)
    {
        /* Construct the AID */
        ip_i2a(buffer.Data.RtrvIpRoute.RouteInfo[i].Dest, destIp);
        sprintf(&routeAid[lumosRowIndex][0], "%s-%s-%d",
                upperAid, destIp, buffer.Data.RtrvIpRoute.RouteInfo[i].SubnetMask);
        result[lumosRowIndex]._ipRouteId = &routeAid[lumosRowIndex][0];

        /* Construct the associated data */
        ip_i2a(buffer.Data.RtrvIpRoute.RouteInfo[i].Route,
               &routeIp[lumosRowIndex][0]);
        result[lumosRowIndex]._gateway = &routeIp[lumosRowIndex][0];
        
        routePing[lumosRowIndex] = 
            (buffer.Data.RtrvIpRoute.RouteInfo[i].PingEnabled == TRUE)?
            EnableType_ENABLED: EnableType_DISABLED;
        result[lumosRowIndex]._gatewayPing = &routePing[lumosRowIndex];

        lumosRowIndex++;
            
        /* If the max number of output rows has been reached or no more entries */
        if ((lumosRowIndex >= MAX_IPROUTE_ROWS) || (i == buffer.Data.RtrvIpRoute.NRoutes-1))
        {
            /* Assign the TL1 completion code for TL1 header output */
            tcc = (i == buffer.Data.RtrvIpRoute.NRoutes-1) ? TCC_COMPLD : TCC_RTRV;
            
            /* Output the current batch of entries */
            agc_EM_NE_RTRV_IPROUTE_resp( modifier,
                                         handle,
                                         ctag,
                                         tcc,
                                         result,
                                         lumosRowIndex,
                                         "RTRV-IPROUTE",
                                         NULL );
            lumosRowIndex = 0;
            usleep(100000); /* 100 ms - throttle output */
        }
    }

#else
    if (RtrvIPRouteResp(&buffer) == eosl_false)
    {
        tc_error_response(handle, ctag, TE_SDNR, "RTRV-IPROUTE" );
        return eosl_false;
    } 
#endif
    return eosl_true;
    
}

/**
 * Retrieve  LIST SUIOM
 */
eosl_bool agc_EM_NE_RTRV_LIST_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suListId)
{
    TL1_BUF_t         buffer;
    int               Iom;
    TL1_SULISTRSP_t   tl1SuListRsp;
    eosl_bool         status;

    memset(&buffer, 0, sizeof(TL1_BUF_t));

    buffer.Buf.Cmd = EQMCMD_RTRV_SULIST;
    buffer.Buf.SessionHandle = handle;
    buffer.Buf.CTag =ctag;

    if (CheckMultiRespMode( buffer.Buf.Cmd, handle, ctag) == MULTI_RESP_MODE_ON )
    {
        tc_error_response( handle, ctag,TE_SRCI,"Busy responding to previous RTRV-LIST-SUIOM message");
    }   
    
    if(_suListId)
    {
        if(parseSuListAid(_suListId, &Iom, NULL) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.RtrvSuList.SuListName, _suListId, SUAUTO_LIST_LEN + 1);
        buffer.CmdInfo.RtrvSuList.IomNum = Iom;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_SULIST,
                  (TL1_CMD_BUF_t *)&tl1SuListRsp, sizeof(TL1_SULISTRSP_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, tl1SuListRsp.tl1SuListResp.Tl1Cmd.Error );
        return eosl_false;
    }

    status = RtrvSuListResp((SULIST_RSP_t *)&tl1SuListRsp);

    if (status == eosl_false)
    {
        tc_error_response(handle, ctag, TE_SDNR, "RTRV-LIST-SUIOM");
    } 
    return status;
}

/**
 */
eosl_bool agc_EM_NE_RTRV_LNPSCREEN_DIGITS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _screenDigits)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   short          retVal;
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   short          length;
   int            screenDigitsLen;

   length = sizeof(SMCMD_t);
    
   tableId = TELICA_TABLE_LNPSCRDIGITS;
   transId = ctag;

   colArray.numCols = 0;
   colArray.colArray = columns;
   if(_screenDigits)
   {
     if(!(IsInputStrInRange(_screenDigits,"0123456789")))
     {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Input for screenDigits");
        return eosl_false;
     }
     screenDigitsLen = strlen(_screenDigits);
     if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
     {
       tc_error_response( handle, ctag, TE_IIAC, "Invalid number:must be 3 or 6-10 digits");
       return eosl_false;
     }
     rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
     rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
     rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);
     rowKey.numIndices = 1;
   }
   else
   {
      rowKey.numIndices = 0;
   }
   retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   retVal=emfUnpkSmiGetMultiResp(rtrvLnpScreenDigitsMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}


/**
 * Retrieves messages from one of the message logs.
 */
eosl_bool agc_EM_NE_RTRV_LOG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _log_id, LogName_ENUM _lognm)
{
    FAMCMD_t     famCmd;
    TL1_LOGRSP_t sysLog;
    eosl_bool    status;
    eosl_mask    ses_mask;

    if ( _log_id )
    {
        if(eosl_strcasecmp(_log_id, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    switch (_lognm)
    {
      case LogName_SYSLOGS:
          memset(&sysLog, 0x0, sizeof( TL1_LOGRSP_t));
          famCmd.Tl1Cmd.Cmd           = FAMCMD_RTRV_LOG;
          famCmd.Tl1Cmd.SessionHandle = handle;
          famCmd.Tl1Cmd.CTag          = ctag;
          famCmd.Data.RtrvLog.LogType = SYS_LOG;
          
          if(TL1SendMsg(handle, ctag,
                        FAM_CMD_CLASS, CMD, FAMCMD_RTRV_LOG,
                        (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                        (TL1_CMD_BUF_t *)&sysLog, sizeof(sysLog),
                        TL1_MSG_TIMEOUT) == FAIL)
          {
              TL1ErrorResp( handle, ctag, CMD_FAM, sysLog.tl1FamResp.Tl1Cmd.Error );
              return eosl_false;
          }
          
          if ((status = RtrvSysLogResp ((FAMRSP_t *)&sysLog)) == eosl_false)
          {
              tc_error_response( handle, ctag, TE_SROF, "Failed to Retrieve Sys Log" );
          }
          break;

      case LogName_INACTIVE:
          if ((status = RtrvInactiveLogResp(handle, ctag)) == eosl_false)
          {
              tc_error_response( handle, ctag, TE_SROF, "Failed to Retrieve Inactive Log");
          }
          break;

      case LogName_MGCPLOGS:
          /* Design Note: MGCP log is N/A for 5.0
           */
          tc_simple_reply( handle, ctag, TCC_COMPLD, "RTRV-LOG", NULL);
          status= eosl_true;
          break;

      case LogName_MESSAGELOGS:
          status = RtrvTL1LogResp ( handle, ctag, TL1_MESSAGE_LOG, NULL);
          break;

      case LogName_SECURITYLOGS:
          /* Design Note: only ADMIN can view the security logs
           */
          ses_mask = tc_session_get_mask(handle);
          ses_mask = ses_mask & UAP_MASK; /* Only use UAP bits from the mask */
          if (ADMIN_MASK != ses_mask)
          {
              tc_error_response( handle, ctag, TE_EANS, "Access to Security Log denied." );
              return eosl_false;
          }
          status = RtrvTL1LogResp ( handle, ctag, SEC_MESSAGE_LOG, NULL);
          break;

      case LogName_SECURITYBKUPLOGS:
          /* Design Note: only ADMIN can view the security logs
           */
          ses_mask = tc_session_get_mask(handle);
          ses_mask = ses_mask & UAP_MASK; /* Only use UAP bits from the mask */
          if (ADMIN_MASK != ses_mask)
          {
              tc_error_response( handle, ctag, TE_EANS, "Access to Security Log denied." );
              return eosl_false;
          }
          status = RtrvTL1LogResp ( handle, ctag, SEC_MESSAGE_LOG_BKUP, NULL);
          break;

#ifndef ATCA
      case LogName_OSSECURITYLOGS:
          ses_mask = tc_session_get_mask(handle);
          ses_mask = ses_mask & UAP_MASK; /* Only use UAP bits from the mask */
          if (ADMIN_MASK != ses_mask)
          {
              tc_error_response( handle, ctag, TE_EANS, "Access to Security Log denied." );
              return eosl_false;
          }
          status = RtrvTL1LogResp ( handle, ctag, OSSEC_MESSAGE_LOG, NULL);
          break;
#endif
          
      case LogName_AOLOGS:
          status = RtrvTL1LogResp ( handle, ctag, AO_MESSAGE_LOG, NULL);
          break;

      case LogName_BACKUPLOGS:
          status = RtrvTL1LogResp ( handle, ctag, BKUP_MESSAGE_LOG, NULL);
          break;

      case LogName_BULKLOGS:
          status = RtrvTL1LogResp ( handle, ctag, BULK_MESSAGE_LOG, NULL);
          break;

      case LogName_FRAUDLOGS:
          status = RtrvTL1LogResp ( handle, ctag, FRAUD_MESSAGE_LOG, NULL);
          break;

      case LogName_CALLCAPTLOGS:
          status = RtrvTL1LogResp ( handle, ctag, CALLCAPT_MESSAGE_LOG, NULL);
          break;

      case LogName_CALLCAPTVERBOSELOGS:
          status = RtrvTL1LogResp ( handle, ctag, CALLCAPTVERBOSE_MESSAGE_LOG, NULL);
          break;

      case LogName_PATCHLOGS:
          status = RtrvTL1LogResp ( handle, ctag, PATCH_MESSAGE_LOG, NULL);
          break;

#ifdef ATCA
      case LogName_LCPVERSION:
          status = RtrvTL1LogResp ( handle, ctag, LCPVERSION_LOG, NULL);
          break;
#endif

#ifdef ATCA /* FID 15827.0 */
      case LogName_CPURSRC:
          status = RtrvTL1LogResp (handle, ctag, CPURSRC_MESSAGE_LOG, NULL);
          break;
#endif /* ATCA */

      default:
          tc_error_response( handle, ctag, TE_IPNV, "Invalid Log Type" );
          status= eosl_false;
    }

    return status;
}

/**
 */
eosl_bool agc_EM_NE_RTRV_LRN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _lrn)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   short          retVal;
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   short          length;

   length = sizeof(SMCMD_t);

   tableId = TELICA_TABLE_OWNLRN;
   transId = ctag;

   colArray.numCols = 0;
   colArray.colArray = columns;

   if(_lrn)
   {
     if(strlen(_lrn) != 10 )
     {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LRN ");
        return eosl_false;
 
     }
     /*validate AID to permit only numbers within*/
     if(!(IsInputStrInRange(_lrn,"0123456789")))
     {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
     }
     rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
     rowKey.rowIndex[0].value.stringVal.ptr = _lrn;
     rowKey.rowIndex[0].value.stringVal.len = strlen(_lrn);
     rowKey.numIndices = 1;
   }
   else
   {
      rowKey.numIndices = 0;
   }
   retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   retVal=emfUnpkSmiGetMultiResp(rtrvLrnMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}


/**
 */
eosl_bool agc_EM_NE_RTRV_LSET_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _lsetId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    int            lsetId;
    int            i;
    short          length;
    RTRV_LSET_resp_row  rows[MAX_RTRV_LSET_ROWS];
    char      xchr;

    length = sizeof(SMCMD_t);

    tableId = MTPLSET_TAB_ID;
    transId = ctag;

    if (_lsetId)
    {
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        i = sscanf(_lsetId, "%d%c", &lsetId, &xchr);
        if ((i != 1) || (lsetId < 0))
        {
            tc_error_response(handle, ctag, TE_IIAC, "Invalid LinkSetId");  
            return eosl_false;
        }
        rowKey.rowIndex[0].value.longVal  = lsetId;
    }
    else
    {
        rowKey.numIndices = 0;
    }

    colArray.numCols = 0;
    colArray.colArray = columns;
    memset(rows, 0, sizeof(rows));
    
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,/*bug 53600*/
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if (retVal == FALSE)
    {
       TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
       return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvLsetMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
    }
    return eosl_true;

    
}

/**
 */
eosl_bool agc_EM_NE_RTRV_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
    RTRV_EQPT_resp_row  *rowsPtr;
    AID_INFO_TYPE_t     aidInfo;
    int                 slotCount;
    int                 i;
    char                slotNum[MAX_IOMS+NUM_SCS+NUM_SF][8];
    CMD_BUF_t           respBuff;
    TL1_BUF_t           cmdMsg;
    char                pstStr[PST_SIZE];
    char                psqStr[PSQ_SIZE];
    int                 slot;
    char                primaryState[MAX_IOMS+NUM_SCS+NUM_SF][12];
    char                secondaryState[MAX_IOMS+NUM_SCS+NUM_SF][24];
    Redundancy_ENUM     rnArray[MAX_IOMS+NUM_SCS+NUM_SF];
    int                 retVal;


    /* If the EQPT response array can not be dynamically allocated */
    if ((rowsPtr =
         (RTRV_EQPT_resp_row *)eosl_malloc(
             sizeof(RTRV_EQPT_resp_row) * (MAX_IOMS + NUM_SCS + NUM_SF))) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_EQPT_ALL_req",
                    "agc_EM_NE_RTRV_EQPT_ALL_req malloc failure\n");
        return eosl_false;
    }

    memset(slotNum,0x0, sizeof(slotNum));

    if (_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM | AID_SF), NULL))
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            eosl_free(rowsPtr);
            return eosl_false;
        }
        slotCount=1;
        slot=aidInfo.lvl1;
    }
    else
        /* No AID given -- default to ALL. */
    {
        slotCount = MAX_IOMS + NUM_SCS + NUM_SF;
        slot=ALL_SLOTS;
    }
    /*
  ** Prepare event
  */

    cmdMsg.CmdInfo.SlotNum=slot;

    /*
  ** Send event
  */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        eosl_free(rowsPtr);
        return eosl_false;
    }


    /*
  ** get cpu information
  */
  /* c_data = (cpuData*)&data;
     GoAheadGetThreshold(c_data);*/

    for ( i=0;  i < slotCount; i++)
    {
        SlotToAid(respBuff.CmdInfo.RtrvEqpt[i].SlotNum, slotNum[i]);
        rowsPtr[i]._iomOrSp = slotNum[i];

        rowsPtr[i]._moduleType = respBuff.CmdInfo.RtrvEqpt[i].Type;

        rnArray[i] = (Redundancy_ENUM) enum_lookup_no_case(&Redundancy_ENUM_type,
                                                           respBuff.CmdInfo.RtrvEqpt[i].Redundancy);
        rowsPtr[i]._rn = &rnArray[i];

        rowsPtr[i]._swVersion = respBuff.CmdInfo.RtrvEqpt[i].SWVersion;

        SetStateNames(respBuff.CmdInfo.RtrvEqpt[i].State,
                      respBuff.CmdInfo.RtrvEqpt[i].State2,
                      pstStr, psqStr, &(secondaryState[i][0]));

        if (strlen(psqStr) > 0)
            sprintf(&(primaryState[i][0]),"%s-%s", pstStr, psqStr);
        else
            sprintf(&(primaryState[i][0]),"%s", pstStr);
        rowsPtr[i]._primaryState = &(primaryState[i][0]);
        if (strlen(secondaryState[i]) > 0)
        {
            rowsPtr[i]._secondaryState = &(secondaryState[i][0]);
        }
        else
        {
            rowsPtr[i]._secondaryState = NULL;
        }


        /*
        ** fill cpu response information
        */
        rowsPtr[i]._spMemThreshold = respBuff.CmdInfo.RtrvEqpt[i].MemUtilThresh;
        rowsPtr[i]._spNVMemThreshold = respBuff.CmdInfo.RtrvEqpt[i].DiskUtilLowThresh;
        rowsPtr[i]._diskMajorThreshold = respBuff.CmdInfo.RtrvEqpt[i].DiskUtilMedThresh;
        rowsPtr[i]._diskCriticalThreshold = respBuff.CmdInfo.RtrvEqpt[i].DiskUtilHighThresh;
        rowsPtr[i]._spBusyThreshold = respBuff.CmdInfo.RtrvEqpt[i].CpuUtilThresh;
    }

    /*
  ** send tl1 response
  */

    retVal = agc_EM_NE_RTRV_EQPT_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       rowsPtr,
                                       slotCount,
                                       "RTRV-EQPT",
                                       NULL );
    eosl_free(rowsPtr);
    return retVal;

}



/**
 * Instructs the NE to retrieve its equpment-related information.
 */
eosl_bool agc_EM_NE_RTRV_NETYPE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag )
{
    RTRV_NETYPE_resp_row                  result;
    TL1_BUF_t                             cmdMsg;
    CMD_BUF_t                             respBuff;
    unsigned long addr;
    unsigned short port;
    struct in_addr  in;

    if (getSessionIpAddr(handle, (UserAccessPort_ENUM *)&port, (long *)&addr) == eosl_true)
    {
       in.s_addr = addr;
       TL1LOGP(PLOG_ERROR, "KeepAlive Received for ipaddr = %s:%d handle=%d\n",inet_ntoa(in),port,handle);
    }
    /* keep alive */
    if (handleKeepAlive(handle) == eosl_false)
    {
       TL1LOGP(PLOG_ERROR, "agc_EM_NE_RTRV_NETYPE_req handleKeepAlive failed handle=%d\n",handle);
    }
    else
    {
       TL1LOGP(PLOG_ERROR, "agc_EM_NE_RTRV_NETYPE_req handleKeepAlive success handle=%d\n",handle);
    }

#ifdef ATCA
    cmdMsg.CmdInfo.AtcaSlot.shelfId  = procInfo.ShelfId;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = procInfo.PhySlotNum;
    cmdMsg.CmdInfo.AtcaSlot.amcSlot  = 0;

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_ATCA_INFOEQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ATCA_INFOEQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#else
    cmdMsg.CmdInfo.SlotNum = procInfo.SlotNum;

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_INFO_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_INFO_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif

    /*
    ** fill in response
    */
    result._neType = NEType_ISDNSWITCH;
#ifndef ATCA
    result._vendor="Telica";
    result._model="Plexus 9000";
    result._swIssue =  respBuff.CmdInfo.RtrvInfoEqpt[0].SWVersion;
#else
    result._vendor="Alcatel-Lucent";
    result._model="5060 MGC-8";
    result._swIssue =  respBuff.CmdInfo.RtrvAtcaInfoEqptRsp.RtrvAtcaInfoEqpt[0].SWVersion;
#endif

    /*
    ** send tl1 response
    */
    return agc_EM_NE_RTRV_NETYPE_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       &result,
                                       1,
                                       "RTRV-NETYPE",
                                       NULL);
    return eosl_true;
}

/**
 * Retrieve  OSUSER Security
 */
eosl_bool agc_EM_NE_RTRV_OSUSER_SECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid)
{
    const int               MAX_OSUSER_SECU_ROWS   = 100;
    const int               OSUSER_SECU_ROW_LENGTH = 150;
    const int               RTRV_OSUSER_SECU_ROWS  = 8;
    int                     count         =  0;
    char                    num[10];
    int                     lumosRowIndex =  0;
    TL1_BUFFER              *tl1_b        =  NULL;
    TL1_COMPLETION_CODE     tcc;
    int                     i;
    RTRV_OSUSER_SECU_resp_row *rowsPtr;
    char*                     script = OSCMD_RTRV_OSUSER_SECU_PATH;
    char                      parameters[MAX_OSUSER_NAME_SIZE * 2] = "";
    char                      fileName[35];
    int                       result;
    FILE*                     fp;
    char                      lines[MAX_OSUSER_SECU_ROWS][OSUSER_SECU_ROW_LENGTH];
    char                      xchr;
    char                      uidArray[MAX_OSUSER_SECU_ROWS][MAX_OSUSER_NAME_SIZE + 1];
    int                       uap;
    int                       page;
    int                       pcnd;
    int                       actTmout;
    int                       maxSes;
    int                       failedLogin;
    int                       currSes;
    int                       lastLogin;
    int                       passwdChange;
    int                       passwdExpir;
    char                      pstArray[MAX_OSUSER_SECU_ROWS][8];
    char                      sstArray[MAX_OSUSER_SECU_ROWS][16];

    memset(lines, 0, sizeof(lines));
    /* If the OSSECU response array can not be dynamically allocated */
    if ((rowsPtr =
         (RTRV_OSUSER_SECU_resp_row *)eosl_malloc(sizeof(
             RTRV_OSUSER_SECU_resp_row) * RTRV_OSUSER_SECU_ROWS)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_OSUSER_SECU_req",
                    "agc_EM_NE_RTRV_OSUSER_SECU_req malloc failure\n");
        return eosl_false;
    }

    if (_uid)
    {
        if (strlen(_uid) < MIN_OSUSER_NAME_SIZE || strlen(_uid) > MAX_OSUSER_NAME_SIZE)
        {            
            tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
            eosl_free(rowsPtr);
            return eosl_false;
        }
        
        strncpy(parameters, _uid, strlen(_uid) + 1);
        count = 1;
    }

    mkTmpFileName(fileName);
    result = runOSCommand(script, parameters, fileName);
    if (result != 0)
    {
        unlink(fileName);
        if( WEXITSTATUS(result) == 1)
        {
            tc_error_response(handle,ctag,TE_SROF,"Specific osuser doesn't exist");
        }
        else
        {
            tc_error_response(handle,ctag,TE_SROF,"RTRV_OSUSER_SECU Failed");
        }
        return eosl_false;
    }

    if ((fp = fopen(fileName, "r")) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_OSUSER_SECU_req",
                    "agc_EM_NE_RTRV_OSUSER_SECU_req unable to open result file\n");
        eosl_free(rowsPtr);
        tc_error_response( handle, ctag, TE_SROF, "RTRV_OSUSER_SECU Failed" );
        unlink(fileName);
        return eosl_false;
    }
    if (fgets(num, 9, fp) == NULL)          /* the first line of file contains the user number */
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_OSUSER_SECU_req",
                    "agc_EM_NE_RTRV_OSUSER_SECU_req unable to get user number from file\n");
        fclose(fp);
        eosl_free(rowsPtr);
        tc_error_response( handle, ctag, TE_SROF, "RTRV_OSUSER_SECU Failed" );
        unlink(fileName);
        return eosl_false;
    }

    if (count != 1)
    {
        sscanf(num, "%d", &count);
    }

    if (count >= MAX_OSUSER_SECU_ROWS || count < 0)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_OSUSER_SECU_req",
                    "agc_EM_NE_RTRV_OSUSER_SECU_req too many OSUSER secu returns\n");
        fclose(fp);
        unlink(fileName);
        eosl_free(rowsPtr);
        tc_error_response( handle, ctag, TE_SROF, "too many OSUSER secu" ); 
        return eosl_false;
    }
    
    /* For each user */
    for (i=0; i < count; i++)
    {
        fgets(lines[i], OSUSER_SECU_ROW_LENGTH, fp);
        if (sscanf(lines[i], "%s %d %d %d %d %d %d %d %d %d %d %s %s %c", uidArray[i], &uap, &page,
                   &pcnd, &actTmout, &maxSes, &failedLogin, &currSes, &lastLogin,
                   &passwdChange, &passwdExpir, pstArray[i], sstArray[i], &xchr) != 13)
        {
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_RTRV_OSUSER_SECU_req",
                        "agc_EM_NE_RTRV_OSUSER_SECU_req return format error\n");
            fclose(fp);
            unlink(fileName);
            eosl_free(rowsPtr);
            tc_error_response( handle, ctag, TE_SROF, "RTRV_OSUSER_SECU Failed" ); 
            return eosl_false;
        }

        /* Assign the current user info to the output object */
        rowsPtr[lumosRowIndex]._uid = uidArray[i];
        switch (uap)            /* 0 stands for ADMIN user, 3 stands for SW user, 4 stands for VIEW user */
        {
        case 0:
            rowsPtr[lumosRowIndex]._uap = UserPrivilege_ADMIN;
            break;
        case 3:
            rowsPtr[lumosRowIndex]._uap = UserPrivilege_SW;
            break;
        case 4:
            rowsPtr[lumosRowIndex]._uap = UserPrivilege_VIEW;
            break;
        default:
            procLogMsg (PLOG_ERROR,
                        "agc_EM_NE_RTRV_OSUSER_SECU_req",
                        "agc_EM_NE_RTRV_OSUSER_SECU_req unsupported uap\n");
            fclose(fp);
            unlink(fileName);
            eosl_free(rowsPtr);
            tc_error_response( handle, ctag, TE_SROF, "RTRV_OSUSER_SECU Failed" );
            return eosl_false;
        }
        rowsPtr[lumosRowIndex]._uap          = uap;
        rowsPtr[lumosRowIndex]._page         = page;
        rowsPtr[lumosRowIndex]._pcnd         = pcnd;
        rowsPtr[lumosRowIndex]._actTmout     = actTmout;
        rowsPtr[lumosRowIndex]._maxSes       = maxSes;
        rowsPtr[lumosRowIndex]._failedLogin  = failedLogin;
        rowsPtr[lumosRowIndex]._currSes      = currSes;
        rowsPtr[lumosRowIndex]._lastLogin    = lastLogin;
        rowsPtr[lumosRowIndex]._passwdChange = passwdChange;
        rowsPtr[lumosRowIndex]._passwdExpired  = passwdExpir;
        rowsPtr[lumosRowIndex]._pst          = &pstArray[i][0];
        if (strcmp(sstArray[i], "IS") == 0)
        {
            rowsPtr[lumosRowIndex]._sst = "";
        }
        else
        {
            rowsPtr[lumosRowIndex]._sst = &sstArray[i][0];
        }

        lumosRowIndex++;

        /* If the max number of output rows has been reached or no more entries */
        if ((lumosRowIndex >= RTRV_OSUSER_SECU_ROWS) || (i == count-1))
        {
            /* Assign the TL1 completion code for TL1 header output */
            tcc = (i == count-1) ? TCC_COMPLD : TCC_RTRV;
            /* Output the current batch of entries */
            agc_EM_NE_RTRV_OSUSER_SECU_resp(modifier,
                                          handle,
                                          ctag,
                                          tcc,
                                          rowsPtr,
                                          lumosRowIndex,
                                          "RTRV-OSUSER-SECU",
                                          tl1_b);
            lumosRowIndex = 0;
            usleep(100000); /* 100 ms - throttle output */
        }
    }

    fclose(fp);
    unlink(fileName);
    eosl_free(rowsPtr);
    return eosl_true;
}

/**
 */
eosl_bool agc_EM_NE_RTRV_PM_C_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pm_id, PMCmontype_ENUM * _montype, char * _monlev, Location_ENUM * _locn, Direction_ENUM * _dirn, char * _tmper, char * _mondat, char * _montm)
{
    TL1_BUF_t       buffer;
    DSX_ACK_BUF_t   resp, *response = (DSX_ACK_BUF_t *)&resp;
    char            tmpArray[16];
    int             tmpVal;
    int             tmpEnum;
    int             mon, day, hr, min;
    eosl_date       dateStruct;
    eosl_time       timeStruct;
    int             deviceMap;
    int             i;
    eosl_bool       retval;

    /*
     * prepare data structure
     */
    memset(&buffer, 0, SIZEOF_EQMCMD_RTRV_CMP_PM);

    if (ParseAidToDeviceIdMap(&buffer.CmdInfo.RtrvCmpPm.DeviceId, _pm_id, (AID_IOM), &deviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_montype)
    {
        buffer.CmdInfo.RtrvCmpPm.MonitoredType.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.MonitoredType.value = *_montype;
    }

    if (_monlev)
    {
        i = sscanf(_monlev, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonLev" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "UP") == 0)
        {
            tmpEnum = MONITOR_LEVEL_UP;
        }
        else if (eosl_strcasecmp(tmpArray, "DOWN") == 0)
        {
            tmpEnum = MONITOR_LEVEL_DOWN;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonLev" );
            return eosl_false;
        }
        buffer.CmdInfo.RtrvCmpPm.Monitoredlevel.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.Monitoredlevel.value = PACK_MONITOR_LEVEL(tmpVal, tmpEnum);
    }

    if (_locn)
    {
        buffer.CmdInfo.RtrvCmpPm.Location.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.Location.value = *_locn;
    }

    if (_dirn)
    {
        buffer.CmdInfo.RtrvCmpPm.Direction.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.Direction.value = *_dirn;
    }

    if (_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        buffer.CmdInfo.RtrvCmpPm.TimePeriod.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if (_mondat || _montm)
    {
        if (_mondat)
        {
            i = sscanf(_mondat, "%d-%d", &mon, &day);
            if ((i != 2) || (!validateDate(mon, day)))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonDat" );
                return eosl_false;
            }
        }
        else
        {
            dateStruct = eosl_get_current_date();
            mon = dateStruct.month;
            day = dateStruct.day;
        }

        if (_montm)
        {
            i = sscanf(_montm, "%d-%d", &hr, &min);
            if ((i != 2) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
        }
        else
        {
            timeStruct = eosl_get_current_time();
            hr = timeStruct.hour;
            min = timeStruct.minute;
        }

        buffer.CmdInfo.RtrvCmpPm.Time.valid = VALID_VALUE;
        buffer.CmdInfo.RtrvCmpPm.Time.value = PACK_TIME(mon, day, hr, min);
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_CMP_PM,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_CMP_PM,
                  (TL1_CMD_BUF_t *)&resp, sizeof(DSX_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_PM_C_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_EQM, response->Tl1Cmd.Error );
        return eosl_false;
    }

    /* move to tl1tlca.c for MORE_TO_FOLLOW processing */
    retval = RtrvPmCResp(response);


    return retval;
}

/**
 * This command retrieves current and historical performance data.
 * SCHED-PMREPT is used to schedule periodic performance reports of the
 * same data. The time intervals, AIDs and AIDTypes
 * of specific performance counters are given in the counter
 * definitions.
 *
 * Essential to NMA. GR-833.
 */
eosl_bool agc_EM_NE_RTRV_PM_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id, char * _montype, char * _monlev, Location_ENUM * _locn, Direction_ENUM * _dirn, char * _tmper, char * _mondat, char * _montm)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId      transId = ctag;
    TsTableId      tableId = 0;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    int            colCnt = 0;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length = sizeof(SMCMD_t);
    int            cmd = SM_GETNEXTMULTI_REQUEST;
    int            i;
    char           tmpArray[16];
    int            tmpVal = 0;
    U8             tmpEnum = 0;
        
    colArray.numCols  = 0;
    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = PMT1_TAB_ID;

        TL1LOGP (PLOG_ERROR, "PM-T1 aid:%s\n", _pm_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId = PMT1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch (enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype))
            {
              case T3T1MonType_ALL:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ALL;
                  break;
              case T3T1MonType_CSS:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CSS;
                  break;
              case T3T1MonType_CSS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CSS_FE;
                  break;
              case T3T1MonType_CV_L:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_L;
                  break;
              case T3T1MonType_CV_P:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_P;
                  break;
              case T3T1MonType_CV_PFE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_PFE;
                  break;
              case T3T1MonType_ES_L:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ES_L;
                  break;
              case T3T1MonType_ES_LFE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ES_LFE;
                  break;
              case T3T1MonType_SEFS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SEFS_FE;
                  break;
              case T3T1MonType_SES:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SES;
                  break;
              case T3T1MonType_SES_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SES_FE;
                  break;
              case T3T1MonType_UAS:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_UAS;
                  break;
              case T3T1MonType_UAS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_UAS_FE;
                  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid monType Value" );
                  return eosl_false;
                  break;
            }
            colCnt++;
        }

        if(_monlev)
        {
            if (sscanf(_monlev, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monLev Value" );
                return eosl_false;
            }

            if (eosl_strcasecmp(tmpArray, "UP") == 0)
            {
                tmpEnum = MONITOR_LEVEL_UP;
            }
            else if (eosl_strcasecmp(tmpArray, "DOWN") == 0)
            {
                tmpEnum = MONITOR_LEVEL_DOWN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monLev Value" );
                return eosl_false;
            }
            
            if((tmpVal < 0) || (tmpVal > 255))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid monLev Value" );
                return eosl_false;            
            }
            
            columns[colCnt].columnId = PMT1_MONLEV_VAL;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = tmpVal;
            colCnt++;
            
            columns[colCnt].columnId = PMT1_MONLEV_DIR;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = tmpEnum;
            colCnt++;
            
        }
        if(_locn)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid locn Value" );
            return eosl_false;
        }

        if(_dirn)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid dirn Value" );
            return eosl_false;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = PMT1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;

            if (eosl_strcasecmp(_tmper, "24-HR") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(_tmper, "15-MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }

#if 0            
            if (sscanf(_tmper, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }

            if (eosl_strcasecmp(tmpArray, "HR") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }
#endif
            
            colCnt++;
        }

        if(_mondat)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monDat Value" );
            return eosl_false;
        }

        if(_montm)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monTm Value" );
            return eosl_false;
        }

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                           &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
        {
             TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
             return eosl_false;
        }

        if (emfUnpkSmiGetMultiResp(rtrvPmT1MultiTsmResp, &smCmdPtr, &length, handle) == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }

        return eosl_true; 
    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = PM_E1_TAB_ID;

        TL1LOGP (PLOG_ERROR, "PM-E1 aid:%s\n", _pm_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == E1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        
        if(_montype)
        {
            columns[colCnt].columnId = PM_E1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(enum_lookup_no_case(&E1MonType_ENUM_type, _montype))
            {
            	case E1MonType_ALL:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_ALL;
            		  break;
            	case E1MonType_CSS:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_CSS;
            		  break;
           	case E1MonType_CSS_FE:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_CSS_FE;
            		  break;
            	case E1MonType_ESC:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_ES;
            		  break;
            	case E1MonType_ESC_FE:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_ES_FE;
            		  break;
            	case E1MonType_SESC:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_SES;
            		  break;
            	case E1MonType_SESC_FE:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_SES_FE;
            		  break;
            	case E1MonType_UASC:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_UAS;
            		  break;
            	case E1MonType_UASC_FE:
            		  columns[colCnt].value.value.longVal = PM_E1_MONTYPE_UAS_FE;
            		  break;
                case E1MonType_CV_L:
                          columns[colCnt].value.value.longVal = PM_E1_MONTYPE_LCV;
                          break;
                case E1MonType_CV_P:
                          columns[colCnt].value.value.longVal = PM_E1_MONTYPE_PCV;
                          break;
                case E1MonType_CV_PFE:
                          columns[colCnt].value.value.longVal = PM_E1_MONTYPE_PCV_FE;
                          break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, monType Invalid" );
                  return eosl_false;
            }
            colCnt++;
        }

        if(_monlev)
        {
            if (sscanf(_monlev, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monLev Value" );
                return eosl_false;
            }
            
            if (eosl_strcasecmp(tmpArray, "UP") == 0)
            {
                tmpEnum = MONITOR_LEVEL_UP;
            }
            else if (eosl_strcasecmp(tmpArray, "DOWN") == 0)
            {
                tmpEnum = MONITOR_LEVEL_DOWN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }

            if((tmpVal < 0) || (tmpVal > 255))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid monLev Value" );
                return eosl_false;            
            }
            
            columns[colCnt].columnId = PM_E1_MONLEV_VAL;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = tmpVal;
            colCnt++;
            
            columns[colCnt].columnId = PM_E1_MONLEV_DIR;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = tmpEnum;
            colCnt++;
                        
        }

        if(_locn)
        {
            columns[colCnt].columnId = PM_E1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
            case Location_FEND:
                columns[colCnt].value.value.longVal = PM_E1_LOCN_FEND;
                break;

            case Location_NEND:
                columns[colCnt].value.value.longVal = PM_E1_LOCN_NEND;
                break;

            default:
                break;
            }
            colCnt++;
        }
        
        if(_dirn)
        {
            /* _dirn must be NULL */
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid dirn Value" );
            return eosl_false;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = PM_E1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;
            i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
            if (i != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
                return eosl_false;
            }

            if (eosl_strcasecmp(tmpArray, "HR") == 0)
            {
                columns[colCnt].value.value.longVal = PM_E1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PM_E1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
            colCnt++;
        }
        
        if(_mondat)
        {
            /* _mondat must be NULL */
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monDat Value" );
            return eosl_false;
        }
        
        if(_montm)
        {
            /* _montm must be NULL */
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monTm Value" );
            return eosl_false;
        }
                
        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                           &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
        {
             TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
             return eosl_false;
        }

        if (emfUnpkSmiGetMultiResp(rtrvPmE1MultiTsmResp, &smCmdPtr, &length, handle) == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }

        return eosl_true; /*tc_compld_comment( handle, ctag, "RTRV-PM-E1" );*/
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - pm_id type is not supported at this time.");
        return eosl_false;        	
    }
    
#else
    DSX_CMD_BUF_t   buffer;
    DSX_ACK_BUF_t   resp, *response = (DSX_ACK_BUF_t *)&resp;

    char            *cmdClass;
    unsigned int    cmd;
    char            tmpArray[16];
    int             tmpVal;
    int             tmpEnum;
    int             mon, day, hr, min;
    eosl_date       dateStruct;
    eosl_time       timeStruct;
    int             i;
    eosl_bool       retval;

    /*
     * prepare t1 data structure
     */
    memset(&buffer, 0, SIZEOF_DSXCMD_RTRV_PM_RQST);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT |
                                   AID_OC3_STS1 | AID_OC12_STS1 |
                                   AID_OC3_STS1_T1 | AID_OC12_STS1_T1 |
                                   AID_STS1 | AID_AU3TUG3_T1 | AID_AU3 | AID_TUG3),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_T1;

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_T1;
            break;
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
            break;
        case DEVICE_MAP_IOM_T3:
            buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_T3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All T3s on DS3 board */
            buffer.DeviceMap = DEVICE_MAP_IOM_T3;
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_E1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_E1 | AID_AU3 | AID_TUG3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    
            buffer.DeviceMap = DEVICE_MAP_IOM_E1;
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:    
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_E1;
            break;
        case DEVICE_MAP_IOM_STM4_TUG3:    
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_E1;
            break;
        case DEVICE_MAP_IOM_STM1_AU3:    
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_E1;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:    
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_E1;
            break;
	default:
	    break;
        }
    }
    else if ((!eosl_strcasecmp(modifier, "OC3")) ||
             (!eosl_strcasecmp(modifier, "OC12")))
    {
        cmdClass = OC_CMD_CLASS; /* DS3_CMD_CLASS; */
        cmd = DS3CMD_RTRV_PM_OC;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_OC),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_OC3:
            if (!eosl_strcasecmp(modifier, "OC12"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM_OC12:
            if (!eosl_strcasecmp(modifier, "OC3"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM:
            if (!eosl_strcasecmp(modifier, "OC3"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC3;
            else if (!eosl_strcasecmp(modifier, "OC12"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC12;
            break;
        }
    }
    else if (!eosl_strcasecmp(modifier, "STS1"))
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_STS1 | AID_OC |
                                  AID_OC3_STS1 | AID_OC12_STS1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1;
            break;
        case DEVICE_MAP_IOM_STS1:
            break;
        case DEVICE_MAP_IOM_OC3:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            break;
        case DEVICE_MAP_IOM_OC12:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "VT1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_VT1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_OC3_STS1 | AID_OC3_STS1_VT |
                                  AID_OC12_STS1 | AID_OC12_STS1_VT |
                                  AID_STS1 | AID_STS1_VT),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "TUG3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_TUG3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TUG3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "AU3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_AU3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_AU3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU12") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_TU12;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU12|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU12;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU12;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU12;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU12;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU11") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_PM_TU11;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU11|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU11;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU11;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU11;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU11;
            break;
        }

    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - pm_id type is not supported at this time.");
        return eosl_false;
    }

    if (_montype)
    {
        switch (buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_T1:
        case DEVICE_MAP_IOM_T3_T1:
        case DEVICE_MAP_IOM_STS1_T1:
        case DEVICE_MAP_IOM_OC3_STS1_T1:
        case DEVICE_MAP_IOM_OC12_STS1_T1:
        case DEVICE_MAP_IOM_STM1_TUG3_T1:
        case DEVICE_MAP_IOM_STM4_TUG3_T1:
        case DEVICE_MAP_IOM_STM1_AU3_T1:
        case DEVICE_MAP_IOM_STM4_AU3_T1:
            tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case T3T1MonType_AISS_P:
                tmpEnum = DS3T1MonType_AISS_P;
                break;
            case T3T1MonType_ALL:
                tmpEnum = DS3T1MonType_ALL;
                break;
            case T3T1MonType_CSS_P:
                tmpEnum = DS3T1MonType_CSS_P;
                break;
            case T3T1MonType_CSS_PFE:
                tmpEnum = DS3T1MonType_CSS_PFE;
                break;
            case T3T1MonType_CV_L:
                tmpEnum = DS3T1MonType_CV_L;
                break;
            case T3T1MonType_CV_P:
                tmpEnum = DS3T1MonType_CV_P;
                break;
            case T3T1MonType_CV_PFE:
                tmpEnum = DS3T1MonType_CV_PFE;
                break;
            case T3T1MonType_ES_L:
                tmpEnum = DS3T1MonType_ES_L;
                break;
            case T3T1MonType_ES_LFE:
                tmpEnum = DS3T1MonType_ES_LFE;
                break;
            case T3T1MonType_ES_P:
                tmpEnum = DS3T1MonType_ES_P;
                break;
            case T3T1MonType_ES_PFE:
                tmpEnum = DS3T1MonType_ES_PFE;
                break;
            case T3T1MonType_ESA_P:
                tmpEnum = DS3T1MonType_ESA_P;
                break;
            case T3T1MonType_ESA_PFE:
                tmpEnum = DS3T1MonType_ESA_PFE;
                break;
            case T3T1MonType_ESB_P:
                tmpEnum = DS3T1MonType_ESB_P;
                break;
            case T3T1MonType_ESB_PFE:
                tmpEnum = DS3T1MonType_ESB_PFE;
                break;
            case T3T1MonType_FC:
                tmpEnum = DS3T1MonType_FC;
                break;
            case T3T1MonType_FC_FE:
                tmpEnum = DS3T1MonType_FC_FE;
                break;
            case T3T1MonType_LOSS_L:
                tmpEnum = DS3T1MonType_LOSS_L;
                break;
            case T3T1MonType_SAS_P:
                tmpEnum = DS3T1MonType_SAS_P;
                break;
            case T3T1MonType_SEFS_PFE:
                tmpEnum = DS3T1MonType_SEFS_PFE;
                break;
            case T3T1MonType_SES_L:
                tmpEnum = DS3T1MonType_SES_L;
                break;
            case T3T1MonType_SES_P:
                tmpEnum = DS3T1MonType_SES_P;
                break;
            case T3T1MonType_SES_PFE:
                tmpEnum = DS3T1MonType_SES_PFE;
                break;
            case T3T1MonType_UAS_P:
                tmpEnum = DS3T1MonType_UAS_P;
                break;
            case T3T1MonType_UAS_PFE:
                tmpEnum = DS3T1MonType_UAS_PFE;
                break;
            default:
                tmpEnum = -1;
            }
            break;

        case DEVICE_MAP_IOM_T3:
            tmpEnum = enum_lookup_no_case(&T3MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_OC3:
        case DEVICE_MAP_IOM_OC12:
            tmpEnum = enum_lookup_no_case(&OCnMonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1:
        case DEVICE_MAP_IOM_OC3_STS1:
        case DEVICE_MAP_IOM_OC12_STS1:
            tmpEnum = enum_lookup_no_case(&Sts1MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1_VT1:
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            tmpEnum = enum_lookup_no_case(&VtMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_E1:
        case DEVICE_MAP_IOM_STM1_TUG3_E1:
        case DEVICE_MAP_IOM_STM4_TUG3_E1:
        case DEVICE_MAP_IOM_STM1_AU3_E1:
        case DEVICE_MAP_IOM_STM4_AU3_E1:
            tmpEnum = enum_lookup_no_case(&E1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case E1MonType_AISS:
                tmpEnum = DS3E1MonType_AISS;
                break;
            case E1MonType_ALL:
                tmpEnum = DS3E1MonType_ALL;
                break;
            case E1MonType_BBEC:
                tmpEnum = DS3E1MonType_BBEC;
                break;
            case E1MonType_BBEC_FE:
                tmpEnum = DS3E1MonType_BBEC_FE;
                break;
            case E1MonType_BBER1:
                tmpEnum = DS3E1MonType_BBER1;
                break;
            case E1MonType_BBER1_FE:
                tmpEnum = DS3E1MonType_BBER1_FE;
                break;
            case E1MonType_CV:
                tmpEnum = DS3E1MonType_CV;
                break;
            case E1MonType_ESC:
                tmpEnum = DS3E1MonType_ESC;
                break;
            case E1MonType_ESC_FE:
                tmpEnum = DS3E1MonType_ESC_FE;
                break;
            case E1MonType_ESR1:
                tmpEnum = DS3E1MonType_ESR1;
                break;
            case E1MonType_ESR1_FE:
                tmpEnum = DS3E1MonType_ESR1_FE;
                break;
            case E1MonType_ESR2:
                tmpEnum = DS3E1MonType_ESR2;
                break;
            case E1MonType_ESR2_FE:
                tmpEnum = DS3E1MonType_ESR2_FE;
                break;
            case E1MonType_ESR3:
                tmpEnum = DS3E1MonType_ESR3;
                break;
            case E1MonType_ESR3_FE:
                tmpEnum = DS3E1MonType_ESR3_FE;
                break;
            case E1MonType_LOSS:
                tmpEnum = DS3E1MonType_LOSS;
                break;
            case E1MonType_OOFS:
                tmpEnum = DS3E1MonType_OOFS;
                break;
            case E1MonType_RAI:
                tmpEnum = DS3E1MonType_RAI;
                break;
            case E1MonType_RAI_FE:
                tmpEnum = DS3E1MonType_RAI_FE;
                break;
            case E1MonType_SESC:
                tmpEnum = DS3E1MonType_SESC;
                break;
            case E1MonType_SESC_FE:
                tmpEnum = DS3E1MonType_SESC_FE;
                break;
            case E1MonType_SESR1:
                tmpEnum = DS3E1MonType_SESR1;
                break;
            case E1MonType_SESR1_FE:
                tmpEnum = DS3E1MonType_SESR1_FE;
                break;
            case E1MonType_SESR2:
                tmpEnum = DS3E1MonType_SESR2;
                break;
            case E1MonType_SESR2_FE:
                tmpEnum = DS3E1MonType_SESR2_FE;
                break;
            case E1MonType_SESR3:
                tmpEnum = DS3E1MonType_SESR3;
                break;
            case E1MonType_SESR3_FE:
                tmpEnum = DS3E1MonType_SESR3_FE;
                break;
            case E1MonType_SESR4:
                tmpEnum = DS3E1MonType_SESR4;
                break;
            case E1MonType_SESR4_FE:
                tmpEnum = DS3E1MonType_SESR4_FE;
                break;
            case E1MonType_UASC:
                tmpEnum = DS3E1MonType_UASC;
                break;
            case E1MonType_UASC_FE:
                tmpEnum = DS3E1MonType_UASC_FE;
                break;
            case E1MonType_CSS:
                tmpEnum = DS3E1MonType_CSS;
                break;
            case E1MonType_LOFS:
            default:
                tmpEnum = -1;
            }
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:
        case DEVICE_MAP_IOM_STM4_TUG3:
            tmpEnum = enum_lookup_no_case(&TugnMonType_ENUM_type, _montype);
	    break;
        case DEVICE_MAP_IOM_STM1_AU3:
        case DEVICE_MAP_IOM_STM4_AU3:
            tmpEnum = enum_lookup_no_case(&Au3nMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_STM1_TUG3_TU12:
        case DEVICE_MAP_IOM_STM4_TUG3_TU12:
        case DEVICE_MAP_IOM_STM1_AU3_TU12:
        case DEVICE_MAP_IOM_STM4_AU3_TU12:
        case DEVICE_MAP_IOM_STM1_TUG3_TU11:
        case DEVICE_MAP_IOM_STM4_TUG3_TU11:
        case DEVICE_MAP_IOM_STM1_AU3_TU11:
        case DEVICE_MAP_IOM_STM4_AU3_TU11:
            tmpEnum = enum_lookup_no_case(&TUnMontype_ENUM_type, _montype);
            break;

          default:
              tmpEnum = -1;
              break;
        }

        if (tmpEnum == -1)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> montype" );
            return eosl_false;
        }
        buffer.Data.RtrvPmRqst.MonitoredType.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.MonitoredType.value = tmpEnum;
    }

    if (_monlev)
    {
        i = sscanf(_monlev, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonLev" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "UP") == 0)
        {
            tmpEnum = MONITOR_LEVEL_UP;
        }
        else if (eosl_strcasecmp(tmpArray, "DOWN") == 0)
        {
            tmpEnum = MONITOR_LEVEL_DOWN;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonLev" );
            return eosl_false;
        }
        buffer.Data.RtrvPmRqst.Monitoredlevel.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.Monitoredlevel.value = PACK_MONITOR_LEVEL(tmpVal, tmpEnum);
    }

    if (_locn)
    {
        buffer.Data.RtrvPmRqst.Location.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.Location.value = *_locn;
    }

    if (_dirn)
    {
        buffer.Data.RtrvPmRqst.Direction.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.Direction.value = *_dirn;
    }

    if (_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        buffer.Data.RtrvPmRqst.TimePeriod.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if (_mondat || _montm)
    {
        if (_mondat)
        {
            i = sscanf(_mondat, "%d-%d", &mon, &day);
            if ((i != 2) || (!validateDate(mon, day)))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonDat" );
                return eosl_false;
            }
        }
        else
        {
            dateStruct = eosl_get_current_date();
            mon = dateStruct.month;
            day = dateStruct.day;
        }

        if (_montm)
        {
            i = sscanf(_montm, "%d-%d", &hr, &min);
            if ((i != 2) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
        }
        else
        {
            timeStruct = eosl_get_current_time();
            hr = timeStruct.hour;
            min = timeStruct.minute;
        }

        buffer.Data.RtrvPmRqst.Time.valid = VALID_VALUE;
        buffer.Data.RtrvPmRqst.Time.value = PACK_TIME(mon, day, hr, min);
    }

    /*
    ** Prepare response buffer
    */

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_RTRV_PM_RQST,
                  (TL1_CMD_BUF_t *)&resp, sizeof(DSX_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_PM_DSnFacility_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response->Tl1Cmd.Error );
        return eosl_false;
    }

    /* move to tl1tlca.c for MORE_TO_FOLLOW processing */
    retval = RtrvPmDSnResp(response);

    return retval;
#endif
}


/**
 * Return the performance schedules known to the NE. Schedules
 * are created and deleted using SCHED-PMREPT.
 *
 * This message and other performance related messages rely on
 * the fact that only the reporting of PM Data and not how it
 * is gathered can be affected through TL1.
 *
 * In addition:
 * - accumulation periods are fixed on the NE
 * - all daily accumulation is from midnight to midnight
 * - all hourly accumulation begins and ends on the hour
 * - the duration of all periods less than an hour must be such that
 * an integral number of periods add up to an hour and that
 * there be a period transition on the hour.
 *
 * Defined in GR-833.
 */
eosl_bool agc_EM_NE_RTRV_PMSCHED_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id)
{
#if 0
    DSX_CMD_BUF_t       buffer;
    DSX_ACK_BUF_t       response;
    RTRV_PMSCHED_DSnFacility_resp_row   result[MAX_T1S_PER_T3];
    char                *cmdClass;
    unsigned int        cmd;
    char                T1Comment[] = "RTRV-PMSCHED-T1";
    char                T3Comment[] = "RTRV-PMSCHED-T3";
    char                *p_comment;
    int                 tmpUnits, tmpVal, tmpEnum;
    char                intervalStr[16];
    char                periodStr[16];
    int                 mon, day, hr, min;
    char                dateStr[16];
    char                timeStr[16];
    char                levelStr[16];
    char                offsetStr[16];
    char                aidStrings[MAX_T1S_PER_T3][32];
    int                 i;
    DSN_TYPE_t          dsnType;
    char                monTypeStrings[MAX_T1S_PER_T3][16];
    char                *temp;


    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_RTRV_PMSCHED_RQST);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        dsnType = DSN_DS1;
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PMSCHED_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        dsnType = DSN_DS3;
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_PMSCHED_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_T3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier - Only T1 & T3 supported at this time." );
        return eosl_false;
    }

    /*
    ** Prepare event
    */
    buffer.Tl1Cmd.Cmd = cmd;
    buffer.Tl1Cmd.SessionHandle = handle;
    buffer.Tl1Cmd.CTag = ctag;

    /*
    ** Prepare response buffer
    */

    /*
    ** Send event
    */
    if(TL1SendMsg(cmdClass, (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_RTRV_PMSCHED_RQST))
    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_PMSCHED_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
        return eosl_false;
    }

    /*
    ** load result into structure
    */
    memset(&result, 0, sizeof(RTRV_PMSCHED_DSnFacility_resp_row)*MAX_T1S_PER_T3);

    for (i = 0; i < response.Data.RtrvPmSchedResp.NumScheds; i++)
    {
        DeviceIdMapToAid(response.Data.RtrvPmSchedResp.Data[i].DeviceId,
                         response.DeviceMap,
                         aidStrings[i]);

        result[i]._pm_id = (TL1_AID)&(aidStrings[i][0]);

        result[i]._entitytype = NULL;

        tmpUnits = TIME_PERIOD_GET_UNITS(response.Data.RtrvPmSchedResp.Data[i].ReportInterval);
        tmpVal = TIME_PERIOD_GET_VALUE(response.Data.RtrvPmSchedResp.Data[i].ReportInterval);
        if (tmpUnits == TIME_PERIOD_HR)
        {
            eosl_sprintf(intervalStr, "%d-HR", tmpVal);

        }
        else if (tmpUnits == TIME_PERIOD_DAY)
        {
            eosl_sprintf(intervalStr, "%d-DAY", tmpVal);
        }
        else
        {
            eosl_sprintf(intervalStr, "%d-MIN", tmpVal);
        }
        result[i]._reptinvl = intervalStr;

        tmpVal = response.Data.RtrvPmSchedResp.Data[i].ReportStartTime;
        mon = TIME_GET_MON(tmpVal);
        day = TIME_GET_DAY(tmpVal);
        hr = TIME_GET_HR(tmpVal);
        min = TIME_GET_MIN(tmpVal);
        eosl_sprintf(dateStr, "%d-%d", mon, day);
        eosl_sprintf(timeStr, "%d-%d", hr, min);
        result[i]._reptdat = dateStr;
        result[i]._repttm = timeStr;

        result[i]._numinvl = &(response.Data.RtrvPmSchedResp.Data[i].NumReports);

        if (dsnType == DSN_DS1)
        {
            temp = enum_lookup_name(&T3T1MonType_ENUM_type, (T3T1MonType_ENUM)response.Data.RtrvPmSchedResp.Data[i].MonitoredType);
        }
        else if (dsnType == DSN_DS3)
        {
            temp = enum_lookup_name(&T3MonType_ENUM_type, (T3MonType_ENUM)response.Data.RtrvPmSchedResp.Data[i].MonitoredType);
        }

        /* OK if enum_lookup returns NULL, since this is an optional parameter. */
        if (temp == NULL)
        {
            result[i]._montype = NULL;
        }
        else
        {
            strncpy(monTypeStrings[i], temp, sizeof(monTypeStrings[i]));
            monTypeStrings[i][sizeof(monTypeStrings[i]) - 1] = '\0';
            result[i]._montype = &(monTypeStrings[i][0]);
        }

        tmpVal = MONITOR_LEVEL_GET_LEVEL(response.Data.RtrvPmSchedResp.Data[i].Monitoredlevel);
        tmpEnum = MONITOR_LEVEL_GET_DIRN(response.Data.RtrvPmSchedResp.Data[i].Monitoredlevel);
        if (tmpEnum == MONITOR_LEVEL_UP)
        {
            eosl_sprintf(levelStr, "%d-UP", tmpVal);
        }
        else
        {
            eosl_sprintf(levelStr, "%d-DOWN", tmpVal);
        }

        result[i]._monlev = levelStr;

        result[i]._locn = (Location_ENUM *)&(response.Data.RtrvPmSchedResp.Data[i].Location);
        result[i]._dirn = (Direction_ENUM *)&(response.Data.RtrvPmSchedResp.Data[i].Direction);
        tmpUnits = TIME_PERIOD_GET_UNITS(response.Data.RtrvPmSchedResp.Data[i].TimePeriod);
        tmpVal = TIME_PERIOD_GET_VALUE(response.Data.RtrvPmSchedResp.Data[i].TimePeriod);
        if (tmpUnits == TIME_PERIOD_HR)
        {
            eosl_sprintf(periodStr, "%d-HR", tmpVal);
        }
        else if (tmpUnits == TIME_PERIOD_DAY)
        {
            eosl_sprintf(periodStr, "%d-DAY", tmpVal);
        }
        else
        {
            eosl_sprintf(periodStr, "%d-MIN", tmpVal);
        }
        result[i]._tmper = periodStr;

        tmpVal = response.Data.RtrvPmSchedResp.Data[i].TimeOffset;
        day = TIME_OFFSET_GET_DAY(tmpVal);
        hr = TIME_OFFSET_GET_HR(tmpVal);
        min = TIME_OFFSET_GET_MIN(tmpVal);
        eosl_sprintf(offsetStr, "%d-%d-%d", day, hr, min);
        result[i]._tmofst = offsetStr;

        result[i]._inhmode = (InhibitMode_ENUM *)&response.Data.RtrvPmSchedResp.Data[i].InhibitMode;


    }
    return agc_EM_NE_RTRV_PMSCHED_DSnFacility_resp( modifier,
                                                    handle,
                                                    ctag,
                                                    TCC_COMPLD,
                                                    result,
                                                    i,
                                                    p_comment,
                                                    NULL);
#endif

   tc_error_response( handle, ctag, TE_IPNV, "Command not supported");
   return eosl_false;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_PRFL_CIC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _cicPrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    int            i;
    short          length;
    RTRV_PRFL_CIC_resp_row  rows[MAX_RTRV_PRFL_CIC_ROWS];
    RTRV_PRFL_CIC_STRUCT_t rtrvStruct;
    int       respRowIndex = 0;
    char           xchr;
    int            cicPrflId;
    TL1_BUFFER     *tl1_b = NULL;

    length = sizeof(SMCMD_t);
    tableId = TELICA_TABLE_SS7TRKPRFL_CFG;
    transId = ctag;
    colArray.numCols  = 0;
    colArray.colArray = columns;
    memset(rows, 0, sizeof(rows));

    if (_cicPrflId)
    {
        /*If the RTRV is a single a specific record
         *we don't use the MULTIGET reuest.
         *TSM uses two different APIs for these two diff cases
         */
        i = sscanf(_cicPrflId, "%d%c", &cicPrflId, &xchr); 
        if ((i != 1) || (cicPrflId < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> cicPrflId" );
            return eosl_false;
        }

        rowKey.numIndices          = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal = cicPrflId;

        rtrvStruct.Ptrs.TsmRtrvRowKeysPtr = &rowKey;
        rtrvStruct.Ptrs.RespRowPtr = (char *)&rows[respRowIndex];
        rtrvStruct.Ptrs.StringsPtr = (char *)&(rtrvStruct.Strings[respRowIndex]);

        retVal = emfPkSmiGetReq(SM_RTRV_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


        if (retVal == FALSE)
        {
            if (smCmd.Tl1Cmd.Error == TSSMI_NO_NEXT_ROW)
            {
                /* Past last record -- not really an error. */
                retVal = TRUE;
            }
            else
            {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
            }
        }

        /* Successfully retrieved some data -- unpack it. */
        retVal=emfUnpkSmiGetNextResp(rtrvPrflCicTsmResp, &smCmdPtr, &length, handle, (u8 *)&rtrvStruct);
        if (retVal == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }
        retVal = agc_EM_NE_RTRV_PRFL_CIC_resp( modifier,
                                               handle,
                                               transId,
                                               TCC_COMPLD,
                                               rows,
                                               1,
                                               "RTRV-PRFL-CIC",
                                               tl1_b);


    }
    else
    {
        /*If the RTRV is for all the records
         *we use the MULTIGET request.
         *TSM uses two different APIs for these two diff cases
         */

        rowKey.numIndices = 0;
        retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


        if (retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        retVal=emfUnpkSmiGetMultiResp(rtrvPrflCicMultiTsmResp, &smCmdPtr, &length, handle);
        if (retVal == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }
        else
        {
            return eosl_true;
        }

    }
    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_PRFL_SGPC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcPrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    int            i;
    char           xchr;
    int            pcPrflId;

    length     = sizeof(SMCMD_t);
    tableId    = MTPPC_PRFL_TAB_ID; 
    transId    = ctag;
    colArray.numCols  = 0;

    if (_pcPrflId)
    {
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        i = sscanf(_pcPrflId,"%d%c", &pcPrflId, &xchr);
        if ((i != 1) || (pcPrflId < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid PcPrflId" );  
            return eosl_false;
        }
        rowKey.rowIndex[0].value.longVal = pcPrflId;
    }
    else
    {
        /* Retrieve All */
        rowKey.numIndices = 0;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvPrflPcMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    if (retVal == TRUE)
    {
        return eosl_true;
    }
    return eosl_false;

}

/**
 * Retrieve  PRFL PFP
 */
eosl_bool agc_EM_NE_RTRV_PRFL_PFP_req( const char * modifier,\
									   eosl_handle handle,\
									   TL1_TAG ctag ,\
									   TL1_AID _pfpPrflId)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[0];
   SMCMD_t        smCmd;
   u8             *smCmdPtr = (u8 *)&smCmd;
   s16            retVal;
   short          length;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = PRFLPFP_TAB_ID;
   
   rowKey.numIndices = 0;
   colArray.numCols = 0;
   colArray.colArray = columns;

   if(_pfpPrflId)
   {
	   if(!IsInputStrInRange(_pfpPrflId,"0123456789"))
	   {
		   tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
		   return eosl_false;
	   }
	   rowKey.rowIndex[0].colType = TSSMI_LONG;
	   rowKey.rowIndex[0].value.longVal = atoi(_pfpPrflId);
	   rowKey.numIndices = 1;
   }

   retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
						   handle,
						   transId,
						   tableId,
						   &rowKey,
						   &colArray,
						   &smCmd,
						   TL1_MSG_TIMEOUT);
   if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvPrflPfpMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

/**
 */
eosl_bool agc_EM_NE_RTRV_PRFL_SLKL2_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp2PrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    int            mtp2Prfl;
    int            i;
    short          length;
    char           xchr=0;
    u8             *smCmdPtr = (u8 *)&smCmd;



    length = sizeof(SMCMD_t);
    transId = ctag;
    tableId = MTPLY2_PRFL_TAB_ID;

    if (_mtp2PrflId)
    {
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        i = sscanf(_mtp2PrflId, "%d%c", &mtp2Prfl, &xchr);
        if ((i != 1) || (mtp2Prfl < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Mtp2PrflId" );  
            return eosl_false;
        }
        rowKey.rowIndex[0].value.longVal = mtp2Prfl;
    }
    else
    {
        rowKey.numIndices = 0;
    }

    colArray.numCols  = 0;
    colArray.colArray = columns;
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);
    if (retVal == FALSE)
    {
       TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
       return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvPrflSlkl2MultiTsmResp, (u8 **)&smCmdPtr, &length, handle);
    
    if (retVal == FALSE)
    {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
    }
    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_PRFL_SLKL3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp3PrflId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    int            mtp3Prfl;
    int            i;
    short          length;
    char      xchr=0;
    u8             *smCmdPtr = (u8 *)&smCmd;


    length = sizeof(SMCMD_t);
    transId = ctag;
    tableId = MTPLY3_PRFL_TAB_ID;

    if (_mtp3PrflId)
    {
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        i = sscanf(_mtp3PrflId, "%d%c", &mtp3Prfl, &xchr);
        if ((i != 1) || (mtp3Prfl < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Mtp3PrflId" );  
            return eosl_false;
        }
        rowKey.rowIndex[0].value.longVal = mtp3Prfl;
    }
    else
    {
        /* Retrieve All */
        rowKey.numIndices = 0;
    }

    colArray.numCols  = 0;
    colArray.colArray = columns;
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if (retVal == FALSE)
    {
       TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
       return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvPrflSlkl3MultiTsmResp, &smCmdPtr, &length, handle);

    if (retVal == FALSE)
    {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
    }

    return eosl_true;
}

/**
 * Retrieve  RADIUS System
 */
eosl_bool agc_EM_NE_RTRV_RADIUS_SYS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _src)
{
#ifdef ATCA
    RTRV_RADIUS_SYS_resp_row    radiusSysResult = {0};
    eosl_bool   result;
    DB_RADIUS_CFG_t dbRadiusCfg = {0};

    if (getDbRadiusCfg(&dbRadiusCfg) != SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Not in valid state" );
        return eosl_false;
    }

    /* _src */
    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    radiusSysResult._src = "COM"; 

    radiusSysResult._prisrvr = dbRadiusCfg.priRadiusSrvr;
    radiusSysResult._prisrvrport = dbRadiusCfg.priRadiusSrvrPort;
    radiusSysResult._prisrvrkey = dbRadiusCfg.priRadiusSrvrKey;
    radiusSysResult._secsrvr = dbRadiusCfg.secRadiusSrvr;
    radiusSysResult._secsrvrport = dbRadiusCfg.secRadiusSrvrPort;
    radiusSysResult._secsrvrkey = dbRadiusCfg.secRadiusSrvrKey;
    radiusSysResult._timeout = dbRadiusCfg.radiusTimeOut;
    radiusSysResult._retry = dbRadiusCfg.radiusRetry;

    result = agc_EM_NE_RTRV_RADIUS_SYS_resp(modifier,
                                            handle,
                                            ctag,
                                            TCC_COMPLD,
                                            &radiusSysResult,
                                            1,
                                            "RTRV-RADIUS-SYS",
                                            NULL);

    return result;
#else  /* ifdef ATCA */   
    return tc_compld_comment( handle, ctag, "RTRV-RADIUS-SYS" );
#endif
}


/**
 */
eosl_bool agc_EM_NE_RTRV_ROUTE_SS7_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _routeSs7)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    int            pc, pcFormat;
    int            lset;

    length     = sizeof(SMCMD_t);
    tableId    = MTPROUT_TAB_ID;
    transId    = ctag;
    colArray.numCols  = 0;

    rowKey.numIndices = 0;

    if(_routeSs7)
    {
        if (ParsePcPlusOptionalIntAid(_routeSs7, &pc, &pcFormat, &lset) == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
            return eosl_false;
        }
        rowKey.numIndices = 2;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal = pc;
        
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = pcFormat;
        
        if (lset > 0)
        {
            rowKey.numIndices = 3;
            rowKey.rowIndex[2].colType = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal = lset;
        }
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvRouteSs7MultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    if (retVal == TRUE)
    {
        return eosl_true;
    }
    return eosl_false;

}

/**
 * Retrieve  RULE IPFLTR
 */
eosl_bool agc_EM_NE_RTRV_RULE_IPFLTR_req( const char * modifier,\
                                          eosl_handle handle,\
                                          TL1_TAG ctag ,\
                                          TL1_AID _ruleId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    char	   sp[RULE_IPFLTR_SPLEN_MAX+1] = "";
    int            ruleNum = 0;
    int            spEnum;
    int            cardType = RULE_IPFLTR_CARDTYPE_UNK;     
    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = RULE_IPFLTR_TAB_ID;
    
    rowKey.numIndices = 0;
    colArray.numCols  = 0;
    colArray.colArray = columns;
    
    if(_ruleId)
    {
#ifdef ATCA
        if(parseATCAIpFilterAid(_ruleId, &cardType,&sp[0], &ruleNum, &spEnum,AID_IPFLTR_PARTIAL) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
            return eosl_false;
        }
        else
        {
            rowKey.rowIndex[0].colType = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal = cardType;
	    rowKey.numIndices = 1;
	    if(spEnum != RULE_IPFLTR_SP_UNK)
	    {
                rowKey.rowIndex[1].colType = TSSMI_OCTET_STRING;
                rowKey.rowIndex[1].value.stringVal.ptr = sp;
                rowKey.rowIndex[1].value.stringVal.len = strlen(sp);
                rowKey.numIndices ++;
                if (ruleNum != 0)
                {
                    rowKey.rowIndex[2].colType = TSSMI_LONG;
                    rowKey.rowIndex[2].value.longVal = ruleNum;
                    rowKey.numIndices ++ ;
                }  
            }
	}
#else
        if(parseIpFilterAid(_ruleId, &sp[0], &ruleNum, &spEnum,
			    AID_IPFLTR_PARTIAL) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
            return eosl_false;
        }
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal = cardType; /* this is useless in LGP */
        rowKey.rowIndex[1].colType = TSSMI_OCTET_STRING;
        rowKey.rowIndex[1].value.stringVal.ptr = sp;
        rowKey.rowIndex[1].value.stringVal.len = strlen(sp);
        rowKey.numIndices = 2;
        if(ruleNum != 0)
        {
            rowKey.rowIndex[2].colType = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal = ruleNum;
            rowKey.numIndices = 3;
        }
#endif
    }
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvRuleIpFltrMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

eosl_bool agc_EM_NE_RTRV_SCCP_ROUTE_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    int            dpc;
    PointCodeFormat pcFormat = PC_INVALID;

#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif


    length = sizeof(SMCMD_t);
    tableId = SCCPROUTE_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 0;
    colArray.numCols = 0;
    colArray.colArray = columns;

    if(_pcId)
    {
        /* AID string format, LGP: <pc> */
        /* AID string format, ATCA: <netId>-DPC-<pc> */
    
#ifndef ATCA
        p_commonStr = _pcId;
#else
        if (ParseNetIdKey((char *)_pcId, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
        {
           tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid pcId");
           return eosl_false;
        }
#endif
    
        dpc = pc_atoi(p_commonStr, &pcFormat);
        if(dpc == -1)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, PC Invalid");
            return eosl_false;
        }

        rowKey.rowIndex[SCCPROUTE_PC].colType = TSSMI_LONG;
        rowKey.rowIndex[SCCPROUTE_PC].value.longVal = dpc;
        rowKey.rowIndex[SCCPROUTE_PCFORMAT].colType = TSSMI_LONG;
        rowKey.rowIndex[SCCPROUTE_PCFORMAT].value.longVal = pcFormat;
#ifndef ATCA
        rowKey.numIndices = 2;
#else
        rowKey.rowIndex[SCCPROUTE_NETID].colType = TSSMI_LONG;
        rowKey.rowIndex[SCCPROUTE_NETID].value.longVal = netId;
        rowKey.numIndices = 3;
#endif
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvSccpRouteMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

eosl_bool agc_EM_NE_RTRV_SCCP_SSN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sccpSsnAid)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    int            colCnt = 0;
    int            ssn;
    int            pc;
    int            pcFormat = PC_INVALID;
#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = SCCPSSN_TAB_ID;

    rowKey.numIndices = 0;
     
    if (_sccpSsnAid)
    {
        /* AID string format, LGP: [<pc>-<ssn>] */
        /* AID string format, ATCA: [<netId>-DPC-<pc>-<ssn>] */

#ifndef ATCA
        p_commonStr = _sccpSsnAid;
#else
        if (ParseNetIdKey((char *)_sccpSsnAid, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier" );
            return eosl_false;
        }
#endif

        if (ParsePcPlusIntAid(p_commonStr, &pc, &pcFormat, &ssn) == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier" );
            return eosl_false;
       }
#ifndef ATCA
       rowKey.numIndices = 2;
#else
       rowKey.numIndices = 3;
       rowKey.rowIndex[SCCPSSN_NETID].colType = TSSMI_LONG;
       rowKey.rowIndex[SCCPSSN_NETID].value.longVal = netId;
#endif
       rowKey.rowIndex[SCCPSSN_PC].colType = TSSMI_LONG;
       rowKey.rowIndex[SCCPSSN_PC].value.longVal = pc;

       rowKey.rowIndex[SCCPSSN_PCFORMAT].colType = TSSMI_LONG;
       rowKey.rowIndex[SCCPSSN_PCFORMAT].value.longVal = pcFormat;

       if (ssn> 0)
       {
          rowKey.numIndices++;
          rowKey.rowIndex[SCCPSSN_SSN].colType = TSSMI_LONG;
          rowKey.rowIndex[SCCPSSN_SSN].value.longVal = ssn;
       }

    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
        return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvSccpSsnMultiTsmResp,
                                  &smCmdPtr,
                                  &length,
                                  handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

/**
 */
eosl_bool agc_EM_NE_RTRV_SESSIONS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _sessionId)
{

    TL1_CMD_MSG_t      *bufferPtr;
    TL1_SESSION_RESP_t *localSessionsPtr;
    eosl_bool          peerEntriesExist  = eosl_false;
    eosl_bool          localEntriesExist = eosl_false;
    eosl_bool          retVal            = eosl_true;

    /* If the TL1 cmd msg can not be dynamically allocated */
    if ((bufferPtr = (TL1_CMD_MSG_t *)eosl_malloc(
        sizeof(TL1_CMD_MSG_t))) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_SESSIONS_req",
                    "agc_EM_NE_RTRV_SESSIONS_req malloc failure\n");
        return eosl_false;
    }

    /* If the TL1 cmd msg can not be dynamically allocated */
    if ((localSessionsPtr = (TL1_SESSION_RESP_t *)eosl_malloc(
        sizeof(TL1_SESSION_RESP_t))) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_SESSIONS_req",
                    "agc_EM_NE_RTRV_SESSIONS_req malloc failure\n");
        eosl_free(bufferPtr);
        return eosl_false;
    }

    /* Initialize the message */
    memset(bufferPtr, 0, sizeof(TL1_CMD_MSG_t));    
    memset(localSessionsPtr, 0, sizeof(TL1_SESSION_RESP_t));    

    /* If a session identifier was specified */
    if (_sessionId != NULL)
    {
        strcpy(&bufferPtr->Data.SessionReq.uid[0], _sessionId);
    }
    
    /* Dispatch the request message to the peer (standby) SP */
    if (TL1SendMsg(handle, ctag,
                   TL1_PEER_CLASS, TL1_SESSION_REQ, TL1CMD_SESSION,
                   (TL1_CMD_BUF_t *)bufferPtr, sizeof(TL1_CMD_MSG_t),
                   (TL1_CMD_BUF_t *)bufferPtr, sizeof(TL1_CMD_MSG_t),
                   2) != FAIL)
    {
        peerEntriesExist = (bufferPtr->Data.SessionResp.numSessions > 0);
    }

    /* Get the session data for this local (active) SP */
    GetSessionStatus(_sessionId, localSessionsPtr);
    localEntriesExist = (localSessionsPtr->numSessions > 0);

    if (peerEntriesExist && localEntriesExist)
    {
        /* Output the session data for the peer (standby) SP */
        RtrvSessionResp(handle, ctag, TCC_RTRV, &bufferPtr->Data.SessionResp);

        /* Output the session data for this local (active) SP */
        RtrvSessionResp(handle, ctag, TCC_COMPLD, localSessionsPtr);
    }
    else if (peerEntriesExist && (!localEntriesExist))
    {
        /* Output the session data for the peer (standby) SP */
        RtrvSessionResp(handle, ctag, TCC_COMPLD, &bufferPtr->Data.SessionResp);
    }
    else if ((!peerEntriesExist) && localEntriesExist)
    {
        /* Output the session data for this local (active) SP */
        RtrvSessionResp(handle, ctag, TCC_COMPLD, localSessionsPtr);
    }
    else
    {
        /* Design Note: If the wildcard (i.e. no AID specified) form of this
         *     command was invoked, this code block will not be reached -
         *     logic being that at least 1 session must be active for this
         *     command to be invoked.  This means that an AID must have
         *     been specified which does not match any active sessions.
         */
        tc_error_response(handle, ctag, TE_IENE, "No such session");
        retVal = eosl_false;
    }

    /* Clean up */
    eosl_free(bufferPtr);
    eosl_free(localSessionsPtr);

    return retVal;
}

/**
 * Retrieve  SSH
 */
eosl_bool agc_EM_NE_RTRV_SSH_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _sshId)
{
    TL1_BUF_t         buffer;
    CMD_BUF_t         rsp;
    int               record = SSH_NUM;
    int               i;
    RTRV_SSH_resp_row result[SSH_NUM];

    memset(&buffer, -1, sizeof(TL1_BUF_t));

    /* In EQM side, 0 for CLIENT, 1 for SERVER, 2 for ALL */
    if(_sshId)
    {
        if (eosl_strncasecmp(_sshId, "CLIENT", strlen("CLIENT") + 1) == 0)
        {
            buffer.CmdInfo.EdSSH.SshId = 0;
        }
        else if(eosl_strncasecmp(_sshId, "SERVER", strlen("SERVER") + 1) == 0)
        {
            buffer.CmdInfo.EdSSH.SshId = 1;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
            return eosl_false;
        }
        record = 1;
    }
    else
    {
        buffer.CmdInfo.EdSSH.SshId = 2;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_SSH,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_SSH,
                  (TL1_CMD_BUF_t *)&rsp, sizeof(rsp),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, rsp.Buf.Error );
        return eosl_false;
    }

    if (record == 1)
    {
        if (buffer.CmdInfo.EdSSH.SshId == 0)
        {
            result[0]._sshId = "CLIENT";
            result[0]._version = rsp.CmdInfo.RtrvSSH[0].Version - 1;
        }
        else if (buffer.CmdInfo.EdSSH.SshId == 1)
        {
            result[0]._sshId = "SERVER";
            result[0]._version = rsp.CmdInfo.RtrvSSH[1].Version - 1;
        }
        else
        {
            tc_error_response( handle, ctag, TE_SROF, "Invalid returned sshId" );
            return eosl_false;
        }
    }
    else
    {
        for(i = 0; i < SSH_NUM; ++i)
        {
            if (rsp.CmdInfo.RtrvSSH[i].SshId == 0)
            {
                result[i]._sshId = "CLIENT";
            }
            else if (rsp.CmdInfo.RtrvSSH[i].SshId == 1)
            {
                result[i]._sshId = "SERVER";
            }
            else
            {
                tc_error_response( handle, ctag, TE_SROF, "Invalid returned sshId" );
                return eosl_false;
            }
            result[i]._version = rsp.CmdInfo.RtrvSSH[i].Version - 1;
        }
    }
    
    return agc_EM_NE_RTRV_SSH_resp( modifier,
                                           handle,
                                           ctag,
                                           TCC_COMPLD,
                                           result,
                                           record,
                                           "RTRV-SSH",
                                           NULL );
}

/**
 */
eosl_bool agc_EM_NE_RTRV_SLK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7LnkId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    int            lnkId;
    short          length;
    int       i;
    char           lnkXchr;
    u8             *smCmdPtr = (u8 *)&smCmd;

    length = sizeof(SMCMD_t);

    colArray.numCols = 0;
    colArray.colArray = columns;
 
    tableId = MTPLNK_TAB_ID;
    transId = ctag;
    if (_ss7LnkId)
    {
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;

        i = sscanf(_ss7LnkId, "%d%c", &lnkId, &lnkXchr);
        if ((i != 1) || (lnkId < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> lnkId" );
            return eosl_false;
        }
        rowKey.rowIndex[0].value.longVal = lnkId;
    }
    else
    {
        rowKey.numIndices = 0;
    }
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if (retVal == FALSE)
    {
       TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
       return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvSlkMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
    }
    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_STATS_CC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ccId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;

    length = sizeof(SMCMD_t);

    tableId = TELICA_TABLE_CC_STS;
    transId = ctag;

    rowKey.numIndices = 0;
    colArray.numCols = 0;
    colArray.colArray = columns;

    if ((_ccId != NULL) && (eosl_strcasecmp(_ccId, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    retVal = emfPkSmiGetReq(SM_RTRV_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal== FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetResp(rtrvStatsCcTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

/**
 * Enter PRFL IPATKLOG
 */
eosl_bool agc_EM_NE_ENT_PRFL_IPATKLOG_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkLogPrflId,\
									int * _atkLogInterval,\
									int * _maxPktStreams)
{
	TL1_EMF_IPATK_DATA_t      buffer;
	SMCMD_t                   smCmd;
	/* Prepare data structure */
	memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
	memset(&smCmd, 0, sizeof(SMCMD_t));
	if(_ipAtkLogPrflId)
	{
		if(!(IsInputStrInRange(_ipAtkLogPrflId,"0123456789")))
		{
			tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid ipAtkLogPrflId");
			return eosl_false;
		}
		buffer.Data.EntPrfl.LogPrflId = atoi(_ipAtkLogPrflId);
		if((buffer.Data.EntPrfl.LogPrflId < 1)||(buffer.Data.EntPrfl.LogPrflId > 32) )
		{
			tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> ipAtkLogPrflId");
			return eosl_false;
		}
	}
	if(_atkLogInterval)
	{
		if((*_atkLogInterval > 60)||(*_atkLogInterval < 10))
		{
			tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> atkLogInterval");
			return eosl_false;
		}
		buffer.Data.EntPrfl.LogInterval = *_atkLogInterval;
	}
	else
   {
		buffer.Data.EntPrfl.LogInterval = 10;    
   }

   if(_maxPktStreams)
   {
		if ((*_maxPktStreams < 0)||*_maxPktStreams > 50)
	   {
		    tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range ->maxPktStreams");
		    return eosl_false;
	   }
	   buffer.Data.EntPrfl.MaxPackets = *_maxPktStreams;
   }
   else
   {
	    buffer.Data.EntPrfl.MaxPackets = 50;
   }

    /*
    ** Send event
    */
    if (TL1SendMsg(handle, ctag,
		   TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		   CMD_ENT_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_ENT_PRFL_IPATKLOG,
		   (TL1_CMD_BUF_t *)&smCmd, sizeof(SMCMD_t),
		   TL1_MSG_TIMEOUT) == FAIL)
    {
	    procLogMsg(PLOG_ERROR,
		       "agc_EM_NE_ENT_PRFL_IPATKLOG_req",
		       "agc_EM_NE_ENT_PRFL_IPATKLOG_req: bad response \n");
	    TL1ErrorResp(handle, ctag, CMD_EQM, smCmd.Tl1Cmd.Error);
	    return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "ENT-PRFL-IPATKLOG" );
}


eosl_bool agc_EM_NE_RTRV_STATS_ISDNMSG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _isdnIfNum)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          retVal;
    short          length;
    unsigned int   cmd;
    RTRV_STATS_ISDNMSG_resp_row  rows[MAX_RTRV_STATS_ISDNMSG_ROWS];
    RTRV_STATS_ISDNMSG_STRUCT_t rtrvStruct;
    int       respRowIndex = 0;
    TL1_BUFFER     *tl1_b = NULL;
    char           comment[] = "RTRV-STATS-ISDNMSG";
    int            ifNumber;
    int       i;
    char      xchr=0;


    length = sizeof(SMCMD_t);

    transId = ctag;
    tableId = TELICA_TABLE_ISDN_STS;

    if (_isdnIfNum)
    {
        cmd = SM_RTRV_REQUEST;
        i = sscanf(_isdnIfNum, "%d%c", &ifNumber, &xchr);
        if ((i != 1) || (ifNumber < 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> ifNumber" );
            return eosl_false;
        }
        rowKey.numIndices = 1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal = ifNumber;
    }
    else
    {
        /* Retrieve All */
        cmd = SM_GETNEXT_REQUEST;
        rowKey.numIndices = 0;
    }

    colArray.numCols  = 0;
    colArray.colArray = columns;
    memset(rows, 0, sizeof(rows));

    rtrvStruct.Ptrs.TsmRtrvRowKeysPtr = &rowKey;
    rtrvStruct.Ptrs.RespRowPtr = (char *)&rows[respRowIndex];
    rtrvStruct.Ptrs.StringsPtr = (char *)&(rtrvStruct.Strings[respRowIndex]);

    while (TRUE)  /* Loop until we get an error back */
    {
        retVal = emfPkSmiGetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


        if (retVal == FALSE)
        {
            if (smCmd.Tl1Cmd.Error == TSSMI_NO_NEXT_ROW)
            {
                /* Past last record -- not really an error. */
                retVal = TRUE;
            }
            else
            {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
            }
            break;  /* exit while loop */
        }

        /* Successfully retrieved some data -- unpack it. */
        retVal=emfUnpkSmiGetNextResp(rtrvStatsIsdnMsgTsmResp, &smCmdPtr, &length, handle, (u8 *)&rtrvStruct);
        if (retVal == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }

        respRowIndex++;
        if (cmd != SM_GETNEXT_REQUEST)
        {
            break;
        }

        if (respRowIndex >= MAX_RTRV_STATS_ISDNMSG_ROWS)
        {
            /* Assume no errors need handling here. */
            retVal = agc_EM_NE_RTRV_STATS_ISDNMSG_resp( modifier,
                                                        handle,
                                                        transId,
                                                        TCC_RTRV,
                                                        rows,
                                                        respRowIndex,
                                                        comment,
                                                        tl1_b);

            respRowIndex = 0;
            memset(rows, 0, sizeof(rows));
        }

        rtrvStruct.Ptrs.RespRowPtr = (char *)&rows[respRowIndex];
        rtrvStruct.Ptrs.StringsPtr = (char *)&(rtrvStruct.Strings[respRowIndex]);
    }

    if (respRowIndex > 0)
    {
        return agc_EM_NE_RTRV_STATS_ISDNMSG_resp( modifier,
                                                  handle,
                                                  transId,
                                                  TCC_COMPLD,
                                                  rows,
                                                  respRowIndex,
                                                  comment,
                                                  tl1_b);
    }
    else
    {
        /* Just returned a full load to Lumos and now we find we're done. */
        return tc_compld_comment( handle, ctag, "RTRV-STATS-ISDNMSG" );
    }
}

/**
 */
eosl_bool agc_EM_NE_RTRV_STATUS_ISDNBCHAN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _isdnBcStaChanId, int * _numChans)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    short          length;
    int            numHyphens=0;
    int            *intPtr;
    int            colCnt = 0;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;


    memset(&smCmd,0x0,sizeof(SMCMD_t));
    intPtr=aidStringToInts(_isdnBcStaChanId ,&numHyphens );
    if (!intPtr || (numHyphens > 2))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    length = sizeof(SMCMD_t);
    
    tableId = ISDNBCHAN_TAB_ID;
    transId = ctag;

    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = intPtr[0]; /* ifnum */
    rowKey.numIndices = 1;

    if (numHyphens >=1)
      {
    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = intPtr[1]; /* lnknum */
        rowKey.numIndices++;
      }
    if(numHyphens >=2)
      {
    rowKey.rowIndex[2].colType = TSSMI_LONG;
    rowKey.rowIndex[2].value.longVal = intPtr[2]; /* channum */
        rowKey.numIndices++;
      }

    if (_numChans)
    {
	if (numHyphens !=2)
	  {
	    tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid format, incomplete AID" );
            return eosl_false;
	  }
        if (*_numChans < 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid numChans" );
            return eosl_false;
        }
        /*columns[colCnt].columnId = ISDNBCHAN_CHAN_RANGE;*/
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_numChans;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;
  
    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvStatusIsdnBChanTsmResp,&smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    
    return eosl_true;
}

/**
 */
eosl_bool agc_EM_NE_RTRV_STATUS_ISDNLNK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _isdnLnkStaStateId)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    int            numHyphens=0;
    int            *intPtr;

	/*Bug 19451*/
	tc_error_response(handle, ctag, TE_ICNV, "Command Not Supported");
	return eosl_false;


    intPtr=aidStringToInts(_isdnLnkStaStateId ,&numHyphens );
    if ((intPtr== NULL) || (numHyphens != 1) )
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    length = sizeof(SMCMD_t);

    tableId = ISDN_LNK_STA_TABLE_ID;
    transId = ctag;

    rowKey.numIndices = 2;


    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = intPtr[0]; /* ifnum */

    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = intPtr[1]; /* lnknum */

    colArray.numCols  = 0;
    colArray.colArray = columns;

    retVal = emfPkSmiGetReq(SM_RTRV_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetResp(rtrvStatusIsdnLnkTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}


/**
 */
eosl_bool agc_EM_NE_RTRV_STATUS_ROUTESS7_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _routeSs7Aid)
{
    /*Adding new Function Telica prakash 10/12/01*/
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    int            pc, lset, pcFormat;

    length     = sizeof(SMCMD_t);
    tableId    = MTPROUT_STA_TAB_ID;
    transId    = ctag;
    colArray.numCols  = 0;

    if (ParsePcPlusOptionalIntAid(_routeSs7Aid, &pc, &pcFormat, &lset) == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> routeSs7" );
        return eosl_false;
    }
    rowKey.numIndices = 2;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = pc;
    
    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = pcFormat;
    
    if (lset > 0)
    {
        rowKey.numIndices = 3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = lset;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvStatusRouteSs7MultiTsmResp,&smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}


/**
 */
eosl_bool agc_EM_NE_RTRV_SYS_SECU_req( const char * modifier,\
                                       eosl_handle handle,\
                                       TL1_TAG ctag ,\
                                       TL1_AID _src)
{
    TsTransId      transId   = ctag;
    TsTableId      tableId   = SYS_SECU_TAB_ID;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length    = sizeof(SMCMD_t);

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    rowKey.numIndices = 0;
    colArray.numCols  = 0;
    colArray.colArray = columns;
    if (emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                       handle,
                       transId,
                       tableId,
                       &rowKey,
                       &colArray,
                       &smCmd,
                       TL1_MSG_TIMEOUT) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    if (emfUnpkSmiGetMultiResp(rtrvSysSecuTsmResp, &smCmdPtr,
                               &length, handle) == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF,
                          "Error unpacking signaling response data");
        return eosl_false;
    }
    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_RTRV_VERS_TL1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
    TL1_COMPLETION_CODE tcc=TCC_COMPLD;
    int count=0;
    TL1_BUFFER * tl1_b=NULL;
    char sw_cpu_version[32];

    while(adapterVer[count]._aid != NULL)
    {
        strncpy(sw_cpu_version, SW_CPU_VERSION, sizeof(SW_CPU_VERSION));
        adapterVer[count]._version = sw_cpu_version;
        count++;
    }

    return  agc_EM_NE_RTRV_VERS_TL1_resp( modifier, handle,ctag, tcc,
                                          adapterVer, count, NULL,tl1_b);
}


/**
 */
eosl_bool agc_EM_NE_RTRV_SYS_TL1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{

    TL1_COMPLETION_CODE tcc=TCC_COMPLD;
    RTRV_SYS_TL1_resp_row rows[1];
    TL1_BUFFER * tl1_b=NULL;
    static char com[]="COM";
    TL1_SESSION *ts = NULL;


    if( _src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    ts = ts_lookup_session(handle);
    /* bug88989 ++  coverity issue fix */
    if (ts == NULL)
    {
        return eosl_false;
    }
    /* bug88989 -- */
    rows[0]._com=com;
    rows[0]._tlntcntrlopt=ts->tlntcntrlopt;
    rows[0]._promptmode=getMemEscForPromptMode();

    return agc_EM_NE_RTRV_SYS_TL1_resp(modifier, 
									   handle, 
									   ctag, 
									   tcc, 
									   rows, 
									   1, 
									   "RTRV-SYS-TL1",
									   tl1_b);
}


/**
 */
eosl_bool agc_EM_NE_RTRV_T3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id)
{
    DSX_CMD_BUF_t       buffer;
    DSX_ACK_BUF_t       response;
    RTRV_T3_resp_row    result[DS3HM_NUM_T3_PORTS];
    int                 i;
    int                 resultRows = 0;
    char                aidStrings[DS3HM_NUM_T3_PORTS][32];
    char                tmpPrimaryState[32];
    char                tmpPrimaryQualifier[32];
    char                primaryState[DS3HM_NUM_T3_PORTS][32];
    char                secondaryState[DS3HM_NUM_T3_PORTS][32];
    char                aiscStrings[DS3HM_NUM_T3_PORTS][64];
    char                mapStrings[DS3HM_NUM_T3_PORTS][64];
    int                 tmpT3;
    int                 tmpT3RespMap;
    int                 t3EnumBits;

    /*
    ** set up t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id, (AID_T3 | AID_IOM),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /* Handle wildcard DeviceMap ambiguities here */
    switch(buffer.DeviceMap)
    {
    case DEVICE_MAP_IOM:
        buffer.DeviceMap = DEVICE_MAP_IOM_T3;
        break;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_RTRV_IF,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&response, sizeof(DSX_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_T3_req","We have a bad response \n");
/* ??? Change to CMD_T3 when T3 error codes are in TL1ErrorResp. */
        TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
        return eosl_false;
    }

    /* modify our copy of device id if we are handling wildcard T3 */
    if (response.Data.T3BulkRtrvResp.NumEntries!=1)
    {
        SetLevel2(response.DeviceId, 1);
    }

    for (i = 0, resultRows = 0; i < response.Data.T3BulkRtrvResp.NumEntries; i++)
    {
        /* skip over interfaces assigned as STS1
         */
        if (!response.Data.T3BulkRtrvResp.Data[i].ValidData)
        {
            tmpT3 = GetLevel2(response.DeviceId);
            SetLevel2(response.DeviceId, (tmpT3 + 1)); /* for next T3 */
            continue;
        }

        DeviceIdMapToAid(response.DeviceId, response.DeviceMap, aidStrings[resultRows]);
        result[resultRows]._ds_id = (TL1_AID)&(aidStrings[resultRows][0]);
        /* Ignoring errors for now (shouldn't get any) */
        if (response.Data.T3BulkRtrvResp.Data[i].Aisc == 0)
        {
            strcpy(aiscStrings[resultRows], "NONE");
        }
        else
        {
            enumBitMapToStringList(response.Data.T3BulkRtrvResp.Data[i].Aisc, 0,
                                   &AISC_ENUM_type, aiscStrings[resultRows]);
        }
        result[resultRows]._aisc = &aiscStrings[resultRows][0];
        result[resultRows]._aist = (AlarmIndicationSignal_ENUM)response.Data.T3BulkRtrvResp.Data[i].Aist;
        result[resultRows]._fmt = (FMT_ENUM)response.Data.T3BulkRtrvResp.Data[i].Fmt;
        if (response.Data.T3BulkRtrvResp.Data[i].Idle == TRUE)
        {
            result[resultRows]._idle = ON_OFF_ON;
        }
        else
        {
            result[resultRows]._idle = ON_OFF_OFF;
        }
        result[resultRows]._lbo = response.Data.T3BulkRtrvResp.Data[i].Lbo;
        result[resultRows]._linecde = (T3LineCode_ENUM)response.Data.T3BulkRtrvResp.Data[i].Linecde;

        /* Map DS3 driver enums to Lumos enums. */
        tmpT3RespMap = response.Data.T3BulkRtrvResp.Data[i].Map;
        t3EnumBits = 0;
        if (tmpT3RespMap == 0)
        {
            t3EnumBits = 1 << T3Map_NA;
        }
        else
        {
            if (tmpT3RespMap & (1 << T3MAP_ASYNC))  /* Defined in dsx_cmds.h */
            {
                t3EnumBits |= (1 << T3Map_ASYNC);  /* Lumos definition */
            }
            if (tmpT3RespMap & (1 << T3MAP_DL))
            {
                t3EnumBits |= (1 << T3Map_DL);
            }
            if (tmpT3RespMap & (1 << T3MAP_SYNC))
            {
                t3EnumBits |= (1 << T3Map_SYNC);
            }
        }

        /* Ignoring errors for now (shouldn't get any) */
        enumBitMapToStringList(t3EnumBits, 0, &T3Map_ENUM_type, mapStrings[resultRows]);
        result[resultRows]._map = &mapStrings[resultRows][0];

        result[resultRows]._omode = (DSMode_ENUM)response.Data.T3BulkRtrvResp.Data[i].Omode;
        if (response.Data.T3BulkRtrvResp.Data[i].Pbit == TRUE)
        {
            result[resultRows]._pbit = ON_OFF_ON;
        }
        else
        {
            result[resultRows]._pbit = ON_OFF_OFF;
        }
        result[resultRows]._xbit = (XBit_ENUM)response.Data.T3BulkRtrvResp.Data[i].Xbit;
        result[resultRows]._xbitrcv = (XBitReceive_ENUM)response.Data.T3BulkRtrvResp.Data[i].Xbitrcv;
        result[resultRows]._xpol = (XBitPolarity_ENUM)response.Data.T3BulkRtrvResp.Data[i].Xpol;

        SetStateNames(response.Data.T3BulkRtrvResp.Data[i].State,
                      response.Data.T3BulkRtrvResp.Data[i].State2,
                      tmpPrimaryState,
                      tmpPrimaryQualifier,
                      &(secondaryState[resultRows][0]));
        if (strlen(tmpPrimaryQualifier) > 0)
        {
            sprintf(&(primaryState[resultRows][0]), "%s-%s", tmpPrimaryState, tmpPrimaryQualifier);
        }
        else
        {
            strcpy(&(primaryState[resultRows][0]), tmpPrimaryState);
        }

        result[resultRows]._pst = &(primaryState[resultRows][0]);
        if (strlen(secondaryState[resultRows]) > 0)
        {
            result[resultRows]._sst = &(secondaryState[resultRows][0]);
        }
        else
        {
            result[resultRows]._sst = NULL;
        }

        resultRows++;
        tmpT3 = GetLevel2(response.DeviceId);
        SetLevel2(response.DeviceId, (tmpT3 + 1)); /* for next T3 */
    }


    return agc_EM_NE_RTRV_T3_resp( modifier,
                                   handle,
                                   ctag,
                                   TCC_COMPLD,
                                   result,
                                   resultRows,
                                   "RTRV-T3",
                                   NULL);

}


/**
 * Retrieve the current threshold level of one or more
 * monitored performance counts. The violation of these
 * thresholds will trigger a condition. Thresholds are
 * provisioned using SET-TH.
 *
 * Defined in GR-833.
 */
eosl_bool agc_EM_NE_RTRV_TH_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id, char * _montype, Location_ENUM * _locn, char * _tmper)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = 0;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[MAX_TSM_COLS];
    SMCMD_t           smCmd;
    u8                *smCmdPtr = (u8 *)&smCmd;
    short             length = sizeof(SMCMD_t);
    int               cmd = SM_GETNEXTMULTI_REQUEST;
    int               colCnt = 0;
    char              tmpArray[16];
    int               tmpVal = 0;
    int               i = 0;
    char              tmpTmPerArray[16];
    
    colArray.numCols  = 0;

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = THT1_TAB_ID;

        TL1LOGP (PLOG_ERROR, "TH-T1 aid:%s\n", _pm_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId = THT1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch (enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype))
            {
              case T3T1MonType_ALL:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ALL;
                  break;
              case T3T1MonType_CSS:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CSS;
                  break;
              case T3T1MonType_CSS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CSS_FE;
                  break;
              case T3T1MonType_CV_L:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_L;
                  break;
              case T3T1MonType_CV_P:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_P;
                  break;
              case T3T1MonType_CV_PFE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_PFE;
                  break;
              case T3T1MonType_ES_L:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ES_L;
                  break;
              case T3T1MonType_ES_LFE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ES_LFE;
                  break;
              case T3T1MonType_SEFS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SEFS_FE;
                  break;
              case T3T1MonType_SES:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SES;
                  break;
              case T3T1MonType_SES_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SES_FE;
                  break;
              case T3T1MonType_UAS:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_UAS;
                  break;
              case T3T1MonType_UAS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_UAS_FE;
                  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid monType Value" );
                  return eosl_false;
                  break;
            }
            colCnt++;
        }

        if(_locn)
        {
            columns[colCnt].columnId = THT1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
            case Location_FEND:
                columns[colCnt].value.value.longVal = THT1_LOCN_FEND;
                break;

            case Location_NEND:
                columns[colCnt].value.value.longVal = THT1_LOCN_NEND;
                break;

            default:
                break;
            }
            colCnt++;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = THT1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;

            if (sscanf(_tmper, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }

            if ((eosl_strcasecmp(tmpArray, "HR") == 0) && (tmpVal == 24))
            {
                columns[colCnt].value.value.longVal = THT1_TMPER_24_HR;
            }
            else if ((eosl_strcasecmp(tmpArray, "MIN") == 0) && (tmpVal == 15))
            {
                columns[colCnt].value.value.longVal = THT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }
            colCnt++;
        }
        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                           &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
        {
             TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
             return eosl_false;
        }

        if (emfUnpkSmiGetMultiResp(rtrvThT1MultiTsmResp, &smCmdPtr, &length, handle) == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }

        return eosl_true;
    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = THE1_TAB_ID;

        TL1LOGP (PLOG_ERROR, "TH-T1 aid:%s\n", _pm_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == E1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId = THE1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(enum_lookup_no_case(&E1MonType_ENUM_type, _montype))
            {
            	case E1MonType_AISS:
            		  columns[colCnt].value.value.longVal = THE1_AISS;
            		  break;
            	case E1MonType_ALL:
            		  columns[colCnt].value.value.longVal = THE1_ALL;
            		  break;
            	case E1MonType_BBEC:
            		  columns[colCnt].value.value.longVal = THE1_BBEC;
            		  break;            	
            	case E1MonType_BBEC_FE:
            		  columns[colCnt].value.value.longVal = THE1_BBEC_FE;
            		  break;
            	case E1MonType_BBER1:
            		  columns[colCnt].value.value.longVal = THE1_BBER1;
            		  break;
            	case E1MonType_BBER1_FE:
            		  columns[colCnt].value.value.longVal = THE1_BBER1_FE;
            		  break;
            	case E1MonType_CV_L:
            		  columns[colCnt].value.value.longVal = THE1_CV_L;
            		  break;
            	case E1MonType_CV_P:
            		  columns[colCnt].value.value.longVal = THE1_CV_P;
            		  break;
            	case E1MonType_ESC:
            		  columns[colCnt].value.value.longVal = THE1_ESC;
            		  break;
            	case E1MonType_ESC_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESC_FE;
            		  break;
            	case E1MonType_ESR1:
            		  columns[colCnt].value.value.longVal = THE1_ESR1;
            		  break;
            	case E1MonType_ESR1_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR1_FE;
            		  break;
            	case E1MonType_ESR2:
            		  columns[colCnt].value.value.longVal = THE1_ESR2;
            		  break;
            	case E1MonType_ESR2_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR2_FE;
            		  break;
            	case E1MonType_ESR3:
            		  columns[colCnt].value.value.longVal = THE1_ESR3;
            		  break;
            	case E1MonType_ESR3_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR3_FE;
            		  break;
            	case E1MonType_LOSS:
            		  columns[colCnt].value.value.longVal = THE1_LOSS;
            		  break;
            	case E1MonType_OOFS:
            		  columns[colCnt].value.value.longVal = THE1_OOFS;
            		  break;
            	case E1MonType_RAI:
            		  columns[colCnt].value.value.longVal = THE1_RAI;
            		  break;
            	case E1MonType_RAI_FE:
            		  columns[colCnt].value.value.longVal = THE1_RAI_FE;
            		  break;
            	case E1MonType_SESC:
            		  columns[colCnt].value.value.longVal = THE1_SESC;
            		  break;
            	case E1MonType_SESC_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESC_FE;
            		  break;
            	case E1MonType_SESR1:
            		  columns[colCnt].value.value.longVal = THE1_SESR1;
            		  break;
            	case E1MonType_SESR1_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR1_FE;
            		  break;
            	case E1MonType_SESR2:
            		  columns[colCnt].value.value.longVal = THE1_SESR2;
            		  break;
            	case E1MonType_SESR2_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR2_FE;
            		  break;
            	case E1MonType_SESR3:
            		  columns[colCnt].value.value.longVal = THE1_SESR3;
            		  break;
            	case E1MonType_SESR3_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR3_FE;
            		  break;
            	case E1MonType_SESR4:
            		  columns[colCnt].value.value.longVal = THE1_SESR4;
            		  break;
            	case E1MonType_SESR4_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR4_FE;
            		  break;
            	case E1MonType_UASC:
            		  columns[colCnt].value.value.longVal = THE1_UASC;
            		  break;
            	case E1MonType_UASC_FE:
            		  columns[colCnt].value.value.longVal = THE1_UASC_FE;
            		  break;
            	case E1MonType_CSS:
            		  columns[colCnt].value.value.longVal = THE1_CSS;
            		  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, monType Invalid" );
                  return eosl_false;
            }
            colCnt++;
        }

        if(_locn)
        {
            columns[colCnt].columnId = THE1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
            case Location_FEND:
                columns[colCnt].value.value.longVal = THE1_LOCN_FEND;
                break;

            case Location_NEND:
                columns[colCnt].value.value.longVal = THE1_LOCN_NEND;
                break;

            default:
                break;
            }
            colCnt++;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = THE1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;
            i = sscanf(_tmper, "%d-%s", &tmpVal, tmpTmPerArray);
            if (i != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
                return eosl_false;
            }

            if ((eosl_strcasecmp(tmpTmPerArray, "HR") == 0) && (tmpVal == 24))
            {
                columns[colCnt].value.value.longVal = THE1_TMPER_24HR;
            }
            else if ((eosl_strcasecmp(tmpTmPerArray, "MIN") == 0) && (tmpVal == 15))
            {
                columns[colCnt].value.value.longVal = THE1_TMPER_15MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
            colCnt++;
        }
        
        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                           &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
        {
             TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
             return eosl_false;
        }

        if (emfUnpkSmiGetMultiResp(rtrvThE1MultiTsmResp, &smCmdPtr, &length, handle) == FALSE)
        {
            tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
            return eosl_false;
        }

        return eosl_true;
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Threshold type is not supported at this time.");
        return eosl_false;        	
    }

#else
    DSX_CMD_BUF_t   buffer;
    DSX_ACK_BUF_t   resp, *response = (DSX_ACK_BUF_t *)&resp;

    char            *cmdClass;
    unsigned int    cmd;
    char            tmpTmPerArray[16];
    int             tmpVal;
    int             tmpEnum;
    int             i;
    eosl_bool       retval;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_RTRV_TH_RQST);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT |
                                   AID_OC3_STS1 | AID_OC12_STS1 |
                                   AID_OC3_STS1_T1 | AID_OC12_STS1_T1 |
                                   AID_STS1|AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_T1;

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_T1;
            break;
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
            break;
        case DEVICE_MAP_IOM_T3:
            buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
            break;                
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
            break;                
        case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_T3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All T3s on DS3 board */
            buffer.DeviceMap = DEVICE_MAP_IOM_T3;
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_E1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_E1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    
            buffer.DeviceMap = DEVICE_MAP_IOM_E1;
            break;
        default:
            break;
        }
    }
    else if ((!eosl_strcasecmp(modifier, "OC3")) ||
             (!eosl_strcasecmp(modifier, "OC12")))
    {
        cmdClass = OC_CMD_CLASS; /* DS3_CMD_CLASS; */
        cmd = DS3CMD_RTRV_TH_OC;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_OC),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_OC3:
            if (!eosl_strcasecmp(modifier, "OC12"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM_OC12:
            if (!eosl_strcasecmp(modifier, "OC3"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM:
            if (!eosl_strcasecmp(modifier, "OC3"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC3;
            else if (!eosl_strcasecmp(modifier, "OC12"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC12;
            break;
        default:
            break;
        }
    }
    else if (!eosl_strcasecmp(modifier, "STS1"))
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_STS1 | AID_OC |
                                  AID_OC3_STS1 | AID_OC12_STS1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1;
            break;
        case DEVICE_MAP_IOM_STS1:
            break;
        case DEVICE_MAP_IOM_OC3:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            break;
        case DEVICE_MAP_IOM_OC12:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "VT1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_VT1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_OC3_STS1 | AID_OC3_STS1_VT |
                                  AID_OC12_STS1 | AID_OC12_STS1_VT |
                                  AID_STS1 | AID_STS1_VT),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "TUG3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_TUG3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TUG3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "AU3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_AU3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_AU3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU12") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_TU12;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU12|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU12;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU12;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU12;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU12;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU11") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_RTRV_TH_TU11;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU11|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU11;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU11;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU11;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU11;
            break;
        }
    }
    else
    {
        tc_error_response(handle, ctag, TE_IIAC,
                          "Invalid Access Identifier - Threshold type is not supported at this time.");
        return eosl_false;
    }

    if(_montype)
    {
        switch (buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_T1:
        case DEVICE_MAP_IOM_T3_T1:
        case DEVICE_MAP_IOM_STS1_T1:
        case DEVICE_MAP_IOM_OC3_STS1_T1:
        case DEVICE_MAP_IOM_OC12_STS1_T1:
        case DEVICE_MAP_IOM_STM1_TUG3_T1:
        case DEVICE_MAP_IOM_STM4_TUG3_T1:
        case DEVICE_MAP_IOM_STM1_AU3_T1:
        case DEVICE_MAP_IOM_STM4_AU3_T1:
            tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case T3T1MonType_AISS_P:
                tmpEnum = DS3T1MonType_AISS_P;
                break;
            case T3T1MonType_ALL:
                tmpEnum = DS3T1MonType_ALL;
                break;
            case T3T1MonType_CSS_P:
                tmpEnum = DS3T1MonType_CSS_P;
                break;
            case T3T1MonType_CSS_PFE:
                tmpEnum = DS3T1MonType_CSS_PFE;
                break;
            case T3T1MonType_CV_L:
                tmpEnum = DS3T1MonType_CV_L;
                break;
            case T3T1MonType_CV_P:
                tmpEnum = DS3T1MonType_CV_P;
                break;
            case T3T1MonType_CV_PFE:
                tmpEnum = DS3T1MonType_CV_PFE;
                break;
            case T3T1MonType_ES_L:
                tmpEnum = DS3T1MonType_ES_L;
                break;
            case T3T1MonType_ES_LFE:
                tmpEnum = DS3T1MonType_ES_LFE;
                break;
            case T3T1MonType_ES_P:
                tmpEnum = DS3T1MonType_ES_P;
                break;
            case T3T1MonType_ES_PFE:
                tmpEnum = DS3T1MonType_ES_PFE;
                break;
            case T3T1MonType_ESA_P:
                tmpEnum = DS3T1MonType_ESA_P;
                break;
            case T3T1MonType_ESA_PFE:
                tmpEnum = DS3T1MonType_ESA_PFE;
                break;
            case T3T1MonType_ESB_P:
                tmpEnum = DS3T1MonType_ESB_P;
                break;
            case T3T1MonType_ESB_PFE:
                tmpEnum = DS3T1MonType_ESB_PFE;
                break;
            case T3T1MonType_FC:
                tmpEnum = DS3T1MonType_FC;
                break;
            case T3T1MonType_FC_FE:
                tmpEnum = DS3T1MonType_FC_FE;
                break;
            case T3T1MonType_LOSS_L:
                tmpEnum = DS3T1MonType_LOSS_L;
                break;
            case T3T1MonType_SAS_P:
                tmpEnum = DS3T1MonType_SAS_P;
                break;
            case T3T1MonType_SEFS_PFE:
                tmpEnum = DS3T1MonType_SEFS_PFE;
                break;
            case T3T1MonType_SES_L:
                tmpEnum = DS3T1MonType_SES_L;
                break;
            case T3T1MonType_SES_P:
                tmpEnum = DS3T1MonType_SES_P;
                break;
            case T3T1MonType_SES_PFE:
                tmpEnum = DS3T1MonType_SES_PFE;
                break;
            case T3T1MonType_UAS_P:
                tmpEnum = DS3T1MonType_UAS_P;
                break;
            case T3T1MonType_UAS_PFE:
                tmpEnum = DS3T1MonType_UAS_PFE;
                break;
            default:
                tmpEnum = -1;
            }
            break;

        case DEVICE_MAP_IOM_T3:
            tmpEnum = enum_lookup_no_case(&T3MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_OC3:
        case DEVICE_MAP_IOM_OC12:
            tmpEnum = enum_lookup_no_case(&OCnMonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1:
        case DEVICE_MAP_IOM_OC3_STS1:
        case DEVICE_MAP_IOM_OC12_STS1:
            tmpEnum = enum_lookup_no_case(&Sts1MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1_VT1:
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            tmpEnum = enum_lookup_no_case(&VtMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_E1:
        case DEVICE_MAP_IOM_STM1_TUG3_E1:
        case DEVICE_MAP_IOM_STM4_TUG3_E1:
        case DEVICE_MAP_IOM_STM1_AU3_E1:
        case DEVICE_MAP_IOM_STM4_AU3_E1:
            tmpEnum = enum_lookup_no_case(&E1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case E1MonType_AISS:
                tmpEnum = DS3E1MonType_AISS;
                break;
            case E1MonType_ALL:
                tmpEnum = DS3E1MonType_ALL;
                break;
            case E1MonType_BBEC:
                tmpEnum = DS3E1MonType_BBEC;
                break;
            case E1MonType_BBEC_FE:
                tmpEnum = DS3E1MonType_BBEC_FE;
                break;
            case E1MonType_BBER1:
                tmpEnum = DS3E1MonType_BBER1;
                break;
            case E1MonType_BBER1_FE:
                tmpEnum = DS3E1MonType_BBER1_FE;
                break;
            case E1MonType_CV:
                tmpEnum = DS3E1MonType_CV;
                break;
            case E1MonType_ESC:
                tmpEnum = DS3E1MonType_ESC;
                break;
            case E1MonType_ESC_FE:
                tmpEnum = DS3E1MonType_ESC_FE;
                break;
            case E1MonType_ESR1:
                tmpEnum = DS3E1MonType_ESR1;
                break;
            case E1MonType_ESR1_FE:
                tmpEnum = DS3E1MonType_ESR1_FE;
                break;
            case E1MonType_ESR2:
                tmpEnum = DS3E1MonType_ESR2;
                break;
            case E1MonType_ESR2_FE:
                tmpEnum = DS3E1MonType_ESR2_FE;
                break;
            case E1MonType_ESR3:
                tmpEnum = DS3E1MonType_ESR3;
                break;
            case E1MonType_ESR3_FE:
                tmpEnum = DS3E1MonType_ESR3_FE;
                break;
            case E1MonType_LOSS:
                tmpEnum = DS3E1MonType_LOSS;
                break;
            case E1MonType_OOFS:
                tmpEnum = DS3E1MonType_OOFS;
                break;
            case E1MonType_RAI:
                tmpEnum = DS3E1MonType_RAI;
                break;
            case E1MonType_RAI_FE:
                tmpEnum = DS3E1MonType_RAI_FE;
                break;
            case E1MonType_SESC:
                tmpEnum = DS3E1MonType_SESC;
                break;
            case E1MonType_SESC_FE:
                tmpEnum = DS3E1MonType_SESC_FE;
                break;
            case E1MonType_SESR1:
                tmpEnum = DS3E1MonType_SESR1;
                break;
            case E1MonType_SESR1_FE:
                tmpEnum = DS3E1MonType_SESR1_FE;
                break;
            case E1MonType_SESR2:
                tmpEnum = DS3E1MonType_SESR2;
                break;
            case E1MonType_SESR2_FE:
                tmpEnum = DS3E1MonType_SESR2_FE;
                break;
            case E1MonType_SESR3:
                tmpEnum = DS3E1MonType_SESR3;
                break;
            case E1MonType_SESR3_FE:
                tmpEnum = DS3E1MonType_SESR3_FE;
                break;
            case E1MonType_SESR4:
                tmpEnum = DS3E1MonType_SESR4;
                break;
            case E1MonType_SESR4_FE:
                tmpEnum = DS3E1MonType_SESR4_FE;
                break;
            case E1MonType_UASC:
                tmpEnum = DS3E1MonType_UASC;
                break;
            case E1MonType_UASC_FE:
                tmpEnum = DS3E1MonType_UASC_FE;
                break;
            case E1MonType_CSS:
                tmpEnum = DS3E1MonType_CSS;
                break;
            case E1MonType_LOFS:
            default:
                tmpEnum = -1;
            }
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:
        case DEVICE_MAP_IOM_STM4_TUG3:
            tmpEnum = enum_lookup_no_case(&TugnMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
        case DEVICE_MAP_IOM_STM4_AU3:
            tmpEnum = enum_lookup_no_case(&Au3nMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_STM1_TUG3_TU12:
        case DEVICE_MAP_IOM_STM4_TUG3_TU12:
        case DEVICE_MAP_IOM_STM1_AU3_TU12:
        case DEVICE_MAP_IOM_STM4_AU3_TU12:
        case DEVICE_MAP_IOM_STM1_TUG3_TU11:
        case DEVICE_MAP_IOM_STM4_TUG3_TU11:
        case DEVICE_MAP_IOM_STM1_AU3_TU11:
        case DEVICE_MAP_IOM_STM4_AU3_TU11:
            tmpEnum = enum_lookup_no_case(&TUnMontype_ENUM_type, _montype);
            break;

          default:
              tmpEnum = -1;
              break;
        }

        if (tmpEnum == -1)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> montype" );
            return eosl_false;
        }

        buffer.Data.RtrvTh.MonitoredType.valid = VALID_VALUE;
        buffer.Data.RtrvTh.MonitoredType.value = tmpEnum;
    }

    if(_locn)
    {
        buffer.Data.RtrvTh.Location.valid = VALID_VALUE;
        buffer.Data.RtrvTh.Location.value = *_locn;
    }

    if(_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpTmPerArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }

        if (eosl_strcasecmp(tmpTmPerArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpTmPerArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpTmPerArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.RtrvTh.TimePeriod.valid = VALID_VALUE;
        buffer.Data.RtrvTh.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_RTRV_TH_RQST,
                  (TL1_CMD_BUF_t *)response, sizeof(DSX_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_TH_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response->Tl1Cmd.Error );
        return eosl_false;
    }

    /* move to tl1tlca.c for MORE_TO_FOLLOW processing */
    retval = RtrvThDSnResp(response);

    return retval;
#endif
}


/**
 */
eosl_bool agc_EM_NE_RTRV_TOLLFREE_NPA_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _CcNpa)
{ 
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    int            cCode;
    int            npa;
    char           retChar;
    char           tollFree[MAX_NPA_LENGTH + 1];
    char           countrycode_id[MAX_COUNTRYCODE_ID_LENGTH + 1];
        
    length = sizeof(SMCMD_t);
    tableId =TELICA_TABLE_TOLLFREE_NPA;
    transId = ctag;
    colArray.numCols = 0;
   
    countrycode_id[0]= 0;
    tollFree[0] = 0;
   
    if(!IsInputStrInRange(_CcNpa,"0123456789-")||(_CcNpa[strlen(_CcNpa)-1] == '-'))
    {
      tc_error_response(handle, ctag, TE_IIAC, "Input, Invalid Aid");
      return eosl_false;
    }
    retVal = sscanf(_CcNpa,"%d-%d%c[^0-9]", &cCode,&npa,&retChar);

    if (retVal<1||retVal>2)
    {
      tc_error_response(handle, ctag, TE_IIDT,
              "Input, Invalid Input  Enter Countrycode-NPA ");
      return eosl_false;
    }
    
    if((cCode<1||cCode>99999))
    {
       tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid range");
       return eosl_false;
    } 
     
    if(retVal == 2)
    {
      if((npa<1||npa>99999))
      {
          tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid range");
          return eosl_false;
      }
      sprintf(tollFree, "%d" , npa);
    }
    else
    {
      strcpy(tollFree,"\0");
    }

    sprintf(countrycode_id,"%d",cCode);

    
    if (retVal == 1)
    {
      rowKey.numIndices = 1;

      rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
      rowKey.rowIndex[0].value.stringVal.len = strlen(countrycode_id);
      rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) countrycode_id;
    }
    else
    if (retVal == 2)
    {
      rowKey.numIndices = 2;

      rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
      rowKey.rowIndex[0].value.stringVal.len = strlen(countrycode_id);
      rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) countrycode_id;

      rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
      rowKey.rowIndex[1].value.stringVal.len = strlen(tollFree);
      rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) tollFree;
    }
    else  /*ALL RECORD*/    
    {
      rowKey.numIndices = 0;        
    }

   retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }

   retVal=emfUnpkSmiGetMultiResp(rtrvTollFreeNPAMultiTsmResp, &smCmdPtr, &length, handle);

   if (retVal == FALSE)
   {
       tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
       return eosl_false;
   }
   if (retVal == TRUE)
   {
     return eosl_true;
   }
   return eosl_false;
}

/**
 * Retrieve  User LISECU
 */
#define MAX_USER_SECU_ROWS (8)
eosl_bool agc_EM_NE_RTRV_USER_LISECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid)
{
    int                     count         =  0;
    int                     lumosRowIndex =  0;
    TL1_BUFFER              *tl1_b        =  NULL;
    TL1_COMPLETION_CODE     tcc;
    int                     i;
    USER_DATA_t             *userDataPtr;
    RTRV_USER_LISECU_resp_row *rowsPtr;
    char                    tl1Owner[33]   = {0};

    char                    uidArray[MAX_USERS][MAX_USER_NAME_SIZE+1];
    char                    pstArray[MAX_USERS][USR_PST_LEN];
    char                    sstArray[MAX_USERS][USR_SST_LEN];

    TELICA_SESSION_DATA_t   *pTelicaSessionData;    

    /* If the SECU response array can not be dynamically allocated */
    if ((rowsPtr =
         (RTRV_USER_LISECU_resp_row *)eosl_malloc(sizeof(
             RTRV_USER_LISECU_resp_row) * MAX_USER_SECU_ROWS)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_USER_LISECU_req",
                    "agc_EM_NE_RTRV_USER_LISECU_req malloc failure\n");
        return eosl_false;
    }

    /* If a user ID has not been specified */
    if ( _uid == NULL)
    {
        count = tl1DbGetNumRows(TL1_USER_TABLE_NAME);
        count = (count > MAX_USERS) ? MAX_USERS : count;
        /* Has to be at least one user to issue this command */
        if (count == 0)
        {
            tc_error_response(handle,ctag,TE_EANS,
                              "Failed RTRV-USER-LISECU");
            eosl_free(rowsPtr);
            return eosl_false;
        }
    }
    else
    {
        if (strlen(_uid) > MAX_USER_NAME_SIZE)
        {
            tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
            eosl_free(rowsPtr);
            return eosl_false;
        }

        if (etsiLiValidate(handle, _uid) == eosl_false)
        {
            tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
            eosl_free(rowsPtr);
            return eosl_false;
        }
        count = 1;
    }

    pTelicaSessionData = getTelicaSessionData(handle);
    if (pTelicaSessionData == NULL)
    {
        tc_error_response(handle,ctag,TE_EANS, "Failed to get session data");
        eosl_free(rowsPtr);
        return eosl_false;
    }

    /* FID15737.0 START */
    if (getTL1UserOwnerName(handle, tl1Owner) != eosl_true)
    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ENT_USER_LISECU_req",
                   "agc_EM_NE_ENT_USER_LISECU_req get TL1 OWNER NAME failed!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        eosl_free(rowsPtr);
        return eosl_false;
    }
    /* FID15737.0 END */

    /* For each user */
    for (  i=0; i < count; i++)
    {
        /* If a specific user ID was specified */
        if (_uid)
        {
            /* Get user data for specified user ID */
            userDataPtr = GetUserDataFromDb(_uid);
            if (userDataPtr == NULL)
            {
                tc_error_response(handle,ctag,TE_EANS,
                                  "Input, Specified user does not exist");
                eosl_free(rowsPtr);
                return eosl_false;
            }
        }
        else
        {
            /* Get user data for specified table row */
            userDataPtr = GetUserDataByRow(i);
        }

        if (userDataPtr)
        {
            if ((pTelicaSessionData->etsiLiFlag != userDataPtr->etsiLi)||
                (eosl_strcmp(tl1Owner, userDataPtr->ownername) != 0))  /* FID 15737.0 */
            {
                eosl_free(userDataPtr);
            }
            else
            {
                strcpy(&uidArray[i][0], userDataPtr->username);
                formatUserState(getUserState(userDataPtr),
                                &pstArray[i][0], &sstArray[i][0]);

                /* Assign the current user info to the output object */
                rowsPtr[lumosRowIndex]._uid       = &uidArray[i][0];
                rowsPtr[lumosRowIndex]._uap       = userDataPtr->accLevel;
                rowsPtr[lumosRowIndex]._page      = userDataPtr->page;
                rowsPtr[lumosRowIndex]._pcnd      = userDataPtr->pcnd;
                rowsPtr[lumosRowIndex]._tmout     = userDataPtr->tmout;
                rowsPtr[lumosRowIndex]._freezable = 
                    (userDataPtr->freezeInh) ? BoolYN_N : BoolYN_Y;
                rowsPtr[lumosRowIndex]._pst       = &pstArray[i][0];
                rowsPtr[lumosRowIndex]._sst       = 
                    (sstArray[i][0] == 0) ? NULL : &sstArray[i][0];

                eosl_free(userDataPtr);
                lumosRowIndex++;
            }

            /* If the max number of output rows has been reached or no more entries */
            if ((lumosRowIndex >= MAX_USER_SECU_ROWS) || (i == count-1))
            {
                /* Assign the TL1 completion code for TL1 header output */
                tcc = (i == count-1) ? TCC_COMPLD : TCC_RTRV;
                /* Output the current batch of entries */
                agc_EM_NE_RTRV_USER_LISECU_resp(modifier,
                                              handle,
                                              ctag,
                                              tcc,
                                              rowsPtr,
                                              lumosRowIndex,
                                              "RTRV-USER-LISECU",
                                              tl1_b);
                lumosRowIndex = 0;
                usleep(100000); /* 100 ms - throttle output */
            }
        }
    }
    eosl_free(rowsPtr);

    return eosl_true;

}


/**
 * This command is used to retrieve the privilege/security
 * level of one or more or all users. It does not return a
 * user's password. Usually, only an administrator may invoke
 * the general version of this command. Individual users may
 * be able to retrieve their own information. The AID block
 * contains the user identifier(s).
 *
 * Defined in TR-835
 */
eosl_bool agc_EM_NE_RTRV_USER_SECU_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid)
{

    int                     count         =  0;
    int                     lumosRowIndex =  0;
    TL1_BUFFER              *tl1_b        =  NULL;
    TL1_COMPLETION_CODE     tcc;
    int                     i;
    USER_DATA_t             *userDataPtr;
    RTRV_USER_SECU_resp_row *rowsPtr;

    char                    uidArray[MAX_USERS][MAX_USER_NAME_SIZE+1];
    char                    pstArray[MAX_USERS][USR_PST_LEN];
    char                    sstArray[MAX_USERS][USR_SST_LEN];

    TELICA_SESSION_DATA_t   *pTelicaSessionData;

    /* If the SECU response array can not be dynamically allocated */
    if ((rowsPtr =
         (RTRV_USER_SECU_resp_row *)eosl_malloc(sizeof(
             RTRV_USER_SECU_resp_row) * MAX_USER_SECU_ROWS)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_RTRV_USER_SECU_req",
                    "agc_EM_NE_RTRV_USER_SECU_req malloc failure\n");
        return eosl_false;
    }

    /* If a user ID has not been specified */
    if ( _uid == NULL)
    {
        count = tl1DbGetNumRows(TL1_USER_TABLE_NAME);
        count = (count > MAX_USERS) ? MAX_USERS : count;
        /* Has to be at least one user to issue this command */
        if (count == 0)
        {
            tc_error_response(handle,ctag,TE_EANS, "Failed RTRV-USER-SECU");
            eosl_free(rowsPtr);
            return eosl_false;
        }
    }
    else
    {
        if (strlen(_uid) > MAX_USER_NAME_SIZE)
        {
            tc_error_response(handle,ctag,TE_PIUI,"User ID is not valid");
            eosl_free(rowsPtr);
            return eosl_false;
        }

        if (etsiLiValidate(handle, _uid) == eosl_false)
        {
            tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
            eosl_free(rowsPtr);
            return eosl_false;
        } 
        count = 1;
    }

    pTelicaSessionData = getTelicaSessionData(handle);
    if (pTelicaSessionData == NULL)
    {
        tc_error_response(handle,ctag,TE_EANS, "Failed to get session data");
        eosl_free(rowsPtr);
        return eosl_false;
    }
    
    /* For each user */
    for (  i=0; i < count; i++)
    {
        /* If a specific user ID was specified */
        if (_uid)
        {
            /* Get user data for specified user ID */
            userDataPtr = GetUserDataFromDb(_uid);
            if (userDataPtr == NULL)
            {
                tc_error_response(handle,ctag,TE_EANS, "Input, Specified user does not exist");
                eosl_free(rowsPtr);
                return eosl_false;
            }
        }
        else
        {
            /* Get user data for specified table row */
            userDataPtr = GetUserDataByRow(i);
        }

        if (userDataPtr)
        {
            if (pTelicaSessionData->etsiLiFlag != userDataPtr->etsiLi)
            {
                eosl_free(userDataPtr);
            }
            else
            {
                checkUserActTmout(userDataPtr, NULL);
                strcpy(&uidArray[i][0], userDataPtr->username);
                formatUserState(getUserState(userDataPtr), &pstArray[i][0], &sstArray[i][0]);
            
                /* Assign the current user info to the output object */
                rowsPtr[lumosRowIndex]._uid       = &uidArray[i][0];
                rowsPtr[lumosRowIndex]._uap       = userDataPtr->accLevel;
                rowsPtr[lumosRowIndex]._page      = userDataPtr->page;
                rowsPtr[lumosRowIndex]._pcnd      = userDataPtr->pcnd;
                rowsPtr[lumosRowIndex]._tmout     = userDataPtr->tmout;
                rowsPtr[lumosRowIndex]._calea     = (userDataPtr->calea)     ? BoolYN_Y : BoolYN_N;
                rowsPtr[lumosRowIndex]._freezable = (userDataPtr->freezeInh) ? BoolYN_N : BoolYN_Y;
                rowsPtr[lumosRowIndex]._maxSes    = userDataPtr->maxSes;
                rowsPtr[lumosRowIndex]._actTmout      = userDataPtr->actTmout;
                rowsPtr[lumosRowIndex]._authType      = userDataPtr->authType;
                rowsPtr[lumosRowIndex]._pst       = &pstArray[i][0];
                rowsPtr[lumosRowIndex]._sst       = (sstArray[i][0] == 0) ? NULL : &sstArray[i][0];
            
                eosl_free(userDataPtr);
                lumosRowIndex++;
            }
            
            /* If the max number of output rows has been reached or no more entries */
            if ((lumosRowIndex >= MAX_USER_SECU_ROWS) || (i == count-1))
            {
                /* Assign the TL1 completion code for TL1 header output */
                tcc = (i == count-1) ? TCC_COMPLD : TCC_RTRV;
                /* Output the current batch of entries */
                agc_EM_NE_RTRV_USER_SECU_resp(modifier,
                                              handle,
                                              ctag,
                                              tcc,
                                              rowsPtr,
                                              lumosRowIndex,
                                              "RTRV-USER-SECU",
                                              tl1_b);
                lumosRowIndex = 0;
                usleep(100000); /* 100 ms - throttle output */
            }
        }
    }
    eosl_free(rowsPtr);

    return eosl_true;

}

/**
 * EXEC SUIOM START
 */
eosl_bool agc_EM_NE_EXEC_SUIOM_START_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suName,\
									SuMode_ENUM * _suMode,\
									int * _suSoakTime)
{
    TL1_BUF_t          buffer;
    /* Check if there is already an existing running upgrade */
    if(_suName)
    {
        if(strlen(_suName) > SUAUTO_NAME_LEN)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SUNAME" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.StartSuIom.SuName, _suName, SUAUTO_NAME_LEN + 1);
    }

    if(_suMode)
    {
        switch(*_suMode)
        {
        case SuMode_FAST:
            buffer.CmdInfo.StartSuIom.SuMode = 3;
            break;
        case SuMode_MEDIUM:
            buffer.CmdInfo.StartSuIom.SuMode = 2;
            break;
        case SuMode_SLOW:
            buffer.CmdInfo.StartSuIom.SuMode = 1;
            break;
        default:
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid SUMODE" );
            return eosl_false;
        }
    }
    else
    {
        buffer.CmdInfo.StartSuIom.SuMode = 2;
    }

    if(_suSoakTime)
    {
        if(*_suSoakTime < 0 || *_suSoakTime > 60)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid SUSOAKTIME" );
            return eosl_false;
        }
        buffer.CmdInfo.StartSuIom.SuSoakTime = *_suSoakTime;
    }
    else
    {
        buffer.CmdInfo.StartSuIom.SuSoakTime = 0;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_START_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_START_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "EXEC-SUIOM-START" );
}

/**
 * EXEC SUIOM STOP
 */
eosl_bool agc_EM_NE_EXEC_SUIOM_STOP_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _src)
{
    TL1_BUF_t          buffer;
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_STOP_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_STOP_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "EXEC-SUIOM-STOP" );
}

/**
 * EXEC SUIOM VERIFY
 */
eosl_bool agc_EM_NE_EXEC_SUIOM_VERIFY_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suName)
{
    TL1_BUF_t          buffer;
    if(_suName)
    {
        if(strlen(_suName) > SUAUTO_NAME_LEN)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SUNAME" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.VerifySuIom.SuName, _suName, SUAUTO_NAME_LEN + 1);
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_VERIFY_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_VERIFY_SUIOM,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "EXEC-SUIOM-VERIFY" );
}

/**
 * Exercise Equipment
 */
eosl_bool agc_EM_NE_EX_EQPT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _iomOrSp,\
									Reportmode_ENUM * _reptmode,\
									ExType_ENUM * _exType)
{

#ifndef ATCA
    
    AID_INFO_TYPE_t     aidInfo;
    TL1_BUF_t           cmdMsg;
    CMD_BUF_t           respBuff;


    memset(&cmdMsg,0x0,SIZEOF_EQMCMD_EX);

    if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;

    if(_reptmode)
    {
        switch (*_reptmode)
        {
        case Reportmode_ALL:
            cmdMsg.CmdInfo.ExEqptParams.ExType.value = REPORT_ALL;
            cmdMsg.CmdInfo.ExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        case Reportmode_FAIL:
            cmdMsg.CmdInfo.ExEqptParams.ExType.value = REPORT_FAIL;
            cmdMsg.CmdInfo.ExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        default:
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> reptMode" );
            return eosl_false;
            break;
        }
    }

    if(_exType)
    {
        switch (*_exType)
        {
        case ExType_SWTOPROTN:
            cmdMsg.CmdInfo.ExEqptParams.ExType.value = SW_TO_PROTECTION;
            cmdMsg.CmdInfo.ExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        case ExType_STANDARD:
            cmdMsg.CmdInfo.ExEqptParams.ExType.value = STANDARD_SELFTEST;
            cmdMsg.CmdInfo.ExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        case ExType_EXTENDED:
            cmdMsg.CmdInfo.ExEqptParams.ExType.value = EXTENDED_SELFTEST;
            cmdMsg.CmdInfo.ExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        default:
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> exType" );
            return eosl_false;
            break;
        }
    }
    
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_EX,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_EX,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif

    return tc_compld_comment( handle, ctag, "EX-EQPT" );
}

/**
 */
eosl_bool agc_EM_NE_INH_EX_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
    
    AID_INFO_TYPE_t     aidInfo;
    TL1_BUF_t           cmdMsg;
    CMD_BUF_t           respBuff;

    memset(&cmdMsg,0x0,sizeof(TL1_BUF_t)); /* set all valid flags=0 */
    /*
    ** let's do the slot stuff first(for command INH-EX-EQPT)
    */
#ifdef ATCA
    if (_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
    }
    else  
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Missing Aid" );
        return eosl_false;
    }
#else 
    if(ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM), NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_INH_EX,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_INH_EX,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    
    return tc_compld_comment( handle, ctag, "INH-EX-EQPT" );
}

/**
 */
eosl_bool agc_EM_NE_INH_MSG_USER_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _uid)
{

    int result;
    int InhMsg=1;
    const char * userName;


    userName = tc_session_get_username(handle);
    if (strcmp(userName, _uid) != 0)
    {
        tc_error_response(handle,ctag,TE_PIUC,"INH-MSG-USER Failed");
        return eosl_false;
    }


    result=ModifyUserDb(_uid, NULL, NULL, NULL,NULL, NULL,NULL,
                        NULL, &InhMsg, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if(result == -1)
    {
        tc_error_response( handle, ctag, TE_SROF, "INH-MSG-USER Failed" );
        return eosl_false;
    }
    else
    {
        synchActiveSessions(_uid);
        return tc_compld_comment( handle, ctag, "INH-MSG-USER" );
    }
}


/**
 * INHIBIT-LOOPBACK prevents future automatic loopback of
 * equipment units, facilities, subscriber lines, trunks,
 * links, packet links, or signaling links.
 */
eosl_bool agc_EM_NE_INH_LPBK_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _src)
{
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "INH-LPBK-T1";
    char            T3Comment[] = "INH-LPBK-T3";
    char            E1Comment[] = "INH-LPBK-E1";
    char            *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _src, (AID_PORT | AID_OC3_STS1_T1 | AID_OC12_STS1_T1 | AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INH_LPBK_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INH_LPBK_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _src, AID_T3,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INH_LPBK_E1;
		p_comment = E1Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _src, 
								 AID_E1,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
	}
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }

    
    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_INH_LPBK_DSnFacility_req",  "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, p_comment );
}


/**
 * Instructs an NE to inhibit processing of PM reports. GR 833.
 */
eosl_bool agc_EM_NE_INH_PMREPT_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id)
{
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "INH-PMREPT-T1";
    char            T3Comment[] = "INH-PMREPT-T3";
    char            *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INH_PMREPT_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INH_PMREPT_IF;
        
        p_comment = T3Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_T3),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier - Only T1 & T3 supported at this time." );
        return eosl_false;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_INH_PMREPT_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, p_comment );
}


/**
 * Instructs an NE to inhibit automatic or manual switching of an equipment unit or facility to protection. The AID parameter is used to specify the unit being allowed
 * (either the working or the protection unit). This function is sometimes called release lockon or release lockout.
 * This command is not to be used for SONET line protection switching. For SONET line protection switching commands,
 * see EX SW, OPR PROTNSW, and RLS PROTNSW. GR 833.
 */
eosl_bool agc_EM_NE_INH_SWTOPROTN_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sw_id, Direction_ENUM * _dirn)
{
    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;


#ifdef ATCA
    if(ParseAidMap(&aidInfo, _sw_id, AID_ACM, NULL))
#else
    if(ParseAidMap(&aidInfo, _sw_id, AID_IOM, NULL))
#endif
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#ifdef ATCA
    cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
#else
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_INH_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_INH_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "INH-SWTOPROTN-EQPT" );
}


/**
 * INHIBIT-SWITCHING TO WORKING instructs an NE to inhibit
 * automatic or manual switching of an equipment unit or
 * facility back to working.
 */
eosl_bool agc_EM_NE_INH_SWTOWKG_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, Direction_ENUM * _dirn)
{
    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;

    if(ParseAidMap(&aidInfo, _src, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;


    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_INH_SWTOWKG,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ALW_SWTOWKG,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "INH-SWTOWKG-EQPT" );
}

/**
 */
eosl_bool agc_EM_NE_INH_TL1_CMD_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _tl1cmd)
{
    INHCMD_DATA_t 	inhCmdData;
    char			tmpTl1cmd[MAX_TL1_CMD_LEN];
    char 			tmpStr[MAX_TL1_CMD_LEN];
    int 			result;
    int 			retVal;
    int 			status;
    int 			len;
    int 			i;


    /* the following commands can't be disabled
     */
    if((eosl_strncasecmp(_tl1cmd, "ACT-USER",eosl_strlen(_tl1cmd)) == 0) ||
       (eosl_strncasecmp(_tl1cmd, "CANC-USER",eosl_strlen(_tl1cmd)) == 0) ||
       (eosl_strncasecmp(_tl1cmd, "ALW-TL1-CMD",eosl_strlen(_tl1cmd)) == 0) ||
       (eosl_strncasecmp(_tl1cmd, "INH-TL1-CMDR",eosl_strlen(_tl1cmd)) == 0) || 
       (eosl_strncasecmp(_tl1cmd, "RTRV-TL1-INH",eosl_strlen(_tl1cmd)) == 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    
    len = strlen(_tl1cmd);
    if (len > MAX_TL1_CMD_LEN)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    strcpy(tmpTl1cmd, _tl1cmd);
    
    
    /* validate INH tl1 
       MAYBE there's an option in tl1_parce.c we can use
    */
    retVal = lookup_message_info (_tl1cmd,&Current_Network_Element);
    if (retVal == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    
    /* uniform all inh cmd to upper case. */
    for (i = 0; i < len; i++)
    {
        tmpStr[i] = (char)toupper((int)tmpTl1cmd[i]);
    }
    
    strncpy(inhCmdData.tl1cmd,tmpStr,len);
    inhCmdData.tl1cmd[len] = '\0';
    
    result = AddInhTL1CmdToDB(handle, &inhCmdData);
    if (result >= 0)
    {
        status=SaveInhTl1cmdsFrmDbToMem();
        if(status < 0)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_INH_TL1_CMD_req", 
                       "agc_EM_NE_INH_TL1_CMD_req Failed "
                       "to refresh tl1InhCmdArray\n");
        }
        
        return tc_compld_comment( handle, ctag, "INH-TL1-CMD" );
    }
    else
    {
        if (result == -2)
        {
            tc_error_response(handle,
                              ctag,
                              TE_IEAE,
                              "Specified Object Entity Already Exists");
        }
        else
        {
            tc_error_response(handle,
                              ctag,
                              TE_SROF,
                              "Failed To Add TL1 Command To DB"); 
        }
    }
    return  eosl_false;
}

/**
 * Instruct an NE to initialize one or more storage registers
 * or event counters associated with specific entities in the
 * NE. In most cases, registers contain performance data.
 *
 * Defined in GR-833.
 */
eosl_bool agc_EM_NE_INIT_REG_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id, char * _montype, nullmonval_ENUM * _monval, Location_ENUM * _locn, Direction_ENUM * _dirn, char * _tmper, nullmondate_ENUM * _mondat, nullmontime_ENUM * _montm)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId      transId = ctag;
    TsTableId      tableId = 0;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    int            colCnt = 0;
    SMCMD_t        smCmd;
    int            cmd = SM_ED_REQUEST;
    int            i;
    int            shlefId = 0, atcaSlot = 0, amcSlot = 0, portId = 0, aidSize = 0;
    char           tmpArray[16];
    int            tmpVal = 0, retVal = 0;        
        
    colArray.numCols  = 0;
    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = PMT1_TAB_ID;

        TL1LOGP (PLOG_ERROR, "PM-T1 aid:%s\n", _pm_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId = PMT1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch (*_montype)
            {
              case T3T1MonType_ALL:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ALL;
                  break;
              case T3T1MonType_CSS:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CSS;
                  break;
              case T3T1MonType_CSS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CSS_FE;
                  break;
              case T3T1MonType_CV_L:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_L;
                  break;
              case T3T1MonType_CV_P:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_P;
                  break;
              case T3T1MonType_CV_PFE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_CV_PFE;
                  break;
              case T3T1MonType_ES_L:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ES_L;
                  break;
              case T3T1MonType_ES_LFE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_ES_LFE;
                  break;
              case T3T1MonType_SEFS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SEFS_FE;
                  break;
              case T3T1MonType_SES:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SES;
                  break;
              case T3T1MonType_SES_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_SES_FE;
                  break;
              case T3T1MonType_UAS:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_UAS;
                  break;
              case T3T1MonType_UAS_FE:
                  columns[colCnt].value.value.longVal = PMT1_MONTYPE_UAS_FE;
                  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid monType Value" );
                  return eosl_false;
                  break;
            }
            colCnt++;
        }

        if(_monval)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monval Value" );
            return eosl_false;
        }
        if(_locn)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid locn Value" );
            return eosl_false;
        }

        if(_dirn)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid dirn Value" );
            return eosl_false;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = PMT1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;

            if (eosl_strcasecmp(_tmper, "24-HR") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(_tmper, "15-MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }
#if 0            
            if (sscanf(_tmper, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }

            if (eosl_strcasecmp(tmpArray, "HR") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PMT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }
#endif            
            colCnt++;
        }

        if(_mondat)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monDat Value" );
            return eosl_false;
        }

        if(_montm)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid monTm Value" );
            return eosl_false;
        }

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(cmd,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
        }
        else
        {
                return tc_compld_comment( handle, ctag, "INIT-REG-T1" );
        }
    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = PM_E1_TAB_ID;
        if (_pm_id)
        {
            /* convert to upper case */
            for (i = 0; i < strlen(_pm_id); i++)
            {
                _pm_id[i] = toupper(_pm_id[i]);
            }

            if (sscanf(_pm_id, "SHELF-%d-ACM-%d-AMCSS7-%d-E1-%d %n", &shlefId, &atcaSlot, &amcSlot, &portId, &aidSize) == 4)
            {
                if (aidSize != strlen(_pm_id))
                {
                    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                    return eosl_false;
                }
                
                rowKey.numIndices = 4;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = shlefId;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = atcaSlot;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = amcSlot;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = portId;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
        }
        
        if(_montype)
        {
            columns[colCnt].columnId            = PM_E1_MONTYPE;
            columns[colCnt].value.colType       = TSSMI_LONG;
            columns[colCnt].value.value.longVal = PM_E1_MONTYPE_ALL;
            colCnt++;
        }

        if (_monval)
        {
            /* _monval must be NULL */    	
        }

        if(_locn)
        {
            columns[colCnt].columnId      = PM_E1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
                case Location_FEND:
                    columns[colCnt].value.value.longVal = PM_E1_LOCN_FEND;
                    break;

                case Location_NEND:
                    columns[colCnt].value.value.longVal = PM_E1_LOCN_NEND;
                    break;

                default:
                    break;
            }
            colCnt++;
        }
 
        if(_dirn)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> dirn" );
            return eosl_false;
        }
 
        if(_tmper)
        {
            columns[colCnt].columnId      = PM_E1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;
            i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
            if (i != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
                return eosl_false;
            }

            if (eosl_strcasecmp(tmpArray, "HR") == 0)
            {
                columns[colCnt].value.value.longVal = PM_E1_TMPER_24_HR;
            }
            else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
            {
                columns[colCnt].value.value.longVal = PM_E1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
            colCnt++;
        }
        
        if(_mondat)
        {
        	  /* _mondat must be NULL */
        }
        
        if(_montm)
        {
        	  /* _montm must be NULL */
        }

        colArray.numCols  = colCnt;
        colArray.colArray = columns;
        
        retVal = emfPkSmiSetReq(cmd,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
        }
        else
        {
                return tc_compld_comment( handle, ctag, "INIT-REG-E1" );
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - pm_id type is not supported at this time.");
        return eosl_false;        	
    }

#else
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            RespComment[16];
    char            tmpArray[16];
    int             tmpVal;
    int             tmpEnum;
    int             mon = 0;
    int             day = 0;
    int             hr  = 0;
    int             min = 0;
    int             i;
    char            mod[64];
    char            defMonType[] = "ALL";
   
    /*
     * prepare t1 data structure
     */
    memset(&buffer, 0, SIZEOF_DSXCMD_INIT_REG);
    memset(RespComment, 0, sizeof(RespComment));
    memset(mod, 0, sizeof(mod));


    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT |
                                   AID_OC3_STS1 | AID_OC12_STS1 |
                                   AID_OC3_STS1_T1 | AID_OC12_STS1_T1 |
                                   AID_STS1|AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_T1;

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_T1;
            break;
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
            break;
        case DEVICE_MAP_IOM_T3:
            buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
            break;
        default:
            break;

        }
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_IF;

        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_T3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All T3s on DS3 board */
        case DEVICE_MAP_IOM_T3: /* T3 on DS3 board */
            buffer.DeviceMap = DEVICE_MAP_IOM_T3;
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_E1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, 
								 (AID_IOM | AID_E1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:  
        case DEVICE_MAP_IOM_E1:
            buffer.DeviceMap = DEVICE_MAP_IOM_E1;
            break;
        default:
            break;
        }
    }
    else if ((!eosl_strcasecmp(modifier, "OC3")) ||
             (!eosl_strcasecmp(modifier, "OC12")))
    {
        cmdClass = OC_CMD_CLASS; /* DS3_CMD_CLASS; */
        cmd = DS3CMD_INIT_REG_OC;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_OC),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_OC3:
            if (!eosl_strcasecmp(modifier, "OC12"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM_OC12:
            if (!eosl_strcasecmp(modifier, "OC3"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM:
            if (!eosl_strcasecmp(modifier, "OC3"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC3;
            else if (!eosl_strcasecmp(modifier, "OC12"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC12;
            break;
        default:
            break;
        }
    }
    else if (!eosl_strcasecmp(modifier, "STS1"))
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_STS1 | AID_OC |
                                  AID_OC3_STS1 | AID_OC12_STS1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1;
            break;
        case DEVICE_MAP_IOM_STS1:
            break;
        case DEVICE_MAP_IOM_OC3:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            break;
        case DEVICE_MAP_IOM_OC12:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "VT1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_VT1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_OC3_STS1 | AID_OC3_STS1_VT |
                                  AID_OC12_STS1 | AID_OC12_STS1_VT |
                                  AID_STS1 | AID_STS1_VT),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "TUG3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_TUG3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TUG3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "AU3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_AU3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_AU3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU12") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_TU12;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU12|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU12;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU12;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU12;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU12;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU11") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_INIT_REG_TU11;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU11|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU11;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU11;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU11;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU11;
            break;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - pm_id type is not supported at this time.");
        return eosl_false;
    }

    /* BUG: 45095 */
    if (_montype == NULL)
    {       
        _montype = defMonType;
    }
    TL1LOGP(PLOG_DEBUG, "_montype = %s\n", _montype);

    switch (buffer.DeviceMap)
    {
    case DEVICE_MAP_IOM_T1:
    case DEVICE_MAP_IOM_T3_T1:
    case DEVICE_MAP_IOM_STS1_T1:
    case DEVICE_MAP_IOM_OC3_STS1_T1:
    case DEVICE_MAP_IOM_OC12_STS1_T1:
    case DEVICE_MAP_IOM_STM1_TUG3_T1:
    case DEVICE_MAP_IOM_STM4_TUG3_T1:
    case DEVICE_MAP_IOM_STM1_AU3_T1:
    case DEVICE_MAP_IOM_STM4_AU3_T1:
        tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
        switch(tmpEnum)
        {
        case T3T1MonType_AISS_P:
            tmpEnum = DS3T1MonType_AISS_P;
            break;
        case T3T1MonType_ALL:
            tmpEnum = DS3T1MonType_ALL;
            break;
        case T3T1MonType_CSS_P:
            tmpEnum = DS3T1MonType_CSS_P;
            break;
        case T3T1MonType_CSS_PFE:
            tmpEnum = DS3T1MonType_CSS_PFE;
            break;
        case T3T1MonType_CV_L:
            tmpEnum = DS3T1MonType_CV_L;
            break;
        case T3T1MonType_CV_P:
            tmpEnum = DS3T1MonType_CV_P;
            break;
        case T3T1MonType_CV_PFE:
            tmpEnum = DS3T1MonType_CV_PFE;
            break;
        case T3T1MonType_ES_L:
            tmpEnum = DS3T1MonType_ES_L;
            break;
        case T3T1MonType_ES_LFE:
            tmpEnum = DS3T1MonType_ES_LFE;
            break;
        case T3T1MonType_ES_P:
            tmpEnum = DS3T1MonType_ES_P;
            break;
        case T3T1MonType_ES_PFE:
            tmpEnum = DS3T1MonType_ES_PFE;
            break;
        case T3T1MonType_ESA_P:
            tmpEnum = DS3T1MonType_ESA_P;
            break;
        case T3T1MonType_ESA_PFE:
            tmpEnum = DS3T1MonType_ESA_PFE;
            break;
        case T3T1MonType_ESB_P:
            tmpEnum = DS3T1MonType_ESB_P;
            break;
        case T3T1MonType_ESB_PFE:
            tmpEnum = DS3T1MonType_ESB_PFE;
            break;
        case T3T1MonType_FC:
            tmpEnum = DS3T1MonType_FC;
            break;
        case T3T1MonType_FC_FE:
            tmpEnum = DS3T1MonType_FC_FE;
            break;
        case T3T1MonType_LOSS_L:
            tmpEnum = DS3T1MonType_LOSS_L;
            break;
        case T3T1MonType_SAS_P:
            tmpEnum = DS3T1MonType_SAS_P;
            break;
        case T3T1MonType_SEFS_PFE:
            tmpEnum = DS3T1MonType_SEFS_PFE;
            break;
        case T3T1MonType_SES_L:
            tmpEnum = DS3T1MonType_SES_L;
            break;
        case T3T1MonType_SES_P:
            tmpEnum = DS3T1MonType_SES_P;
            break;
        case T3T1MonType_SES_PFE:
            tmpEnum = DS3T1MonType_SES_PFE;
            break;
        case T3T1MonType_UAS_P:
            tmpEnum = DS3T1MonType_UAS_P;
            break;
        case T3T1MonType_UAS_PFE:
            tmpEnum = DS3T1MonType_UAS_PFE;
            break;
        default:
            tmpEnum = -1;
        }
        break;

    case DEVICE_MAP_IOM_T3:
        tmpEnum = enum_lookup_no_case(&T3MonType_ENUM_type, _montype);
        break;

    case DEVICE_MAP_IOM_OC3:
    case DEVICE_MAP_IOM_OC12:
        tmpEnum = enum_lookup_no_case(&OCnMonType_ENUM_type, _montype);
        break;

    case DEVICE_MAP_IOM_STS1:
    case DEVICE_MAP_IOM_OC3_STS1:
    case DEVICE_MAP_IOM_OC12_STS1:
        tmpEnum = enum_lookup_no_case(&Sts1MonType_ENUM_type, _montype);
        break;

    case DEVICE_MAP_IOM_STS1_VT1:
    case DEVICE_MAP_IOM_OC3_STS1_VT1:
    case DEVICE_MAP_IOM_OC12_STS1_VT1:
        tmpEnum = enum_lookup_no_case(&VtMonType_ENUM_type, _montype);
        break;
    case DEVICE_MAP_IOM_E1:
    case DEVICE_MAP_IOM_STM1_TUG3_E1:
    case DEVICE_MAP_IOM_STM4_TUG3_E1:
    case DEVICE_MAP_IOM_STM1_AU3_E1:
    case DEVICE_MAP_IOM_STM4_AU3_E1:
		tmpEnum = enum_lookup_no_case(&E1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case E1MonType_AISS:
                tmpEnum = DS3E1MonType_AISS;
                break;
            case E1MonType_ALL:
                tmpEnum = DS3E1MonType_ALL;
                break;
            case E1MonType_BBEC:
                tmpEnum = DS3E1MonType_BBEC;
                break;
            case E1MonType_BBEC_FE:
                tmpEnum = DS3E1MonType_BBEC_FE;
                break;
            case E1MonType_BBER1:
                tmpEnum = DS3E1MonType_BBER1;
                break;
            case E1MonType_BBER1_FE:
                tmpEnum = DS3E1MonType_BBER1_FE;
                break;
            case E1MonType_CV:
                tmpEnum = DS3E1MonType_CV;
                break;
            case E1MonType_ESC:
                tmpEnum = DS3E1MonType_ESC;
                break;
            case E1MonType_ESC_FE:
                tmpEnum = DS3E1MonType_ESC_FE;
                break;
            case E1MonType_ESR1:
                tmpEnum = DS3E1MonType_ESR1;
                break;
            case E1MonType_ESR1_FE:
                tmpEnum = DS3E1MonType_ESR1_FE;
                break;
            case E1MonType_ESR2:
                tmpEnum = DS3E1MonType_ESR2;
                break;
            case E1MonType_ESR2_FE:
                tmpEnum = DS3E1MonType_ESR2_FE;
                break;
            case E1MonType_ESR3:
                tmpEnum = DS3E1MonType_ESR3;
                break;
            case E1MonType_ESR3_FE:
                tmpEnum = DS3E1MonType_ESR3_FE;
                break;
            case E1MonType_LOSS:
                tmpEnum = DS3E1MonType_LOSS;
                break;
            case E1MonType_OOFS:
                tmpEnum = DS3E1MonType_OOFS;
                break;
            case E1MonType_RAI:
                tmpEnum = DS3E1MonType_RAI;
                break;
            case E1MonType_RAI_FE:
                tmpEnum = DS3E1MonType_RAI_FE;
                break;
            case E1MonType_SESC:
                tmpEnum = DS3E1MonType_SESC;
                break;
            case E1MonType_SESC_FE:
                tmpEnum = DS3E1MonType_SESC_FE;
                break;
            case E1MonType_SESR1:
                tmpEnum = DS3E1MonType_SESR1;
                break;
            case E1MonType_SESR1_FE:
                tmpEnum = DS3E1MonType_SESR1_FE;
                break;
            case E1MonType_SESR2:
                tmpEnum = DS3E1MonType_SESR2;
                break;
            case E1MonType_SESR2_FE:
                tmpEnum = DS3E1MonType_SESR2_FE;
                break;
            case E1MonType_SESR3:
                tmpEnum = DS3E1MonType_SESR3;
                break;
            case E1MonType_SESR3_FE:
                tmpEnum = DS3E1MonType_SESR3_FE;
                break;
            case E1MonType_SESR4:
                tmpEnum = DS3E1MonType_SESR4;
                break;
            case E1MonType_SESR4_FE:
                tmpEnum = DS3E1MonType_SESR4_FE;
                break;
            case E1MonType_UASC:
                tmpEnum = DS3E1MonType_UASC;
                break;
            case E1MonType_UASC_FE:
                tmpEnum = DS3E1MonType_UASC_FE;
                break;
            case E1MonType_CSS:
                tmpEnum = DS3E1MonType_CSS;
                break;
            case E1MonType_LOFS:
            default:
                tmpEnum = -1;
            }
		break;
    case DEVICE_MAP_IOM_STM1_TUG3:
    case DEVICE_MAP_IOM_STM4_TUG3:
		tmpEnum = enum_lookup_no_case(&TugnMonType_ENUM_type, _montype);
		break;
    case DEVICE_MAP_IOM_STM1_AU3:
    case DEVICE_MAP_IOM_STM4_AU3:
            tmpEnum = enum_lookup_no_case(&Au3nMonType_ENUM_type, _montype);
            break;
    case DEVICE_MAP_IOM_STM1_TUG3_TU12:
    case DEVICE_MAP_IOM_STM4_TUG3_TU12:
    case DEVICE_MAP_IOM_STM1_AU3_TU12:
    case DEVICE_MAP_IOM_STM4_AU3_TU12:
    case DEVICE_MAP_IOM_STM1_TUG3_TU11:
    case DEVICE_MAP_IOM_STM4_TUG3_TU11:
    case DEVICE_MAP_IOM_STM1_AU3_TU11:
    case DEVICE_MAP_IOM_STM4_AU3_TU11:
            tmpEnum = enum_lookup_no_case(&TUnMontype_ENUM_type, _montype);
            break;


      default:
          tmpEnum = -1;
          break;
    }

    if (tmpEnum == -1)
    {
        tc_error_response( handle, ctag, TE_IPNV,
                           "Input, Parameter Not Valid -> montype" );
        return eosl_false;
    }
    buffer.Data.InitReg.MonitoredType = tmpEnum;

    if (_monval)
    {
        buffer.Data.InitReg.MonitoredValue.valid = VALID_VALUE;
        buffer.Data.InitReg.MonitoredValue.value = *_monval;
    }

    if (_locn)
    {
        buffer.Data.InitReg.Location.valid = VALID_VALUE;
        buffer.Data.InitReg.Location.value = *_locn;
    }

    if (_dirn)
    {
        buffer.Data.InitReg.Direction.valid = VALID_VALUE;
        buffer.Data.InitReg.Direction.value = *_dirn;
    }

    if (_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.InitReg.TimePeriod.valid = VALID_VALUE;
        buffer.Data.InitReg.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if (_mondat || _montm)
    {
        if (_mondat)
        {
#ifdef bug15652
            if ((strcmp(_mondat,"NULL") != 0))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Allowed NULL only" );
                return eosl_false;
            }
            
            i = sscanf(_mondat, "%d-%d", &mon, &day);
            if ((i != 2) || (!validateDate(mon, day)))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonDat" );
                return eosl_false;
            }
        }
        else
        {
            dateStruct = eosl_get_current_date();
            mon = dateStruct.month;
            day = dateStruct.day;
#endif
        }

        if (_montm)
        {
#ifdef bug15652
            if ((strcmp(_montm,"NULL") != 0))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Allowed NULL only" );
                return eosl_false;
            }
            i = sscanf(_montm, "%d-%d", &hr, &min);
            if ((i != 2) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonTm" );
                return eosl_false;
            }
        }
        else
        {
            timeStruct = eosl_get_current_time();
            hr = timeStruct.hour;
            min = timeStruct.minute;
#endif
        }
        buffer.Data.InitReg.Time.valid = VALID_VALUE;
        buffer.Data.InitReg.Time.value = PACK_TIME(mon, day, hr, min);
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_INIT_REG,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_INIT_REG_DSnFacility_req",
                    "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    for(i=0;i<=strlen(modifier);i++)
    {
       mod[i] = toupper(modifier[i]);
    }

    sprintf(RespComment, "INIT-REG-%s", mod);
    return tc_compld_comment(handle, ctag, RespComment);
#endif
}

#define TL1_REBOOT_TIMEOUT (60)   /* seconds */
/**
 * Intitialize ATCA System
 */
eosl_bool agc_EM_NE_INIT_ATCA_SYS_req( const char * modifier,\
									eosl_handle handle,\
									TL1_TAG ctag ,\
									char * _poolId,\
									int _ph)
{
#ifdef ATCA
    TL1_BUF_t         cmdMsg;
    TL1_BUF_t         respBuff;

    if (execResourceBusy())
    {
	tc_error_response( handle, ctag, TE_SARB, "A shell command is running." );
	 return eosl_false;
    }

    /*
    ** Prepare event
    */
    
    cmdMsg.Buf.Cmd                  = EQMCMD_SHUTDOWN_CHASSIS;
    cmdMsg.Buf.SessionHandle        = handle;
    cmdMsg.Buf.CTag                 = ctag;
    if(_poolId)
    {
	if(!IsInputStrInRange(_poolId, "0123456789"))
	{
	    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
	    return eosl_false;
	}
	if((atoi(_poolId)<1)||(atoi(_poolId)>21))
	{
	    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
	    return eosl_false;
	}
        cmdMsg.CmdInfo.InitSysParams.PoolId = atoi(_poolId);
	
    }
    cmdMsg.CmdInfo.InitSysParams.Ph = _ph;
    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_SHUTDOWN_CHASSIS,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SHUTDOWN_CHASSIS,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_REBOOT_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif 
    return tc_compld_comment( handle, ctag, "INIT-ATCA-SYS" );
}

/**
 * This command initialize the NE as a whole to its default
 * values for its TL1 interface and general parameters like
 * Date and Time.
 *
 * Note that we left out AID so subsystems are not resetable
 * using this command. Such a limitation is followed in most
 * NEs.
 *
 * Defined in GR-833.
 */
eosl_bool agc_EM_NE_INIT_SYS_req( const char * modifier,\
                                  eosl_handle handle,\
                                  TL1_TAG ctag ,\
                                  int _ph)
{
    TL1_BUF_t         cmdMsg;
    TL1_BUF_t         respBuff;

    /* BUG 17413:  Don't allow INIT-SYS to run while shell command is running. */
    /* If another EXEC command is in progress */
    if (execResourceBusy())
    {
        tc_error_response( handle, ctag, TE_SARB, "A shell command is running." );
        return eosl_false;
    }

    /*
    ** Prepare event
    */
    cmdMsg.Buf.Cmd                  = EQMCMD_SHUTDOWN_CHASSIS;
    cmdMsg.Buf.SessionHandle        = handle;
    cmdMsg.Buf.CTag                 = ctag;
    cmdMsg.CmdInfo.InitSysParams.Ph = _ph;

    /* Design Note: If this command succeeds, a response will
     *     not be received since the system shuts down.  To avoid
     *     a false impression that the command failed, a larger
     *     timeout value is used.  This will prevent the premature
     *     issuance of the "Reply Timeout Occurred" message.
     */

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_SHUTDOWN_CHASSIS,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SHUTDOWN_CHASSIS,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_REBOOT_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "INIT-SYS" );
}


/**
 */
eosl_bool agc_EM_NE_CANC_USER_SECU_req( const char * modifier,\
                                        eosl_handle handle,\
                                        TL1_TAG ctag ,\
                                        char * _sessionId)
{
    /* Carry out the CANC-USER-SECU request */
    return cancelUser( handle, ctag, _sessionId, eosl_false);
}


/**
 * Instructs an NE to operate a loopback on a specified
 * equipment unit, facility, subscriber line, etc. associated
 * with a test access session in the NE. The loop may be
 * accomplished at either the near or far end, or on the line.
 * It is assumed that the specified entity is in a state that
 * allows a loopback to occur. If not, an error response
 * should be issued by the NE. Any NE that has a loopback in
 * effect should include the appropriate condition type
 * information in response to a RTRV COND message.
 * GR 833.
 */
eosl_bool agc_EM_NE_OPR_LPBK_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _lpbk_id, Location_ENUM * _locn, OriginatingOffice_ENUM * _orgn, InternalExternal_ENUM * _intext, LoopbackType_ENUM * _lpbktype)
{
#ifdef ATCA
    TsTransId      transId = ctag;
    TsTableId      tableId = 0;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    SMCMD_t        smCmd;
    int            cmd = SM_ENT_REQUEST;
    int            retVal =0;
    int            colCnt = 0;
    char           T1Comment[] = "OPR-LPBK-T1";
    char           E1Comment[] = "OPR-LPBK-E1";
    char           *p_comment;
    AID_INFO_TYPE_t   aidInfo;

    memset(&rowKey, 0, sizeof(rowKey));
    memset(&colArray, 0, sizeof(colArray));

    if(eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = LPBK_T1_TAB_ID;
        p_comment = T1Comment;
        
        TL1LOGP (PLOG_ERROR, "OPR-LPBK-T1 aid:%s\n", _lpbk_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);
 
        if(ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORT, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                                 (aidInfo.devicemap == T1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4);
    
            if (aidInfo.devicemap == T1)
            {
                rowKey.numIndices = 4;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }

        }
        else if (ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORTCHAN, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d, channel:%d\n",
                                 (aidInfo.devicemap == T1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4, aidInfo.lvl5);

                rowKey.numIndices = 5;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
                rowKey.rowIndex[4].colType          = TSSMI_LONG;
                rowKey.rowIndex[4].value.longVal    = aidInfo.lvl5;

        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_locn)
        {
            columns[colCnt].columnId                  = LPBK_T1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_locn)
            {
                case Location_FEND:
                    columns[colCnt].value.value.longVal = LPBK_T1_LOCN_FEND;
                    break;
                case Location_NEND:
                    columns[colCnt].value.value.longVal = LPBK_T1_LOCN_NEND;
                    break;
                default:
                    break;
            }
            colCnt++;
        }

        if(_orgn)
        {
            columns[colCnt].columnId                  = LPBK_T1_ORGN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal       = LPBK_T1_ORGN_NULL;
            colCnt++;
        }

        if(_intext)
        {
            columns[colCnt].columnId                  = LPBK_T1_INTEXT;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal       = LPBK_T1_INTEXT_NULL;
            colCnt++;
        }

        if(_lpbktype)
        {
            columns[colCnt].columnId                  = LPBK_T1_LPBKTYPE;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_lpbktype)
            {
                case LoopbackType_LINE:
                    columns[colCnt].value.value.longVal = LPBK_T1_TYPE_LINE;
                    break;
                case LoopbackType_PAYLOAD:
                    columns[colCnt].value.value.longVal = LPBK_T1_TYPE_PAYLOAD;
                    break;
                case LoopbackType_LOCAL:
                    columns[colCnt].value.value.longVal = LPBK_T1_TYPE_LOCAL;
                    break;
                case LoopbackType_CHANNEL:
                    columns[colCnt].value.value.longVal = LPBK_T1_TYPE_CHANNEL;
                    break;

                default:
                    break;
            }
            colCnt++;
        }
 
    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = LPBK_E1_TAB_ID;
        p_comment = E1Comment;

        TL1LOGP (PLOG_ERROR, "OPR-LPBK-E1 aid:%s\n", _lpbk_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);
 
        if(ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORT, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                                 (aidInfo.devicemap == E1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4);
    
            if (aidInfo.devicemap == E1)
            {
                rowKey.numIndices = 4;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }

        }
        else if (ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORTCHAN, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d, channel:%d\n",
                                 (aidInfo.devicemap == E1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4, aidInfo.lvl5);

                rowKey.numIndices = 5;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
                rowKey.rowIndex[4].colType          = TSSMI_LONG;
                rowKey.rowIndex[4].value.longVal    = aidInfo.lvl5;

        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Bug 71879 : 
        ** ORGN is not supported and should be left blank for OPR-LPBK-E1.
        */
        if(_locn)
        {
            columns[colCnt].columnId                  = LPBK_E1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_locn)
            {
                case Location_FEND:
                    columns[colCnt].value.value.longVal = LPBK_E1_LOCN_FEND;
                    break;
                case Location_NEND:
                    columns[colCnt].value.value.longVal = LPBK_E1_LOCN_NEND;
                    break;
                default:
                    break;
            }
            colCnt++;
        }

        if(_orgn)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Orgn - Must leave it blank" );
            return eosl_false;
#if 0            
            columns[colCnt].columnId                  = LPBK_E1_ORGN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal       = LPBK_E1_ORGN_NULL;
            colCnt++;
#endif
        }

        if(_intext)
        {
            columns[colCnt].columnId                  = LPBK_E1_INTEXT;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal       = LPBK_E1_INTEXT_NULL;
            colCnt++;
        }

        if(_lpbktype)
        {
            columns[colCnt].columnId                  = LPBK_E1_LPBKTYPE;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_lpbktype)
            {
                /* There is a mismatch, need to be correct */
                case LoopbackType_LINE:
                    columns[colCnt].value.value.longVal = LPBK_E1_TYPE_LINE;
                    break;
                case LoopbackType_PAYLOAD:
                    columns[colCnt].value.value.longVal = LPBK_E1_TYPE_PAYLOAD;
                    break;
                case LoopbackType_LOCAL:
                    columns[colCnt].value.value.longVal = LPBK_E1_TYPE_LOCAL;
                    break;
                case LoopbackType_CHANNEL:
                    columns[colCnt].value.value.longVal = LPBK_E1_TYPE_CHANNEL;
                    break;

                default:
                    break;
            }
            colCnt++;
        }

    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }

    if (colCnt> MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_OPR_LPBK_DSnFacility_req", "OPR-LPBK - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(cmd,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);


    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, p_comment);
    }

    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;

#else
    DSX_CMD_BUF_t       buffer;
    char                *cmdClass;
    unsigned int        cmd;
    char                T1Comment[] = "OPR-LPBK-T1";
    char                T3Comment[] = "OPR-LPBK-T3";
    char                E1Comment[] = "OPR-LPBK-E1";
    char                *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_OPR_LPBK);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, (AID_PORT | AID_OC3_STS1_T1 | AID_OC12_STS1_T1 | AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_OPR_LPBK_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_OPR_LPBK_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, AID_T3,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_OPR_LPBK_E1; 
        p_comment = E1Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, AID_E1,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }

    /* Bug 71879 : LOCN set as FEND is an invalid option and should not 
    ** be allowed for command OPR-LPBK-E1. ORGN is not supported and
    ** should be left blank for OPR-LPBK-E1 and OPR-LPBK-T3.
    */
    if(_locn)
    {
        if (eosl_strcasecmp(modifier, "E1") == 0)
        {
            if ( *_locn == Location_FEND )
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Locn - FEND not supported" );
                return eosl_false;
            }
        }
        buffer.Data.OprLpbk.Location.valid = VALID_VALUE;
        buffer.Data.OprLpbk.Location.value = *_locn;
    }
    if(_orgn)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Orgn - Must leave it blank" );
        return eosl_false;
#if 0
        buffer.Data.OprLpbk.OriginatingOffice.valid = VALID_VALUE;
        buffer.Data.OprLpbk.OriginatingOffice.value = *_orgn;
#endif
    }
    if(_intext)
    {
        buffer.Data.OprLpbk.IntExt.valid = VALID_VALUE;
        buffer.Data.OprLpbk.IntExt.value = *_intext;
    }
    if(_lpbktype)
    {
        /*bug86770*/
        if(*_lpbktype == LoopbackType_LOCAL || *_lpbktype == LoopbackType_CHANNEL)
        {
           tc_error_response( handle, ctag, TE_IIAC, "Invalid lpbktype - CHANNEL and LOCAL used for LGP");
           return eosl_false;
        }
        /*End of bug86770*/

        buffer.Data.OprLpbk.LpbkType.valid = VALID_VALUE;
        buffer.Data.OprLpbk.LpbkType.value = *_lpbktype;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_OPR_LPBK,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_OPR_LPBK_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, p_comment );
#endif
}

/**
 */
eosl_bool agc_EM_NE_OPR_CCR_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7TrkAid)
{
    
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    unsigned int   cmd;
    int            TGN;
    int            TrkId;
    int            Range;
    int            RangePresent=0;
    int            TGNOnly=0;

    length=sizeof(SMCMD_t);
    tableId = OPRISUP_CCR_TAB_ID;
    transId = ctag;
    colArray.numCols  = 0;
    colArray.colArray = columns;

    if (_ss7TrkAid)
    {
        cmd = SM_RTRV_REQUEST;
        if(!(IsInputStrInRange(_ss7TrkAid,"0123456789&&-")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Ss7TrkAid" );  
            return eosl_false;       
        }
        if(!ParseSs7TrkAid(_ss7TrkAid,&TGN,&TrkId,&RangePresent,&Range,&TGNOnly))
        {
            if(TGNOnly !=1)
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Ss7TrkAid" );  
                return eosl_false;       
            }
        }

        rowKey.rowIndex[0].colType        = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal  = TGN;

        rowKey.rowIndex[1].colType        = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal  = TrkId;

        rowKey.numIndices = 2;
        if(RangePresent)
        {
            rowKey.numIndices = 3;
            rowKey.rowIndex[2].colType       = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal = Range;
        }
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_OPR_CQM_TIMEOUT);
    
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal = emfUnpkSmiGetMultiResp(rtrvOprIsupCcrMultiTsmResp,&smCmdPtr, 
                                    &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, 
                          "Error unpacking signaling response data");
        return eosl_false;
    }
    if (retVal == TRUE)
    {
        return eosl_true;
    }
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_OPR_CQM_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _TrkAid)
{
    /*Adding new Function Telica prakash 01/11/02*/
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;
    int            TGN;
    unsigned int   TrkId;
    unsigned int   Range;
    int            RangePresent=0;
    int            TGNOnly=0;

    length     = sizeof(SMCMD_t);
    tableId    = OPRISUP_CQM_TAB_ID;
    transId    = ctag;
    colArray.numCols  = 0;
    colArray.colArray = columns;

    if (_TrkAid)
    {
        if(!(IsInputStrInRange(_TrkAid,"0123456789&&-")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid TrkAid" );  
            return eosl_false;       
        }
        if(!ParseBiccTrkAid(_TrkAid,&TGN,&TrkId,&RangePresent,&Range,&TGNOnly))
        {
            if(TGNOnly !=1)
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid TrkAid" );  
                return eosl_false;       
            }
        }
        rowKey.rowIndex[0].colType        = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal  = TGN;

        rowKey.rowIndex[1].colType        = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal  = TrkId;

        rowKey.numIndices = 2;
        if(RangePresent)
        {
            rowKey.numIndices = 3;
            rowKey.rowIndex[2].colType       = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal = Range;
        }
        if(TGNOnly)
        {
            rowKey.numIndices = 1;
        }
    }
    else
    {
        rowKey.numIndices = 0;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_OPR_CQM_TIMEOUT);
    
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal = emfUnpkSmiGetMultiResp(rtrvOprIsupCqmMultiTsmResp,&smCmdPtr, 
                                    &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, 
                          "Error unpacking signaling response data");
        return eosl_false;
    }
    if (retVal == TRUE)
    {
        return eosl_true;
    }
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_OPR_CVT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7TrkAid)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    unsigned int   cmd;
    int            TGN;
    int            TrkId;
    int            Range;
    int            RangePresent=0;
    int            TGNOnly=0;


    length=sizeof(SMCMD_t);
    tableId = OPRISUP_CVT_TAB_ID;
    transId = ctag;
    colArray.numCols  = 0;
    colArray.colArray = columns;

    if (_ss7TrkAid)
    {
        cmd = SM_RTRV_REQUEST;
        if(!(IsInputStrInRange(_ss7TrkAid,"0123456789&&-")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Ss7TrkAid" );  
            return eosl_false;       
        }
        if(!ParseSs7TrkAid(_ss7TrkAid,&TGN,&TrkId,&RangePresent,&Range,&TGNOnly))
        {
            if(TGNOnly !=1)
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Ss7TrkAid" );  
                return eosl_false;       
            }
        }
        if(RangePresent||TGNOnly)
        {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Ss7TrkAid No Ranging allowed" );  
                return eosl_false;       
        }

        rowKey.rowIndex[0].colType        = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal  = TGN;

        rowKey.rowIndex[1].colType        = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal  = TrkId;

        rowKey.numIndices = 2;

    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_OPR_CVT_TIMEOUT);
    
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal = emfUnpkSmiGetMultiResp(rtrvOprIsupCvtMultiTsmResp,&smCmdPtr, 
                                    &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, 
                          "Error unpacking signaling response data");
        return eosl_false;
    }
    if (retVal == TRUE)
    {
        return eosl_true;
    }
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_RD_MEM_ADRS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, char * _hex_adrs, int * _numwords)
{
#if 0

    /* _numwords is optional -- if not present, use 1 */
    /* check that numwords <= 8 */

    MP_CMD_BUF_t                  mpRequest;
    MP_ACK_BUF_t                  *p_mpResponse;
    AID_INFO_TYPE_t               aidInfo;
    RD_MEM_ADRS_resp_row          result;
    char                          adrsStr[16];
    char                          hex1Str[16];
    char                          hex2Str[16];
    char                          hex3Str[16];
    char                          hex4Str[16];
    char                          hex5Str[16];
    char                          hex6Str[16];
    char                          hex7Str[16];
    char                          hex8Str[16];
    int                           msgLen;

        ??? NOT IMPLEMENTED IN MAINTENANCE LINK YET.
/*************/
#endif
                tc_error_response( handle, ctag, TE_IICM, "Command Not Supported" );
    return eosl_false;

/*************/
#if 0
    /*
    ** prepare t1 data structure
    */
    msgLen = sizeof(TL1_CMD_BUF_t) + sizeof(RD_MEM_t);
    memset(&mpRequest, 0, msgLen);

    if(ParseAidMap(&aidInfo, _src, AID_SLOT, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    mpRequest.Data.RdMem.SlotNum = aidInfo.lvl1;

    if ((sscanf(_hex_adrs, "%x", &(mpRequest.Data.RdMem.Addr))) != 1)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
        return eosl_false;
    }

    if (_numwords)
    {
        if ((*_numwords < 1) || (*_numwords > 8))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> NumWords" );
            return eosl_false;
        }
        mpRequest.Data.RdMem.WordCount = *_numwords;
    }
    else
    {
        mpRequest.Data.RdMem.WordCount = 1;
    }

    /* Set up CMD_BUF header data. */
    mpRequest.Tl1Cmd.Cmd = MPCMD_MEM_READ;
    mpRequest.Tl1Cmd.SessionHandle = handle;
    mpRequest.Tl1Cmd.CTag = ctag;

    p_mpResponse = (MP_ACK_BUF_t *)respBuffer;

    if(TL1SendMsg(MP_CMD_CLASS, &buffer, msgLen) == FAIL)
    {
    ??? REPORT ERROR
            tc_error_response( handle, ctag, TE_SROF, "RD-MEM-ADRS Failed" );
    return eosl_false;
    }


    memset(&result, 0, sizeof(result));

    sprintf(adrsStr, "%X", p_mpResponse->Data.RdMem.Addr);
    result._hex_adrs = adrsStr;

    sprintf(hex1Str, "%X", p_mpResponse->Data.RdMem.Data1);
    result._hex1 = hex1Str;

    if (p_mpResponse->Data.RdMem.WordCount > 1)
    {
        sprintf(hex2Str, "%X", p_mpResponse->Data.RdMem.Data2);
        result._hex2 = hex2Str;

        if (p_mpResponse->Data.RdMem.WordCount > 2)
        {
            sprintf(hex3Str, "%X", p_mpResponse->Data.RdMem.Data3);
            result._hex3 = hex3Str;

            if (p_mpResponse->Data.RdMem.WordCount > 3)
            {
                sprintf(hex4Str, "%X", p_mpResponse->Data.RdMem.Data4);
                result._hex4 = hex4Str;

                if (p_mpResponse->Data.RdMem.WordCount > 4)
                {
                    sprintf(hex5Str, "%X", p_mpResponse->Data.RdMem.Data5);
                    result._hex5 = hex5Str;

                    if (p_mpResponse->Data.RdMem.WordCount > 5)
                    {
                        sprintf(hex6Str, "%X", p_mpResponse->Data.RdMem.Data6);
                        result._hex6 = hex6Str;

                        if (p_mpResponse->Data.RdMem.WordCount > 6)
                        {
                            sprintf(hex7Str, "%X", p_mpResponse->Data.RdMem.Data7);
                            result._hex7 = hex7Str;

                            if (p_mpResponse->Data.RdMem.WordCount > 8)
                            {
                                sprintf(hex8Str, "%X", p_mpResponse->Data.RdMem.Data8);
                                result._hex8 = hex8Str;

                            }
                        }
                    }
                }
            }
        }
    }

    return agc_EM_NE_RD_MEM_ADRS_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       &result,
                                       1,
                                       "RD-MEM-ADRS",
                                       NULL);

    /* return tc_compld_comment( handle, ctag, "RD-MEM-ADRS" ); */

#endif
}

/**
 * Instructs an NE to release a loopback being run on a specified
 * equipment unit, facility, subscriber line, etc. associated
 * with a test access session in the NE. The loop may be
 * accomplished at either the near or far end, or on the line.
 * It is assumed that the specified entity is in a state that
 * allows a loopback to aoccur. If not, and error response
 * should be issued by the NE. Any NE that has a loopback in
 * effect should include the appropriate condition type
 * information in response to a RTRV COND message.
 * GR 833.
 */
eosl_bool agc_EM_NE_RLS_LPBK_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _lpbk_id, Location_ENUM * _locn, OriginatingOffice_ENUM * _orgn, InternalExternal_ENUM * _intext, LoopbackType_ENUM * _lpbktype)
{
#ifdef ATCA
    TsTransId      transId = ctag;
    TsTableId      tableId = 0;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    int            cmd = SM_DLT_REQUEST;
    int            retVal = 0;
    char           T1Comment[] = "RLS-LPBK-T1";
    char           E1Comment[] = "RLS-LPBK-E1";
    char           *p_comment;
    AID_INFO_TYPE_t   aidInfo;

    int            colCnt = 0;
    TsSmiColObj    columns[MAX_TSM_COLS];

    memset(&rowKey, 0, sizeof(rowKey));
    memset(&colArray, 0, sizeof(colArray));


    if(eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = LPBK_T1_TAB_ID;
        p_comment = T1Comment;

        TL1LOGP (PLOG_ERROR, "RLS-LPBK-T1 aid:%s\n", _lpbk_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);
 
        if(ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORT, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                                 (aidInfo.devicemap == T1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4);
    
            if (aidInfo.devicemap == T1)
            {
                rowKey.numIndices = 4;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }

        }
        else if (ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORTCHAN, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d, channel:%d\n",
                                 (aidInfo.devicemap == T1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4, aidInfo.lvl5);

                rowKey.numIndices = 5;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
                rowKey.rowIndex[4].colType          = TSSMI_LONG;
                rowKey.rowIndex[4].value.longVal    = aidInfo.lvl5;

        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_locn)
        {
            columns[colCnt].columnId                  = LPBK_T1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_locn)
            {
                case Location_FEND:
                    columns[colCnt].value.value.longVal = LPBK_T1_LOCN_FEND;
                    break;
                case Location_NEND:
                    columns[colCnt].value.value.longVal = LPBK_T1_LOCN_NEND;
                    break;
                default:
                    break;
            }
            colCnt++;
        }
        else
        {
            columns[colCnt].columnId                  = LPBK_T1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal = LPBK_T1_LOCN_NEND;
            colCnt++;
        }

    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = LPBK_E1_TAB_ID;
        p_comment = E1Comment;

        TL1LOGP (PLOG_ERROR, "RLS-LPBK-E1 aid:%s\n", _lpbk_id);
        TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);
 
        if(ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORT, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                                 (aidInfo.devicemap == E1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4);
    
            if (aidInfo.devicemap == E1)
            {
                rowKey.numIndices = 4;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }

        }
        else if (ParseAidMap(&aidInfo, _lpbk_id, AID_AMCSS7PORTCHAN, NULL) == SUCCESS)
        {
            TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d, channel:%d\n",
                                 (aidInfo.devicemap == E1)?"T1":"E1",
                                 aidInfo.lvl1, aidInfo.lvl2,
                                 aidInfo.lvl3, aidInfo.lvl4, aidInfo.lvl5);

                rowKey.numIndices = 5;
                rowKey.rowIndex[0].colType          = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
                rowKey.rowIndex[1].colType          = TSSMI_LONG;
                rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
                rowKey.rowIndex[2].colType          = TSSMI_LONG;
                rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
                rowKey.rowIndex[3].colType          = TSSMI_LONG;
                rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
                rowKey.rowIndex[4].colType          = TSSMI_LONG;
                rowKey.rowIndex[4].value.longVal    = aidInfo.lvl5;

        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_locn)
        {
            columns[colCnt].columnId                  = LPBK_E1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            switch(*_locn)
            {
                case Location_FEND:
                    columns[colCnt].value.value.longVal = LPBK_E1_LOCN_FEND;
                    break;
                case Location_NEND:
                    columns[colCnt].value.value.longVal = LPBK_E1_LOCN_NEND;
                    break;
                default:
                    break;
            }
            colCnt++;
        }
        else
        {
            columns[colCnt].columnId                  = LPBK_E1_LOCN;
            columns[colCnt].value.colType             = TSSMI_LONG;
            columns[colCnt].value.value.longVal = LPBK_E1_LOCN_NEND;
            colCnt++;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }
    
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

/*    colArray.numCols  = 0;*/

    retVal = emfPkSmiSetReq(cmd,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);


    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, p_comment);
    }
    else
    {
        /* Now report the TSM error to the operator */
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
        return eosl_false;
    }
    
#else
    DSX_CMD_BUF_t   buffer;
    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "RLS-LPBK-T1";
    char            T3Comment[] = "RLS-LPBK-T3";
    char            E1Comment[] = "RLS-LPBK-E1";
    char            *p_comment;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_RLS_LPBK);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, (AID_PORT | AID_OC3_STS1_T1 | AID_OC12_STS1_T1 | AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RLS_LPBK_T1;
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RLS_LPBK_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, AID_T3,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_RLS_LPBK_E1; 
        p_comment = E1Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _lpbk_id, AID_E1,
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Loopback type is not supported at this time." );
        return eosl_false;
    }

    if(_locn)
    {
        buffer.Data.RlsLpbk.Location.valid = VALID_VALUE;
        buffer.Data.RlsLpbk.Location.value = *_locn;
    }
    if(_orgn)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Orgn - Must leave it blank" );
        return eosl_false;
#if 0
        buffer.Data.RlsLpbk.OriginatingOffice.valid = VALID_VALUE;
        buffer.Data.RlsLpbk.OriginatingOffice.value = *_orgn;
#endif
    }
    if(_intext)
    {
        buffer.Data.RlsLpbk.IntExt.valid = VALID_VALUE;
        buffer.Data.RlsLpbk.IntExt.value = *_intext;
    }
    if(_lpbktype)
    {
        buffer.Data.RlsLpbk.LpbkType.valid = VALID_VALUE;
        buffer.Data.RlsLpbk.LpbkType.value = *_lpbktype;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_RLS_LPBK,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RLS_LPBK_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, p_comment );
#endif
}


/**
 * Instructs an NE to remove one or more entities from
 * service. The entity is taken from an in service state and
 * placed in a maintenance state in which maintenance
 * activities can be performed or moved from the current
 * maintenance state to another maintenance state. No alarms
 * should be generated at the near end office as a result of
 * the RMV command. Once an entity is removed from service,
 * service-affecting diagnostic routines or replacement can be
 * initiated. The functionality can also be achieved using the
 * appropriate ED command.
 * GR 833
 */
eosl_bool agc_EM_NE_RMV_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp, char * _mode, char * _state)
{

    AID_INFO_TYPE_t                 aidInfo;
    TL1_BUF_t cmdMsg;
    TL1_BUF_t    respBuff;
#ifndef ATCA
    char                            *option = NULL;
    char                            *tmp    = NULL;
    eosl_bool                       normal  = eosl_false;
#endif
    
    /* parse AID, for command RMV-EQPT */
#ifdef ATCA
    int isAmc = 0;
    if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM | AID_AMCSS7, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;          
    }                                
    cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
    cmdMsg.CmdInfo.AtcaSlot.amcSlot = aidInfo.lvl3;
    isAmc = (aidInfo.lvl3 == -1)? 0:1;
#else     
    if(ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM), NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    cmdMsg.CmdInfo.RmvParams.SlotNum = aidInfo.lvl1;
#endif 


#ifdef ATCA
    if(_mode)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> mode");
        return eosl_false;
    }
    
#else

    cmdMsg.CmdInfo.RmvParams.Mode.valid = INVALID_VALUE;
    cmdMsg.CmdInfo.RmvParams.Mode.value = RMMODE_NORMAL;
    cmdMsg.CmdInfo.RmvParams.State.valid = INVALID_VALUE; /* Not support, but set any how */

    if(_mode)
    {

        /* For each option specified for mode */
       for (option = strtok_r(_mode, "&", &tmp);
            option;
            option = strtok_r(NULL, "&", &tmp))
       {
          if (eosl_strcasecmp(option, "FRCD") == 0) 
          {
             if (normal == eosl_true)
             {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Invalid option combination "
                                   "specified for mode" );  
                return eosl_false;
             }
             else if ((cmdMsg.CmdInfo.RmvParams.Mode.valid == VALID_VALUE)
                 && (cmdMsg.CmdInfo.RmvParams.Mode.value & RMMODE_FRCD_BIT))
             {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Duplicate options "
                                   "specified for mode" );  
                return eosl_false;
             }
             cmdMsg.CmdInfo.RmvParams.Mode.valid = VALID_VALUE;
             cmdMsg.CmdInfo.RmvParams.Mode.value |= RMMODE_FRCD_BIT;
          }

          else if (eosl_strcasecmp(option, "NORST") == 0)
          {
             if ((cmdMsg.CmdInfo.RmvParams.Mode.valid == VALID_VALUE)
                 && (cmdMsg.CmdInfo.RmvParams.Mode.value & RMMODE_NORST_BIT))
             {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Duplicate options "
                                   "specified for mode" );  
                return eosl_false;
             }
             cmdMsg.CmdInfo.RmvParams.Mode.valid = VALID_VALUE;
             cmdMsg.CmdInfo.RmvParams.Mode.value |= RMMODE_NORST_BIT;
          }

          else if (eosl_strcasecmp(option, "NORM") == 0) 
          {
             if (normal == eosl_true)
             {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Duplicate options "
                                   "specified for mode" );  
                return eosl_false;   
             }
             /* If the NORST option has also been specified */
             else if ((cmdMsg.CmdInfo.RmvParams.Mode.valid == VALID_VALUE)
                 && (cmdMsg.CmdInfo.RmvParams.Mode.value & RMMODE_FRCD_BIT))
             {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Invalid option combination "
                                   "specified for mode" );  
                return eosl_false;
             }

             /* No bit to set for NORM - it's the default */
             normal = eosl_true;
          }
          else
          {
             tc_error_response( handle, ctag, TE_IIAC,
                                "Input, Invalid mode option specified" );  
             return eosl_false;       
          }
       }
       
       if (cmdMsg.CmdInfo.RmvParams.Mode.valid == VALID_VALUE)
       {     
          if ((cmdMsg.CmdInfo.RmvParams.Mode.value & RMMODE_FRCD_BIT) && !(cmdMsg.CmdInfo.RmvParams.Mode.value & RMMODE_NORST_BIT))
          {
             tc_error_response( handle, ctag, TE_IIAC,
                                "Input, Invalid option combination "
                                "specified for mode" );  
             return eosl_false;
          }
          else
          {
             /* Only supported on SPs.
              */
             if (ParseAidMap(&aidInfo, _iomOrSp, AID_CPU, NULL) != SUCCESS)
             {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
                return eosl_false;
             }
          }
       }
    }
#endif
    if(_state)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> state" );
        return eosl_false;
    }

#ifdef ATCA
    /* EDWARD */
    if (isAmc)
    {
        TsSmiRowKey     rowKey;
        TsSmiColArray   colArray;
        TsSmiColObj     columns[MAX_TSM_COLS];
        TsTransId       transId = ctag;
        TsTableId       tableId = STGAMC_TAB_ID;
        int             colCnt = 0;
        int             retVal;
        SMCMD_t        smCmd;

        memset(&smCmd,0x0,sizeof(SMCMD_t));

        rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = aidInfo.lvl3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;

        rowKey.numIndices = 3;

        columns[colCnt].columnId = STGAMC_COL_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_PST_OOS;
        colCnt++;

        columns[colCnt].columnId = STGAMC_COL_CMD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_CMD_RMV;
        colCnt++;

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        return tc_compld_comment( handle, ctag, "RMV-EQPT" );
    }
    /* EDWARD */
#endif

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_REMOVE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_REMOVE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "RMV-EQPT" );
}


/**
 * Instructs the NE to restore one of more equipment units,
 * facilities, etc. The entity is taken from a maintenance
 * state and placed in an in-service state for which the unit
 * is ready to provide its service functions. It is assumed
 * that these entities are in good working order. This can be
 * verified with the DNG command. In addition, some NEs may
 * perform automatic tests fo the equipment before returning
 * it to an in-service state.
 */
eosl_bool agc_EM_NE_RST_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp, char * _mode)
{

    AID_INFO_TYPE_t                 aidInfo;
    TL1_BUF_t cmdMsg;
    TL1_BUF_t  respBuff;

    memset(&cmdMsg, 0, sizeof(TL1_BUF_t));

    /* parse AID, for command RST-EQPT */
#ifdef ATCA
    int isAmc = 0;
    if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM | AID_AMCSS7, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    cmdMsg.CmdInfo.RstParams.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.RstParams.AtcaSlot.atcaSlot = aidInfo.lvl2;
    cmdMsg.CmdInfo.RstParams.AtcaSlot.amcSlot = aidInfo.lvl3;
    isAmc = (aidInfo.lvl3 == -1) ?  0 : 1;
#else
    if(ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM), NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif

#ifndef ATCA
    if(_mode)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported" );
        return eosl_false;
    }
#else
    if (_mode)
    {
          if (strcasecmp(_mode, "NORST") != 0)
          {
             tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported" );
             return eosl_false;
          }
          else
          {
              cmdMsg.CmdInfo.RstParams.RsMode.valid = VALID_VALUE;
              cmdMsg.CmdInfo.RstParams.RsMode.value |= RSMODE_NOREBOOT_BIT;
          }
    }
#endif

#ifdef ATCA
    /* EDWARD */
    if (isAmc)
    {
        TsSmiRowKey     rowKey;
        TsSmiColArray   colArray;
        TsSmiColObj     columns[MAX_TSM_COLS];
        TsTransId       transId = ctag;
        TsTableId       tableId = STGAMC_TAB_ID;
        int             colCnt = 0;
        int             retVal;
        SMCMD_t        smCmd;

        memset(&smCmd,0x0,sizeof(SMCMD_t));

        rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = aidInfo.lvl3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;

        rowKey.numIndices = 3;

        columns[colCnt].columnId = STGAMC_COL_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_PST_IS;
        colCnt++;

        columns[colCnt].columnId = STGAMC_COL_CMD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_CMD_RST;
        colCnt++;

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        return tc_compld_comment( handle, ctag, "RST-EQPT" );
    }
    /* EDWARD */
#endif

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RESTORE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RESTORE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {

        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "RST-EQPT" );
}
/**
 * Retrieve  ATCA CHASSIS
 */
eosl_bool agc_EM_NE_RTRV_ATCA_CHASSIS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _src)
{
#ifdef ATCA
    CMD_BUF_t                   buffer;
    RTRV_ATCA_CHASSIS_resp_row  result;

    char s_dnsIP1[16];
    char s_dnsIP2[16];
    char s_SigAIpv4DfltGw[16];
    char s_SigBIpv4DfltGw[16];
    char s_SigCIpv4DfltGw[16];
    char s_SigDIpv4DfltGw[16];
    char s_EmIpv4DfltGw[16];  
    char s_SigAIpv6DfltGw[INET6_ADDRSTRLEN];
    char s_SigBIpv6DfltGw[INET6_ADDRSTRLEN];
    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(CMD_BUF_t));  /* sets all "valid" flags to 0 */

    if (_src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_CHASSIS,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    result._src = "COM";

    switch(buffer.CmdInfo.RtrvChassis.ChassisType)
    {
      case CHASSIS_TYPE_ATCA_MGC:
          result._chassisType = ChassisType_ATCA_MGC;
          break;
      case CHASSIS_TYPE_ATCA_SG:
          result._chassisType = ChassisType_ATCA_VSG;
          break;
      case CHASSIS_TYPE_ATCA_SG_MGC:
          result._chassisType = ChassisType_ATCA_VSG_MGC;
          break;
      default:
          result._chassisType = ChassisType_ALL;
          break;
     }

    if(strlen(buffer.CmdInfo.RtrvChassis.CLLI) > 0)
    {
        result._clli = buffer.CmdInfo.RtrvChassis.CLLI;
    }
    else
    {
        result._clli = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.Location) > 0)
    {
        result._loc  = buffer.CmdInfo.RtrvChassis.Location;
    }
    else
    {
        result._loc = "NULL";
    }
    
    result._sigaPort = mapTSMCTL1ATCAPortType(buffer.CmdInfo.RtrvChassis.MalbanPortForSigA);
    result._sigbPort = mapTSMCTL1ATCAPortType(buffer.CmdInfo.RtrvChassis.MalbanPortForSigB);
    result._sigcPort = mapTSMCTL1ATCAPortType(buffer.CmdInfo.RtrvChassis.MalbanPortForSigC);
    result._sigdPort = mapTSMCTL1ATCAPortType(buffer.CmdInfo.RtrvChassis.MalbanPortForSigD);
    result._emPort   = mapTSMCTL1ATCAPortType(buffer.CmdInfo.RtrvChassis.MalbanPortForMgmt);

    if (buffer.CmdInfo.RtrvChassis.DnsIP1)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.DnsIP1, s_dnsIP1);
        result._dnsIp1 = s_dnsIP1;
    }
    else
    {
        result._dnsIp1 = "NULL";
    }

    if (buffer.CmdInfo.RtrvChassis.DnsIP2)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.DnsIP2, s_dnsIP2);
        result._dnsIp2 = s_dnsIP2;
    }
    else
    {
        result._dnsIp2 = "NULL";
    }

    if(strlen(buffer.CmdInfo.RtrvChassis.DnsName) > 0)
    {
        result._dnsName = buffer.CmdInfo.RtrvChassis.DnsName;
    }
    else
    {
        result._dnsName = "NULL";
    }

    result._emtos = (strlen(buffer.CmdInfo.RtrvChassis.MgmtTos) == TOS_BITS_STR_LEN)?
                    buffer.CmdInfo.RtrvChassis.MgmtTos:"NULL";

    result._sigatos = (strlen(buffer.CmdInfo.RtrvChassis.SigATos) == TOS_BITS_STR_LEN)?
                      buffer.CmdInfo.RtrvChassis.SigATos:"NULL";

    result._sigbtos = (strlen(buffer.CmdInfo.RtrvChassis.SigBTos) == TOS_BITS_STR_LEN)?
                      buffer.CmdInfo.RtrvChassis.SigBTos:"NULL";

    result._sigctos = (strlen(buffer.CmdInfo.RtrvChassis.SigCTos) == TOS_BITS_STR_LEN)?
                      buffer.CmdInfo.RtrvChassis.SigCTos:"NULL";

    result._sigdtos = (strlen(buffer.CmdInfo.RtrvChassis.SigDTos) == TOS_BITS_STR_LEN)?
                      buffer.CmdInfo.RtrvChassis.SigDTos:"NULL";

    /*
    **  Send off Response
    */
    switch(buffer.CmdInfo.RtrvChassis.ChassisState)
   {
     case CHASSIS_STATE_NORMAL:
         result._upgradeState = upgradeState_NORMAL;
         break;
     case CHASSIS_STATE_UPGRADE:
         result._upgradeState = upgradeState_UPGRADE;
         break;
     default:
        break;
   }

    switch(buffer.CmdInfo.RtrvChassis.EnableBTS)
   {
     case TRUE:
         result._internalBTS = BoolYN_Y;
         break;
     case FALSE:
         result._internalBTS = BoolYN_N;
         break;
     default:
        break;
   }

    result._systemId = (strlen(buffer.CmdInfo.RtrvChassis.SystemId))
        ? buffer.CmdInfo.RtrvChassis.SystemId
        : "NULL";

    /*16576.0*/
    if (buffer.CmdInfo.RtrvChassis.SigAIpv4DfltGw)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SigAIpv4DfltGw, s_SigAIpv4DfltGw);
        result._sigAIPv4DfltGw = s_SigAIpv4DfltGw;
    }
    else
    {
        result._sigAIPv4DfltGw = "NULL";
    }
 
   switch(buffer.CmdInfo.RtrvChassis.SigAIpv4GwPing)
   {
     case TRUE:
         result._sigAIPv4GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigAIPv4GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
     if(IPV6_VALID(buffer.CmdInfo.RtrvChassis.SigAIpv6DfltGw))
     {
        ip6_ntopexp(&buffer.CmdInfo.RtrvChassis.SigAIpv6DfltGw, s_SigAIpv6DfltGw, INET6_ADDRSTRLEN);
        result._sigAIPv6DfltGw = tl1QuoteString(s_SigAIpv6DfltGw, s_SigAIpv6DfltGw);
     }
    else
     {
        result._sigAIPv6DfltGw = "NULL";
     }
    switch(buffer.CmdInfo.RtrvChassis.SigAIpv6GwPing)
   {
     case TRUE:
         result._sigAIPv6GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigAIPv6GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
   
    if (buffer.CmdInfo.RtrvChassis.SigBIpv4DfltGw)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SigBIpv4DfltGw, s_SigBIpv4DfltGw);
        result._sigBIPv4DfltGw = s_SigBIpv4DfltGw;
    }
    else
    {
        result._sigBIPv4DfltGw = "NULL";
    }
   switch(buffer.CmdInfo.RtrvChassis.SigBIpv4GwPing)
   {
     case TRUE:
         result._sigBIPv4GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigBIPv4GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
    if(IPV6_VALID(buffer.CmdInfo.RtrvChassis.SigBIpv6DfltGw))
     {
        ip6_ntopexp(&buffer.CmdInfo.RtrvChassis.SigBIpv6DfltGw, s_SigBIpv6DfltGw, INET6_ADDRSTRLEN);
        result._sigBIPv6DfltGw = tl1QuoteString(s_SigBIpv6DfltGw, s_SigBIpv6DfltGw);
     }
    else
     {
        result._sigBIPv6DfltGw = "NULL";
     }
    switch(buffer.CmdInfo.RtrvChassis.SigBIpv6GwPing)
   {
     case TRUE:
         result._sigBIPv6GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigBIPv6GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
   
   /*sigc*/
    if (buffer.CmdInfo.RtrvChassis.SigCIpv4DfltGw)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SigCIpv4DfltGw, s_SigCIpv4DfltGw);
        result._sigCIPv4DfltGw = s_SigCIpv4DfltGw;
    }
    else
    {
        result._sigCIPv4DfltGw = "NULL";
    }
   switch(buffer.CmdInfo.RtrvChassis.SigCIpv4GwPing)
   {
     case TRUE:
         result._sigCIPv4GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigCIPv4GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
   /*sigD*/
    if (buffer.CmdInfo.RtrvChassis.SigDIpv4DfltGw)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.SigDIpv4DfltGw, s_SigDIpv4DfltGw);
        result._sigDIPv4DfltGw = s_SigDIpv4DfltGw;
    }
    else
    {
        result._sigDIPv4DfltGw = "NULL";
    }
    switch(buffer.CmdInfo.RtrvChassis.SigDIpv4GwPing)
   {
     case TRUE:
         result._sigDIPv4GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._sigDIPv4GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
   /*EM*/
     if (buffer.CmdInfo.RtrvChassis.EmIpv4DfltGw)
    {
        ip_i2a(buffer.CmdInfo.RtrvChassis.EmIpv4DfltGw, s_EmIpv4DfltGw);
        result._emIPv4DfltGw = s_EmIpv4DfltGw;
    }
    else
    {
        result._emIPv4DfltGw = "NULL";
    }
     switch(buffer.CmdInfo.RtrvChassis.EmIpv4GwPing)
   {
     case TRUE:
         result._emIPv4GwPing = dfltGateWay_ENABLED;
         break;
     case FALSE:
         result._emIPv4GwPing = dfltGateWay_DISABLED;
         break;
     default:
        break;
   }
    return agc_EM_NE_RTRV_ATCA_CHASSIS_resp( modifier,
                                             handle,
                                             ctag,
                                             TCC_COMPLD,
                                             &result,
                                             1,
                                             "RTRV-ATCA-CHASSIS",
                                             NULL );
#endif
    return eosl_true;

 
}

/**
 */
eosl_bool agc_EM_NE_RTRV_CRS_T0_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _t0From, TL1_AID _t0To)
{
    BITS_CMD_BUF_t      buffer;
    BITS_ACK_BUF_t      response;
    RTRV_CRS_T0_resp_row result[DS0S_PER_E1];
    char                aidStrings[DS0S_PER_E1][32];
    char                tmpPrimaryState[32];
    char                tmpPrimaryQualifier[32];
    char                primaryState[DS0S_PER_E1][32];
    char                secondaryState[DS0S_PER_E1][32];
    char                tpStr[DS0S_PER_E1][32];
    int                 totRows;
    int                 tmpPort;
    int                 i;
    int                 crsFound=0;
    int                 rtrvAll=0;

#if 0 /* Bug:74316 Remove sending to Signaling, because LM doesn't implement it. */
   /*designate for Sig*/
    TsTransId      	    transId;
    TsTableId      	    tableId;
    TsSmiRowKey    	    rowKey;
    TsSmiColArray  	    colArray;
    TsSmiColObj    	    columns[MAX_TSM_COLS];
    SMCMD_t        	    smCmd;
    u8                  *smCmdPtr = (u8 *)&smCmd;
    short		        retVal;
    short 		        length;
    char		        fromIomToPort[64]; /*1st half of the aid except the range "from" num*/
    char		        toIomToPort[64]; /*1st half of the aid except the range "to" num*/
    int 		        numPart=0;
    int			        totParts=0;
    int            	    colnCnt=0;
    int                 rangePresentFrom = 0;
    int                 rangePresentTo   = 0;
    char			    secondHalfFrom[64]; /*1st half of the aid except the range "from" num*/
    char			    secondHalfTo[64]; /*1st half of the aid except the range "from" num*/
#endif /* Bug 74316 */

       /* 
       ** we will send request to BITS
       ** if TP is specified
       */
       if (_t0To == NULL   && _t0From == NULL)
       {
         rtrvAll=1;
       }

       /*
       ** set up t1 data structure
       */
       memset(&buffer, 0, SIZEOF_BITSCMD);

       /* Bug:74316. change the original judgement as following to if(1), in case only t0From
          is present and t0To is NULL, or t0T0 is present and t0From is NULL.
          original judgement:
          if (rtrvAll || ((_t0From && _t0To) && !(eosl_strncasecmp(_t0To, "TP-", 3)))) */
       if (1)
       {
          /* 
          ** Send event
          */
          if(TL1SendMsg(handle, ctag,
                  BITS_CMD_CLASS, CMD, BITSCMD_CRS_RTRV,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_BITSCMD,
                  (TL1_CMD_BUF_t *)&response, sizeof(BITS_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)


          {
              procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_CRS_T0_req","We have a bad response \n");
              TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
              return eosl_false;
          }
        
          totRows = response.Data.CrsBulkRtrvResp.NumEntries;

          /* 
          ** fill response info
          */
          for (i = 0; i <  totRows; i++)
          {

              if(response.Data.CrsBulkRtrvResp.Data[i].TypeIsT3Flag !=0)
              {
                  DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                FALSE,
                                aidStrings[i]);
              }
              else
              {
                  switch(response.DeviceMap)
                  {
                  case DEVICE_MAP_IOM_E1:
                  {
                      E1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                      FALSE,
                                      aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_STM1_TUG3_E1:
                  {
                      StmTug3E1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                             FALSE,
                                             aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_STM1_AU3_E1:
                  {
                      StmAu3E1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                            FALSE,
                                            aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_STM1_TUG3_T1:
                  {
                      StmTug3T1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                             FALSE,
                                             aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_STM1_AU3_T1:
                  {
                      StmAu3T1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                            FALSE,
                                            aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_T1:                      
                  {
                      T1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                      FALSE,
                                      aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_STS1_T1:                      
                  {
                      STS1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                        FALSE,
                                        aidStrings[i]);
                  }
                  break;
                  case DEVICE_MAP_IOM_OC3_STS1_T1:                      
                  {
                      OC3STS1T1DeviceIdToAid(response.Data.CrsBulkRtrvResp.Data[i].DeviceId,
                                        FALSE,
                                        aidStrings[i]);
                  }
                  break;
                  }
              }
              result[i]._t0From= &(aidStrings[i][0]);
            
              tmpPort = response.Data.CrsBulkRtrvResp.Data[i].TestPort;
              eosl_sprintf(&tpStr[i][0], "TP-%d", tmpPort);
              result[i]._t0To = &(tpStr[i][0]);

              SetStateNames(response.Data.CrsBulkRtrvResp.Data[i].State,
                            0x00,
                            tmpPrimaryState,
                            tmpPrimaryQualifier,
                            &(secondaryState[i][0]));
              strcpy(&(primaryState[i][0]), tmpPrimaryState);
              result[i]._pst = &(primaryState[i][0]);
          /*sprintf( &(tempBuff[i][0]),"%s,%s",result[i]._t0Type,result[i]._tpNum);
            result[i]._src=tempBuff[i];*/
          

          if ( !rtrvAll )
          {
            if ( eosl_strcasecmp(_t0From, result[i]._t0From)   == 0  &&
                     eosl_strcasecmp(_t0To,  result[i]._t0To)   == 0 )
              {
                result[0]._t0From  = result[i]._t0From;
                result[0]._t0To    = result[i]._t0To;
                totRows=1;
                crsFound=1;
                break;
              }

          }
          
          }


          if  (  !rtrvAll &&  !crsFound )
          {

              tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
              return eosl_false;
          }

          /*
          ** send tl1 response
          */
          if(totRows >0||rtrvAll)
          agc_EM_NE_RTRV_CRS_T0_resp( modifier,
                                             handle,
                                             ctag,
                                             TCC_COMPLD,
                                             result,
                                             totRows,
                                             "RTRV-CRS-T0",
                                             NULL );
       }

#if 0 /* Bug:74316 Remove sending to Signaling, because LM doesn't implement it. */

       /*Send the command to Signaling only if it is not a RTRV-ALL
        *Signaling does not support a RTRV-ALL for DSO Nail up
        */

       if(!rtrvAll)
       {
        length = sizeof(SMCMD_t);
        tableId = CRS_TAB_ID;
		transId = ctag;
        if (_t0From== NULL   && _t0To== NULL)
        {
       
                rowKey.numIndices = 0;
		        colArray.numCols  = 0;
		        colArray.colArray = columns;
        }
        else
        {
                /*
                ** prepare tp data structure
                */
                if(_t0From)
                {
                        if(!parseAidT0RngCk(_t0From, fromIomToPort, secondHalfFrom, &numPart,&rangePresentFrom))
                        {
                            tc_error_response( handle, ctag, TE_IIAC, 
                                               "Invalid Access Identifier (AID) -> _crsFrom" );  
                            return eosl_false;
                        }
                        totParts = numPart; /*numPart = 2 if aid is range other wise 1*/
                }
                if(_t0To)
                {
                    if(!parseAidT0RngCk(_t0To, toIomToPort, secondHalfTo, &numPart,&rangePresentTo))
                    {
                        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> _crsT0" );  
                        return eosl_false;
                    }
                    totParts += numPart;
                }

                /*
                **validate different combination of AIDs
                */
                if((totParts != 1) && (totParts != 2) && (totParts != 4))
                {
                    tc_error_response( handle, ctag, TE_IIAC, 
                                       "Invalid Access Identifier (AID)" );  
                    return eosl_false;
                }
          
                if (totParts == 1)
                {
                    rowKey.numIndices =1;

                    rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
                    rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
                    rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;
                }	
            
                if ((totParts == 2) && (_t0To == NULL))
                {
                    rowKey.numIndices =2;

                    rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
                    rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
                    rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;

                    rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
                    rowKey.rowIndex[1].value.stringVal.len = strlen(secondHalfFrom);
                    rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) secondHalfFrom;
                }
                else if (totParts == 2)
                {
                    rowKey.numIndices =2;

                    rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
                    rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
                    rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;

                    rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
                    rowKey.rowIndex[1].value.stringVal.len = strlen(toIomToPort);
                    rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) toIomToPort;
                }

                /*both from and to DSO are in range*/
                if (totParts == 4)
                {
                   rowKey.numIndices =4;
                  
                   rowKey.rowIndex[0].colType =TSSMI_OCTET_STRING;
                   rowKey.rowIndex[0].value.stringVal.len = strlen(fromIomToPort);
                   rowKey.rowIndex[0].value.stringVal.ptr = (u8 *) fromIomToPort;
                  
                   rowKey.rowIndex[1].colType =TSSMI_OCTET_STRING;
                   rowKey.rowIndex[1].value.stringVal.len = strlen(secondHalfFrom);
                   rowKey.rowIndex[1].value.stringVal.ptr = (u8 *) secondHalfFrom;

                   rowKey.rowIndex[2].colType =TSSMI_OCTET_STRING;
                   rowKey.rowIndex[2].value.stringVal.len = strlen(toIomToPort);
                   rowKey.rowIndex[2].value.stringVal.ptr = (u8 *) toIomToPort;

                   rowKey.rowIndex[3].colType =TSSMI_OCTET_STRING;
                   rowKey.rowIndex[3].value.stringVal.len = strlen(secondHalfTo);
                   rowKey.rowIndex[3].value.stringVal.ptr = (u8 *) secondHalfTo;
                }
                if(rangePresentFrom || rangePresentTo)
                {
                    columns[colnCnt].columnId = CRS_RANGE;
                    columns[colnCnt].value.colType = TSSMI_LONG;
                    columns[colnCnt].value.value.longVal = rangePresentFrom|rangePresentTo;
                    colnCnt++;
                }
       }
		colArray.numCols  = colnCnt;
		colArray.colArray = columns;
	
        retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


		if (retVal == FALSE)
		{
			TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
			return eosl_false;
		}

		retVal=emfUnpkSmiGetMultiResp(rtrvCrsT0Resp, &smCmdPtr, &length, handle);
		if (retVal == FALSE)
		{
			tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
			return eosl_false;
		}
		else
		{
			return eosl_true;
		}
     }
#endif  /* Bug 74316 */
    return eosl_true;
}
/**
 */
eosl_bool agc_EM_NE_RTRV_EXSCHED_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
    
    RTRV_EXSCHED_EQPT_resp_row  result[MAX_IOMS + NUM_SCS + NUM_SF];
    AID_INFO_TYPE_t             aidInfo;
    char                        slotNum[MAX_IOMS+NUM_SCS][16];
    char                        invlUnVal[MAX_IOMS+NUM_SCS][16];
    char                        stadat[MAX_IOMS+NUM_SCS][16];
    char                        statm[MAX_IOMS+NUM_SCS][16];
    char                        interval[MAX_IOMS+NUM_SCS][16];
    CMD_BUF_t                   respBuff;
    TL1_BUF_t                   cmdMsg;
    int                         entryCount = 0, slotCount;
#ifndef ATCA
    int                         slot=0;
#endif
    int                         i;

    memset(slotNum,0x0, sizeof(slotNum));
    /* parse AID, for command RTRV-EXSCHED-EQPT */
#ifdef ATCA
    if(_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
        slotCount = 1;
    }
    else /* No AID given -- default to ALL. */
    {
        slotCount = NUM_IOMS;
        cmdMsg.CmdInfo.AtcaSlot.shelfId = 0;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = ALL_SLOTS;
    }
#else
    if(_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        slotCount=1;
        slot=aidInfo.lvl1;
    }
    else /* No AID given -- default to ALL. */
    {
        slotCount = MAX_IOMS + NUM_SCS;

        slot=ALL_SLOTS;
    }

    /*
    ** Prepare event
    */

    cmdMsg.CmdInfo.SlotNum=slot;
#endif

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_EX_SCHED,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_EX_SCHED,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }   


    /*
    ** get cpu information
    */

#ifdef ATCA
    for ( i=0;  i < (MAX_PHYSICAL_SLOT_ID - MIN_PHYSICAL_SLOT_ID); i++)
#else
    for( i=0; i< slotCount; i++)
#endif
    {
#ifdef ATCA
        procLogMsg (PLOG_ERROR,
                    "DEBUG",
                    "Entry[%d/%d]: shelfId: %d, slotNum: %d, Interval: %d\n"
                    "StartHour:%d, StartMinute: %d, NumInvl: %d, ReptMode: %d, Inhibited: %d\n",
                    i, slotCount, respBuff.CmdInfo.RtrvExSchedEqpt[i].shelfId,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].SlotNum, 
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].Interval,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].StartHour,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].StartMinute,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].NumInvl,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].ReptMode,
                    respBuff.CmdInfo.RtrvExSchedEqpt[i].Inhibited
                    );

        sprintf(&(slotNum[i][0]), "SHELF-%d-ACM-%d", respBuff.CmdInfo.RtrvExSchedEqpt[i].shelfId, respBuff.CmdInfo.RtrvExSchedEqpt[i].SlotNum);

        if (respBuff.CmdInfo.RtrvExSchedEqpt[i].SlotNum == 0)
        {
            continue;
        } 
#else
        if( respBuff.CmdInfo.RtrvExSchedEqpt[i].SlotNum == 0 )
            continue;
        
        SlotToAid(respBuff.CmdInfo.RtrvExSchedEqpt[i].SlotNum, slotNum[i]);
#endif
        result[entryCount]._iomOrSp = &(slotNum[i][0]);

        if (respBuff.CmdInfo.RtrvExSchedEqpt[i].IntervalUnit==1)
        {
            sprintf(&(invlUnVal[i][0]), "%d-DAY", respBuff.CmdInfo.RtrvExSchedEqpt[i].Interval);
        }
        else
        {
            sprintf(&(invlUnVal[i][0]), "%d-HR", respBuff.CmdInfo.RtrvExSchedEqpt[i].Interval);
        }
        result[entryCount]._invl = &(invlUnVal[i][0]);
           
        /*15134*/
        sprintf(&(stadat[i][0]),"%d-%d",respBuff.CmdInfo.RtrvExSchedEqpt[i].StartMonth,
                respBuff.CmdInfo.RtrvExSchedEqpt[i].StartDay);
        result[entryCount]._stadat = &(stadat[i][0]);
 
        sprintf(&(statm[i][0]), "%d-%d", respBuff.CmdInfo.RtrvExSchedEqpt[i].StartHour,
                respBuff.CmdInfo.RtrvExSchedEqpt[i].StartMinute);
        result[entryCount]._statm = &(statm[i][0]);
       
        if (respBuff.CmdInfo.RtrvExSchedEqpt[i].NumInvl == INDEFINITE_INVL_VALUE)
        {
          result[entryCount]._numinvl = "";
        }
        else
        {
           sprintf(&(interval[i][0]),"%d",respBuff.CmdInfo.RtrvExSchedEqpt[i].NumInvl);
        
           result[entryCount]._numinvl = &(interval[i][0]);
        }
        result[entryCount]._reptmode = respBuff.CmdInfo.RtrvExSchedEqpt[i].ReptMode;
        result[entryCount]._inhmode = (respBuff.CmdInfo.RtrvExSchedEqpt[i].Inhibited)
            ? InhibitMode_INHIBITED : InhibitMode_ALLOWED;
#ifdef ATCA
        result[entryCount]._exType = ExType_SWTOPROTN;
#else
        switch (respBuff.CmdInfo.RtrvExSchedEqpt[i].ExType)
        {
        case SW_TO_PROTECTION:
            result[entryCount]._exType = ExType_SWTOPROTN;
            break;
            
        case STANDARD_SELFTEST:
            result[entryCount]._exType = ExType_STANDARD;
            break;
            
        case EXTENDED_SELFTEST:
            result[entryCount]._exType = ExType_EXTENDED;
            break;
            
        default:
            result[entryCount]._exType = ExType_ALL; /* exception handler */
            break;
        }
#endif

        entryCount++;
#ifdef ATCA
        /* hardcode to let the max of entryCount be 10 */
        if (entryCount == 10)
        {
            break;
        }
#endif
    }

    /*
    ** send tl1 response
    */
    return agc_EM_NE_RTRV_EXSCHED_EQPT_resp( modifier,
                                             handle,
                                             ctag,
                                             TCC_COMPLD,
                                             result,
                                             entryCount,
                                             "RTRV-EXSCHED-EQPT",
                                             NULL );

}

/**
 * Retrieve  IPATK PARAMS
 */
eosl_bool agc_EM_NE_RTRV_IPATK_PARAMS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkType)
{
	int i,count = 0;
	RTRV_IPATK_PARAMS_resp_row result[MAX_NUM_IPATK_MONTYPE];
	TL1_EMF_IPATK_DATA_t buffer;
	EMF_TL1_IPATK_t resp;
	memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
	memset(&resp, 0, sizeof(EMF_TL1_IPATK_t));
	if(_ipAtkType)
	{
		if (eosl_strcasecmp(_ipAtkType,"SMURF") == 0)
		{
			buffer.Data.RtrvParams.MonType = IPATK_SMURF;
		}
		else if (eosl_strcasecmp(_ipAtkType,"INV_TCPFLAG") == 0)
		{
			buffer.Data.RtrvParams.MonType = IPATK_INV_TCPFLAG; 
		}
		else if (eosl_strcasecmp(_ipAtkType,"ICMP_REDIRECT") == 0)
		{
			buffer.Data.RtrvParams.MonType = IPATK_ICMP_REDIRECT;
		}
		else
		{
			tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
			return eosl_false;
		}
		count = 1;
	}
	else
	{
		 buffer.Data.RtrvParams.MonType = IPATK_ALL_MONTYPES;
		 count = MAX_NUM_IPATK_MONTYPE;
	}
        /*
	 ** Send event
        */
	if (TL1SendMsg(handle, ctag,
		       TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		       CMD_RTRV_IPATK_PARAMS,
		       (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_RTRV_IPATK_PARAMS,
		       (TL1_CMD_BUF_t *)&resp, sizeof(EMF_TL1_IPATK_t),
		       TL1_MSG_TIMEOUT) == FAIL)
	{
		TL1ErrorResp( handle, ctag, CMD_EQM, resp.Tl1Cmd.Error );
		return eosl_false;
	}
	for ( i = 0 ;i < count ; i++)
	{
		switch(resp.Data.Params[i].MonType)
		{
			case IPATK_SMURF:
				result[i]._ipAtkType = "SMURF";
				break;
			case IPATK_INV_TCPFLAG:
				result[i]._ipAtkType = "INV_TCPFLAG";
				break;
			case IPATK_ICMP_REDIRECT:
				result[i]._ipAtkType = "ICMP_REDIRECT";
				break;
			default:
				break;
		}
		result[i]._ipAtkLogPrflId = resp.Data.Params[i].LogPrflId;
	}
    return agc_EM_NE_RTRV_IPATK_PARAMS_resp(modifier,
		                            handle,
		                            ctag,
		                            TCC_COMPLD,
		                            result,
		                            count,
		                            "RTRV-IPATK-PARAMS",
		                            NULL);
}

/**
 */
eosl_bool agc_EM_NE_RTRV_STATUS_ALMQ_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _almqSessionId)
{
    RTRV_STATUS_ALMQ_resp_row result[MAX_ALMQ_USERS];
    Link_Object *tmp = NULL;
    char sidStrings[MAX_ALMQ_USERS][33];
    char ipStrings[MAX_ALMQ_USERS][24];
    char ctsStrings[MAX_ALMQ_USERS][MAX_TIMESTAMP_LEN];
    char qtsStrings[MAX_ALMQ_USERS][MAX_TIMESTAMP_LEN];
    char rtsStrings[MAX_ALMQ_USERS][MAX_TIMESTAMP_LEN];
    char stStrings[MAX_ALMQ_USERS][16];
    char *tmpStString;
    char ipbuf[16];

    TL1_ASESSION *as = NULL;
    const Vector *asessions = NULL;

    int i,j;
    int resultRows = 0;
    int entries = 0;
    char * pch;
    char sessionId[20];   
  
    /*
    ** Prepare response buffer
    */

    /* for either single-shot or wildcard almqSession, display the ASESSION
     * status
     */
    if ((entries = as_count_sessions()) > 0)
    {
        if ((!(asessions = as_get_internal_vector())) ||
            (!(tmp = asessions->head)))
        {
            tc_error_response( handle, ctag, TE_IIAC,
                               "Invalid Access Identifier (AID) - no ALMQ Session" );
            return eosl_false;
        }
        if (entries > 32)
        {
            tc_error_response( handle, ctag, TE_IIAC,
                               "Invalid Number of ALMQ Entries" );
            TL1LOGP(PLOG_ERROR, "Invalid number of entries %d\n",entries);
            return eosl_false;
        }
    }
    if(!_almqSessionId) 
    {  
    for (i = 0; i < entries; i++, tmp = tmp->next)
    {
        if (!tmp)
            break;
        if (!(as = (TL1_ASESSION *)tmp->object))
           continue;

        if (as->sin_port == EMSPORT_DEFAULT)
        continue;

        sprintf(sidStrings[resultRows], "%d.%d.%d.%lx", 
		as->handle,
		as->ts?as->ts->handle:0,
		handle,
		as->sin_addr);
        result[resultRows]._almqSessionId = sidStrings[resultRows];

        ip_i2a(as->sin_addr, ipbuf);
        sprintf(ipStrings[resultRows], "%s-%d", ipbuf, as->UserAccessPortType);
        result[resultRows]._srcIpAddr = ipStrings[resultRows];

        sprintf(ctsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                as->cdate.year, as->cdate.month, as->cdate.day,
                as->ctime.hour, as->ctime.minute, as->ctime.second);
        result[resultRows]._connectTimestamp = ctsStrings[resultRows];

        sprintf(qtsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                as->qdate.year, as->qdate.month, as->qdate.day,
                as->qtime.hour, as->qtime.minute, as->qtime.second);
        result[resultRows]._queueingTimestamp = qtsStrings[resultRows];

        sprintf(rtsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                as->rdate.year, as->rdate.month, as->rdate.day,
                as->rtime.hour, as->rtime.minute, as->rtime.second);
        result[resultRows]._replayTimestamp = rtsStrings[resultRows];
        switch(as->almqState)
        {
        case ALMQ_STATE_CONNECT:
            tmpStString = "CONNECT";
            break;
        case ALMQ_STATE_QUEUE:
            tmpStString = "QUEUE";
            break;
        case ALMQ_STATE_REPLAY:
            tmpStString = "REPLAY";
            break;
        case ALMQ_STATE_KEEPALIVE:
            tmpStString = "KEEPALIVE";
            break;
        default:
            tmpStString = "UNKNOWN";
            break;
        }

        sprintf(stStrings[resultRows], "%s", tmpStString);
        result[resultRows]._almqState = stStrings[resultRows];

        resultRows++;
    }
    }
    /*BUG82840  Specific almqSessionId - validate AID almqSessionId, the ipAddr */
    else
    {
        sprintf(sessionId,"%s",_almqSessionId);
        pch = strtok (_almqSessionId,".");
        for (j=0; j<3; j++)
        {
            if((!pch)||(strlen(pch)>2)||(!IsInputStrInRange(pch,"0123456789")))
            {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            pch = strtok (NULL, ".");
        }
        if((!pch)||(strlen(pch)>8)||(!IsInputStrInRange(pch,"0123456789ABCDEFabcdef")))
        {
            tc_error_response( handle, ctag, TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        for (i = 0; i < entries; i++, tmp = tmp->next)
        {
            if (!tmp)
              break;
            if (!(as = (TL1_ASESSION *)tmp->object))
              continue;
 
            if (as->sin_port == EMSPORT_DEFAULT)
              continue;
            sprintf(sidStrings[resultRows], "%d.%d.%d.%lx",
                    as->handle,
                    as->ts?as->ts->handle:0,
                    handle,
                    as->sin_addr);
            if(!strcmp(sessionId, sidStrings[resultRows]))
            {
                result[resultRows]._almqSessionId =sidStrings[resultRows];;
                ip_i2a(as->sin_addr, ipbuf);
                sprintf(ipStrings[resultRows], "%s-%d", ipbuf, as->UserAccessPortType);
                result[resultRows]._srcIpAddr = ipStrings[resultRows];
                sprintf(ctsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                        as->cdate.year, as->cdate.month, as->cdate.day,
                        as->ctime.hour, as->ctime.minute, as->ctime.second);
                result[resultRows]._connectTimestamp = ctsStrings[resultRows];
         
                sprintf(qtsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                        as->qdate.year, as->qdate.month, as->qdate.day,
                        as->qtime.hour, as->qtime.minute, as->qtime.second);
                result[resultRows]._queueingTimestamp = qtsStrings[resultRows];

                sprintf(rtsStrings[resultRows], "%04d-%02d-%02d %02d:%02d:%02d",
                        as->rdate.year, as->rdate.month, as->rdate.day,
                        as->rtime.hour, as->rtime.minute, as->rtime.second);
                result[resultRows]._replayTimestamp = rtsStrings[resultRows];
                switch(as->almqState)
                {
                  case ALMQ_STATE_CONNECT:
                    tmpStString = "CONNECT";
                    break;
                  case ALMQ_STATE_QUEUE:
                    tmpStString = "QUEUE";
                    break;
                  case ALMQ_STATE_REPLAY:
                    tmpStString = "REPLAY";
                    break;
                  case ALMQ_STATE_KEEPALIVE:
                    tmpStString = "KEEPALIVE";
                    break;
                  default:
                    tmpStString = "UNKNOWN";
                    break;
                }
                sprintf(stStrings[resultRows], "%s", tmpStString);
                result[resultRows]._almqState = stStrings[resultRows];
            
                resultRows = 1 ;
                break;
            }
            else
            {
                if(i==entries-1)
                {
	        tc_error_response( handle, ctag, TE_IENE,
                               "Specified Object Entity Does Not Exist" );
                return eosl_false;
                }   
	    }
        }
    }

    return agc_EM_NE_RTRV_STATUS_ALMQ_resp( modifier,
                                            handle,
                                            ctag,
                                            TCC_COMPLD,
                                            (RTRV_STATUS_ALMQ_resp_row *)result,
                                            resultRows,
                                            "RTRV-STATUS-ALMQ",
                                            NULL);

}

/**
 * Retrieve  STATUS CM
 */
eosl_bool agc_EM_NE_RTRV_STATUS_CM_req( const char * modifier,\
                                        eosl_handle handle,\
                                        TL1_TAG ctag ,\
                                        TL1_AID _iomAid)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
    int            colCnt = 0;
    AID_INFO_TYPE_t     aidInfo;

    length = sizeof(SMCMD_t);
	
    tableId = STATUS_CM_TAB_ID;
    transId = ctag;

#ifndef ATCA
    if(ParseAidMap(&aidInfo, _iomAid, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, 
                           "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
#else
    if(ParseAidMap(&aidInfo, _iomAid, AID_ACM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    rowKey.numIndices = 2;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
#endif


    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_RTRV_STATUS_CM_req", 
                   "RTRV_STATUS_CM - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if (retVal== FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }	

    retVal=emfUnpkSmiGetMultiResp(rtrvStatusCmMultiTsmResp, &smCmdPtr, &length,
                                  handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, 
                          "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
}

/**
 */
eosl_bool agc_EM_NE_RTRV_TESTPORT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
    
    BITS_CMD_BUF_t      buffer;
    BITS_ACK_BUF_t      response;
    RTRV_TESTPORT_resp_row result[NUM_TEST_PORTS];
    char                tmpPrimaryState[32];
    char                tmpPrimaryQualifier[32];
    char                primaryState[NUM_TEST_PORTS][32];
    char                secondaryState[NUM_TEST_PORTS][32];
    char                aidStrings[NUM_TEST_PORTS][32];
    int         totRows;
    int                 i;


    /*
    ** set up t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD);

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }

    /* 
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  BITS_CMD_CLASS, CMD, BITSCMD_TEST_PORT_RTRV,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD,
                  (TL1_CMD_BUF_t *)&response, sizeof(BITS_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_TESTPORT_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
        return eosl_false;
    }
  
    totRows = response.Data.TpBulkRtrvResp.NumEntries;

    /* 
    ** fill response info
    */
    for (i = 0; i <  totRows; i++)
    {
        result[i]._src = "COM";
        DeviceIdToAid(response.DeviceId,
                      FALSE,
                      aidStrings[i]);
        result[i]._iom = &(aidStrings[i][0]);
        result[i]._tpMonitor = response.Data.TpBulkRtrvResp.Data[i].Mode;

        SetStateNames(response.Data.TpBulkRtrvResp.Data[i].State,
                      0x00,
                      tmpPrimaryState,
                      tmpPrimaryQualifier,
                      &(secondaryState[i][0]));
        if (strlen(tmpPrimaryQualifier) > 0)
        {
            sprintf(&(primaryState[i][0]), "%s-%s", tmpPrimaryState, tmpPrimaryQualifier);
        }
        else
        {
            strcpy(&(primaryState[i][0]), tmpPrimaryState);
        }
        result[i]._primaryState = &(primaryState[i][0]);
    }


    /*
    ** send tl1 response
    */
    return agc_EM_NE_RTRV_TESTPORT_resp( modifier,
                                         handle,
                                         ctag,
                                         TCC_COMPLD,
                                         result,
                                         totRows,
                                         "RTRV-TESTPORT",
                                         NULL );    
}

/**
 */
eosl_bool agc_EM_NE_RTRV_TL1_INH_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _tl1cmd)
{
    TL1_BUFFER            *tl1_b   = NULL;
    RTRV_TL1_INH_resp_row *rowsPtr;
    INHCMD_DATA_t         *cmds;
    INHCMD_DATA_t         *tl1cmdPtr;
    char                  no_cmd[] = "NO_CMD";
    int                   mode     = RTRV_ROW;
    int                   count    = 0;
    int                   i;
    eosl_bool             rc;

    /* If the inhibited command array can not be dynamically allocated */
    if ((cmds = (INHCMD_DATA_t *)eosl_malloc(
        sizeof(INHCMD_DATA_t) * MAX_INH_TL1_CMD)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_ALW_TL1_CMD_req",
                    "agc_EM_NE_ALW_TL1_CMD_req malloc failure\n");
        return eosl_false;
    }
    memset(cmds, 0, (MAX_INH_TL1_CMD * sizeof(INHCMD_DATA_t)));
    
    /* If the inhibited command response array can not be dynamically allocated */
    if ((rowsPtr =
         (RTRV_TL1_INH_resp_row *)eosl_malloc(sizeof(
             RTRV_TL1_INH_resp_row) * MAX_INH_TL1_CMD)) == NULL)
    {
        procLogMsg (PLOG_ERROR,
                    "agc_EM_NE_ALW_TL1_CMD_req",
                    "agc_EM_NE_ALW_TL1_CMD_req malloc failure\n");
        return eosl_false;
    }

    if (_tl1cmd == NULL)
    {
        mode=RTRV_ALL;
        tl1cmdPtr=RtrvTl1CmdRow(no_cmd, mode, &count, cmds); /* use dummy tl1 cmd */
    }
    else
    {
        tl1cmdPtr=RtrvTl1CmdRow(_tl1cmd,mode,&count, cmds);
    }
    
    if (tl1cmdPtr==NULL)
    {
        tc_error_response(handle,
                          ctag,
                          TE_IENE,
                          "Specified Object Entity Does Not Exist");
        eosl_free(cmds);
        return eosl_false;    
    }
    
    for ( i=0; i < count; i++)
    {
        rowsPtr[i]._tl1cmd=tl1cmdPtr->tl1cmd;
        tl1cmdPtr++;
    }
    
    rc = agc_EM_NE_RTRV_TL1_INH_resp(modifier,
                                     handle, 
                                     ctag, 
                                     TCC_COMPLD, 
                                     rowsPtr, 
                                     count, 
                                     "RTRV-TL1-INH", 
                                     tl1_b);
    eosl_free(cmds);
    return rc;
}	

/**
 */
eosl_bool agc_EM_NE_RTRV_TMGREF_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, char * _prisrc)
{

    BITS_CMD_BUF_t       buffer;
    BITS_ACK_BUF_t      response;
    RTRV_TMGREF_resp_row  result[2];
    char                tmpPrimaryState[32];
    char                primaryState[MAX_T1S_PER_T3][32];
    char                aidStrings[MAX_T1S_PER_T3][32];
    char                tmpPrimaryQualifier[32];
    char                secondaryState[MAX_T1S_PER_T3][32];
    int                 i=0;
    int                 j=0;
    int                 tmpT1=0;
    int                 totRecs;

    /*
    ** set up data structure
    */
    memset(&buffer, 0, SIZEOF_BITSCMD);

    if (_src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    if (_prisrc)
    {
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _prisrc,
                                 (AID_IOM | AID_BITS), &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                 BITS_CMD_CLASS, CMD, BITSCMD_TMGREF_RTRV,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_BITSCMD,
                  (TL1_CMD_BUF_t *)&response, sizeof(BITS_ACK_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_TMGREF_req","We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, response.Tl1Cmd.Error );
        return eosl_false;
    }

    totRecs = response.Data.RtrvTmgRefResp.NumEntries;

    for (i = 0; i <  totRecs; i++)
    {
        result[i]._src = "COM";

        DeviceIdToAid(response.Data.RtrvTmgRefResp.Data[i].DeviceId, FALSE, aidStrings[i]);
        result[i]._prisrc = &(aidStrings[i][0]);

        switch (response.Data.RtrvTmgRefResp.Data[i].TmgRefState)
        {
        case PRIMARY_STATE:
            result[i]._ref = RefState_PRIMARY;
            break;
        case SECONDARY_STATE:
            result[i]._ref = RefState_SECONDARY;
            break;
        case OOS_STATE:
            result[i]._ref = RefState_OOS;
            break;
        default:
            break;
        }

        SetStateNames(response.Data.RtrvTmgRefResp.Data[i].PortState,
                      0x00,
                      tmpPrimaryState,
                      tmpPrimaryQualifier,
                      &(secondaryState[i][0]));
        if (strlen(tmpPrimaryQualifier) > 0)
        {
            sprintf(&(primaryState[i][0]), "%s", tmpPrimaryState);
        }
        else
        {
            strcpy(&(primaryState[i][0]), tmpPrimaryState);
        }

        result[i]._lockState = enum_lookup_no_case(&LockState_ENUM_type, &(primaryState[i][0]));

        if (strlen(secondaryState[i]) > 0)
        {
            tc_error_response( handle, ctag, TE_SDBE, "Internal Data Base Error" );
            return eosl_false;
        }

        tmpT1 = GetLevel3(response.DeviceId);
        SetLevel3(response.DeviceId, (tmpT1 + 1)); /* for next T1 */
    }

    for (j = 0; j <  2; j++)
    {
        result[i]._src = "COM";

        if (j ==0 )
            strcpy(aidStrings[i], "SP-A-TMGMODULE");
        else
            strcpy(aidStrings[i], "SP-B-TMGMODULE");
        result[i]._prisrc =  &(aidStrings[i][0]);
        switch(response.Data.RtrvTmgRefResp.Data[i].ClockState)
        {
        case LOCKED_STATE:
            result[i]._lockState = LockState_LOCKED;
            break;
        case UNLOCKED_STATE:
            result[i]._lockState = LockState_UNLOCKED;
            break;
        case HOLDOVER_STATE:
            result[i]._lockState = LockState_HOLDOVER;
            break;
        case FREERUN_STATE:
            result[i]._lockState = LockState_FREERUN;
            break;
        case LOCKED_TMGA:
            result[i]._lockState = LockState_LOCKED_TMGA;
            break;
        case LOCKED_TMGB:
            result[i]._lockState = LockState_LOCKED_TMGB;
            break;
        case FLT_STATE:
            result[i]._lockState = LockState_FLT;
            break;
        case LOCKED_IOM1:
            result[i]._lockState = LockState_LOCKED_IOM1;
            break;
        case LOCKED_IOM2:
            result[i]._lockState = LockState_LOCKED_IOM2;
            break;
        case LOCKED_IOM3:
            result[i]._lockState = LockState_LOCKED_IOM3;
            break;
        case LOCKED_IOM8:
            result[i]._lockState = LockState_LOCKED_IOM8;
            break;
        case LOCKED_IOM10:
            result[i]._lockState = LockState_LOCKED_IOM10;
            break;
        default:
            break;
        }
        
        switch (response.Data.RtrvTmgRefResp.Data[i].TmgRefState)
        {
        case PRIMARY_STATE:
            result[i]._ref = RefState_PRIMARY;
            break;
        case SECONDARY_STATE:
            result[i]._ref = RefState_SECONDARY;
            break;
        case OOS_STATE:
            result[i]._ref = RefState_OOS;
            break;
        case ACTIVE_STATE:
            result[i]._ref = RefState_ACTIVE;
            break;
        case STANDBY_STATE:
            result[i]._ref = RefState_STANDBY;
            break;
        default:
            break;
        }
        i++;
        totRecs+=1;
    }   

    return agc_EM_NE_RTRV_TMGREF_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       result,
                                       totRecs,
                                       "RTRV-TMGREF",
                                       NULL);
}

/**
 */
eosl_bool agc_EM_NE_SCHED_EX_EQPT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _iomOrSp,\
									ScheduleInterval_PATTERNED_ENUM _invl,\
                                    StaDate_PATTERNED_ENUM _stadat,\
									StartTime_PATTERNED_ENUM _statm,\
									char * _numinvl,\
									Reportmode_ENUM * _reptmode,\
									ExType_ENUM * _exType)
{
    
    AID_INFO_TYPE_t     aidInfo;
    TL1_BUF_t           cmdMsg;
    CMD_BUF_t           respBuff;
    char                tmpArray[16];
    char                xchr;
    int                 i;
    int                 hr;
    int                 min;
    int                 invl;
    int                 month;
    int                 date;


    memset(&cmdMsg,0x0,SIZEOF_EQMCMD_SCHED_EX); /* set all valid flags=0 */


    /*
    ** let's do the slot stuff first(for command SCHED-EX-EQPT)
    */
#ifdef ATCA
    if (_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM, NULL))
        {   
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
    }
    else
    {   
        tc_error_response( handle, ctag, TE_IIAC, "Input, Missing Aid" );
        return eosl_false;
    }
#else 
    if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
#endif

    if(_invl)
    {
        i = sscanf(_invl, "%d-%s", &invl, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> invl" );
            return eosl_false;
        }
       
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            if ((invl < 0) || (invl > 23))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> invl" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.SchedExEqptParams.IntervalUnit.value = INTERVAL_HOUR;
            cmdMsg.CmdInfo.SchedExEqptParams.IntervalUnit.valid = VALID_VALUE;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            if ((invl < 1) || (invl > 31))
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> invl" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.SchedExEqptParams.IntervalUnit.value = INTERVAL_DAY;
            cmdMsg.CmdInfo.SchedExEqptParams.IntervalUnit.valid = VALID_VALUE;

        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.SchedExEqptParams.Interval.value = invl;
        cmdMsg.CmdInfo.SchedExEqptParams.Interval.valid = VALID_VALUE;
    }
    /*Fid 15134*/
      if(_stadat)
    {
        i = sscanf(_stadat, "%d-%d", &month, &date);
        if ((i != 2) || (month < 1) || (month > 12) || (date< 1) || (date > 31))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> stadat" );
            return eosl_false;
        }
       if (month !=0)
      {
            if(!validateDate(month, date))
            {
                tc_error_response( handle, ctag, TE_IPNV,
                                   "validate Input, Parameter Not Valid -> stadat" );
                return eosl_false;
            }
     }

        cmdMsg.CmdInfo.SchedExEqptParams.StartMonth.value = month;
        cmdMsg.CmdInfo.SchedExEqptParams.StartMonth.valid = VALID_VALUE;

        cmdMsg.CmdInfo.SchedExEqptParams.StartDay.value = date;
        cmdMsg.CmdInfo.SchedExEqptParams.StartDay.valid = VALID_VALUE;
        TL1LOGP (PLOG_ERROR, "month:%d , date =%d\n", month, date);
    }
    

    if(_statm)
    {
        i = sscanf(_statm, "%d-%d%c", &hr, &min, &xchr);
        if ((i != 2) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> statm" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.SchedExEqptParams.StartHour.value = hr;
        cmdMsg.CmdInfo.SchedExEqptParams.StartHour.valid = VALID_VALUE;

        cmdMsg.CmdInfo.SchedExEqptParams.StartMinute.value = min;
        cmdMsg.CmdInfo.SchedExEqptParams.StartMinute.valid = VALID_VALUE;
    }

    if(_numinvl)
    {
        if (IsInputStrInRange(_numinvl, "1234567890"))
        {
            if (atoi(_numinvl) < 0 || atoi(_numinvl) > 1000)
            {
                tc_error_response(handle, ctag, TE_IPNV, "Input Range Incorrect -> numinvl");
                return eosl_false;
            }
        
            cmdMsg.CmdInfo.SchedExEqptParams.NumInvl.value = atoi(_numinvl);
            cmdMsg.CmdInfo.SchedExEqptParams.NumInvl.valid = VALID_VALUE;
        }
        else
        {
             tc_error_response(handle, ctag, TE_IPNV, "Input invalid -> numinvl");
            return eosl_false;

        }
    }
    else
    {
         cmdMsg.CmdInfo.SchedExEqptParams.NumInvl.valid = INVALID_VALUE; 
    }

    if(_reptmode)
    {
        cmdMsg.CmdInfo.SchedExEqptParams.ReptMode.value = *_reptmode;
        cmdMsg.CmdInfo.SchedExEqptParams.ReptMode.valid = VALID_VALUE;
    }

#ifndef ATCA
    if(_exType)
    {
        switch (*_exType)
        {
        case ExType_SWTOPROTN:
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.value = SW_TO_PROTECTION;
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        case ExType_STANDARD:
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.value = STANDARD_SELFTEST;
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        case ExType_EXTENDED:
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.value = EXTENDED_SELFTEST;
            cmdMsg.CmdInfo.SchedExEqptParams.ExType.valid = VALID_VALUE;
            break;
            
        default:
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> exType" );
            return eosl_false;
            break;
        }
    }
#else
    if(_exType)
    {
        switch (*_exType)
        {
            case ExType_SWTOPROTN:
            break;

            case ExType_STANDARD:
            case ExType_EXTENDED:
          default:
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valiid -> exType" );
            return eosl_false;
            break;
        }
    }


#endif
    
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_SCHED_EX,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SCHED_EX,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "SCHED-EX-EQPT" );
}

/**
 * Instructs an NE to start, reschedule or remove the reporting
 * of performance monitoring data for particular entities in
 * the NE. The NE will report performance information using
 * REPT-PM. A user may poll for performance data at any time
 * using RTRV-PM.
 *
 * Performance management in TL1 assumes that counts are
 * accumulated at regular intervals on an NE and that neither
 * the intervals nor the items counted may be provisioned
 * through external means. Only a schedule for their
 * collection or inhibiting the reporting of their values is
 * possible. Scheduled reports are only possible for the
 * intervals over which counting happens on the NE.
 *
 * Essential to NMA. GR-833.
 */
eosl_bool agc_EM_NE_SCHED_PMREPT_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id, char * _reptinvl, char * _reptstatm, int * _numrept, char * _montype, char * _monlev, Location_ENUM * _locn, Direction_ENUM * _dirn, char * _tmper, char * _tmofst)
{
    DSX_CMD_BUF_t   buffer;

    char            *cmdClass;
    unsigned int    cmd;
    char            T1Comment[] = "SCHED-PMREPT-T1";
    char            T3Comment[] = "SCHED-PMREPT-T3";
    char            *p_comment;
    char            tmpArray[16];
    int             tmpVal;
    int             tmpEnum;
    int             day, hr, min;
    int             i;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_SCHED_PMREPT);

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        p_comment = T1Comment;
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if (GetLevel2(buffer.DeviceId) == TERMINATOR_VALUE)  /* No T3 entered */
        {
            cmdClass = DS3_CMD_CLASS;
            cmd = DS3CMD_SCHED_PMREPT_T1;

            /* Handle wildcard DeviceMap ambiguities here */
            switch(buffer.DeviceMap)
            {
            case DEVICE_MAP_IOM: /* All T1s on DS1 board */
            case DEVICE_MAP_IOM_T1: /* T1 on DS1 board */
            default:
                buffer.DeviceMap = DEVICE_MAP_IOM_T1;
                break;
            }
        }
        else
        {
            cmdClass = DS3_CMD_CLASS;
            cmd = DS3CMD_SCHED_PMREPT_T1;

            /* Handle wildcard DeviceMap ambiguities here */
            switch(buffer.DeviceMap)
            {
            case DEVICE_MAP_IOM_T3: /* All T1s on T3 on DS3 board */
            case DEVICE_MAP_IOM_T3_T1: /* T1 on T3 on DS3 board */
            default:
                buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
                break;
            }
        }
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SCHED_PMREPT_IF;
        p_comment = T3Comment;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_T3), &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All T3s on DS3 board */
        case DEVICE_MAP_IOM_T3: /* T3 on DS3 board */
        default:
            buffer.DeviceMap = DEVICE_MAP_IOM_T3;
            break;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier - Only T1 & T3 supported at this time." );
        return eosl_false;
    }

    if(_reptinvl)
    {
        i = sscanf(_reptinvl, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> ReptInvl" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tmpEnum = -1;
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.ReportInterval.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.ReportInterval.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if(_reptstatm)
    {
        i = sscanf(_reptstatm, "%d-%d", &hr, &min);
        if ((i != 2) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.ReportStartTime.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.ReportStartTime.value = PACK_TIME(0, 0, hr, min);
    }

    if(_numrept)
    {
        buffer.Data.SchedPmRept.NumReports.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.NumReports.value = *_numrept;
    }

    if(_montype)
    {
        if (buffer.DeviceMap == DEVICE_MAP_IOM_T1)
        {
            tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case T3T1MonType_AISS_P:
                tmpEnum = DS3T1MonType_AISS_P;
                break;
            case T3T1MonType_ALL:
                tmpEnum = DS3T1MonType_ALL;
                break;
            case T3T1MonType_CSS_P:
                tmpEnum = DS3T1MonType_CSS_P;
                break;
            case T3T1MonType_CSS_PFE:
                tmpEnum = DS3T1MonType_CSS_PFE;
                break;
            case T3T1MonType_CV_L:
                tmpEnum = DS3T1MonType_CV_L;
                break;
            case T3T1MonType_CV_P:
                tmpEnum = DS3T1MonType_CV_P;
                break;
            case T3T1MonType_CV_PFE:
                tmpEnum = DS3T1MonType_CV_PFE;
                break;
            case T3T1MonType_ES_L:
                tmpEnum = DS3T1MonType_ES_L;
                break;
            case T3T1MonType_ES_LFE:
                tmpEnum = DS3T1MonType_ES_LFE;
                break;
            case T3T1MonType_ES_P:
                tmpEnum = DS3T1MonType_ES_P;
                break;
            case T3T1MonType_ES_PFE:
                tmpEnum = DS3T1MonType_ES_PFE;
                break;
            case T3T1MonType_ESA_P:
                tmpEnum = DS3T1MonType_ESA_P;
                break;
            case T3T1MonType_ESA_PFE:
                tmpEnum = DS3T1MonType_ESA_PFE;
                break;
            case T3T1MonType_ESB_P:
                tmpEnum = DS3T1MonType_ESB_P;
                break;
            case T3T1MonType_ESB_PFE:
                tmpEnum = DS3T1MonType_ESB_PFE;
                break;
            case T3T1MonType_FC:
                tmpEnum = DS3T1MonType_FC;
                break;
            case T3T1MonType_FC_FE:
                tmpEnum = DS3T1MonType_FC_FE;
                break;
            case T3T1MonType_LOSS_L:
                tmpEnum = DS3T1MonType_LOSS_L;
                break;
            case T3T1MonType_SAS_P:
                tmpEnum = DS3T1MonType_SAS_P;
                break;
            case T3T1MonType_SEFS_PFE:
                tmpEnum = DS3T1MonType_SEFS_PFE;
                break;
            case T3T1MonType_SES_L:
                tmpEnum = DS3T1MonType_SES_L;
                break;
            case T3T1MonType_SES_P:
                tmpEnum = DS3T1MonType_SES_P;
                break;
            case T3T1MonType_SES_PFE:
                tmpEnum = DS3T1MonType_SES_PFE;
                break;
            case T3T1MonType_UAS_P:
                tmpEnum = DS3T1MonType_UAS_P;
                break;
            case T3T1MonType_UAS_PFE:
                tmpEnum = DS3T1MonType_UAS_PFE;
                break;
            default:
                tmpEnum = -1;
            }
        }
        else if (buffer.DeviceMap == DEVICE_MAP_IOM_T3_T1)
        {
            tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case T3T1MonType_AISS_P:
                tmpEnum = DS3T1MonType_AISS_P;
                break;
            case T3T1MonType_ALL:
                tmpEnum = DS3T1MonType_ALL;
                break;
            case T3T1MonType_CSS_P:
                tmpEnum = DS3T1MonType_CSS_P;
                break;
            case T3T1MonType_CSS_PFE:
                tmpEnum = DS3T1MonType_CSS_PFE;
                break;
            case T3T1MonType_CV_L:
                tmpEnum = DS3T1MonType_CV_L;
                break;
            case T3T1MonType_CV_P:
                tmpEnum = DS3T1MonType_CV_P;
                break;
            case T3T1MonType_CV_PFE:
                tmpEnum = DS3T1MonType_CV_PFE;
                break;
            case T3T1MonType_ES_L:
                tmpEnum = DS3T1MonType_ES_L;
                break;
            case T3T1MonType_ES_LFE:
                tmpEnum = DS3T1MonType_ES_LFE;
                break;
            case T3T1MonType_ES_P:
                tmpEnum = DS3T1MonType_ES_P;
                break;
            case T3T1MonType_ES_PFE:
                tmpEnum = DS3T1MonType_ES_PFE;
                break;
            case T3T1MonType_ESA_P:
                tmpEnum = DS3T1MonType_ESA_P;
                break;
            case T3T1MonType_ESA_PFE:
                tmpEnum = DS3T1MonType_ESA_PFE;
                break;
            case T3T1MonType_ESB_P:
                tmpEnum = DS3T1MonType_ESB_P;
                break;
            case T3T1MonType_ESB_PFE:
                tmpEnum = DS3T1MonType_ESB_PFE;
                break;
            case T3T1MonType_FC:
                tmpEnum = DS3T1MonType_FC;
                break;
            case T3T1MonType_FC_FE:
                tmpEnum = DS3T1MonType_FC_FE;
                break;
            case T3T1MonType_LOSS_L:
                tmpEnum = DS3T1MonType_LOSS_L;
                break;
            case T3T1MonType_SAS_P:
                tmpEnum = DS3T1MonType_SAS_P;
                break;
            case T3T1MonType_SEFS_PFE:
                tmpEnum = DS3T1MonType_SEFS_PFE;
                break;
            case T3T1MonType_SES_L:
                tmpEnum = DS3T1MonType_SES_L;
                break;
            case T3T1MonType_SES_P:
                tmpEnum = DS3T1MonType_SES_P;
                break;
            case T3T1MonType_SES_PFE:
                tmpEnum = DS3T1MonType_SES_PFE;
                break;
            case T3T1MonType_UAS_P:
                tmpEnum = DS3T1MonType_UAS_P;
                break;
            case T3T1MonType_UAS_PFE:
                tmpEnum = DS3T1MonType_UAS_PFE;
                break;
            default:
                tmpEnum = -1;
            }
        }
        else if (buffer.DeviceMap == DEVICE_MAP_IOM_T3)
        {
            tmpEnum = enum_lookup_no_case(&T3MonType_ENUM_type, _montype);
        }
        else
        {
            tmpEnum = -1;
        }

        if (tmpEnum == -1)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> montype" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.MonitoredType.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.MonitoredType.value = tmpEnum;
    }

    if (_monlev)
    {
        i = sscanf(_monlev, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> MonLev" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "UP") == 0)
        {
            tmpEnum = MONITOR_LEVEL_UP;
        }
        else if (eosl_strcasecmp(tmpArray, "DOWN") == 0)
        {
            tmpEnum = MONITOR_LEVEL_DOWN;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.Monitoredlevel.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.Monitoredlevel.value = PACK_MONITOR_LEVEL(tmpVal, tmpEnum);
    }

    if(_locn)
    {
        buffer.Data.SchedPmRept.Location.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.Location.value = *_locn;
    }

    if(_dirn)
    {
        buffer.Data.SchedPmRept.Direction.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.Direction.value = *_dirn;
    }

    if(_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.TimePeriod.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if(_tmofst)
    {
        if (sscanf(_tmofst, "%d-%d-%d", &day, &hr, &min) != 3)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }

        if ((day < 0) || (day > 99) || (hr < 0) || (hr > 23) || (min < 0) || (min > 59))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
            return eosl_false;
        }
        buffer.Data.SchedPmRept.TimeOffset.valid = VALID_VALUE;
        buffer.Data.SchedPmRept.TimeOffset.value = PACK_TIME_OFFSET(day, hr, min);
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_SCHED_PMREPT,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_SCHED_PMREPT_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, p_comment );
}


/**
 * Instructs an NE to set the attributes associated with a message log. If a log already exists, the new values specified by the command replace the previous values. WHen this command is exectued, a copy of it should be placed in the log.
 */
eosl_bool agc_EM_NE_SET_ATTR_LOG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _log_id, LogName_ENUM _lognm, ClearLog_ENUM * _clrlog, int * _maxmsg)
{

    /*
    ** WEChin - We will need a case statement to check the multple logs
    **          and switch on the log name (_lognm)
    */

    FAMRSP_t respBuff;
    FAMCMD_t  famCmd;
    eosl_bool status=eosl_true;
#ifndef ATCA
    TL1_BUF_t cmdMsg;
#endif
    eosl_mask ses_mask;


    memset(&famCmd,0x0,sizeof(famCmd));
#ifndef ATCA
    memset(&cmdMsg, 0, SIZEOF_EQMCMD_SET_ATTRLOG);
#endif

    if ((_log_id != NULL) && (eosl_strcasecmp(_log_id, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_lognm == LogName_SECURITYLOGS || _lognm == LogName_OSSECURITYLOGS)
    {
        ses_mask = tc_session_get_mask(handle);
        ses_mask = ses_mask & UAP_MASK; /* Only use UAP bits from the mask */
        if (ADMIN_MASK != ses_mask)
        {
            tc_error_response( handle, ctag, TE_EANS, "Incorrect Access Permission" );
            return eosl_false;
        }
    }

    if (_maxmsg && *_maxmsg < 1)
    {
        tc_error_response( handle, ctag, TE_IIDT, "MAXMSG value can't not be set less than 1" );
        return eosl_false;
    }

    if (_lognm==LogName_SYSLOGS)
    {

        famCmd.Tl1Cmd.Cmd = FAMCMD_SET_ATTR_LOG;
        famCmd.Tl1Cmd.SessionHandle = handle;
        famCmd.Tl1Cmd.CTag =ctag;
        famCmd.Data.SetAttrLog.LogType = SYS_LOG; 
        
        if (_clrlog)
        {
            famCmd.Data.SetAttrLog.LogClear.value=*_clrlog;
            famCmd.Data.SetAttrLog.LogClear.valid=VALID_VALUE;
        }

        if (_maxmsg)
        {
            /* bug 72637 add check for maxmsg here, FAM miss zero case */
            if ((*_maxmsg > 5000) || (*_maxmsg <= 0))
            {
                tc_error_response(handle, ctag, TE_IIDT, "Input, Parameter, Not Valid");
                return eosl_false;
            } /* end of bug 72637 */
            famCmd.Data.SetAttrLog.LogSize.value=*_maxmsg;
            famCmd.Data.SetAttrLog.LogSize.valid=VALID_VALUE;
        }


        if(TL1SendMsg(handle, ctag,
                  FAM_CMD_CLASS, CMD, FAMCMD_SET_ATTR_LOG,
                  (TL1_CMD_BUF_t *)&famCmd, sizeof(FAMCMD_t),
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(FAMRSP_t),
                  TL1_MSG_TIMEOUT) == FAIL)

        {
            TL1ErrorResp( handle, ctag, CMD_FAM, respBuff.Tl1Cmd.Error );
            return eosl_false;
        }
    }
#ifndef ATCA
    else if (_lognm == LogName_OSSECURITYLOGS)
    {
        cmdMsg.Buf.Cmd           = EQMCMD_SET_ATTR_LOG;
        cmdMsg.Buf.SessionHandle = handle;
        cmdMsg.Buf.CTag          = ctag;
                
        if (_clrlog && (*_clrlog != ClearLog_DONOTCLEAR))
        {
             ClearTL1Log(OSSEC_MSG_TYPE);
        }
                
        if (_maxmsg)
        {
             if (*_maxmsg > 20000)
             {
                tc_error_response( handle, ctag, TE_IIDT, "MAXMSG value exceeds 20000" );
                return eosl_false;
             }
                
             cmdMsg.CmdInfo.SetAttrLog.MaxMsg.value = *_maxmsg;
             cmdMsg.CmdInfo.SetAttrLog.MaxMsg.valid = VALID_VALUE;
        }
                
        if(TL1SendMsg(handle, ctag,
                EQM_CMD_CLASS, CMD, EQMCMD_SET_ATTR_LOG,
                (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SET_ATTRLOG,
                (TL1_CMD_BUF_t *)&cmdMsg, sizeof(cmdMsg),
                TL1_MSG_TIMEOUT) == FAIL)
        {
                TL1ErrorResp( handle, ctag, CMD_EQM, cmdMsg.Buf.Error );
                return eosl_false;
        }
    }
#endif
    else
    {
        if (_clrlog && (*_clrlog != ClearLog_DONOTCLEAR))
        {
            switch(_lognm)
            {

            case LogName_AOLOGS:
                ClearTL1Log(AO_MSG_TYPE);
                break;

            case LogName_BULKLOGS:
                ClearTL1Log(BULK_MSG_TYPE);
                break;

            case LogName_FRAUDLOGS:
                ClearTL1Log(FRAUD_MSG_TYPE);
                break;

            case LogName_MESSAGELOGS:
                ClearTL1Log(CMD_MSG_TYPE);
                break;

            case LogName_SECURITYLOGS:
#if 0
                if(*_clrlog == ClearLog_DONOTCLEAR)
                {
                    return tc_compld_comment( handle, ctag, "No Clearing of Security Log" );
                    return eosl_true;
                }
                else
                {
                    tc_error_response( handle, ctag, TE_SROF, "Clearing of Security Log is not allowed" );
                    return eosl_false;
                }
#endif
                /*BUG:10352 - TELICA kyee, we now support clear seculog 
                  (not to delete but to rename to .bak) per Tom Manning*/
                ClearTL1Log(SEC_MSG_TYPE);
                break;

            case LogName_CALLCAPTLOGS:
                ClearTL1Log(CALLCAPT_MSG_TYPE);
                break;
            case LogName_CALLCAPTVERBOSELOGS:
                ClearTL1Log(CALLCAPTVERBOSE_MSG_TYPE);
                break;

            case LogName_PATCHLOGS:
                ClearTL1Log(PATCH_MSG_TYPE);
                break;
#ifdef ATCA /* FID 15827.0 */
            case LogName_CPURSRC:
                ClearTL1Log(CPURSRC_MSG_TYPE);
                break;
#endif /* ATCA */

            default:
                break;
            }
        }

        if (_maxmsg)
        {

            switch(_lognm)
            {
            case LogName_MESSAGELOGS:
                status=SetLogSize(LogName_MESSAGELOGS,*_maxmsg);
                break;

            case LogName_AOLOGS:
                status=SetLogSize(LogName_AOLOGS,*_maxmsg);
                break;

             case LogName_BULKLOGS:
                status=SetLogSize(LogName_BULKLOGS,*_maxmsg);
                break;

           case LogName_SECURITYLOGS:
                status=SetLogSize(LogName_SECURITYLOGS,*_maxmsg);
                break;

            case LogName_CALLCAPTLOGS:
                tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported" );
                return eosl_false;
#if 0 /* This file is managed by Signaling. They rename the file to .old when filled per Ming Qin*/
                status=SetLogSize(LogName_CALLCAPTLOGS,*_maxmsg);
#endif
                break;

            case LogName_CALLCAPTVERBOSELOGS:
                status=SetLogSize(LogName_CALLCAPTVERBOSELOGS,*_maxmsg);
                break;


            case LogName_PATCHLOGS:
                tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported" );
                return eosl_false;
#if 0
                status=SetLogSize(LogName_PATCHLOGS,*_maxmsg);
#endif
                break;
#ifdef ATCA /* FID 15827.0 */
            case LogName_CPURSRC:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, Specified log file not supported for this operation" );
                return eosl_false;
                break;
#endif /* ATCA */

            default:
                tc_error_response( handle, ctag, TE_IIDT,
                                   "Input, Specified log file not supported for this operation" );
                return eosl_false;
                break;
            }
        }

        if (status != SET_LOG_SIZE_OK)
        {
            switch(status)
            {
            case MAX_LOG_FILE_RECORDS_EXCEEDED:
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter, Not Valid" );
                return eosl_false;
                break;

            case DB_WRITE_ERROR_LOG_SIZE:
                tc_error_response( handle, ctag, TE_SDBE, "Internal Data Base Error" );
                return eosl_false;
                break;

            default:
                break;
            }
        }

    }

    return tc_compld_comment( handle, ctag, "SET-ATTR-LOG" );
}

/**
 * Retrieve  PRFL IPATKLOG
 */
eosl_bool agc_EM_NE_RTRV_PRFL_IPATKLOG_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipAtkLogPrflId)
{
	int i;
	char prflId[MAX_NUM_PROFILES][10];
	RTRV_PRFL_IPATKLOG_resp_row result[MAX_NUM_PROFILES];
	TL1_EMF_IPATK_DATA_t buffer;
	EMF_TL1_IPATK_t resp;
	memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
	memset(&resp, 0, sizeof(EMF_TL1_IPATK_t));
	if(_ipAtkLogPrflId)
	{
		if(!(IsInputStrInRange(_ipAtkLogPrflId,"0123456789")))
		{
			tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid ipAtkLogPrflId");
			return eosl_false;
		}
		buffer.Data.RtrvPrfl.LogPrflId = atoi(_ipAtkLogPrflId);
		if((buffer.Data.RtrvPrfl.LogPrflId < 1)||(buffer.Data.RtrvPrfl.LogPrflId > 32) )
		{
			tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> ipAtkLogPrflId");
			return eosl_false;
		}
	}
	/*
	**  Send Event
	*/
	if (TL1SendMsg(handle, ctag,
		       TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		       CMD_RTRV_PRFL_IPATKLOG,
		       (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_RTRV_PRFL_IPATKLOG,
		       (TL1_CMD_BUF_t *)&resp, sizeof(EMF_TL1_IPATK_t),
		       TL1_MSG_TIMEOUT) == FAIL)
	{
		TL1ErrorResp( handle, ctag, CMD_EQM, resp.Tl1Cmd.Error );
		return eosl_false;
	}
	for (i = 0;i < resp.NumRecords; i++)
	{
		sprintf(prflId[i],"%d",resp.Data.Profiles[i].LogPrflId);
		result[i]._ipAtkLogPrflId = prflId[i];
		result[i]._atkloginterval = resp.Data.Profiles[i].LogInterval;
		result[i]._maxPktStreams = resp.Data.Profiles[i].MaxPackets;
	}
	
	return agc_EM_NE_RTRV_PRFL_IPATKLOG_resp(modifier,
			                         handle,
						 ctag,
						 TCC_COMPLD,
						 result,
						 resp.NumRecords,
						 "RTRV-PRFL-IPATKLOG",
						 NULL);
}

/**
 */
eosl_bool agc_EM_NE_SET_ATTR_SECULOG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, int _wrnLn, char * _wrnTx)
{
    char    buffer[MAX_GOAHEAD_MSG_SIZE];
    DB_WRITE_t  *p_dbData = (DB_WRITE_t *) &buffer[0];
    DB_COLUMN_t *p_dbEntry = (DB_COLUMN_t *) &p_dbData->Columns[0];
    int     rowNum = -1;
    char    errorMsg[60];
    int     retVal = 1;
    const char  *userName;
    char  noUser[] = "";
    char    WrnTxBuf[USER_BANNER_MAXLINLEN];
    int     numWrnTx = 0;
#if 0
    FILE    *fp;
    char    lines[USER_BANNER_MAXLIN][USER_BANNER_MAXLINLEN];
    char    line[USER_BANNER_MAXLINLEN] = "";
    char    temp[USER_BANNER_MAXLINLEN];
    int     i = -1;
#endif
#ifndef ATCA
    char         parameters[USER_BANNER_MAXLINLEN + 6] = "";
    char *       script = OSCMD_SET_OS_SECU_PATH;
#endif

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") != 0) &&
        (eosl_strcasecmp(_src, "TL1") != 0) && (eosl_strcasecmp(_src, "OS") != 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#ifdef ATCA
    if (_src == NULL)
    {
        _src = "TL1";
    }
    
    if (eosl_strcasecmp(_src, "OS") == 0)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
#endif    

#ifndef ATCA
    if (_src == NULL)
    {
        _src = "COM";
    }
#endif    
    
    /* _wrnLn range validation - {1,USER_BANNER_MAXLIN}
     * NOTE: in *-ATTR-SECULOG, wrnLn is one-based but in the GA
     * database and mem routines, it is zero-based so sub one before
     * calling GA or mem routines.
     */
    if ((_wrnLn < 1) || (_wrnLn > USER_BANNER_MAXLIN))
    {
        tc_error_response(handle, ctag, TE_IIAC, "Invalid Warning Message  Line Number (wrnLn)");
        return eosl_false;
    }

    if ((rowNum = tl1DbGetNumRows(TL1_WRNTX_TABLE_NAME)) < 0)
    {
        tc_error_response(handle, ctag, TE_SDBE, "Error reading WrnTx table");
        return eosl_false;
    }

    /* _wrnTx is type string - length restriction of 63 chars imposed due to
     * GoAhead XML string maximums of 64 chars, one of which is null (0x00).
     */
    memset(WrnTxBuf, 0, sizeof(WrnTxBuf));

    if(_wrnTx)
    {
        if ((numWrnTx = strlen(_wrnTx)) > MAX_WRNTX_LEN)
        {
            sprintf(errorMsg, "Input, Invalid wrnTx, length (%d) exceeds %d characters",
                    numWrnTx, MAX_WRNTX_LEN);
            tc_error_response(handle, ctag, TE_IIDT, errorMsg);
            return eosl_false;
        }

        /* if wrnTx is a quoted string (to get special chars past the parser) */
        if ((_wrnTx[0] == 0x22) && (_wrnTx[strlen(_wrnTx)-1] == 0x22) &&
            (strlen(_wrnTx) > QUOTEPAIR_SIZE))
        {
            /* Strip off the quotes */
            strncpy(WrnTxBuf, &_wrnTx[1], strlen(_wrnTx)-QUOTEPAIR_SIZE);
        }
        else
        {
            strcpy(WrnTxBuf, _wrnTx);
        }

        /* if the banner line contains any invalid characters */
        if(!IsInputStrInRange(WrnTxBuf, bannerList))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, wrnTx Parameter Not Valid" );
            return eosl_false;
        }

    }

    strcpy(p_dbData->DBName, TL1_DB_NAME);
    strcpy(p_dbData->TableName, TL1_WRNTX_TABLE_NAME);
    p_dbData->NumColumns = 0;

    /* Note: rowNum is zero-based */

    if (eosl_strcasecmp(_src, "TL1") == 0 || eosl_strcasecmp(_src, "COM") == 0)
    {
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_WRNTX_COL,
                                        _wrnLn - 1, DB_DATA_TYPE_STRING, 0,
                                        WrnTxBuf);

        if (sendDbWriteRequest(p_dbData, (unsigned int)p_dbEntry - (unsigned int)buffer) == FAIL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_SET_ATTR_SECULOG_req",
                       "agc_EM_NE_SET_ATTR_SECULOG_req: Failed sendDbWriteRequest\n");
            tc_error_response( handle, ctag, TE_SDBE, "Internal Data Base Error" );
            retVal = -1;
        }
    }

#ifndef ATCA
    if (eosl_strcasecmp(_src, "OS") == 0 || eosl_strcasecmp(_src, "COM") == 0)
    {
#if 0
        memset(lines, 0, sizeof(lines));
        if ((fp = fopen("/etc/motd", "r+")) == NULL)
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_ATTR_SECULOG_req",
                       "SET_ATTR_SECULOG Unable to read Warning Message from OS\n");
            tc_error_response(handle,ctag,TE_SROF,"Unable to set attr seculog");
            return eosl_false;
        }

        if (fseek(fp, 0, SEEK_SET))
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_ATTR_SECULOG_req",
                       "SET_ATTR_SECULOG Unable to read Warning Message from OS\n");
            tc_error_response(handle,ctag,TE_SROF,"Unable to set attr seculog");
            fclose(fp);
            return eosl_false;
        }
 
        for (i = 0; fgets(lines[i], USER_BANNER_MAXLINLEN, fp) != NULL; ++i);

        if (fseek(fp, 0, SEEK_SET))
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_ATTR_SECULOG_req",
                       "SET_ATTR_SECULOG Unable to read Warning Message from OS\n");
            tc_error_response(handle,ctag,TE_SROF,"Unable to set attr seculog");
            fclose(fp);
            return eosl_false;
        }
            
        for (i = 0; i < _wrnLn - 1; ++i)
        {
            fgets(line, USER_BANNER_MAXLINLEN, fp);
        }

        if (_wrnTx)
        {
            sprintf(temp, "%s\n", _wrnTx);
            strncpy(lines[i], temp, strlen(temp) + 1);
        }
        else
        {
            strncpy(lines[i], "", 2);
        }

        if (fseek(fp, 0, SEEK_SET))
        {
            procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_ATTR_SECULOG_req",
                       "SET_ATTR_SECULOG Unable to read Warning Message from OS\n");
            tc_error_response(handle,ctag,TE_SROF,"Unable to set attr seculog");
            fclose(fp);
            return eosl_false;
        }

        for (i = 0; lines[i][0] != '\0' || i < _wrnLn; ++i)
        {
            if (lines[i][0] != '\0')
            {
                fputs(lines[i], fp);
            }
            else
            {
                fputs("\n", fp);
            }
        }

        fclose(fp);
#endif
        if (_wrnTx)
        {
            sprintf(parameters, "%d \"%s\"", _wrnLn, WrnTxBuf);
        }
        else
        {
            sprintf(parameters, "%d", _wrnLn);
        }

        if(runOSCommand(script, parameters, NULL) != 0)
        {
            tc_error_response( handle, ctag, TE_SROF, "Failed in SET-ATTR-SECULOG command" );
            return eosl_false;
        }
    }
#endif
    
    /* change the instance in memory - setMemUserBanner is 0-based.
     */
    setMemUserBanner(_wrnLn - 1, WrnTxBuf);

    /* Report Security event
     */
    if(!(userName = tc_session_get_username(handle)))
    {
        userName = noUser;
    }
    AddSecEvent(handle, SYSTEM_SECURITY_PARAMETERS_MODIFIED, (char *)userName,
                " System Security Parameters Modified. ");
    
    return tc_compld_comment( handle, ctag, "SET-ATTR-SECULOG" );
}


/**
 */
eosl_bool agc_EM_NE_SET_DATASERVER_HOSTCFG_req( const char * modifier,\
                                    eosl_handle handle,\
                                     TL1_TAG ctag ,\
                                    TL1_AID _COM,\
                                    char * _billing_dataserver_a1,\
                                    char * _billing_dataserver_b1,\
                                    char * _billing_dataserver_a2,\
                                    char * _billing_dataserver_b2,\
                                    int * _initRetryTmrAnet1,\
                                    int * _failRetryTmrAnet1,\
                                    int * _initRetryTmrBnet1,\
                                    int * _failRetryTmrBnet1,\
                                    int * _initRetryTmrAnet2,\
                                    int * _failRetryTmrAnet2,\
                                    int * _initRetryTmrBnet2,\
                                    int * _failRetryTmrBnet2)

{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   unsigned int   ipHost;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_BILLING_DATASERVE;

   rowKey.numIndices = 0;
   if(_COM)
   {
        if(eosl_strcasecmp(_COM, "COM") !=0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
   }
   if (_billing_dataserver_a1)
   {
     if(eosl_strcasecmp(_billing_dataserver_a1,"NULL"))
     {
        if ((ip_a2i(_billing_dataserver_a1, &ipHost)) != 1)
        {
           tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address." );
           return eosl_false;
        }

     columns[colCnt].columnId                  = BILL_DATASERVER_A1;
     columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
     columns[colCnt].value.value.stringVal.ptr = _billing_dataserver_a1;
     columns[colCnt].value.value.stringVal.len = strlen(_billing_dataserver_a1);
     }
     else
     {
         columns[colCnt].columnId                  = BILL_DATASERVER_A1;
         columns[colCnt].value.colType             = TSSMI_RESET;
     }

     colCnt++;
   }
   if (_billing_dataserver_b1)
   {
     if(eosl_strcasecmp(_billing_dataserver_b1,"NULL"))
     {
        if ((ip_a2i(_billing_dataserver_b1, &ipHost)) != 1)
        {
           tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address." );
           return eosl_false;
        }
     columns[colCnt].columnId                  = BILL_DATASERVER_B1;
     columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
     columns[colCnt].value.value.stringVal.ptr = _billing_dataserver_b1;
     columns[colCnt].value.value.stringVal.len = strlen(_billing_dataserver_b1);
       }
       else
       {
           columns[colCnt].columnId                  = BILL_DATASERVER_B1;
           columns[colCnt].value.colType             = TSSMI_RESET;
       }
     colCnt++;
   }
   if (_billing_dataserver_a2)
   {
     if(eosl_strcasecmp(_billing_dataserver_a2,"NULL"))
     {
        if ((ip_a2i(_billing_dataserver_a2, &ipHost)) != 1)
        {
           tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address." );
           return eosl_false;
        }

     columns[colCnt].columnId                  = BILL_DATASERVER_A2;
     columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
     columns[colCnt].value.value.stringVal.ptr = _billing_dataserver_a2;
     columns[colCnt].value.value.stringVal.len = strlen(_billing_dataserver_a2);
       }
       else
       {
           columns[colCnt].columnId                  = BILL_DATASERVER_A2;
           columns[colCnt].value.colType             = TSSMI_RESET;
       }
     colCnt++;
   }
   if (_billing_dataserver_b2)
   {
     if(eosl_strcasecmp(_billing_dataserver_b2,"NULL"))
     {
        if ((ip_a2i(_billing_dataserver_b2, &ipHost)) != 1)
        {
           tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address." );
           return eosl_false;
        }
     columns[colCnt].columnId                  = BILL_DATASERVER_B2;
     columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
     columns[colCnt].value.value.stringVal.ptr = _billing_dataserver_b2;
     columns[colCnt].value.value.stringVal.len = strlen(_billing_dataserver_b2);
       }
       else
       {
           columns[colCnt].columnId                  = BILL_DATASERVER_B2;
           columns[colCnt].value.colType             = TSSMI_RESET;
       }
     colCnt++;
   }
   if(_initRetryTmrAnet1)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_INITTMR_A1;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_initRetryTmrAnet1;
     colCnt++;
   }
   if(_failRetryTmrAnet1)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_FAILTMR_A1;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_failRetryTmrAnet1;
     colCnt++;
   }
   if(_initRetryTmrBnet1)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_INITTMR_B1;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_initRetryTmrBnet1;
     colCnt++;
   }
   if(_failRetryTmrBnet1)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_FAILTMR_B1;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_failRetryTmrBnet1;
     colCnt++;
   }
   if(_initRetryTmrAnet2)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_INITTMR_A2;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_initRetryTmrAnet2;
     colCnt++;
   }
   if(_failRetryTmrAnet2)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_FAILTMR_A2;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_failRetryTmrAnet2;
     colCnt++;
   }
   if(_initRetryTmrBnet2)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_INITTMR_B2;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_initRetryTmrBnet2;
     colCnt++;
   }
   if(_failRetryTmrBnet2)
   {
     columns[colCnt].columnId            = BILL_DATASERVER_FAILTMR_B2;
     columns[colCnt].value.colType       = TSSMI_LONG;
     columns[colCnt].value.value.longVal = *_failRetryTmrBnet2;
     colCnt++;
   }
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_DATASERVER_HOSTCFG_req", "SET-DATASERVER-HOSTCFG - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "SET-DATASERVER-HOSTCFG" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;

}


/**
 */
eosl_bool agc_EM_NE_ED_INSYS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, int *_defSstTmr)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;

    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = SPGENCFG_TAB_ID;  /* BUG: 40346 */

    rowKey.numIndices = 0;

    if(_src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    if(_defSstTmr)
    {
        if (*_defSstTmr < 1 || *_defSstTmr > 32767)
        {
            tc_error_response(handle, ctag, TE_IDRG, "Invalid SST timer, " \
                              "range is 1 - 32767");
            return eosl_false;
        }
        columns[colCnt].columnId = SPGENCFG_DEFSSTTMR;   /* BUG:40346 */
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_defSstTmr;
        colCnt++;
    }
    else
    {
        tc_error_response(handle, ctag, TE_IDRG, "Invalid Payload block. Invalid Data Format. ");
    }
 
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_INSYS_req", "ED-INSYS - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


   if( retVal == TRUE)
   {
	return tc_compld_comment( handle, ctag, "ED-INSYS " );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_ED_STATE_IVR_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, IS_OOS_ENUM _isOos)
{
   /*Telica prakash 02/02/02 changing to sent this to PLM.
    *Previously this was sent to svcmgr
    */
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    int            colCnt = 0;
    SMCMD_t        smCmd;



    tableId = TELICA_TABLE_IVRSTATE;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 0;

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    columns[colCnt].columnId = TS_COL_IVRSTATE_STATE;
    columns[colCnt].value.colType = TSSMI_LONG;
    switch (_isOos) {
    case IS_OOS_IS:
        columns[colCnt].value.value.longVal =  IVRSTATE_ON;
        break;
    case IS_OOS_OOS:
        columns[colCnt].value.value.longVal = IVRSTATE_OFF;
        break;
    default:
        break;
    }
    colCnt++;
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_IVR_req", "ED_STATE_IVR - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-IVR" ); /* success */
    }
}

/**
 * Edit  LIST SUIOM
 */
eosl_bool agc_EM_NE_ED_LIST_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suListId,\
									char * _swVersion,\
									char * _appSwVersion)
{
    TL1_BUF_t         buffer;
    int               Iom;

    memset(&buffer, 0, sizeof(TL1_BUF_t));

    if(_suListId)
    {
        if(parseSuListAid(_suListId, &Iom, NULL) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }

        if (eosl_strcasecmp(_suListId, "NULL") == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SULISTID" );
            return eosl_false;
        }
        
        strncpy(buffer.CmdInfo.EdSuList.SuListName, _suListId, SUAUTO_LIST_LEN + 1);
        buffer.CmdInfo.EdSuList.IomNum = Iom;
    }

    if(_swVersion)
    {
        strncpy(buffer.CmdInfo.EdSuList.SwVersion, _swVersion, SW_VERSION_LEN + 1);
    }

    if(_appSwVersion)
    {
        strncpy(buffer.CmdInfo.EdSuList.AppSwVersion, _appSwVersion, SW_VERSION_LEN + 1);
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ED_SULIST,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "ED-LIST-SUIOM" );
}

/**
 * Edit  LNPSCREEN DIGITS
 */
eosl_bool agc_EM_NE_ED_LNPSCREEN_DIGITS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _screenDigits,\
									char * _trigEscList,\
                                                                        char * _rtKey)
{
   /*Changing TL1 Code to send to PLM instead of
    *Service Manager
    */

   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   int            screenDigitsLen;
   int            trigEscListLen;
   char           *label;
   char           *primKey;
   char           *primValStr;
   char           *state;
   char           *rtKeyClone = NULL;
   int            primKeyEnum;

   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_LNPSCRDIGITS;

   rowKey.numIndices = 1;

   if(!(IsInputStrInRange(_screenDigits,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Input for screenDigits");
        return eosl_false;
   }
   screenDigitsLen = strlen(_screenDigits);
   if(!((screenDigitsLen ==3) || (screenDigitsLen >=6 && screenDigitsLen <=10)))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Invalid number:must be 3 or 6-10 digits");
       return eosl_false;
   }
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _screenDigits;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_screenDigits);

   if(_trigEscList)
   {
	   if(eosl_strcasecmp(_trigEscList, "NULL"))
	   {
		   trigEscListLen = strlen(_trigEscList); 
		   if(trigEscListLen > 10)
		   {
			   tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid trigEscList");
			   return eosl_false;
		   } 
		   columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
		   columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
		   columns[colCnt].value.value.stringVal.ptr = _trigEscList;
		   columns[colCnt].value.value.stringVal.len = strlen(_trigEscList);
	   }
	   else
	   {
		   columns[colCnt].columnId                  = LNPSCREENDIGITS_TRIGESCLIST;
		   columns[colCnt].value.colType             = TSSMI_RESET;
	   }
	   colCnt++;
   }

   /*
    * FID16277.0, add new parameter rtKey to the command.
    * Default value is NULL. The values of the primKey follows
    * the same range as rtKey from TREATMENT.
    * The following formats shall be allowed for the rtKey:
    * - NULL
    * - rtLbl
    * - rtLbl-primKey
    * - rtLbl-NULL (equivalent to rtLbl)
    * The following formats will be invalid:
    * - NULL-primKey
    * - NULL-NULL
    * - rtLbl-
    * - -primKey
    */
   if (_rtKey)
   {
     /* If NULL is expicitly specified */
     if (eosl_strcasecmp(_rtKey, "NULL") == 0)
     {
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTNAME;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
       columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
       columns[colCnt].value.colType       = TSSMI_RESET;
       colCnt++;
     }
     else
     {
       /* If first or last char is a delimeter */
       if ((_rtKey[0] == '-') || (_rtKey[strlen(_rtKey)-1] == '-'))
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid, incomplete rtKey");
         return eosl_false;
       }

       /* Clone input parameter, as strtok_r is destructive */
       rtKeyClone = eosl_malloc(strlen(_rtKey)+1);
       if (rtKeyClone == NULL)
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid, internal memory error");
         return eosl_false;
       }

       strcpy(rtKeyClone, _rtKey);

       /* Get the label */
       label = strtok_r(rtKeyClone,"-", &state);

       /* If the label is not valid */
       if ((eosl_strcasecmp(label, "NULL") == 0) || (strlen(label) > 10))
       {
         tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, wrong rtLbl");
         eosl_free(rtKeyClone);
         return eosl_false;
       }

       columns[colCnt].columnId                   = LNPSCREENDIGITS_RTNAME;
       columns[colCnt].value.colType              = TSSMI_OCTET_STRING;
       columns[colCnt].value.value.stringVal.ptr  = label;
       columns[colCnt].value.value.stringVal.len  = strlen(label);
       colCnt++;

       /* If a primary key was specified */
       if ((primKey = strtok_r(NULL,"-", &state)))
       {
         /* With a given rtLbl, the primKey can be NULL */
         if (eosl_strcasecmp(primKey, "NULL") == 0)
         {
           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
           columns[colCnt].value.colType       = TSSMI_RESET;
           colCnt++;
         }
         else
         {
           /* The primary key can't be out of range */
           if ((primKeyEnum =
               enum_lookup_no_case(&RTPrimkey_ENUM_type, primKey)) == -1)
           {
             tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, primary key out of range");
             eosl_free(rtKeyClone);
             return eosl_false;
           }

           columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
           columns[colCnt].value.colType       = TSSMI_LONG;
           columns[colCnt].value.value.longVal = mapTL1TSMCrtPrimkey(primKeyEnum);
           colCnt++;

           /* If some specific primary keys are set, then need the value */
           if ((primKeyEnum == RTPrimkey_GAP)     ||
               (primKeyEnum == RTPrimkey_GENDGTS) ||
               (primKeyEnum == RTPrimkey_REG)     ||
               (primKeyEnum == RTPrimkey_GP))
           {
             /* Get these primary keys' value */
             if ((primValStr = strtok_r(NULL,"-", &state)))
             {
               /* If the primary key value is not valid */
               if ((!IsInputStrInRange(primValStr,"0123456789")) ||
                   (strlen(primValStr) > 3))
               {
                 tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, primary key value wrong");
                 eosl_free(rtKeyClone);
                 return eosl_false;
               }

               columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
               columns[colCnt].value.colType       = TSSMI_LONG;
               columns[colCnt].value.value.longVal = atoi(primValStr);
               colCnt++;
             }
             else
             {
               tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, miss primary key value");
               eosl_free(rtKeyClone);
               return eosl_false;
             }
           }
           else
           {
             columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
             columns[colCnt].value.colType       = TSSMI_RESET;
             colCnt++;
           }
         }

         /* If extraneous tokens exist */
         if (strtok_r(NULL,"-", &state) != NULL)
         {
           tc_error_response(handle, ctag, TE_IIAC, "Invalid rtKey, too many arguments");
           eosl_free(rtKeyClone);
           return eosl_false;
         }
       }
       else
       {
         columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEY;
         columns[colCnt].value.colType       = TSSMI_RESET;
         colCnt++;
         columns[colCnt].columnId            = LNPSCREENDIGITS_RTPRIMKEYVAL;
         columns[colCnt].value.colType       = TSSMI_RESET;
         colCnt++;
       }
     }
   }

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_LNPSCREEN_DIGITS_req", "ED-LNPSCREEN-DIGITS - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");

        if (rtKeyClone)
        {
            /* Free dynamic memory */
            eosl_free(rtKeyClone);
        }

        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
						   handle,
						   transId,
						   tableId,
						   &rowKey,
						   &colArray,
						   &smCmd,
						   TL1_MSG_TIMEOUT);


   if (rtKeyClone)
   {
     /* Free dynamic memory */
     eosl_free(rtKeyClone);
   }

   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "ED-LNPSCREEN-DIGITS" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 * Edit  LRN
 */
eosl_bool agc_EM_NE_ED_LRN_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _lrn,\
									LRN_ENUM * _lrntype,\
									BoolYN_ENUM * _replaceCDPN)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   char           LrnString[MAX_LRN_LEN+1];


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = TELICA_TABLE_OWNLRN;

   rowKey.numIndices = 1;

   if(strlen(_lrn) != 10 )
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid LRN ");
        return eosl_false;
   }
   /*validate AID to permit only numbers within*/
   if(!(IsInputStrInRange(_lrn,"0123456789")))
   {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
   }
   rowKey.rowIndex[0].colType             = TSSMI_OCTET_STRING;
   rowKey.rowIndex[0].value.stringVal.ptr = _lrn;
   rowKey.rowIndex[0].value.stringVal.len = strlen(_lrn);

   if(_lrntype)
   {
	   if(*_lrntype == LRN_PRI)
	   {
		   sprintf(LrnString,"PRI");
	   }
	   else
	   {
		   sprintf(LrnString,"SEC");
	   }
	   columns[colCnt].columnId                  = TS_COL_OWNLRN_LRNTYPE;
	   columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
	   columns[colCnt].value.value.stringVal.ptr = LrnString;
	   columns[colCnt].value.value.stringVal.len = strlen(LrnString);
	   colCnt++;
   }

   if(_replaceCDPN)
   {
	   columns[colCnt].columnId = TS_COL_OWNLRN_REPCDPN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_replaceCDPN)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
   }
 
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_LRN_req", "ED-LRN - TOO MANY COLUMNS FOR ARRAY!\n");
	   tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
	   return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
						   handle,
						   transId,
						   tableId,
						   &rowKey,
						   &colArray,
						   &smCmd,
						   TL1_MSG_TIMEOUT);

   if( retVal == TRUE)
   {
    return tc_compld_comment( handle, ctag, "ED-LRN" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_ED_LSET_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _lsetId,\
									int _actLnkReqd)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr;
    int            lsetId;
    int            colCnt = 0;
    int            i;


    transId = ctag;

    tableId = MTPLSET_TAB_ID;

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_lsetId, "%d%c", &lsetId, &xchr);
    if ((i != 1) || (lsetId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, LinkSetId Invalid" );  
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal  = lsetId;

    if (_actLnkReqd < 0)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid actLnkReqd" );
        return eosl_false;
    }
    columns[colCnt].columnId = MTPLSET_NMBACTLNKREQD;
    columns[colCnt].value.colType = TSSMI_LONG;
    columns[colCnt].value.value.longVal = _actLnkReqd;
    colCnt++;

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_LSET_req", "ED_LSET - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-LSET" );
    }
}

/**
 * Edit  OSUSER Security
 */
eosl_bool agc_EM_NE_ED_OSUSER_SECU_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _uid,\
									char * _pid,\
									UserPrivilege_ENUM * _uap,\
									int * _page,\
									int * _pcnd,\
									int * _actTmout,\
									int * _maxSes,\
									PrimaryStateIn_ENUM * _pst)
{
    int        result;
    char*      script = OSCMD_ED_OSUSER_SECU_PATH;
    char       parameters[OSUSER_PARAMLEN];
    char       tempPid[150];

    memset(parameters, 0, sizeof(parameters));
    if ( IsUserNameValid(_uid, MIN_OSUSER_NAME_SIZE, MAX_OSUSER_NAME_SIZE) == eosl_false)
    {
        tc_error_response(handle,ctag,TE_PIUI,"User ID's must have a length of 1-32 alphanumeric characters");
        return  eosl_false;
        /* send event */
    }

    sprintf(parameters, "%s %s", optName(uid), _uid);

    if (_pid != NULL)
    {
        if ((strchr(_pid, '-') != NULL)||(strchr(_pid, '\'') !=NULL))
        {
            tc_error_response(handle,ctag,TE_PIUI,"Password shouldn't contain - or ' ");
            return  eosl_false;
        }
        /* 82803 */
        tranStrtoBash(_pid,tempPid,strlen(_pid));
        /* 82803*/

        sprintf(parameters, "%s %s %s", parameters, optName(pid), tempPid);
    }

    if(_uap != NULL)
    {
        if (*_uap == UserPrivilege_NSA || *_uap == UserPrivilege_SA || *_uap == UserPrivilege_VIEW || *_uap == UserPrivilege_ADMIN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid uap" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(uap), (int)_uap);
    }

    if (_page != NULL)
    {
        if ((*_page < 0) || (*_page > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid page" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(page), *_page);
    }

    if (_pcnd != NULL)
    {
        if ((*_pcnd < 0) || (*_pcnd > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pcnd" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(pcnd), *_pcnd);
    }

    if (_actTmout != NULL)
    {
        if ((*_actTmout < 0) || (*_actTmout > 999))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid actTmout" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(actTmout), *_actTmout);
    }

    if (_maxSes != NULL)
    {
        if ((*_maxSes < 0) || (*_maxSes > 20))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid maxSes" );
            return eosl_false;
        }
        sprintf(parameters, "%s %s %d", parameters, optName(maxSes), *_maxSes);
    }

    if (_pst)
    {
      /* If reactivating account */
      if (*_pst == PrimaryStateIn_IS)
      {
        /* If new password not supplied */
        if (!_pid)
        {
          tc_error_response(handle,ctag,TE_PIUI,
                            "Password must be specified when administratively placing an account In-Service.");
          return eosl_false;
        }
      }
      sprintf(parameters, "%s %s %d", parameters, optName(pst), (int)*_pst);
    }

    result = runOSCommand(script, parameters, NULL);
        
    if(result == 0)
    {
        return tc_compld_comment( handle, ctag, "ED-OSUSER-SECU" );
    }
    else
    {
        if(WEXITSTATUS(result) == 1)
        {
            tc_error_response(handle,ctag,TE_SROF,"Specific osuser doesn't exist");
        }
        else
        {
            tc_error_response(handle,ctag,TE_SROF,"Unable to edit osuser");
        }
        return eosl_false;
    }
}

/**
 */
eosl_bool agc_EM_NE_ED_EQPT_req( const char * modifier,\
                                    eosl_handle handle,\
                                     TL1_TAG ctag ,\
                                    TL1_AID _iomOrSp,\
                                    char * _ioModuleType,\
                                    Redundancy_ENUM * _rn,\
                                    int * _spMemThreshold,\
                                    int * _spNVMemThreshold,\
                                    int * _diskMajorThreshold,\
                                    int * _diskCriticalThreshold,\
                                    int * _spBusyThreshold,\
                                    char * _swVersion,\
                                    PrimaryStateIn_ENUM * _pst)
{
    /*SLOT_RTRV_INFO_t      * s_data; */
    char * temp;
    AID_INFO_TYPE_t aidInfo;

    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask=0;
    int                 len;
    int                 i;
    eosl_bool           ret = eosl_false;

    memset(&cmdMsg,0x0,sizeof(TL1_BUF_t)); /* set all valid flags=0 */


    /*
    ** let's do the slot stuff first
    */

    if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;
    cmdMsg.Buf.Cmd = EQMCMD_ED_EQPT;

    if(_ioModuleType)
    {
        len = strlen(_ioModuleType);
        if (len > (int)sizeof(cmdMsg.CmdInfo.EdtParams.Type.strValue))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );  
            return eosl_false;
        }

        /* EMF needs upper case. */
        for (i = 0; i < len; i++)
        {
            cmdMsg.CmdInfo.EdtParams.Type.strValue[i] = (char) toupper((int) _ioModuleType[i]);
        }
        cmdMsg.CmdInfo.EdtParams.Type.strValue[len] = '\0';
        cmdMsg.CmdInfo.EdtParams.Type.valid = VALID_VALUE;
    }

    if(_rn)
    {
        temp = enum_lookup_name( &Redundancy_ENUM_type , *_rn);
        strncpy(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue, temp, sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue));
        cmdMsg.CmdInfo.EdtParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue - 1)] = '\0';
        cmdMsg.CmdInfo.EdtParams.Redundancy.valid= VALID_VALUE;
    }

    if(_swVersion)
    {
        strncpy(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue));
        cmdMsg.CmdInfo.EdtParams.SWVersion.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.SWVersion.valid= VALID_VALUE;
    }

    if(_pst)
    {
        temp=enum_lookup_name( &PrimaryStateIn_ENUM_type, *_pst);
        SetStateMask( temp, temp, NULL, &stateMask, NULL);
        cmdMsg.CmdInfo.EdtParams.State.value=stateMask;
        cmdMsg.CmdInfo.EdtParams.State.valid= (OPTIONAL_PARM_VALID) stateMask;
    }

    if(_spMemThreshold)
    {
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.value = *_spMemThreshold;
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.valid=VALID_VALUE;
    }

    ret = assignDiskThreshold(handle, ctag, 0, _spNVMemThreshold, _diskMajorThreshold, _diskCriticalThreshold, &cmdMsg);
    if (eosl_false == ret) /* error response is set in function */
    {
        return eosl_false;
    }

    if(_spBusyThreshold)
    {
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.value = *_spBusyThreshold;
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.valid=VALID_VALUE;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-EQPT" );

}

/**
 * Edit  IPROUTE
 */
eosl_bool agc_EM_NE_ED_IPROUTE_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ipRouteId,\
                           EnableType_ENUM _gatewayPing)
{
    IPROUTE_CMD_t     buffer;
#if 0
    char *script = EXEC_CHECK_LCP_ROUTE;
    char parameters[MAX_ROUTE_LENGTH];
#endif
    /*
    ** prepare data structure
    */
    memset(&buffer, 0, sizeof(IPROUTE_CMD_t)); /* sets all "valid" flags to 0*/

    /* If the AID was NOT successfully parsed and loaded into the message 
     * structure */
    if (ParseRouteAid(_ipRouteId,
                      &buffer.DeviceId,
                      &buffer.DeviceMap,
                      &buffer.Data.EdIpRoute.Dest,
#ifndef ATCA
                      &buffer.Data.EdIpRoute.SubnetMask,
#else
                      &buffer.Data.EdIpRoute.Subnet,
#endif
                      AID_IPROUTE_FULL) == FAIL)
    {
        tc_error_response( handle, ctag, TE_IIAC, 
                           "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
#ifdef ATCA
    /* IPv6 NETMASK should be > 0 */
    if(buffer.Data.EdIpRoute.Dest.ipVersion == AF_INET6 && 
       (buffer.Data.EdIpRoute.Subnet < 1 || buffer.Data.EdIpRoute.Subnet > 128)
      )
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
#if 0
    /* no need to check edit. */
    /* co-host chassis, should follow LCP's IPv4 route table */
    if(buffer.Data.EntIpRoute.Dest.ipVersion == AF_INET && procInfo.IsOAMCoexist) {
        char destAddr[INET6_ADDRSTRLEN], subnetAddr[INET6_ADDRSTRLEN];
        unsigned int tmp_mask = htonl(OalGetSubnetMask(buffer.Data.EdIpRoute.Subnet));
        strncpy(destAddr, ip_ntoa(&buffer.Data.EdIpRoute.Dest), INET6_ADDRSTRLEN);
        strncpy(subnetAddr, inet_ntoa(tmp_mask), INET6_ADDRSTRLEN);

        snprintf(parameters, MAX_ROUTE_LENGTH, "%s %s %s", /* dest/mask/gwip */
                 destAddr, subnetAddr, _gateway);
        result = runOSCommand(script, parameters, NULL);
        if (result == 1) {
            tc_error_response( handle, ctag, TE_IIDT, "Input, IPROUTE is not compatible to LCP." );
            return eosl_false;
        }
    }
#endif
#endif

    switch(_gatewayPing)
    {
    case EnableType_DISABLED:
        buffer.Data.EdIpRoute.PingEnabled = FALSE;
        break;
    case EnableType_ENABLED:
        buffer.Data.EdIpRoute.PingEnabled = TRUE;
        break;
    default:
        tc_error_response( handle, ctag, TE_IIDT, 
                           "Input, gatewayPing Invalid" );
        return eosl_false;
        break;
    }

    /* Dispatch the message */
    if(TL1SendMsg(handle, ctag,
                  IP_ROUTE_CMD_CLASS, CMD, ED_IPROUTE,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  (TL1_CMD_BUF_t *)&buffer, sizeof(IPROUTE_CMD_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_IPROUTE, buffer.Tl1Cmd.Error );
        return eosl_false;
    }
    return tc_compld_comment( handle, ctag, "ED-IPROUTE" );
}

/**
 * Edits parameters associated with an STS facility. GR 199.
 */
eosl_bool agc_EM_NE_ED_T1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id, char * _eqlz, FormatSignal_ENUM * _fmt, LineCode_ENUM * _linecde, DSMode_ENUM * _omode, TimingReference_ENUM * _tmgref, Side_Network_ENUM * _iftype, PrimaryStateIn_ENUM * _pst)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = T1_TAB_ID;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[MAX_TSM_COLS];
    SMCMD_t           smCmd;
    int               cmd = SM_ED_REQUEST;
    int               colCnt = 0, tenths = 0;

    TL1LOGP (PLOG_ERROR, "T1 aid:%s\n", _ds_id);
    TL1LOGP (PLOG_ERROR, "TABLE ID:%d(0x%x)\n", tableId, tableId);

    if(ParseAidMap(&aidInfo, _ds_id, AID_AMCSS7PORT, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    TL1LOGP (PLOG_ERROR, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                         (aidInfo.devicemap == T1)?"T1":"E1",
                         aidInfo.lvl1, aidInfo.lvl2,
                         aidInfo.lvl3, aidInfo.lvl4);
    if (aidInfo.devicemap == T1)
    {
        rowKey.numIndices = 4;
        rowKey.rowIndex[0].colType          = TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
        rowKey.rowIndex[1].colType          = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
        rowKey.rowIndex[2].colType          = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
        rowKey.rowIndex[3].colType          = TSSMI_LONG;
        rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if(_eqlz)
    {
        columns[colCnt].columnId            = T1_EQLZ;
        columns[colCnt].value.colType       = TSSMI_LONG;
        if (StringToDecimal2(_eqlz, &tenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid eqlz Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = tenths;
        colCnt++;
    }

    if(_fmt)
    {
        columns[colCnt].columnId            = T1_FMT;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_fmt)
        {
          case FormatSignal_ESF:
              columns[colCnt].value.value.longVal = T1_FMT_ESF;
              break;
          case FormatSignal_SF:
              columns[colCnt].value.value.longVal = T1_FMT_SF;
              break;
          case FormatSignal_ESF_NOFDL:
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid fmt Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_linecde)
    {
        columns[colCnt].columnId            = T1_LINECDE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_linecde)
        {
          case LineCode_AMI:
              columns[colCnt].value.value.longVal = T1_LINECDE_AMI;
              break;
          case LineCode_B8ZS:
              columns[colCnt].value.value.longVal = T1_LINECDE_B8ZS;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid lineCde Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_omode)
    {
        columns[colCnt].columnId            = T1_OMODE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_omode)
        {
          case DSMode_AIS:
              columns[colCnt].value.value.longVal = T1_OMODE_AIS;
              break;
          case DSMode_NORM:
              columns[colCnt].value.value.longVal = T1_OMODE_NORM;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid oMode Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_tmgref)
    {
        columns[colCnt].columnId            = T1_TMGREF;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_tmgref)
        {
          case TimingReference_NONE:
              columns[colCnt].value.value.longVal = T1_TMGREF_NONE;
              break;
          case TimingReference_PRI:
          case TimingReference_SEC:
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid tmgRef Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_iftype)
    {
        columns[colCnt].columnId            = T1_IFTYPE;
        columns[colCnt].value.colType       = TSSMI_LONG;
        switch (*_iftype)
        {
          case Side_Network_NETWORKSIDE:
              columns[colCnt].value.value.longVal = T1_IFTYPE_NETWORK;
              break;
          case Side_Network_USERSIDE:
              columns[colCnt].value.value.longVal = T1_IFTYPE_USER;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid ifType Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }
    if(_pst)
    {
        columns[colCnt].columnId = T1_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_pst)
        {
          case PrimaryStateIn_IS:
              columns[colCnt].value.value.longVal = T1_PST_IS;
              break;
          case PrimaryStateIn_OOS:
              columns[colCnt].value.value.longVal = T1_PST_OOS;
              break;
          default:
              tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid pst Value" );
              return eosl_false;
              break;
        }
        colCnt++;
    }


    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (emfPkSmiSetReq(cmd, handle, transId, tableId, &rowKey,
                       &colArray, &smCmd, TL1_MSG_TIMEOUT) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-T1" );
#else
    DSX_CMD_BUF_t      buffer;
    char         *cmdClass;
    unsigned int         cmd;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_PORT_EDIT);

    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id,
                             (AID_PORT | AID_BITS | AID_STS1 | AID_OC3_STS1_T1|AID_AU3TUG3_T1),
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    if ((GetLevel1(buffer.DeviceId) == AID_BITS_SLOT_MAPPING) ||
        (GetLevel1(buffer.DeviceId) == AID_BITS_SLOT_MAPPING + 1))
    {
        /* TBD * We should be using a BITS_CMD_BUF_t structure, not a DSX_CMD_BUF_t !!! */
        /* TBD * Size should be: SIZEOF_BITSCMD_PORT_ENTER */
        cmdClass = BITS_CMD_CLASS;
        cmd = BITSCMD_PORT_EDIT;
    }
    else
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_ED_T1;
    }

    if (_eqlz)
    {
        if(!IsInputStrInRange(_eqlz ,"0123456789"))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid eqlz" );
            return eosl_false;
        }
        buffer.Data.T1Edit.Eqlz.value = atoi(_eqlz);
        buffer.Data.T1Edit.Eqlz.valid = VALID_VALUE;
    }

    if (_fmt)
    {
        buffer.Data.T1Edit.Fmt.value = *_fmt;
        buffer.Data.T1Edit.Fmt.valid = VALID_VALUE;
    }

    if (_linecde)
    {
        buffer.Data.T1Edit.Linecde.value = *_linecde;
        buffer.Data.T1Edit.Linecde.valid = VALID_VALUE;
    }

    if (_omode)
    {
        buffer.Data.T1Edit.Omode.value = *_omode;
        buffer.Data.T1Edit.Omode.valid = VALID_VALUE;
    }

    if (_tmgref)
    {
        buffer.Data.T1Edit.Tmgref.value = *_tmgref;
        buffer.Data.T1Edit.Tmgref.valid = VALID_VALUE;
    }

    if (_iftype)
    {
        buffer.Data.T1Enter.Side.value = *_iftype;
        buffer.Data.T1Enter.Side.valid = VALID_VALUE;
    }

    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.T1Edit.State.value |= PST_IS_BIT;
            buffer.Data.T1Edit.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.T1Edit.State.value |= PST_OOS_BIT;
            buffer.Data.T1Edit.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIAC, "Invalid PrimaryState" );
            return eosl_false;
        }
    }

    

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_PORT_EDIT,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(DSX_CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_T1_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ED-T1" );
#endif
}

/**
 * Retrieve  PLAN SUIOM
 */
eosl_bool agc_EM_NE_RTRV_PLAN_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suPlanName)
{
    TL1_BUF_t         buffer;
    CMD_BUF_t         rsp;
    int               i;
    char              NullString[] ="NULL";
    RTRV_PLAN_SUIOM_resp_row result[MAX_NUM_SUPLAN];

    memset(&buffer, 0, sizeof(TL1_BUF_t));
    
    if(_suPlanName)
    {
        strncpy(buffer.CmdInfo.RtrvSuPlan.SuPlanName, _suPlanName, SUAUTO_PLAN_LEN + 1);
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_RTRV_SUPLAN,
                  (TL1_CMD_BUF_t *)&rsp, sizeof(rsp),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, rsp.Buf.Error );
        return eosl_false;
    }

    for(i = 0; i < rsp.CmdInfo.RtrvSuPlanRsp.NPlans; ++i)
    {
        result[i]._suPlanName = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuPlanName;
        
        if(rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[0][0] == '\0')
        {
            result[i]._list1 = NullString;
        }
        else
        {
            result[i]._list1 = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[0];
        }
        
        if(rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[1][0] == '\0')
        {
            result[i]._list2 = NullString;
        }
        else
        {
            result[i]._list2 = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[1];
        }
        
        if(rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[2][0] == '\0')
        {
            result[i]._list3 = NullString;
        }
        else
        {
            result[i]._list3 = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[2];
        }
        
        if(rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[3][0] == '\0')
        {
            result[i]._list4 = NullString;
        }
        else
        {
            result[i]._list4 = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[3];
        }
        
        if(rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[4][0] == '\0')
        {
            result[i]._list5 = NullString;
        }
        else
        {
            result[i]._list5 = rsp.CmdInfo.RtrvSuPlanRsp.PlanInfo[i].SuListName[4];
        }
    }
    
    return agc_EM_NE_RTRV_PLAN_SUIOM_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       result,
                                       rsp.CmdInfo.RtrvSuPlanRsp.NPlans,
                                       "RTRV-PLAN-SUIOM",
                                       NULL );
}

/**
 */
eosl_bool agc_EM_NE_RTRV_PMDAY_req( const char * modifier, eosl_handle handle, TL1_TAG ctag )
{
    DSX_CMD_BUF_t                buffer;
    RTRV_PMDAY_resp_row          result;

    /*
    ** prepare t1 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_RTRV_PMDAY);

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_RTRV_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_RTRV_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_RTRV_PMDAY_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    result._HourOfDay = buffer.Data.RtrvPmDay.Hour;

    return  agc_EM_NE_RTRV_PMDAY_resp( modifier,
                                       handle,
                                       ctag,
                                       TCC_COMPLD,
                                       &result,
                                       1,
                                       "RTRV-PMDAY",
                                       NULL);

    /*  return tc_compld_comment( handle, ctag, "RTRV-PMDAY" ); */
}


/**
 */
eosl_bool agc_EM_NE_SET_PMDAY_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , int _HourOfDay)
{
    DSX_CMD_BUF_t         buffer;

    /*
    ** prepare t1 data structure
    */

    if (_HourOfDay > 23 || _HourOfDay < 0)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Invalid Hour of Day" );
        return eosl_false;
    }

    memset(&buffer, 0, SIZEOF_DSXCMD_SET_PMDAY);

    buffer.Data.SetPmDay.Hour = _HourOfDay;

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_SET_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_SET_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_SET_PMDAY_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_SET_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_SET_PMDAY,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(DSX_CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_SET_PMDAY_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "SET-PMDAY" );
}

/**
 * Edit  PLAN SUIOM
 */
eosl_bool agc_EM_NE_ED_PLAN_SUIOM_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _suPlanName,\
									char * _list1,\
									char * _list2,\
									char * _list3,\
									char * _list4,\
									char * _list5)
{
    TL1_BUF_t          buffer;

    memset(&buffer, 0, sizeof(TL1_BUF_t));
    
    if(_suPlanName)
    {
        if(strlen(_suPlanName) > SUAUTO_PLAN_LEN)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid SUPLANNAME" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuPlanName, _suPlanName, SUAUTO_PLAN_LEN + 1);
    }

    if(_list1)
    {
        if (strlen(_list1) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST1" );
            return eosl_false;
        }
        if (eosl_strcasecmp(_list1, "NULL") == 0)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid LIST1" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuListName[0], _list1, SUAUTO_LIST_LEN + 1);
    }

    if(_list2)
    {
        if (strlen(_list2) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST2" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuListName[1], _list2, SUAUTO_LIST_LEN + 1);
    }
    
    if(_list3)
    {
        if (strlen(_list3) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST3" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuListName[2], _list3, SUAUTO_LIST_LEN + 1);
    }

    if(_list4)
    {
        if (strlen(_list4) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST4" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuListName[3], _list4, SUAUTO_LIST_LEN + 1);
    }

    if(_list5)
    {
        if (strlen(_list5) > SUAUTO_LIST_LEN)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid LIST5" );
            return eosl_false;
        }
        strncpy(buffer.CmdInfo.EdSuPlan.SuListName[4], _list5, SUAUTO_LIST_LEN + 1);
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ED_SUPLAN,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-PLAN-SUIOM" );
}

/**
 */
eosl_bool agc_EM_NE_ED_PRFL_CIC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _cicPrflId, char * _isupT12, char * _isupT13, char * _isupT14, char * _isupT15, char * _isupT16, char * _isupT17, char * _isupTCVT, char * _isupT24, char * _isupT25, char * _isupT26, char * _isupTCOTD, char * _isupTTBLOM, int * _guardTmr, BoolYN_ENUM * _oliFlag, char * _hopCntr)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    char           hopXchr=0;
    int            colnCnt=0;
    int            cicPrflId;
    int            timerTenths;
    int               hopCntr;
    int           i;
    int           j;


    /* tableId = TS_TABLE_ID_CIC_PRFL; change Bugzilla 6603 */
    tableId = TELICA_TABLE_SS7TRKPRFL_CFG;
    transId = ctag;

    i = sscanf(_cicPrflId, "%d%c", &cicPrflId, &xchr); 
    if ((i != 1) || (cicPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> cicPrflId" );
        return eosl_false;
    }

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal =cicPrflId;



    if (_isupT12)
    {
        columns[colnCnt].columnId = SS7CICT12;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT12, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT13)
    {
        columns[colnCnt].columnId = SS7CICT13;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT13, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT14)
    {
        columns[colnCnt].columnId = SS7CICT14;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT14, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT15)
    {
        columns[colnCnt].columnId = SS7CICT15;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT15, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT16)
    {
        columns[colnCnt].columnId = SS7CICT16;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT16, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupT17)
    {
        columns[colnCnt].columnId = SS7CICT17;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT17, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_isupTCVT)
    {
        columns[colnCnt].columnId = SS7CICTVAL;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTCVT, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT24)

    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T24;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT24, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT25)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T25;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT25, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupT26)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_T26;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupT26, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupTCOTD)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_TCOT_D;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTCOTD, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }
    if (_isupTTBLOM)
    {
        columns[colnCnt].columnId =  SS7TRKPRFL_TBLO;
        columns[colnCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_isupTTBLOM, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =timerTenths;
        colnCnt++;
    }

    if (_hopCntr)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_HOPCOUNTER;
        columns[colnCnt].value.colType = TSSMI_LONG;
        j = sscanf(_hopCntr, "%d%c", &hopCntr, &hopXchr);
        if ((j != 1) || ( hopCntr < 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, hopCntr Invalid" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal = hopCntr;
        colnCnt++;       
    }
    /*Telica prakash Bugfix 6917*/ 
    if(_guardTmr)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_TIMERTGAURD;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = *_guardTmr;
        colnCnt++;  
    }
    if(_oliFlag)
    {
        columns[colnCnt].columnId = SS7TRKPRFL_OLIFLAG;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal = *_oliFlag;
        colnCnt++;  
    }

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_PRFL_CIC_req", "ED_PRFL_CIC - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_SS7TRKPRFL_ED_TIMEOUT);


    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-PRFL-CIC" );
    }


}


/**
 */
eosl_bool agc_EM_NE_ED_PRFL_SGPC_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _pcPrflId, char * _mtp3T6, char * _mtp3T8, char * _mtp3T10, char * _mtp3T11, char * _mtp3T18, char * _mtp3ITUT19, char * _mtp3ITUT21, char * _mtp3T25, char * _mtp3T28, char * _mtp3T29)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char      xchr;
    int            pcPrflId;
    int            colCnt = 0;
    int            timerTenths;
    int            i;

    transId = ctag;

    tableId = MTPPC_PRFL_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_pcPrflId,"%d%c", &pcPrflId, &xchr);
    if ((i != 1) || (pcPrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, PcPrflId Invalid" );  
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = pcPrflId;

    if(_mtp3T6)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT6;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T6, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T8)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT8;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T8, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T10)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT10;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T10, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T11)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT11;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T11, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T18)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT18;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T18, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT19)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRITUT19;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT19, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT21)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRITUT21;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT21, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T25)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT25;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T25, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T28)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT28;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T28, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if(_mtp3T29)
    {
        columns[colCnt].columnId = MTPPCPRFL_TMRT29;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T29, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_PRFL_SGPC_req", "ED_PRFL_SGPC - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-PRFL-SGPC" );
    }
}


/**
 * Edit  PRFL PFP
 */
eosl_bool agc_EM_NE_ED_PRFL_PFP_req( const char * modifier,\
									 eosl_handle handle,\
									 TL1_TAG ctag ,\
									 TL1_AID _pfpPrflId,\
									 PfpType_ENUM * _pfpType,\
									 int * _alarmThresh,\
									 int * _dropThresh,\
									 int * _pollFreq,\
									 PrimaryStateIn_ENUM * _pst)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;


   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = PRFLPFP_TAB_ID;

   if(!IsInputStrInRange(_pfpPrflId,"0123456789"))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
       return eosl_false;
   }
   rowKey.rowIndex[0].colType = TSSMI_LONG;
   rowKey.rowIndex[0].value.longVal = atoi(_pfpPrflId);
   rowKey.numIndices = 1;
	
   if(_pfpType)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_PFPTYPE;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_pfpType)
	   {
	   case PfpType_ALARMONLY:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMONLY;
		   break;
	   case PfpType_ALARMDROP:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMDROP;
		   break;
	   case PfpType_ALARMDROPLOG:
		   columns[colCnt].value.value.longVal = PRFLPFP_PFPTYPE_ALARMDROPLOG;
		   break;
	   default:
		   break;
	   }
	   colCnt++;
   }
   if(_alarmThresh)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_ALARM_THRESH;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_alarmThresh;
	   colCnt++;
   }				
   if(_dropThresh)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_DROP_THRESH;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_dropThresh;
	   colCnt++;
	}				
   if(_pollFreq)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_POLLFREQ;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   columns[colCnt].value.value.longVal = *_pollFreq;
	   colCnt++;
   }				
   if(_pst)
   {
	   columns[colCnt].columnId = PRFLPFP_COL_PST;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch (*_pst) 
	   {
	   case PrimaryStateIn_IS:
		   columns[colCnt].value.value.longVal = PRFLPFP_PST_IS;
		   break;
	   case PrimaryStateIn_OOS:
		   columns[colCnt].value.value.longVal = PRFLPFP_PST_OOS;
		   break;
	   default:
		   break;
	   }
	   colCnt++;
   }
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_PRFL_PFP", "ED-PRFL-PFP - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "ED-PRFL-PFP" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 */
eosl_bool agc_EM_NE_ED_PRFL_SLKL2_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp2PrflId, char * _mtp2T1, char * _mtp2T2, char * _mtp2T3, char * _mtp2T5, char * _mtp2T6, char * _mtp2T7, char * _mtp2ProvEmrgcy, char * _mtp2ProvNormal, int * _congAbate1, int * _congOnset1, int * _congDiscard1, int * _congAbate2, int * _congOnset2, int * _congDiscard2, int * _congAbate3, int * _congOnset3, int * _congDiscard3, int * _maxBufferCnt, BoolYN_ENUM * _multiCongLvl, int * _mtp2AA, BoolYN_ENUM * _hwm1MinCfg, BoolYN_ENUM * _hwm5MinCfg, BoolYN_ENUM * _hwm15MinCfg, int * _hwmLTL1, int * _hwmHTL1, int * _hwmLTL2, int * _hwmHTL2, int * _hwmLTL3, int * _hwmHTL3)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    char      xchr=0;
    int            mtp2Prfl;
    int            colCnt = 0;
    int            timerTenths;
    int            i;


    transId = ctag;
    tableId = MTPLY2_PRFL_TAB_ID;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    i = sscanf(_mtp2PrflId, "%d%c", &mtp2Prfl, &xchr);
    if ((i != 1) || (mtp2Prfl < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Mtp2PrflId Invalid" );  
        return eosl_false;
    }
    rowKey.rowIndex[0].value.longVal = mtp2Prfl;

    if (_mtp2T1)
    {
        columns[colCnt].columnId = MTPLY2_TMRT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T1" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T2)
    {
        columns[colCnt].columnId = MTPLY2_TMRT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T2" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T3)
    {
        columns[colCnt].columnId = MTPLY2_TMRT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T3, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T3" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T5)
    {
        columns[colCnt].columnId = MTPLY2_TMRT5;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T5, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T5" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T6)
    {
        columns[colCnt].columnId = MTPLY2_TMRT6;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T6, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T6" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2T7)
    {
        columns[colCnt].columnId = MTPLY2_TMRT7;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2T7, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value T7" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2ProvEmrgcy)
    {
        columns[colCnt].columnId = MTPLY2_PROVEMRGCY;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2ProvEmrgcy, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value for ProvEmrgcy" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_mtp2ProvNormal)
    {
        columns[colCnt].columnId = MTPLY2_PROVNORMAL;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp2ProvNormal, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value for ProvNormal" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal = timerTenths;
        colCnt++;
    }

    if (_congAbate1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate1;
        colCnt++;
    }
    if (_congOnset1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset1;
        colCnt++;
    }
    if (_congDiscard1)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard1;
        colCnt++;
    }
    if (_congAbate2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate2;
        colCnt++;
    }
    if (_congOnset2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset2;
        colCnt++;
    }
    if (_congDiscard2)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard2;
        colCnt++;
    }
    if (_congAbate3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ABATE3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congAbate3;
        colCnt++;
    }
    if (_congOnset3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_ONSET3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congOnset3;
        colCnt++;
    }
    if (_congDiscard3)
    {
        columns[colCnt].columnId = MTPLY2_CONG_DISCARD3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_congDiscard3;
        colCnt++;
    }
    if (_maxBufferCnt)
    {
        columns[colCnt].columnId = MTPLY2_MAX_BUFFER_CNT;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_maxBufferCnt;
        colCnt++;
    }

    if(_multiCongLvl)
    {
	   columns[colCnt].columnId = MTPLY2_MULTI_CONG_LVL;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_multiCongLvl)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }

    if (_mtp2AA)
    {
        if (*_mtp2AA < 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid mtp2AA" );
            return eosl_false;
        }
        columns[colCnt].columnId = MTPLY2_SDCP;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_mtp2AA;
        colCnt++;
    }
    if(_hwm1MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM1MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm1MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if(_hwm5MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM5MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm5MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if(_hwm15MinCfg)
    {
	   columns[colCnt].columnId = MTPLY2_HWM15MIN;
	   columns[colCnt].value.colType = TSSMI_LONG;
	   switch(*_hwm15MinCfg)
	   {
	   case BoolYN_N:
		   columns[colCnt].value.value.longVal = FALSE;
		   break;
	   case BoolYN_Y:
		   columns[colCnt].value.value.longVal = TRUE;
		   break;
	   default:
		   break;
	   }
	   colCnt++;  
    }
    if (_hwmLTL1)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL1;
        colCnt++;
    }
    if (_hwmHTL1)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL1;
        colCnt++;
    }
    if (_hwmLTL2)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL2;
        colCnt++;
    }
    if (_hwmHTL2)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL2;
        colCnt++;
    }
    if (_hwmLTL3)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMLT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmLTL3;
        colCnt++;
    }
    if (_hwmHTL3)
    {
        columns[colCnt].columnId = MTPLY2_HWMALRMHT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_hwmHTL3;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_PRFL_SLKL2_req", "ED_PRFL_SLKL2 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if( retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-PRFL-SLKL2" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ED_PRFL_SLKL3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _mtp3PrflId, char * _mtp3T1, char * _mtp3T2, char * _mtp3T3, char * _mtp3T4, char * _mtp3T5, char * _mtp3T7, char * _mtp3T12, char * _mtp3T13, char * _mtp3T14, char * _mtp3T17, char * _mtp3T19, char * _mtp3T20, char * _mtp3T21, char * _mtp3ITUT22, char * _mtp3ITUT23, char * _mtp3TstT1, char * _mtp3TstT2, char * _mtp3T31, char * _mtp3T33, char * _mtp3T34)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char      xchr=0;
    int            mtp3PrflId;
    int            colCnt=0;
    int            timerTenths;
    int            cmd=SM_ED_REQUEST;
    int       i;



    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_mtp3PrflId, "%d%c", &mtp3PrflId, &xchr);
    if ((i != 1) || (mtp3PrflId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> mtp3PrflId" );
        return eosl_false;
    }


    tableId = MTPLY3_PRFL_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal= mtp3PrflId;

    if(_mtp3T1)
    {
        columns[colCnt].columnId =MTPLY3_TMRT1;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T2)
    {
        columns[colCnt].columnId =MTPLY3_TMRT2;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T3)
    {
        columns[colCnt].columnId =MTPLY3_TMRT3;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T3, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T4)
    {
        columns[colCnt].columnId =MTPLY3_TMRT4;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T4, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T5)
    {
        columns[colCnt].columnId =MTPLY3_TMRT5;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T5, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T7)
    {
        columns[colCnt].columnId = MTPLY3_TMRT7;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T7, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T12)
    {
        columns[colCnt].columnId = MTPLY3_TMRT12;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T12, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T13)
    {
        columns[colCnt].columnId = MTPLY3_TMRT13;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T13, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T14)
    {
        columns[colCnt].columnId = MTPLY3_TMRT14;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T14, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T17)
    {
        columns[colCnt].columnId = MTPLY3_TMRT17;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T17, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T19)
    {
        columns[colCnt].columnId = MTPLY3_TMRTCRFT;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T19, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T20)
    {
        columns[colCnt].columnId = MTPLY3_TMRT20;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T20, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T21)
    {
        columns[colCnt].columnId = MTPLY3_TMRT21;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T21, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT22)
    {
        columns[colCnt].columnId = MTPLY3_TMRITUT22;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT22, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3ITUT23)
    {
        columns[colCnt].columnId = MTPLY3_TMRITUT23;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3ITUT23, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3TstT1)
    {
        columns[colCnt].columnId = MTPLY3_TMRT32;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3TstT1, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3TstT2)
    {
        columns[colCnt].columnId = MTPLY3_TMRT34;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3TstT2, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T31)
    {
        columns[colCnt].columnId = MTPLY3_TMRT35;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T31, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T33)
    {
        columns[colCnt].columnId = MTPLY3_TMRT36;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T33, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }
        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    if(_mtp3T34)
    {
        columns[colCnt].columnId = MTPLY3_TMRT37;
        columns[colCnt].value.colType = TSSMI_LONG;
        if (StringToDecimal(_mtp3T34, &timerTenths))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid Timer Value" );
            return eosl_false;
        }

        columns[colCnt].value.value.longVal =timerTenths;
        colCnt++;
    }

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_PRFL_SLKL3_req", "ED_PRFL_SLK3 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-PRFL-SLKL3" );
    }

}

/**
 * Edit  RADIUS System
 */
eosl_bool agc_EM_NE_ED_RADIUS_SYS_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _src,\
									char * _prisrvr,\
									int * _prisrvrport,\
									char * _prisrvrkey,\
									char * _secsrvr,\
									int * _secsrvrport,\
									char * _secsrvrkey,\
									int * _timeout,\
									int * _retry)
{
#ifdef ATCA
    char        buffer[MAX_GOAHEAD_MSG_SIZE];
    DB_WRITE_t  *p_dbData = (DB_WRITE_t *) &buffer[0];
    DB_COLUMN_t *p_dbEntry = (DB_COLUMN_t *) &p_dbData->Columns[0];
    int         rowNum = TL1_DB_CFG_ROW;
    int         ipFormats = 0;
    int         ipValidation = TL1_IPVAL_IPV4_UNSPECIFIED | TL1_IPVAL_IPV4_LOOPBACK | TL1_IPVAL_IPV4_NETBROADCAST;
    ip_addr_t   ip;
    char        vldPriSrvr[MAX_RADIUS_IPFQDN_LEN+1] = {0};
    char        vldSecSrvr[MAX_RADIUS_IPFQDN_LEN+1] = {0};
    char        alphaNumCharDashDotQuotes[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.\"";
    char        alphaNumCharList[]= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int         errCode;
    DB_RADIUS_CFG_t dbRadiusCfg = {0};

    strcpy(p_dbData->DBName, TL1_DB_NAME);
    strcpy(p_dbData->TableName, TL1_CFG_TABLE_NAME);
    p_dbData->NumColumns = 0;

    
    if (getDbRadiusCfg(&dbRadiusCfg) != SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Not in valid state" );
        return eosl_false;
    }

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /* priSrvr can be NULL, or a valid IPV4 address, or a FQDN enclosed within double quotes */
    if (_prisrvr)
    {
        ipFormats = TL1_IPFMT_IPV4 | TL1_IPFMT_NULL;

        if ((_prisrvr[0] == 0x22) && (_prisrvr[strlen(_prisrvr)-1] == 0x22))
        {
            ipFormats = TL1_IPFMT_FQDN;
            if (strlen(_prisrvr) > 64)  /* max 64 chars, including double quotes */
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid priSrvr, exceed max length" );
                return eosl_false;
            }
        }

        if ((errCode = tl1ValidateIP(_prisrvr,
                                     vldPriSrvr,
                                     ipFormats,
                                     ipValidation,
                                     alphaNumCharDashDotQuotes,
                                     &ip)) != TL1_IPCDE_SUCCESS)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ED_RADIUS_SYS_req",
                       "agc_EM_NE_ED_RADIUS_SYS_req: Invalid priSrvr[%s], errCode[%d]\n",
                       _prisrvr, errCode);
 
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid priSrvr" );
            return eosl_false;
        }

        /* Dependency: 1) priSrvr can not be NULL when authPolicy in SYS-SECU is not LOCAL; 
                       2) priSrvr can not be NULL when secSrvr is non-NULL */
        if (eosl_strcasecmp(vldPriSrvr, "NULL") == 0)
        {  
            if (dbRadiusCfg.authPolicy != AUTH_POLICY_LOCAL)
            {
                tc_error_response( handle, ctag, TE_IIAC, "authPolicy must be LOCAL for NULL priSrvr" );
                return eosl_false;
            }

            if (!_secsrvr) /* secSrvr is not configured along with priSrvr */
            {
                if (eosl_strcasecmp(dbRadiusCfg.secRadiusSrvr, "NULL") != 0)
                {
                    tc_error_response( handle, ctag, TE_IIAC, "secSrvr must be NULL for NULL priSrvr" );
                    return eosl_false; 
                }
            }
            else /* secSrvr is configured along with priSrvr */
            {
                if (eosl_strcasecmp(_secsrvr, "NULL") != 0)
                {
                    tc_error_response( handle, ctag, TE_IIAC, "secSrvr must be NULL for NULL priSrvr" );
                    return eosl_false;
                }
            }
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PRI_RADIUS_SRVR_COL, rowNum,
                                        DB_DATA_TYPE_STRING, 0, vldPriSrvr);
    }

    if (_prisrvrport)
    {
        if ((*_prisrvrport > 65535) || (*_prisrvrport < 1))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid priSrvrPort" );
            return eosl_false;
        }
 
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PRI_RADIUS_SRVR_PORT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_prisrvrport, NULL);
    } 

    if (_prisrvrkey)
    {
        if ((strlen(_prisrvrkey) < 1) || (strlen(_prisrvrkey) > 32) || !IsInputStrInRange(_prisrvrkey, alphaNumCharList))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid priSrvrKey" );
            return eosl_false;
        } 

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PRI_RADIUS_SRVR_KEY_COL, rowNum,
                                        DB_DATA_TYPE_STRING, 0, _prisrvrkey);
    }

    /* secSrvr can be NULL, or a valid IPV4 address, or a FQDN enclosed within double quotes */
    if (_secsrvr)
    {
        ipFormats = TL1_IPFMT_IPV4 | TL1_IPFMT_NULL;

        if ((_secsrvr[0] == 0x22) && (_secsrvr[strlen(_secsrvr)-1] == 0x22))
        {
            ipFormats = TL1_IPFMT_FQDN;
            if (strlen(_secsrvr) > 64)  /* max 64 chars, including double quotes */
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid secSrvr, exceed max length" );
                return eosl_false;
            }
        }

        if ((errCode = tl1ValidateIP(_secsrvr,
                                     vldSecSrvr,
                                     ipFormats,
                                     ipValidation,
                                     alphaNumCharDashDotQuotes,
                                     &ip)) != TL1_IPCDE_SUCCESS)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ED_RADIUS_SYS_req",
                       "agc_EM_NE_ED_RADIUS_SYS_req: Invalid secSrvr[%s], errCode[%d]\n",
                       _secsrvr, errCode);

            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid secSrvr" );
            return eosl_false;
        }

        /* Dependency: 1) secSrvr must be NULL when priSrvr is NULL */
        if (eosl_strcasecmp(vldSecSrvr, "NULL") != 0)
        {
            if (!_prisrvr) /* priSrvr is not configured along with secSrvr */
            {
                if (eosl_strcasecmp(dbRadiusCfg.priRadiusSrvr, "NULL") == 0)
                {
                    tc_error_response( handle, ctag, TE_IIAC, "secSrvr must be NULL for NULL priSrvr" );
                    return eosl_false;
                }
            }
            else /* priSrvr is configured along with secSrvr,
                    this block should not be run because eosl_false must be returned when checking priSrvr */
            {
                if (eosl_strcasecmp(_prisrvr, "NULL") == 0)
                {
                    tc_error_response( handle, ctag, TE_IIAC, "secSrvr must be NULL for NULL priSrvr" );
                    return eosl_false;
                }
            }
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_SEC_RADIUS_SRVR_COL, rowNum,
                                        DB_DATA_TYPE_STRING, 0, vldSecSrvr);
    }

    if (_secsrvrport)
    {
        if ((*_secsrvrport > 65535) || (*_secsrvrport < 1))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid secSrvrPort" );
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_SEC_RADIUS_SRVR_PORT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_secsrvrport, NULL);
    }

    if (_secsrvrkey)
    {
        if ((strlen(_secsrvrkey) < 1) || (strlen(_secsrvrkey) > 32) || !IsInputStrInRange(_secsrvrkey, alphaNumCharList))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid secSrvrKey" );
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_SEC_RADIUS_SRVR_KEY_COL, rowNum,
                                        DB_DATA_TYPE_STRING, 0, _secsrvrkey);
    }


    if (_timeout)
    {
        if ((*_timeout < 1) || (*_timeout > 10))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid timeOut" );
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_RADIUS_TIMEOUT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_timeout, NULL);
    }

    if (_retry)
    {
        if ((*_retry < 0) || (*_retry > 10))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid retry" );
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_RADIUS_RETRY_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_retry, NULL);
    }


    if (p_dbData->NumColumns > 0)
    {
        if (sendDbWriteRequest(p_dbData, (unsigned int)p_dbEntry - (unsigned int)buffer) == FAIL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ED_RADIUS_SYS_req",
                       "agc_EM_NE_ED_RADIUS_SYS_req: Failed sendDbWriteRequest\n");
            tc_error_response( handle, ctag, TE_SDBE, "Internal Data Base Error" );
            return eosl_false;
        }
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ED_RADIUS_SYS_req",
                   "agc_EM_NE_ED_RADIUS_SYS_req: sendDbWriteRequest done\n");
    }

    /* Add IpFilter for provisioned port.
       Because IpFilter doesn't support FQDN, we only take PORT into consideration. */
    /* If the prisrvrport is not equal to current port in DB */
    if (_prisrvrport && (*_prisrvrport != dbRadiusCfg.priRadiusSrvrPort))
    {
        if (tl1UpdateRadiusPortIPfilterNtfy(dbRadiusCfg.priRadiusSrvrPort,
                                            IPFILTER_NAME_RADIUS_PRI,
                                            IPFILTER_NTFY_TYPE_DELETE) == SUCCESS)
        {
            if (tl1UpdateRadiusPortIPfilterNtfy(*_prisrvrport,
                                                IPFILTER_NAME_RADIUS_PRI,
                                                IPFILTER_NTFY_TYPE_ADD) != SUCCESS)
            {
                procLogMsg(PLOG_ERROR, __FUNCTION__, 
                           "%s: Radius Port [%d] verification - IPFILTER notification failure.\n",
                            __FUNCTION__, *_prisrvrport);
            }
        }
    }

    /* If the secsrvrport is not equal to current port in DB */
    if (_secsrvrport && (*_secsrvrport != dbRadiusCfg.secRadiusSrvrPort))
    {
        if (tl1UpdateRadiusPortIPfilterNtfy(dbRadiusCfg.secRadiusSrvrPort,
                                            IPFILTER_NAME_RADIUS_SEC,
                                            IPFILTER_NTFY_TYPE_DELETE) == SUCCESS)
        {
            if (tl1UpdateRadiusPortIPfilterNtfy(*_secsrvrport,
                                                IPFILTER_NAME_RADIUS_SEC,
                                                IPFILTER_NTFY_TYPE_ADD) != SUCCESS)
            {
                procLogMsg(PLOG_ERROR, __FUNCTION__, 
                           "%s: Radius Port [%d] verification - IPFILTER notification failure.\n",
                            __FUNCTION__, *_secsrvrport);
            }
        }
    }
    
    return tc_compld_comment( handle, ctag, "ED-RADIUS-SYS" );

#else /* ifdef ATCA */
    return tc_compld_comment( handle, ctag, "ED-RADIUS-SYS" );
#endif
}

/**
 * Edit  RULE IPFLTR
 */
eosl_bool agc_EM_NE_ED_RULE_IPFLTR_req( const char * modifier,\
                                        eosl_handle handle,\
                                        TL1_TAG ctag ,\
                                        TL1_AID _ruleId,\
                                        TL1_AID _srcIp,\
                                        char * _srcPortStart,\
                                        char * _srcPortEnd,\
                                        TL1_AID _destIp,\
                                        char * _destPortStart,\
                                        char * _destPortEnd,\
                                        char * _ipHdrPrtcl,\
                                        AppType_ENUM * _app,\
                                        RuleType_ENUM * _ruleType,\
                                        int * _rank,\
                                        IPVersion_ENUM * _IPVersion,\
                                        PrimaryStateIn_ENUM * _pst)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    s16            retVal;
    SMCMD_t        smCmd;
    short          length;
    int            colCnt = 0;
    char           sp[RULE_IPFLTR_SPLEN_MAX+1];
    int            ruleNum;
    int            spEnum;
    char           *ipToken    = NULL;
    char           *mskToken   = NULL;
    ip_addr_t      ip;
    char           errMsg[TL1_IPMSG_MAX_MSG_LEN];
    int            errCode;
    int            ipFormats;
    int            ipValidation = 0;
    char           srcIpAddr[INET6_ADDRSTRLEN];
    char           dstIpAddr[INET6_ADDRSTRLEN];
    length         = sizeof(SMCMD_t);
    transId        = ctag;
    tableId        = RULE_IPFLTR_TAB_ID;
    int            cardType    = RULE_IPFLTR_CARDTYPE_UNK;     

#ifdef ATCA
    if(parseATCAIpFilterAid(_ruleId, &cardType,&sp[0], &ruleNum, &spEnum,AID_IPFLTR_FULL) != SUCCESS)
    {
	tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
	return eosl_false;
    }
#else    
    if(parseIpFilterAid(_ruleId, &sp[0], &ruleNum, &spEnum,
			AID_IPFLTR_FULL) != SUCCESS)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
        return eosl_false;
    }
    if(
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_MGT]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGC]) == 0) ||
        (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGD]) == 0)
    )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCM;
    }
    else if ((strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGA]) == 0) ||
             (strcmp(sp, RuleIpFltr_sp_vals[RULE_IPFLTR_SP_SIGB]) == 0)
            )
    {
        cardType = RULE_IPFLTR_CARDTYPE_SCS;
    }
    else 
    {
        cardType = RULE_IPFLTR_CARDTYPE_ALL;
    }

#endif
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal = cardType;	
    rowKey.rowIndex[1].colType = TSSMI_OCTET_STRING;
    rowKey.rowIndex[1].value.stringVal.ptr = sp;
    rowKey.rowIndex[1].value.stringVal.len = strlen(sp);
    rowKey.rowIndex[2].colType = TSSMI_LONG;
    rowKey.rowIndex[2].value.longVal = ruleNum;
    rowKey.numIndices = 3;
    
    columns[colCnt].columnId = RULE_IPFLTR_COL_SP_ENUM;
    columns[colCnt].value.colType = TSSMI_LONG;
    columns[colCnt].value.value.longVal = spEnum;
    colCnt++;
    
    if(_srcIp)
    {
        /* If NULL was explicitly specified for the IP or IP/mask */
        if((eosl_strcasecmp(_srcIp, "NULL"     ) == 0) ||
           (eosl_strcasecmp(_srcIp, "NULL-NULL") == 0))
        {
            columns[colCnt].columnId       = RULE_IPFLTR_COL_SRC_IPADDR;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
            
            columns[colCnt].columnId       = RULE_IPFLTR_COL_SRC_NETMASK;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            /* If the _srcIp was NOT successfully split into an IP and mask token */
            if ((splitToken(_srcIp, &ipToken, &mskToken, 1, SPLIT_L2R) == FAIL)
		|| (ipToken  == NULL)
		|| (mskToken == NULL))
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ED_RULE_IPFLTR_req",
                            "agc_EM_NE_ED_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _srcIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid srcIp");
                return eosl_false;
            }

            /* Set allowed IP versions and validation tests to perform */
            ipFormats  = TL1_IPFMT_IPV4;
#ifdef ATCA
            ipFormats |= TL1_IPFMT_IPV6;
#endif
            /* If IP token is invalid */
            if ((errCode = tl1ValidateIP(ipToken,
                                         srcIpAddr,
                                         ipFormats,
                                         ipValidation,
                                         NULL,
                                         &ip)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "srcIp", errMsg));
                return eosl_false;
            }

#ifndef ATCA
            /* If the specified mask is invalid */
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > 32))
#else
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > (IS_IPV6(ip) ? 128 : 32)))
#endif
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ED_RULE_IPFLTR_req",
                            "agc_EM_NE_ED_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _srcIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid mask in srcIp");
                return eosl_false;
            }
            
            columns[colCnt].columnId                  = RULE_IPFLTR_COL_SRC_IPADDR;
            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(srcIpAddr);
            columns[colCnt].value.value.stringVal.ptr = srcIpAddr;
            colCnt++;

            columns[colCnt].columnId            = RULE_IPFLTR_COL_SRC_NETMASK;
            columns[colCnt].value.colType       = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(mskToken);
            colCnt++;
        }
    }
    if(_srcPortStart)
    {       
        if(eosl_strcasecmp(_srcPortStart, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_START;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_srcPortStart,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid srcPortStart");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_START;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_srcPortStart);
            colCnt++;
        }
    }
    if(_srcPortEnd)
    {       
        if(eosl_strcasecmp(_srcPortEnd, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_END;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_srcPortEnd,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid srcPortEnd");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_SRCPORT_END;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_srcPortEnd);
            colCnt++;
        }
    }
    if(_destIp)
    {
        /* If NULL was explicitly specified for the IP or IP/mask */
        if((eosl_strcasecmp(_destIp, "NULL"     ) == 0) ||
           (eosl_strcasecmp(_destIp, "NULL-NULL") == 0))
        {
            columns[colCnt].columnId       = RULE_IPFLTR_COL_DEST_IPADDR;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
            
            columns[colCnt].columnId       = RULE_IPFLTR_COL_DEST_NETMASK;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            /* If the _destIp was NOT successfully split into an IP and mask token */
            if ((splitToken(_destIp, &ipToken, &mskToken, 1, SPLIT_L2R) == FAIL)
		|| (ipToken  == NULL)
		|| (mskToken == NULL))
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ED_RULE_IPFLTR_req",
                            "agc_EM_NE_ED_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _destIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid destIp");
                return eosl_false;
            }

            /* Set allowed IP versions and validation tests to perform */
            ipFormats  = TL1_IPFMT_IPV4;
#ifdef ATCA
            ipFormats |= TL1_IPFMT_IPV6;
#endif
            /* If IP token is invalid */
            if ((errCode = tl1ValidateIP(ipToken,
                                         dstIpAddr,
                                         ipFormats,
                                         ipValidation,
                                         NULL,
                                         &ip)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "destIp", errMsg));
                return eosl_false;
            }

#ifndef ATCA
            /* If the specified mask is invalid */
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > 32))
#else
            if ((IsInputStrInRange(mskToken,"0123456789") == 0) ||
                (atoi(mskToken) < 1)                            ||
                (atoi(mskToken) > (IS_IPV6(ip) ? 128 : 32)))
#endif
            {
                procLogMsg (PLOG_ERROR,
                            "agc_EM_NE_ED_RULE_IPFLTR_req",
                            "agc_EM_NE_ED_RULE_IPFLTR_req: Invalid AID format %s\n",
                            _destIp);
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid mask in destIp");
                return eosl_false;
            }
            
            columns[colCnt].columnId                  = RULE_IPFLTR_COL_DEST_IPADDR;
            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(dstIpAddr);
            columns[colCnt].value.value.stringVal.ptr = dstIpAddr;
            colCnt++;

            columns[colCnt].columnId            = RULE_IPFLTR_COL_DEST_NETMASK;
            columns[colCnt].value.colType       = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(mskToken);
            colCnt++;
        }
    }
    if(_destPortStart)
    {       
        if(eosl_strcasecmp(_destPortStart, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_START;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_destPortStart,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid destPortStart");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_START;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_destPortStart);
            colCnt++;
        }
    }
    if(_destPortEnd)
    {       
        if(eosl_strcasecmp(_destPortEnd, "NULL") == 0)
        {
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_END;
            columns[colCnt].value.colType  = TSSMI_RESET;
            colCnt++;
        }
        else
        {
            if(!IsInputStrInRange(_destPortEnd,"0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, 
                                  "Input, Invalid destPortEnd");
                return eosl_false;
            }
            columns[colCnt].columnId = RULE_IPFLTR_COL_DESTPORT_END;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = atoi(_destPortEnd);
            colCnt++;
        }
    }
    if(_ipHdrPrtcl)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_IPHDR_PRTCL;
        if(strlen(_ipHdrPrtcl) > RULE_IPFLTR_IPHDRPRTCLLEN_MAX)
        {
            tc_error_response(handle, ctag, TE_IIDT,
                              "Input, Invalid Input -> ipHdrPrtcl");
            return eosl_false;
        }

        /* if it's NULL, that's valid */
        if (!eosl_strcasecmp(_ipHdrPrtcl,"NULL"))
        {
            columns[colCnt].value.colType = TSSMI_RESET;
        }        

        else
        {
            /* validate integer string input */
            if(IsInputStrInRange(_ipHdrPrtcl, "0123456789"))
            {
                int val = atoi(_ipHdrPrtcl);

                if (val < IPPROTO_IP || val >= IPPROTO_MAX)
                {
                    tc_error_response(handle, ctag, TE_IIDT,
                                      "Input, Invalid Input -> ipHdrPrtcl");
                    return eosl_false;
                }
            }

            /* validate any other string input */
            else
            {
                int ival = ruleIpFltr_ipHdrPrtcl2enum(_ipHdrPrtcl);

                if (ival <= RULE_IPFLTR_IHP_MIN || ival >= RULE_IPFLTR_IHP_MAX)
                {
                    tc_error_response(handle, ctag, TE_IIDT,
                                      "Input, Invalid Input -> ipHdrPrtcl");
                    return eosl_false;
                }

                /* must fit, since validator matched the string */
                strcpy(_ipHdrPrtcl, RuleIpFltr_ipHdrPrtcl_vals[ival]);
            }

            columns[colCnt].value.colType             = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(_ipHdrPrtcl);
            columns[colCnt].value.value.stringVal.ptr = _ipHdrPrtcl;
        }

        colCnt++;
    }
    if(_app)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_APP;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_app)
        {
          case AppType_NONE:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_APP_NONE;
              break;
          default:
                tc_error_response(handle, ctag, TE_IIDT,
                                  "Input, Invalid app. Only NONE is "
                                  "supported for user defined rules");
                return eosl_false;
              break;
        }
        colCnt++;
    }       
#if 0
    if(_src)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_SRC;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_src)
        {
          case SrcType_PROTOCOL:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_PROTOCOL;
              break;
          case SrcType_SYSTEM:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_SYSTEM;
              break;
          case SrcType_USER:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_SRC_USER;
              break;
          default:
              break;
        }
        colCnt++;
    }
#endif
    if(_ruleType)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_RULE_TYPE;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_ruleType)
        {
          case RuleType_BLOCK:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_RULETYPE_BLOCK;
              break;
          case RuleType_PASS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_RULETYPE_PASS;
              break;
          default:
	      tc_error_response(handle, ctag, TE_IIDT,
			        "Input, Invalid ruleType");
	      return eosl_false;
              break;
        }
#ifdef ATCA
	if (*_ruleType == RuleType_POLICE)
	{
	    tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid ruleType -> POLICE not supported in ATCA");
	    return eosl_false;
	}
#endif
        colCnt++;
    }

    if(_rank)
    {
        if((*_rank < RULE_IPFLTR_USERRANK_MIN) || (*_rank > RULE_IPFLTR_USERRANK_MAX))
        {
	      tc_error_response(handle, ctag, TE_IIDT,
			      "Input, Invalid rank");
	      return eosl_false;
        }

        columns[colCnt].columnId = RULE_IPFLTR_COL_RANK;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_rank;
        colCnt++;
    }                               
#if 1  /* FID 14341.0 - enable this code when platform is ready for this parameter */
    if(_IPVersion)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_IPVERSION;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_IPVersion)
        {
            case IPVersion_BOTH:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_BOTH;
                break;

            case IPVersion_IPV4:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_V4;
                break;

            case IPVersion_IPV6:
                columns[colCnt].value.value.longVal = RULE_IPFLTR_IPVERSION_V6;
                break;

            default:
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid IPVersion");
                break;
        }

        colCnt++;
    }
#endif
    if(_pst)
    {
        columns[colCnt].columnId = RULE_IPFLTR_COL_PST;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch (*_pst) 
        {
          case PrimaryStateIn_IS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_PST_IS;
              break;
          case PrimaryStateIn_OOS:
              columns[colCnt].value.value.longVal = RULE_IPFLTR_PST_OOS;
              break;
          default:
              break;
        }
        colCnt++;
    }
    colArray.numCols  = colCnt;
    colArray.colArray = columns;
    
    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_RULE_IPFLTR", "ED-RULE-IPFLTR - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    
    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    if( retVal == TRUE)
    {
        return tc_compld_comment( handle, ctag, "ED-RULE-IPFLTR" );
    }
    /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 * Retrieve  Threshold IPATK
 */
eosl_bool agc_EM_NE_RTRV_TH_IPATK_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _pmId,\
									pmIpAtkMonType_ENUM * _montype,\
									pmNotApplicable_ENUM * _locn,\
									pmNotApplicable_ENUM * _dirn,\
									pmNotApplicable_ENUM * _tmper)
{
    int i,count = 0; 
    RTRV_TH_IPATK_resp_row result[MAX_NUM_IPATK_MONTYPE];  
    TL1_EMF_IPATK_DATA_t buffer;  
    EMF_TL1_IPATK_t resp;

    memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
    memset(&resp, 0, sizeof(EMF_TL1_IPATK_t));
    memset(result, 0, sizeof(result));

    if ((_pmId != NULL) && (eosl_strcasecmp(_pmId, "COM") !=0 ))
    {
	    tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
	    return eosl_false;
    }
    
    if(_montype)
    {
	   buffer.Data.RtrvTres.MonType = mapTL1TsmcIpAtkMonType(*_montype);
	   if(buffer.Data.RtrvTres.MonType == IPATK_ALL_MONTYPES)
      {
         count = MAX_NUM_IPATK_MONTYPE;
      }
      else
      {
         count = 1;
      }
    }
    else
    {
	    buffer.Data.RtrvTres.MonType = IPATK_ALL_MONTYPES;
	    count = MAX_NUM_IPATK_MONTYPE;
    }
    /*
    ** Send event
    */
    if (TL1SendMsg(handle, ctag,
	           TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT, 
		   CMD_RTRV_IPATK_TH,
		   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_RTRV_TH_IPATK, 
		   (TL1_CMD_BUF_t *)&resp, sizeof(EMF_TL1_IPATK_t),
		   TL1_MSG_TIMEOUT) == FAIL)
    {
	    procLogMsg(PLOG_ERROR,
			    "agc_EM_NE_RTRV_TH_IPATK_req",
			    "agc_EM_NE_RTRV_TH_IPATK_req: bad response \n");
	    TL1ErrorResp(handle, ctag, CMD_EQM, resp.Tl1Cmd.Error);
	    return eosl_false;
    }

    for ( i = 0 ;i < count ; i++)
    {
	    result[i]._pmId = "COM";
	    result[i]._montype = mapTsmcTL1IpAtkMonType(resp.Data.Thresholds[i].MonType);
	    result[i]._thlev =  resp.Data.Thresholds[i].AlarmThreshold;
    }
    return agc_EM_NE_RTRV_TH_IPATK_resp(modifier,
                                            handle,
                                            ctag,
                                            TCC_COMPLD,
                                            result,
                                            count,
                                            "RTRV-TH-IPATK",
                                            NULL);

}

/**
 */
eosl_bool agc_EM_NE_ED_SCCP_SSN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sccpSsnAid, SccpSsnStartup_ENUM *_startMode, nind_ENUM * _nind)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   s16            retVal;
   SMCMD_t        smCmd;
   short          length;
   int            colCnt = 0;
   int            pc;
   int            ssn;
   int            status;
   PointCodeFormat pcFormat = PC_INVALID;
#ifdef ATCA
    char PC_TOKEN[] = "DPC";
    char commonStr[PCKEYMAXLEN];
    char *p_commonStr=commonStr;
    int netId;
#else
    char *p_commonStr;
#endif

   length         = sizeof(SMCMD_t);
   transId        = ctag;
   tableId        = SCCPSSN_TAB_ID;

   /* AID string format, LGP: <pc>-<ssn> */
   /* AID string format, ATCA: <netId>-DPC-<pc>-<ssn> */

#ifndef ATCA
    p_commonStr = _sccpSsnAid;
#else
    if (ParseNetIdKey((char *)_sccpSsnAid, PC_TOKEN, &netId, &p_commonStr) != eosl_true)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
    }
#endif

   status = convertSccpSsnAid(p_commonStr, &pc, &pcFormat, &ssn);
   if(status == -1)
   {
        tc_error_response(handle, ctag, TE_IIDT, "Input, AID Invalid");
        return eosl_false;
   }
   rowKey.rowIndex[SCCPSSN_PC].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_PC].value.longVal = pc;
   rowKey.rowIndex[SCCPSSN_PCFORMAT].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_PCFORMAT].value.longVal = pcFormat;
   rowKey.rowIndex[SCCPSSN_SSN].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_SSN].value.longVal = ssn;
#ifndef ATCA
   rowKey.numIndices = 3;
#else
   rowKey.rowIndex[SCCPSSN_NETID].colType = TSSMI_LONG;
   rowKey.rowIndex[SCCPSSN_NETID].value.longVal = netId;
   rowKey.numIndices = 4;
#endif

   if(_startMode)
   {
      columns[colCnt].columnId = SCCPSSN_STARTUP;
      columns[colCnt].value.colType = TSSMI_LONG;
      columns[colCnt].value.value.longVal = MAPTL1TSMCSccpSsnSt[*_startMode];
      colCnt++;
   }
   if(_nind)
   {
        columns[colCnt].columnId = SCCPSSN_NIND;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = *_nind;
        colCnt++;

   }
 

   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
       procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_SCCP_SSN_req", "ENT-SCCP-SSN - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
   }

   retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                           handle,
                           transId,
                           tableId,
                           &rowKey,
                           &colArray,
                           &smCmd,
                           TL1_MSG_TIMEOUT);
   if( retVal == TRUE)
   {
       return tc_compld_comment( handle, ctag, "ED-SCCP-SSN" );
   }
   /* Now report the TSM error to the operator */
    TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
    return eosl_false;
}

/**
 * Edit  SSH
 */
eosl_bool agc_EM_NE_ED_SSH_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _sshId,\
									SshVersion_ENUM _version)
{
    TL1_BUF_t         buffer;

    memset(&buffer, -1, sizeof(TL1_BUF_t));

    if(_sshId)
    {
        if (eosl_strncasecmp(_sshId, "CLIENT", strlen("CLIENT") + 1) == 0)
        {
            buffer.CmdInfo.EdSSH.SshId = 0;
        }
        else if(eosl_strncasecmp(_sshId, "SERVER", strlen("SERVER") + 1) == 0)
        {
            buffer.CmdInfo.EdSSH.SshId = 1;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
	    return eosl_false;
        }
    }

    if(_version >= 0 && _version <= 2)
    {
        buffer.CmdInfo.EdSSH.Version.value = _version + 1;
        buffer.CmdInfo.EdSSH.Version.valid = VALID_VALUE;
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIDT, "Invalid Version");
	return eosl_false;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_SSH,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_EQMCMD_ED_SSH,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, buffer.Buf.Error );
        return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "ED-SSH" );
}

/**
 * Use the SET-SID command to set the Network Element's system identification
 * code. The system_id_code parameter specifies the identification code.
 * It is recommended the system_id_code be set to the CLLI code.
 *
 * This command is based on specifications in Bellcore's document, TR-NWT-199.
 */
eosl_bool agc_EM_NE_SET_SID_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _sid)
{
    TL1_CMD_MSG_t cmdBuffer;

    /* Feature: 6.2.1 - 2151 */
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey; 
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    SMCMD_t        smCmd;  
    int            cmd=SM_ED_REQUEST;
    int            colCnt = 0, retVal = 0;

    memset(&cmdBuffer,0x0,sizeof(cmdBuffer));

    if ((strlen(_sid) < 1) || (strlen(_sid) > MAX_TID_LEN))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Invalid SID length. Length must be 20 characters or less" );
        return eosl_false;
    }
    /*BUG:35143*/
    if(!IsInputStrInRange(_sid,ValidAlphaNumCharList))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    /*BUG:35143*/
    if(!IsInputStrInRange(_sid,ValidAlphaNumCharList))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

#if 0  /*bug 60885  */
    
    if (setTidInDb(_sid) != eosl_true)
    {
        return eosl_false;
    }

    cmdBuffer.Header.SessionHandle = handle;
    cmdBuffer.Header.CTag          = ctag;

   
    strcpy(cmdBuffer.Data.SetSid.sId,_sid);
    /* Dispatch the request message to the peer (standby) SP */
    if (TL1SendMsg(handle, ctag,
                   TL1_PEER_CLASS, TL1_SETSID, TL1CMD_SETSID,
                   (TL1_CMD_BUF_t *)&cmdBuffer, sizeof(TL1_CMD_MSG_t),
                   (TL1_CMD_BUF_t *)&cmdBuffer, sizeof(TL1_CMD_MSG_t),
                   2) != FAIL)
    {
    }

    tc_set_tid(handle, ctag, _sid);
#endif  /* bug 60885 */
    
    /* Feature 2151 - 6.2.1 */
    /* Set up row and send to LM */
    tableId = TELICA_TABLE_SID;;
    transId = ctag;

    rowKey.numIndices = 0;
    colArray.colArray = columns;

    columns[colCnt].columnId = SID_SYSTEMID;;
    columns[colCnt].value.colType = TSSMI_OCTET_STRING;
    columns[colCnt].value.value.stringVal.ptr = _sid;
    columns[colCnt].value.value.stringVal.len = strlen(_sid);
    colCnt++;

    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_SET_SID_req",
                "SET-SID - Too many columns for array\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    procLogMsg(PLOG_INFO, "agc_EM_NE_SET_SID_req",
            "Sending SET_SID with %s to LM\n", _sid);
    retVal = emfPkSmiSetReq(cmd, handle,
                            transId, tableId,
                            &rowKey, &colArray,
                            &smCmd, TL1_MSG_TIMEOUT);
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        /* bug 60885 { */
        if (setTidInDb(_sid) != eosl_true)
        {
            return eosl_false;
        }

        cmdBuffer.Header.SessionHandle = handle;
        cmdBuffer.Header.CTag          = ctag;

   
        strcpy(cmdBuffer.Data.SetSid.sId,_sid);
        /* Dispatch the request message to the peer (standby) SP */
        if (TL1SendMsg(handle, ctag,
                       TL1_PEER_CLASS, TL1_SETSID, TL1CMD_SETSID,
                       (TL1_CMD_BUF_t *)&cmdBuffer, sizeof(TL1_CMD_MSG_t),
                       (TL1_CMD_BUF_t *)&cmdBuffer, sizeof(TL1_CMD_MSG_t),
                       2) != FAIL)
        {
        }
        
        tc_set_tid(handle, ctag, _sid);
        /* bug 60885 } */
#if 0
       return tc_compld_comment( handle, ctag, "SET-SID");
#endif
    }

    return eosl_true;
}


/**
 */
eosl_bool agc_EM_NE_ED_SLK_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _ss7LnkId,\
									int * _slc,\
									TL1_AID _mtp2PrflId,\
									TL1_AID _mtp3PrflId,\
									int * _congLvl1,\
									int * _congLvl2,\
									int * _congLvl3,\
									BoolYN_ENUM * _enableMtp3T31,\
									BoolYN_ENUM * _resetMtp3T31)


{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char           lnkXchr=0;
    char           mtp2Xchr=0;
    char           mtp3Xchr=0;
    int            lnkId;
    int            mtp2Prfl;
    int            mtp3Prfl;
    int            colnCnt=0;
    int            cmd=SM_ED_REQUEST;
    int            i;



    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_ss7LnkId, "%d%c", &lnkId, &lnkXchr);
    if ((i != 1) || (lnkId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> lnkId" );
        return eosl_false;
    }

    tableId = MTPLNK_TAB_ID;
    transId = ctag;

    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=lnkId;


    if (_mtp2PrflId)
    {
        columns[colnCnt].columnId = MTPLNK_LY2PRFL;
        columns[colnCnt].value.colType =TSSMI_LONG;
        i = sscanf(_mtp2PrflId, "%d%c", &mtp2Prfl, &mtp2Xchr);
        if ((i != 1) || (mtp2Prfl < 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Access Identifier-> mtp2PrflId" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =mtp2Prfl;
        colnCnt++;
    }

    if (_slc)
    {
        if (*_slc < 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid slc" );
            return eosl_false;
        }
        columns[colnCnt].columnId = MTPLNK_TSTSLC;
        columns[colnCnt].value.colType = TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_slc;
        colnCnt++;
    }
    if (_mtp3PrflId)
    {
        columns[colnCnt].columnId = MTPLNK_LY3PRFL;
        columns[colnCnt].value.colType =TSSMI_LONG;
        i = sscanf(_mtp3PrflId, "%d%c", &mtp3Prfl, &mtp3Xchr);
        if ((i != 1) || (mtp3Prfl < 0))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Access Identifier-> mtp3PrflId" );
            return eosl_false;
        }
        columns[colnCnt].value.value.longVal =mtp3Prfl;
        colnCnt++;
    }


    if(_congLvl1)
    {
        if (*_congLvl1< 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid congLvl1" );
            return eosl_false;
        }
        columns[colnCnt].columnId = MTPLNK_P1QLEN;
        columns[colnCnt].value.colType =TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_congLvl1;
        colnCnt++;
    }

    if(_congLvl2)
    {
        if (*_congLvl2< 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid congLvl2" );
            return eosl_false;
        }
        columns[colnCnt].columnId = MTPLNK_P2QLEN;
        columns[colnCnt].value.colType =TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_congLvl2;
        colnCnt++;
    }

    if(_congLvl3)
    {
        if (*_congLvl3< 0)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid congLvl3" );
            return eosl_false;
        }
        columns[colnCnt].columnId = MTPLNK_P3QLEN;
        columns[colnCnt].value.colType =TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_congLvl3;
        colnCnt++;
    }
    if(_enableMtp3T31)
    {
        columns[colnCnt].columnId = MTPLNK_MTP3T35ENB;
        columns[colnCnt].value.colType =TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_enableMtp3T31;
        colnCnt++;
    }
    if(_resetMtp3T31)
    {
        columns[colnCnt].columnId = MTPLNK_MTP3T35RST;
        columns[colnCnt].value.colType =TSSMI_LONG;
        columns[colnCnt].value.value.longVal =*_resetMtp3T31;
        colnCnt++;
    }
    colArray.colArray = columns;
    colArray.numCols  = colnCnt;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_SLK_req", "ED_SLK - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }
    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-SLK" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ED_STATE_ISDNBCHAN_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _isdnChanId, int _endChanNum, IsdnChanAction_ENUM _chanAction)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            cmd=SM_ED_REQUEST;
    int            numHyphens;
    int            *  intPtr;
    int            colnCnt=0;


    memset(&smCmd,0x0,sizeof(SMCMD_t));
    intPtr=aidStringToInts(_isdnChanId ,&numHyphens );
    if (intPtr== NULL  || (numHyphens != 2) )
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    tableId = ISDNBCHAN_TAB_ID;
    transId = ctag;

    rowKey.numIndices = 2;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=intPtr[0]; /* ifNumber */

    rowKey.rowIndex[1].colType = TSSMI_LONG;
    rowKey.rowIndex[1].value.longVal=intPtr[1]; /* Link num */

    /* _startChanNum == intPtr[2] */
    if (intPtr[2]  < 0)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid statChanNum" );
        return eosl_false;
    }
    /*columns[colnCnt].columnId = ISDNBCHAN_START_CHAN_NMB;*/
    columns[colnCnt].value.colType =TSSMI_LONG ;
    columns[colnCnt].value.value.longVal = intPtr[2];
    colnCnt++;

    if (_endChanNum < 0)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid endChanNum" );
        return eosl_false;
    }
    /*columns[colnCnt].columnId = ISDNBCHAN_END_CHAN_NMB;*/
    columns[colnCnt].value.colType =TSSMI_LONG ;
    columns[colnCnt].value.value.longVal =_endChanNum;
    colnCnt++;

    /*columns[colnCnt].columnId = ISDNBCHAN_ACTION;*/
    columns[colnCnt].value.colType =TSSMI_LONG;
    switch (_chanAction)
    {
    case IsdnChanAction_CHANFORCE_DIS:
        columns[colnCnt].value.value.longVal = TS_CHANFORCE_DISABLE;
        break;

    case IsdnChanAction_CHAN_ENB:
        columns[colnCnt].value.value.longVal = TS_CHANENABLE;
        break;

    case IsdnChanAction_CHAN_RESET:
    default:
        columns[colnCnt].value.value.longVal = TS_CHANRESET;
        break;
    }
    colnCnt++;

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_ISDNBCHAN_req", "ED_STATE_ISDNBC- TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-ISDNBCHAN" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ED_STATE_ISDNIF_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _isdnIfId, PrimaryStateIn_ENUM _primaryStateIn)
{


    tc_error_response( handle, ctag, TE_IICM, "Command Not Supported" );
    return eosl_false;

}


/**
 */
eosl_bool agc_EM_NE_ED_STATE_LSET_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _lsetId, PrimaryStateIn_ENUM _pst)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            pst;
    int            lsetId;
    int            cmd=SM_ED_REQUEST;
    int            colnCnt=0;
    int       i;


    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_lsetId, "%d%c", &lsetId, &xchr);
    if ((i != 1) || (lsetId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> lsetId" );
        return eosl_false;
    }

    tableId = MTPLSET_EDSTA_TAB_ID;
    transId = ctag;

    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=lsetId;

    columns[colnCnt].columnId = MTPLSET_ROWSTAT;
    columns[colnCnt].value.colType =TSSMI_LONG ;

    if(_pst ==PrimaryStateIn_IS)
    {
        pst=PLM_LSETACTIVATE;
    }
    else
    {
        pst=PLM_LSETDEACTIVATE;
    }

    columns[colnCnt].value.value.longVal =pst;
    colnCnt++;

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_LSET_req", "ED_STATE_LSET- TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-LSET" );
    }
}

/**
 * Edit  STATE SGP
 */
eosl_bool agc_EM_NE_ED_STATE_SGP_req( const char * modifier,\
                                                                      eosl_handle handle,\
                                                                       TL1_TAG ctag ,\
                                                                      TL1_AID _sgAssocId,\
                                                                      sgpState_ENUM _pst)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    SMCMD_t        smCmd;
    int            sgAssocId;
    int            colnCnt=0;

    tableId = MGC_STATESGP_TAB_ID;
    transId = ctag;

    TL1LOGP(PLOG_INFO, "agc_EM_NE_ED_STATE_SGP_req() entered\n");
    memset(&smCmd,0x0,sizeof(SMCMD_t));
    if (_sgAssocId)
    {
        if (IsInputStrInRange(_sgAssocId, "0123456789"))
        {
	    sgAssocId = atoi(_sgAssocId);
            TL1LOGP(PLOG_INFO, "ED_STATE_SGP, sgAssocId = %d\n", sgAssocId);
#ifdef ATCA
        if ((sgAssocId >= 1) && (sgAssocId <= 128))
#else
        if ((sgAssocId >= 1) && (sgAssocId <= 64))
#endif
	    {
                rowKey.rowIndex[0].colType = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal = sgAssocId;
	    }
	    else
	    {
                tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid sgAssocId");
	        return eosl_false;
	    }
	}
	else
	{
            tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid sgAssocId");
	    return eosl_false;
	}
    }
    else
    {
        tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid sgAssocId");
	return eosl_false;
    }

    rowKey.numIndices = 1;

    TL1LOGP(PLOG_INFO, "ED_STATE_SGP, pst = %d\n", _pst);
    columns[colnCnt].columnId = MGC_STATESGP_PST;
    columns[colnCnt].value.colType =TSSMI_LONG ;
    switch(_pst)
    {
        case sgpState_IS:
	    columns[colnCnt].value.value.longVal = SGP_IS;
	    break;

	case sgpState_OOS:
	    columns[colnCnt].value.value.longVal = SCTP_SGP_OOS;
	    break;

	default:
        tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid pst");
	return eosl_false;
	    break;
    }
    TL1LOGP(PLOG_INFO, "ED_STATE_SGP, PST = %d\n", columns[colnCnt].value.value.longVal);
    colnCnt++;

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_SGP_req", "ED_STATE_SGP- TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    if ((emfPkSmiSetReq(SM_ED_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT)) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-SGP" );
    }
}

/**
 */
eosl_bool agc_EM_NE_ED_STATE_SGSLK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7LnkId, SlkState_ENUM _pst)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    char           xchr=0;
    int            cmd=SM_ED_REQUEST;
    int            slkId;
    int            state;
    int            colnCnt=0;
    int            i;


    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_ss7LnkId, "%d%c", &slkId, &xchr);
    if ((i != 1) || (slkId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> slkId" );
        return eosl_false;
    }

    tableId = MTP3LNK_EDSTA_TAB_ID;
    transId = ctag;

    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=slkId;

    columns[colnCnt].columnId = MTPLNK_LNKSTATE;
    columns[colnCnt].value.colType =TSSMI_LONG ;

    if(_pst  ==SlkState_IS)
    {
        state=AENA;
    }
    else if ( _pst== SlkState_INH){
        state=AINH;
    }
    else if ( _pst==SlkState_UNINH){
        state=AUNINH;
    }
    else
    {
        state=ADISIMM_L2;
    }

    columns[colnCnt].value.value.longVal =state;
    colnCnt++;

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_SGSLK_req", "ED_STATE_SGSLK -- TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;

    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-SGSLK" );
    }
}


/**
 */
eosl_bool agc_EM_NE_ED_STATE_SLK_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ss7LnkId, SlkState_ENUM _pst)
{

    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey; 
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal; 
    SMCMD_t        smCmd;  
    char           xchr=0; 
    int            cmd=SM_ED_REQUEST;
    int            slkId;  
    int            state;  
    int            colnCnt=0;
    int            i;      


    memset(&smCmd,0x0,sizeof(SMCMD_t));
    i = sscanf(_ss7LnkId, "%d%c", &slkId, &xchr); 
    if ((i != 1) || (slkId < 0))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier-> slkId" );
        return eosl_false;
    }

    tableId = MTPLNK_EDSTA_TAB_ID;
    transId = ctag; 

    rowKey.numIndices =1;
    rowKey.rowIndex[0].colType = TSSMI_LONG;
    rowKey.rowIndex[0].value.longVal=slkId;

    columns[colnCnt].columnId = MTPLNK_LNKSTATE;
    columns[colnCnt].value.colType =TSSMI_LONG ;

    if(_pst  ==SlkState_IS)
    {
        state=AENA;
    }
    else if ( _pst== SlkState_INH){
        state=AINH;
    }
    else if ( _pst==SlkState_UNINH){
        state=AUNINH;
    }
    else    
    {
        state=ADISIMM_L2;
    }

    columns[colnCnt].value.value.longVal =state;
    colnCnt++;

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_ED_STATE_SLK_req", "ED_STATE_SLK -- TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;

    }

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-STATE-SLK" );
    }
}

/**
 */
eosl_bool agc_EM_NE_ED_SYS_SECU_req( const char * modifier,\
                                     eosl_handle handle,\
                                     TL1_TAG ctag ,\
                                     TL1_AID _src,\
                                     int * _maxInv,\
                                     DuralHrMinSec_PATTERNED_ENUM _dural,\
                                     int * _tmout,\
                                     int * _preLoginTimeOut,\
                                     int * _passwdExpAlert,\
                                     char * _passwdChgFreq,\
                                     int * _heartbeat,\
                                     BoolYN_ENUM * _tcpConnEnabled,\
                                     int * _almqPort,\
                                     int * _almqTmo,\
                                     int * _emPort,\
                                     char * _em1Ip,\
                                     char * _em2Ip,\
                                     BoolYN_ENUM * _ipFltrEnabled,\
                                     int * _eventInterval,\
                                     XferPrtclType_ENUM * _xferPrtcl,\
                                     char * _tl1IntrusionPolicy,\
                                     int * _tl1PasswdMaxReuse,\
                                     TL1PasswdComplxType_ENUM * _tl1PasswdComplx,\
                                     BoolYN_ENUM * _osProcessAcct,\
                                     BoolYN_ENUM * _osSecEventLog,\
                                     int * _osSesTmout,\
                                     int * _osMaxInv,\
                                     int * _osPasswdMinLen,\
                                     int * _osPasswdMaxLen,\
                                     int * _osPasswdMaxReuse,\
                                     PwdComplx_ENUM * _osPasswdComplx,\
                                     BoolYN_ENUM * _osRestrictRoot,\
                                     BoolYN_ENUM * _osRestrictConsole,\
                                     int * _osSuAttemptThreshold,\
                                     BoolYN_ENUM * _telnetAccess,\
                                     int * _actTmout,\
                                     int * _inactiveLog,\
                                     int * _passwdMaxCharRepeat,\
                                     int * _passwdMaxCharUid,\
                                     int * _passwdMaxCharPrevPwd,\
                                     int * _passwdMaxCharSeq,\
                                     int * _passwdMinLen,\
                                     int * _passwdMinLowercase,\
                                     int * _passwdMinUppercase,\
                                     int * _passwdMinDgts,\
                                     int * _passwdMinSpecial,\
		                     UserAuthPolicyType_ENUM * _authPolicy)
{
    TsTransId       transId = ctag;
    TsTableId       tableId = SYS_SECU_TAB_ID;
    TsSmiRowKey     rowKey;
    TsSmiColArray   colArray;
    TsSmiColObj     columns[MAX_TSM_COLS];
    SMCMD_t         smCmd;
    int             colCnt = 0;
    
    char    buffer[MAX_GOAHEAD_MSG_SIZE];
    DB_WRITE_t  *p_dbData = (DB_WRITE_t *) &buffer[0];
    DB_COLUMN_t *p_dbEntry = (DB_COLUMN_t *) &p_dbData->Columns[0];
    int     * intPtr;
    int     numHyphens = 2;
    int     dural = 0;
#ifdef ALMQ_SESS_EST
#if ALMQ_UNSUPPORTED
    int     abacklog = 0;
#endif /* ALMQ_UNSUPPORTED */
#endif
    int     rowNum = TL1_DB_CFG_ROW;
    const char *username;
    int     tmp_xferPrtcl = 0; /* FID 14589 */
    int     policy;
    int     passwdComplx;
    int     passwdChgFreq;
    char    unit[8];

#ifndef ATCA
    int     OSValue = 0;
#endif   
    TL1_CMD_MSG_t   cmdBuffer;
    TL1_BUF_t       cmdMsg;
    int             totalRuleLen = 0;

    memset(&cmdBuffer, 0, sizeof(cmdBuffer));
    memset(&cmdMsg, 0, SIZEOF_EQMCMD_ED_SYSSECU);

    rowKey.numIndices = 0;

    if ( (_src != NULL) && (eosl_strcasecmp(_src, "COM") != 0) )
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    strcpy(p_dbData->DBName, TL1_DB_NAME);
    strcpy(p_dbData->TableName, TL1_CFG_TABLE_NAME);
    p_dbData->NumColumns = 0;

    if (_maxInv)
    {
        if ((*_maxInv < 0) || (*_maxInv > 9))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> maxInv." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_MAX_BAD_TRIES_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_maxInv, NULL);
    }

    if (_dural)
    {
        intPtr = aidStringToInts(_dural, &numHyphens );
        if ((intPtr == NULL) || (numHyphens != 2))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> dural." );
            return eosl_false;
        }

        if ( (intPtr[0] < 0) || (intPtr[0] > 99) )
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> dural." );
            return eosl_false;
        }

        if ( (intPtr[1] < 0) || (intPtr[1] > 59) )
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> dural." );
            return eosl_false;
        }

        if ( (intPtr[2] < 0) || (intPtr[2] > 59) )
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> dural." );
            return eosl_false;
        }

        dural = (intPtr[0] * 60 * 60) + (intPtr[1] * 60) + intPtr[2];
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_DURATION_ALERT_COND_COL, rowNum,
                                        DB_DATA_TYPE_INT, dural, NULL);
    }

    if (_tmout)
    {
        if ((*_tmout < 0) || (*_tmout > 99))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> tmout." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_IDLE_SESSION_TIMEOUT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_tmout, NULL);
    }

    if (_preLoginTimeOut)
    {
        if ((*_preLoginTimeOut < 0) || (*_preLoginTimeOut > 99))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> preLoginTimeOut." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PRE_LOGIN_TMOUT, rowNum,
                                        DB_DATA_TYPE_INT, *_preLoginTimeOut, NULL);
    }

    if (_passwdExpAlert)
    {
        if ((*_passwdExpAlert < 0) || (*_passwdExpAlert > 30))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> passwdExpAlert." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PAGE_WARN_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdExpAlert, NULL);
    }

    if (_passwdChgFreq)
    {
        if (strlen(_passwdChgFreq) > 6)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> passwdChgFreq." );
            return eosl_false;
        }
        
        if (sscanf(_passwdChgFreq, "%d-%4s", &passwdChgFreq, unit) == 2)
        {
            if (eosl_strcasecmp(unit, "DAY") == 0)
            {
                if (passwdChgFreq < 1 || passwdChgFreq > 99)
                {
                    tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> passwdChgFreq." );
                    return eosl_false;
                }
                passwdChgFreq = passwdChgFreq * 24;
            }
            else if (eosl_strcasecmp(unit, "HR") == 0)
            {
                if (passwdChgFreq < 0 || passwdChgFreq > 23)
                {
                    tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> passwdChgFreq." );
                    return eosl_false;
                }
            }
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> passwdChgFreq." );
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_PASSWD_CH_FREQ_COL, rowNum,
                                        DB_DATA_TYPE_INT, passwdChgFreq, NULL);
    }

    if (_heartbeat)
    {
        if ((*_heartbeat < 0) || (*_heartbeat > 120))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> heartbeat." );
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_HEARTBEAT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_heartbeat, NULL);
    }

    if (_tcpConnEnabled)
    {
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, TL1_DB_TCP_CONN_ENABLED_COL, rowNum,
                                        DB_DATA_TYPE_INT, (*_tcpConnEnabled == BoolYN_Y) ? 1 : 0, NULL);
    }


#ifdef ALMQ_SESS_EST
    if (_almqPort)
    {
        if (*_almqPort != 2363)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> almqPort." );
            return eosl_false;
        }
        /* and the GoAhead DB copy */
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_ALMQPORT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_almqPort, NULL);
    }

    if (_almqTmo)
    {
        if ((*_almqTmo < 0) || (*_almqTmo > (ALMQTMO_MAXDAYS * 24 * 60)))
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> almqTmo." );  
            return eosl_false;
        }

        /* and the GoAhead DB copy */
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_ALMQTMO_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_almqTmo, NULL);
	kill_All_AlmQSessions_ALARMQUEUEPORT(handle,UserAccessPort_ALARMQUEUEPORT);
    }

#if ALMQ_UNSUPPORTED
    if (_almqBacklog)
    {
        i = sscanf(_almqBacklog, "%d", &abacklog);
        if ((i != 1) || (abacklog < 1) || (abacklog > 2))
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> almqBacklog." );
            return eosl_false;
        }

        /* and the GoAhead DB copy */
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_ALMQBACKLOG_COL, rowNum,
                                        DB_DATA_TYPE_INT, abacklog, NULL);
    }
#endif /* ALMQ_UNSUPPORTED */
#endif /* ALMQ_SESS_EST */

    if(_emPort)
    {
        if (*_emPort != EMSPORT_DEFAULT)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid emPort");
            return eosl_false;
        }


        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_EM_PORT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_emPort, NULL);
    }

    /* If an IP was specified for a primary EM */
    if (_em1Ip)
    {
        columns[colCnt].columnId          = SYS_SECU_COL_EM1IP;
        /* If NULL was explicitly specified */
        if (eosl_strcasecmp(_em1Ip, "NULL") == 0)
        {
            columns[colCnt].value.colType = TSSMI_RESET;
        }
        /* Else if a valid IP was specified */
        else if (ip_a2i(_em1Ip, &columns[colCnt].value.value.longVal) != 0)
        {
            columns[colCnt].value.colType = TSSMI_LONG;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, em1Ip." );
            return eosl_false;
        }
        colCnt++;
    }

    /* If an IP was specified for a secondary EM */
    if (_em2Ip)
    {
        columns[colCnt].columnId          = SYS_SECU_COL_EM2IP;
        /* If NULL was explicitly specified */
        if (eosl_strcasecmp(_em2Ip, "NULL") == 0)
        {
            columns[colCnt].value.colType = TSSMI_RESET;
        }
        /* Else if a valid IP was specified */
        else if (ip_a2i(_em2Ip, &columns[colCnt].value.value.longVal) != 0)
        {
            columns[colCnt].value.colType = TSSMI_LONG;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid IP Address, em2Ip." );
            return eosl_false;
        }
        colCnt++;
    }

    if(_ipFltrEnabled)
    {
        columns[colCnt].columnId      = SYS_SECU_COL_IPFLTRENABLED;
        columns[colCnt].value.colType = TSSMI_LONG;
        switch(*_ipFltrEnabled)
        {
          case BoolYN_N:
              columns[colCnt].value.value.longVal = SYS_SECU_IPFLTR_ENABLED_NO;
              break;
          case BoolYN_Y:
              columns[colCnt].value.value.longVal = SYS_SECU_IPFLTR_ENABLED_YES;
              break;
          default:
              tc_error_response( handle, ctag, TE_IPNV,
                                 "Invalid Parameter for ipFltrEnabled");
              return eosl_false;
              break;
        }
        colCnt++;
    }

    if(_eventInterval)
    {
        if ((*_eventInterval) < 50 || *_eventInterval > 500)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid eventInterval");
            return eosl_false;
        }

        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_EVENT_INTERVAL_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_eventInterval, NULL);
    }

    /* FID 14589: support SFTP Client */
    if (_xferPrtcl)
    {
	    switch (*_xferPrtcl)
        {
           case XferPrtclType_FTP:
              tmp_xferPrtcl = XFERPRTCL_FTP;
              break;
           case XferPrtclType_SFTP:
              tmp_xferPrtcl = XFERPRTCL_SFTP;
              break;
           default:
              tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> xferPrtcl." );
              return eosl_false;
              break;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry, 
                                        TL1_DB_XFERPRTCL_COL, rowNum,
                                        DB_DATA_TYPE_INT, tmp_xferPrtcl, NULL);
    }
	
    if (_tl1IntrusionPolicy)
    {
      if ((policy = parseIntrusionPolicy(_tl1IntrusionPolicy)) == -1)
      {
        tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid TL1IntrusionPolicy");
        return eosl_false;
      }

      p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                      TL1_DB_INTRUSION_POLICY_COL, rowNum,
                                      DB_DATA_TYPE_INT, policy, NULL);
    }

    if (_tl1PasswdMaxReuse)
    {
        if ((*_tl1PasswdMaxReuse < 0) || (*_tl1PasswdMaxReuse > (MAX_OLD_PASSWDS + 1)))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid TL1PasswdMaxReuse");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MAX_REUSE_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_tl1PasswdMaxReuse, NULL);
    }

    if (_tl1PasswdComplx)
    {
      switch (*_tl1PasswdComplx)
      {
        case TL1PasswdComplxType_DEFAULT:
          passwdComplx = PASSWD_COMPLX_DEFAULT;
          break;
        case TL1PasswdComplxType_ENHANCED:
          passwdComplx = PASSWD_COMPLX_ENHANCED;
          break;
      case TL1PasswdComplxType_CUSTOM:
          passwdComplx = PASSWD_COMPLX_CUSTOM;
          break;
        default:
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid TL1PasswdComplx");
            return eosl_false;
      }
      p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                      TL1_DB_PASSWD_COMPLX_COL, rowNum,
                                      DB_DATA_TYPE_INT, passwdComplx, NULL);
    }

    if (_actTmout)
    {
        if ((*_actTmout < 0) || (*_actTmout > 99))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid ActTmout");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_ACT_TMOUT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_actTmout, NULL);
    }

    if (_inactiveLog)
    {
        if ((*_inactiveLog < 1) || (*_inactiveLog > 120))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid InactiveLog");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_INACTIVELOG_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_inactiveLog, NULL);
    }

    if (_passwdMaxCharRepeat)
    {
        if ((*_passwdMaxCharRepeat < 0) || (*_passwdMaxCharRepeat > 3))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMaxCharRepeat");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MAX_CHAR_REPEAT_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMaxCharRepeat, NULL);
    }

    if (_passwdMaxCharUid)
    {
        if ((*_passwdMaxCharUid < 0) || (*_passwdMaxCharUid > 10))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMaxCharUid");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MAX_CHAR_UID_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMaxCharUid, NULL);
    }

    if (_passwdMaxCharPrevPwd)
    {
        if ((*_passwdMaxCharPrevPwd < 0) || (*_passwdMaxCharPrevPwd > 3))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMaxCharPrevPwd");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MAX_CHAR_PREV_PWD_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMaxCharPrevPwd, NULL);
    }

    if (_passwdMaxCharSeq)
    {
        if ((*_passwdMaxCharSeq < 2) || (*_passwdMaxCharSeq > 10))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMaxCharSeq");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MAX_CHAR_SEQ_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMaxCharSeq, NULL);
    }

    if (_passwdMinLen)
    {
        if ((*_passwdMinLen < 6) || (*_passwdMinLen > 20))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMinLen");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MIN_LEN_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMinLen, NULL);
    }

    if (_passwdMinLowercase)
    {
        if ((*_passwdMinLowercase < 0) || (*_passwdMinLowercase > 10))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMinLowercase");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MIN_LOWERCASE_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMinLowercase, NULL);
        totalRuleLen += *_passwdMinLowercase;
    }
    else
    {
        totalRuleLen += getMemPasswdMinLowercase();
    }

    if (_passwdMinUppercase)
    {
        if ((*_passwdMinUppercase < 0) || (*_passwdMinUppercase > 10))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMinUppercase");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MIN_UPPERCASE_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMinUppercase, NULL);
        totalRuleLen += *_passwdMinUppercase;
    }
    else
    {
        totalRuleLen += getMemPasswdMinUppercase();
    }

    if (_passwdMinDgts)
    {
        if ((*_passwdMinDgts < 0) || (*_passwdMinDgts > 5))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMinDgts");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MIN_DGTS_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMinDgts, NULL);
        totalRuleLen += *_passwdMinDgts;
    }
    else
    {
        totalRuleLen += getMemPasswdMinDgts();
    }

    if (_passwdMinSpecial)
    {
        if ((*_passwdMinSpecial < 0) || (*_passwdMinSpecial > 3))
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid PasswdMinSpecial");
            return eosl_false;
        }
        p_dbEntry = tl1DbAddColToStruct(p_dbData, p_dbEntry,
                                        TL1_DB_PASSWD_MIN_SPECIAL_COL, rowNum,
                                        DB_DATA_TYPE_INT, *_passwdMinSpecial, NULL);
        totalRuleLen += *_passwdMinSpecial;
    }
    else
    {
        totalRuleLen += getMemPasswdMinSpecial();
    }

    if (totalRuleLen > MAX_PASSWORD_SIZE)
    {
        tc_error_response(handle, ctag, TE_IIDT, "Input Invalid, "
                          "PasswdMinLowercase + PasswdMinUppercase + PasswdMinDgts + PasswdMinSpecial "
                          "must <= MAX_PASSWORD_SIZE");
        return eosl_false;
    }
    
#ifndef ATCA  
    if(_osProcessAcct)
    {
        switch(*_osProcessAcct)
        {
          case BoolYN_N:
              OSValue = 0;
              break;
          case BoolYN_Y:
              OSValue = 1;
              break;
          default:
              tc_error_response( handle, ctag, TE_IPNV,
                                 "Invalid Parameter for OSProcessAcct");
              return eosl_false;
              break;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsProcessAcct.value = OSValue;
        cmdMsg.CmdInfo.EdSysSecu.OsProcessAcct.valid = VALID_VALUE;
    }
#else
        if (_osProcessAcct && *_osProcessAcct != BoolYN_N)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif 

#ifndef ATCA    
    if(_osSecEventLog)
    {
        switch(*_osSecEventLog)
        {
          case BoolYN_N:
              OSValue = 0;
              break;
          case BoolYN_Y:
              OSValue = 1;
              break;
          default:
              tc_error_response( handle, ctag, TE_IPNV,
                                 "Invalid Parameter for OSSecEventLog");
              return eosl_false;
              break;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsSecEventLog.value = OSValue;
        cmdMsg.CmdInfo.EdSysSecu.OsSecEventLog.valid = VALID_VALUE;
    }
#else
        if (_osSecEventLog && *_osSecEventLog != BoolYN_N)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif 

#ifndef ATCA      
    if(_osSesTmout)
    {
        if (*_osSesTmout < 0 || *_osSesTmout > 99)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSSesTmout");
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsSesTmout.value = *_osSesTmout;
        cmdMsg.CmdInfo.EdSysSecu.OsSesTmout.valid = VALID_VALUE;
    }
#else
        if (_osSesTmout && *_osSesTmout != 0)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif  

#ifndef ATCA      
    if(_osMaxInv)
    {
        if (*_osMaxInv < 0 || *_osMaxInv > 9)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSMaxInv");
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsMaxInv.value = *_osMaxInv;
        cmdMsg.CmdInfo.EdSysSecu.OsMaxInv.valid = VALID_VALUE;
    }
#else
        if (_osMaxInv && *_osMaxInv != 0)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif 

#ifndef ATCA     
    if(_osPasswdMinLen)
    {
        if ((*_osPasswdMinLen < 6 || *_osPasswdMinLen > 64) && *_osPasswdMinLen != 0)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSPasswdMinLen");
            return eosl_false;
        }

        if (_osPasswdMaxLen)
        {
            if (*_osPasswdMinLen > *_osPasswdMaxLen)
            {
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSPasswdMinLen");
                return eosl_false;
            }
        }
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMinLen.value = *_osPasswdMinLen;
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMinLen.valid = VALID_VALUE;
    }
#else
        if (_osPasswdMinLen && *_osPasswdMinLen != 0)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif

#ifndef ATCA 
    if(_osPasswdMaxLen)
    {
        if (*_osPasswdMaxLen < 6 || *_osPasswdMaxLen > 64)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSPasswdMaxLen");
            return eosl_false;
        }

        if (_osPasswdMinLen)
        {
            if (*_osPasswdMinLen > *_osPasswdMaxLen)
            {
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSPasswdMinLen");
                return eosl_false;
            }
        }
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMaxLen.value = *_osPasswdMaxLen;
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMaxLen.valid = VALID_VALUE;
    }
#else
        if (_osPasswdMaxLen && *_osPasswdMaxLen != 0)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif

#ifndef ATCA     
    if(_osPasswdMaxReuse)
    {
        if (*_osPasswdMaxReuse < 0 || *_osPasswdMaxReuse > 6)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OSPasswdMaxReuse");
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMaxReuse.value = *_osPasswdMaxReuse;
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdMaxReuse.valid = VALID_VALUE;
    }
#else
        if (_osPasswdMaxReuse && *_osPasswdMaxReuse != 0)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif

#ifndef ATCA    
    if(_osPasswdComplx)
    {
        switch(*_osPasswdComplx)
        {
        case PwdComplx_DEFAULT:
            OSValue = 0;
            break;
        case PwdComplx_ENHANCED:
            OSValue = 1;
            break;
        default:
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for OSPasswdComplx");
            return eosl_false;
            break;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdComplex.value = OSValue;
        cmdMsg.CmdInfo.EdSysSecu.OsPasswdComplex.valid = VALID_VALUE;
    }
#else
        if (_osPasswdComplx && *_osPasswdComplx != PwdComplx_DEFAULT)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif

#ifndef ATCA    
    if(_osRestrictRoot)
    {
        switch(*_osRestrictRoot)
        {
            case BoolYN_N:
                OSValue = 0;
                break;
            case BoolYN_Y:
                OSValue = 1;
                break;
            default:
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OsRestrictRoot");
                return eosl_false;
                break;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsRestrictRoot.value = OSValue;
        cmdMsg.CmdInfo.EdSysSecu.OsRestrictRoot.valid = VALID_VALUE;
    }
#else
        if (_osRestrictRoot && *_osRestrictRoot != BoolYN_N)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif

#ifndef ATCA    
    if(_osRestrictConsole)
    {
        switch(*_osRestrictConsole)
        {
            case BoolYN_N:
                OSValue = 0;
                break;
            case BoolYN_Y:
                OSValue = 1;
                break;
            default:
                tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OsRestrictConsole");
                return eosl_false;
                break;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsRestrictConsole.value = OSValue;
        cmdMsg.CmdInfo.EdSysSecu.OsRestrictConsole.valid = VALID_VALUE;
    }
#else
        if (_osRestrictConsole && *_osRestrictConsole != BoolYN_N)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Invalid Parameter for ATCA");
            return eosl_false;
        }
#endif


#ifndef ATCA    
    if(_osSuAttemptThreshold)
    {
        if (*_osSuAttemptThreshold < 0 || *_osSuAttemptThreshold > 999)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid OsSuAttemptThreshold");
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdSysSecu.OsSuAttemptThreshold.value = *_osSuAttemptThreshold;
        cmdMsg.CmdInfo.EdSysSecu.OsSuAttemptThreshold.valid = VALID_VALUE;
    }
#else
    if (_osSuAttemptThreshold && *_osSuAttemptThreshold != BoolYN_N)
    {
        tc_error_response( handle, ctag, TE_IPNV,
                           "Invalid Parameter for ATCA");
        return eosl_false;
    }
#endif
    
    /* If parameter telnetAccess was explicitly specified */
    if (_telnetAccess)
    {
        switch(*_telnetAccess)
        {
        case BoolYN_N:
            cmdMsg.CmdInfo.EdSysSecu.TelnetAccess.value = 0;
#if 0
            /* Dispatch the request message to the peer (standby) to terminate remote connections */
            TL1SendPeerEvent(handle,
                             ctag,
                             TL1_TERM_REMOTE_CONNECTIONS,
                             TL1CMD_TERM_REMOTE_CONNECTIONS,
                             &cmdBuffer);

            /* Terminate all remote TL1 telnet connections on the active SP */
            terminateRemoteConnections(handle);
#endif
            break;
        case BoolYN_Y:
            cmdMsg.CmdInfo.EdSysSecu.TelnetAccess.value = 1;
            break;
        default:
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid telnetAccess");
            return eosl_false;
            break;
        }
        cmdMsg.CmdInfo.EdSysSecu.TelnetAccess.valid = VALID_VALUE;
    }

    /* FID 16687.1
       EMF updates "authPolicy" because of dependency check */
    if (_authPolicy)
    {
#ifdef ATCA
        int tmp_authPolicy = 0;
        DB_RADIUS_CFG_t dbRadiusCfg = {0};

        if (getDbRadiusCfg(&dbRadiusCfg) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Not in valid state" );
            return eosl_false;
        }

        switch(*_authPolicy)
        {
        case UserAuthPolicyType_LOCAL:
            tmp_authPolicy = AUTH_POLICY_LOCAL;
            break;
        case UserAuthPolicyType_REMOTE:
            tmp_authPolicy = AUTH_POLICY_REMOTE;
            break;
        case UserAuthPolicyType_USER:
            tmp_authPolicy = AUTH_POLICY_USER;
            break;
        default:
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid AuthPolicy");
            return eosl_false;
            break;
        }

        /* Dependency:  authPolicy can ONLY be set to LOCAL if priSrvr in RADIUS-SYS is NULL */
        if ((tmp_authPolicy != AUTH_POLICY_LOCAL) && (eosl_strcasecmp(dbRadiusCfg.priRadiusSrvr, "NULL") == 0))
        {
            tc_error_response(handle, ctag, TE_IIDT, "authPolicy must be LOCAL for NULL primary RADIUS server");
            return eosl_false;
        }

        cmdMsg.CmdInfo.EdSysSecu.AuthPolicy.value = tmp_authPolicy;
        cmdMsg.CmdInfo.EdSysSecu.AuthPolicy.valid = VALID_VALUE;
#else
        tc_error_response(handle, ctag, TE_IIDT, "authPolicy is not available on LGP");
        return eosl_false;
#endif
    }

#ifndef ATCA 
    if (_osProcessAcct || _osSecEventLog || _osSesTmout || _osMaxInv || _osPasswdMinLen ||
        _osPasswdMaxLen || _osPasswdMaxReuse || _osPasswdComplx || _osRestrictRoot || 
        _osRestrictConsole || _osSuAttemptThreshold || _telnetAccess)
#else
    if (_telnetAccess || _authPolicy)
#endif
    {
        /* Dispatch message to EMF */
        if(TL1SendMsg(handle, ctag,
                      EQM_CMD_CLASS, CMD, EQMCMD_ED_SYSSECU,
                      (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ED_SYSSECU,
                      (TL1_CMD_BUF_t *)&cmdMsg, sizeof(cmdMsg),
                      TL1_MSG_TIMEOUT) == FAIL)
            
        {
            TL1ErrorResp( handle, ctag, CMD_EQM, cmdMsg.Buf.Error );
            return eosl_false;
        }
    }

    if (_telnetAccess && (*_telnetAccess == BoolYN_N))
    {
        /* Dispatch the request message to the peer (standby) to terminate remote connections */
        TL1SendPeerEvent(handle,
                         ctag,
                         TL1_TERM_REMOTE_CONNECTIONS,
                         TL1CMD_TERM_REMOTE_CONNECTIONS,
                         &cmdBuffer);

        /* Terminate all remote TL1 telnet connections on the active SP */
        terminateRemoteConnections(handle);
    }
   
    /* Design note: Update the MySQL database and/or the
     *     TL1 local hapi database if applicable.
     */
    
    /* If the MySQL DB requires an update due to a config change */
    if (colCnt > 0)
    {
	colArray.numCols  = colCnt;
        colArray.colArray = columns;
        
        if (colArray.numCols > MAX_TSM_COLS)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ED_SYS_SECU_req",
                       "agc_EM_NE_ED_SYS_SECU_req - TOO MANY COLUMNS FOR ARRAY!\n");
            tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
            return eosl_false;
        }
        
        if ((emfPkSmiSetReq(SM_ED_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT)) == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
            return eosl_false;
        }
    }
    
    /* If the TL1 local hapi DB requires an update due to a config change */
    if (p_dbData->NumColumns > 0)
    {
        if (sendDbWriteRequest(p_dbData, (unsigned int)p_dbEntry - (unsigned int)buffer) == FAIL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_ED_SYS_SECU_req",
                       "agc_EM_NE_ED_SYS_SECU_req: Failed sendDbWriteRequest\n");
            tc_error_response( handle, ctag, TE_SDBE, "Internal Data Base Error" );
            return eosl_false;
        }
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ED_SYS_SECU_req",
                   "agc_EM_NE_ED_SYS_SECU_req: sendDbWriteRequest done\n");
        
        if (_dural)
        {
            setMemDURAL(dural);
        }
        
        if (_tmout)
        {
            setMemTMOUT(*_tmout);
        }
        
        if (_preLoginTimeOut)
        {
            setMemPreLoginTmOut(*_preLoginTimeOut);
        }
        
        if (_passwdExpAlert)
        {
            setMemPageWarn(*_passwdExpAlert);
        }
        
        if (_passwdChgFreq)
        {
            setMemPasswdChFreq(passwdChgFreq);
        }
        
        if (_heartbeat)
        {
            setMemHeartbeatInterval(*_heartbeat);
        }
        
        if (_tcpConnEnabled)
        {
            setMemTcpConnectionsEnabled((*_tcpConnEnabled == BoolYN_Y) ? 1 : 0);
        }
        
        if (_maxInv)
        {
            setMemMaxBadTries(*_maxInv);
        }
        
        if (_almqPort)
        {
            setMemAlmqPort(*_almqPort);
        }
        
        if (_almqTmo)
        {
            setMemAlmqTmo(*_almqTmo);
        }
        
#if ALMQ_UNSUPPORTED
        if (_almqBacklog)
        {
            setMemAlmqBacklog(abacklog);
        }
        
        if (_emsBacklog)
        {
            setMemEmsBacklog(ebacklog);
        }
#endif /* ALMQ_UNSUPPORTED */

        if(_emPort)
        {
            if (*_emPort == 2362)           
            setMemEmPort(*_emPort);
            else
            tc_error_response( handle, ctag, TE_SROF, "Invalid EmPort");
        }

        if(_eventInterval)
        {
            setMemEventInterval(*_eventInterval);
        }

        /* FID 14589: support SFTP Client */
        if(_xferPrtcl)
        {
            setMemXferPrtcl(tmp_xferPrtcl);
        }

        if (_tl1IntrusionPolicy)
        {
            setMemIntrusionPolicy(policy);
        }
        
        if (_tl1PasswdMaxReuse)
        {
            setMemPasswdMaxReuse(*_tl1PasswdMaxReuse);
        }
        
        if (_tl1PasswdComplx)
        {
            setMemPasswdComplx(passwdComplx);
        }

        if (_actTmout)
        {
            setMemActTmout(*_actTmout);
        }

        if (_inactiveLog)
        {
            setMemInactiveLog(*_inactiveLog);
        }

        if (_passwdMaxCharRepeat)
        {
            setMemPasswdMaxCharRepeat(*_passwdMaxCharRepeat);
        }

        if (_passwdMaxCharUid)
        {
            setMemPasswdMaxCharUid(*_passwdMaxCharUid);
        }

        if (_passwdMaxCharPrevPwd)
        {
            setMemPasswdMaxCharPrevPwd(*_passwdMaxCharPrevPwd);
        }

        if (_passwdMaxCharSeq)
        {
            setMemPasswdMaxCharSeq(*_passwdMaxCharSeq);
        }

        if (_passwdMinLen)
        {
            setMemPasswdMinLen(*_passwdMinLen);
        }

        if (_passwdMinLowercase)
        {
            setMemPasswdMinLowercase(*_passwdMinLowercase);
        }

        if (_passwdMinUppercase)
        {
            setMemPasswdMinUppercase(*_passwdMinUppercase);
        }

        if (_passwdMinDgts)
        {
            setMemPasswdMinDgts(*_passwdMinDgts);
        }

        if (_passwdMinSpecial)
        {
            setMemPasswdMinSpecial(*_passwdMinSpecial);
        }

        username = tc_session_get_username(handle);
        AddSecEvent(handle, SYSTEM_SECURITY_PARAMETERS_MODIFIED, (char *)username, " System Security Parameters Modified. ");
    }
    
    return tc_compld_comment( handle, ctag, "ED-SYS-SECU" );
}


/**
 */
eosl_bool agc_EM_NE_ED_SYS_TL1_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, BoolYN_ENUM * _tlntcntrlopt, BoolYN_ENUM * _promptmode)
{
    if( _src)
    {
        if(eosl_strcasecmp(_src, "COM") !=0 )
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
    }

    if( _tlntcntrlopt)
    {
        TL1_SESSION *ts = NULL;

        setTlntCntlOptEnabled(*_tlntcntrlopt);

        ts = ts_lookup_session(handle);
        if (ts)
        {  
           if (getTelicaSessionPortType(handle) != UserAccessPort_ELEMENTMANAGER)
           { 
             if ((*_tlntcntrlopt) == BoolYN_N)
             {
                ac_comm_write(handle,disableforceCharMode,sizeof(disableforceCharMode));
                ac_comm_write(handle,disableforceEchoMode,sizeof(disableforceEchoMode));
                ac_comm_write(handle,"\r\n",2);
             }
             else
             {
                ac_comm_write(handle,forceCharMode,3);
                ac_comm_write(handle,forceEchoMode,3);
                ac_comm_write(handle,"\r\n",2);
             }
             ts->tlntcntrlopt = *_tlntcntrlopt;
           }
        }
    }


    if(_promptmode)
    {
        setEscForPromptMode(*_promptmode);
    }

    return tc_compld_comment( handle, ctag, "ED-SYS-TL1" );
}


/**
 */
eosl_bool agc_EM_NE_ED_T3_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _ds_id, char * _aisc, AlarmIndicationSignal_ENUM * _aist, FMT_ENUM * _fmt, ON_OFF_ENUM * _idle, int * _lbo, T3LineCode_ENUM * _linecde, char * _map, DSMode_ENUM * _omode, ON_OFF_ENUM * _pbit, XBit_ENUM * _xbit, XBitReceive_ENUM * _xbitrcv, XBitPolarity_ENUM * _xpol, PrimaryStateIn_ENUM * _pst, SecondaryState_ENUM * _sst)
{
    DSX_CMD_BUF_t      buffer;
    int          enumBits1;
    int          enumBits2;  /* Assuming for now bits 32 - 63 are not needed */
    int          t3EnumBits;

    /*
    ** prepare t3 data structure
    */
    memset(&buffer, 0, SIZEOF_DSXCMD_ED_T3);
    if(ParseAidToDeviceIdMap(&buffer.DeviceId, _ds_id, AID_T3,
                             &buffer.DeviceMap))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_aisc)
    {
        /* Create a bit map containing all specified AISC values */
        if (enumStringListToBitMap(_aisc,
                                   &AISC_ENUM_type,
                                   &enumBits1,
                                   &enumBits2) == eosl_false)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid AISC Value" );
            return eosl_false;
        }

        /* If "NONE" is the only AISC value specified */
        if ((enumBits1 & (1 << AISC_NONE)) == enumBits1)
        {
            /* Clear bitmap to indicate no values */
            enumBits1 = 0;
        }
        else
        {
            /* Design Note: AISC is not supported at this time, so reject this
             *     command unless AISC=NONE
             */
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid AISC Value" );
            return eosl_false;
        }

        buffer.Data.T3Edit.Aisc.value = enumBits1;
        buffer.Data.T3Edit.Aisc.valid = VALID_VALUE;
    }

    if (_aist)
    {
        buffer.Data.T3Edit.Aist.value = *_aist;
        buffer.Data.T3Edit.Aist.valid = VALID_VALUE;
    }

    if (_fmt)
    {
        if ((*_fmt != FMT_ASYNC) && (*_fmt != FMT_CBIT))
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid FMT Value" );
            return eosl_false;
        }
        buffer.Data.T3Edit.Fmt.value = *_fmt;
        buffer.Data.T3Edit.Fmt.valid = VALID_VALUE;
    }

    if (_idle)
    {
        if (*_idle == ON_OFF_ON)
        {
            buffer.Data.T3Edit.Idle.value = TRUE;
        }
        else
        {
            buffer.Data.T3Edit.Idle.value = FALSE;
        }
        buffer.Data.T3Edit.Idle.valid = VALID_VALUE;
    }

    if (_lbo)
    {
        buffer.Data.T3Edit.Lbo.value = *_lbo;
        buffer.Data.T3Edit.Lbo.valid = VALID_VALUE;
    }

    if (_linecde)
    {
        if (*_linecde != T3LineCode_B3ZS)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid LINECDE Value" );
            return eosl_false;
        }
        buffer.Data.T3Edit.Linecde.value = *_linecde;
        buffer.Data.T3Edit.Linecde.valid = VALID_VALUE;
    }

    if (_map)
    {
        if (enumStringListToBitMap(_map, &T3Map_ENUM_type, &enumBits1, &enumBits2) == eosl_false)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid Map Value" );
            return eosl_false;
        }

        /* Map Lumos enums to DS3 enums. */
        t3EnumBits = 0;
        if (enumBits1 & (1 << T3Map_NA))
        {
            t3EnumBits = 0;
        }
        else
        {
            if (enumBits1 & (1 << T3Map_ASYNC))
            {
                t3EnumBits |= (1 << T3MAP_ASYNC);  /* Defined in dsx_cmds.h */
            }
            if (enumBits1 & (1 << T3Map_DL))
            {
                t3EnumBits |= (1 << T3MAP_DL);
            }
            if (enumBits1 & (1 << T3Map_SYNC))
            {
                t3EnumBits |= (1 << T3MAP_SYNC);
            }
        }

        buffer.Data.T3Edit.Map.value = t3EnumBits;
        buffer.Data.T3Edit.Map.valid = VALID_VALUE;
    }

    if (_omode)
    {
        buffer.Data.T3Edit.Omode.value = *_omode;
        buffer.Data.T3Edit.Omode.valid = VALID_VALUE;
    }

    if (_pbit)
    {
        if (*_pbit == ON_OFF_ON)
        {
            buffer.Data.T3Edit.Pbit.value = TRUE;
        }
        else
        {
            buffer.Data.T3Edit.Pbit.value = FALSE;
        }
        buffer.Data.T3Edit.Pbit.valid = VALID_VALUE;
    }

    if (_xbit)
    {
        buffer.Data.T3Edit.Xbit.value = *_xbit;
        buffer.Data.T3Edit.Xbit.valid = VALID_VALUE;
    }

    if (_xbitrcv)
    {
        buffer.Data.T3Edit.Xbitrcv.value = *_xbitrcv;
        buffer.Data.T3Edit.Xbitrcv.valid = VALID_VALUE;
    }

    if (_xpol)
    {
        buffer.Data.T3Edit.Xpol.value = *_xpol;
        buffer.Data.T3Edit.Xpol.valid = VALID_VALUE;
    }

    if (_pst)
    {
        switch (*_pst)
        {
        case PrimaryStateIn_IS:
            buffer.Data.T3Edit.State.value |= PST_IS_BIT;
            buffer.Data.T3Edit.State.valid |= PST_IS_BIT;
            break;

        case PrimaryStateIn_OOS:
            buffer.Data.T3Edit.State.value |= PST_OOS_BIT;
            buffer.Data.T3Edit.State.valid |= PST_OOS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIDT, "Invalid PrimaryState" );
            return eosl_false;
        }
    }

    if (_sst)
    {
        switch (*_sst)
        {
        case SecondaryState_AINS:
            buffer.Data.T3Edit.State.value |= SST_AINS_BIT;
            buffer.Data.T3Edit.State.valid |= SST_AINS_BIT;
            break;

        default:
            tc_error_response( handle, ctag, TE_IIDT, "Invalid SecondaryState" );
            return eosl_false;
        }
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  DS3_CMD_CLASS, CMD, DS3CMD_ED_IF,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_ED_T3,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_ED_T3_req","We have a bad response \n");
/* ??? Change to CMD_T3 when T3 error codes are in TL1ErrorResp. */
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "ED-T3" );
}


/**
 * Set the performance monitoring parameter threshold levels.
 * This command may not be used to turn off threshold crossing
 * alerts: the threshold level may not be set to some
 * "non-applicable" value. SET-ATTR must be used to decide if
 * TCAs should be reported or not.
 *
 * Thresholds are retrieved using RTRV-TH. When
 * thresholds are exceeded, a REPT-ALM or EVT is sent
 * depending on the notification code associatiated with the
 * thresholded condition.
 *
 * Threshold setting for multiple monitored parameters requires
 * multiple OS invocations of this message. In other words,
 * wildcarding is NOT permitted.
 *
 * Defined in GR-833.
 */
eosl_bool agc_EM_NE_SET_TH_DSnFacility_req( const char * modifier, eosl_handle handle, TL1_TAG ctag, TL1_AID _pm_id, char * _montype, int _thlev, Location_ENUM * _locn, Direction_ENUM * _dirn, char * _tmper)
{
#ifdef ATCA
    AID_INFO_TYPE_t   aidInfo;
    TsTransId         transId = ctag;
    TsTableId         tableId = 0;
    TsSmiRowKey       rowKey;
    TsSmiColArray     colArray;
    TsSmiColObj       columns[MAX_TSM_COLS];
    SMCMD_t           smCmd;
    int               cmd = SM_ED_REQUEST;
    int               colCnt = 0;
    char              tmpArray[16];
    int               tmpVal = 0;
    int               retVal = 0;

    colArray.numCols  = 0;

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        tableId = THT1_TAB_ID;

        TL1LOGP (PLOG_DEBUG, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_DEBUG, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == T1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId = THT1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch (enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype))
            {
              case T3T1MonType_ALL:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ALL;
                  break;
              case T3T1MonType_CSS:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CSS;
                  break;
              case T3T1MonType_CSS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CSS_FE;
                  break;
              case T3T1MonType_CV_L:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_L;
                  break;
              case T3T1MonType_CV_P:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_P;
                  break;
              case T3T1MonType_CV_PFE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_CV_PFE;
                  break;
              case T3T1MonType_ES_L:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ES_L;
                  break;
              case T3T1MonType_ES_LFE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_ES_LFE;
                  break;
              case T3T1MonType_SEFS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SEFS_FE;
                  break;
              case T3T1MonType_SES:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SES;
                  break;
              case T3T1MonType_SES_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_SES_FE;
                  break;
              case T3T1MonType_UAS:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_UAS;
                  break;
              case T3T1MonType_UAS_FE:
                  columns[colCnt].value.value.longVal = THT1_MONTYPE_UAS_FE;
                  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid monType Value" );
                  return eosl_false;
                  break;
            }
            colCnt++;
        }

        printf("kavon line %d for _thlev is %d\n", __LINE__, _thlev);
        if (_thlev >= 0)
        {
            columns[colCnt].columnId             = THT1_THLEV;
            columns[colCnt].value.colType        = TSSMI_LONG;
            columns[colCnt].value.value.longVal  = _thlev;
            colCnt++;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid thlev Value" );
            return eosl_false;
        }

        if(_locn)
        {
            columns[colCnt].columnId      = THT1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
            case Location_FEND:
                columns[colCnt].value.value.longVal = THT1_LOCN_FEND;
                break;

            case Location_NEND:
                columns[colCnt].value.value.longVal = THT1_LOCN_NEND;
                break;
            default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, locn Invalid" );
                  return eosl_false;
            }
            colCnt++;
        }

        if(_dirn)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Invalid dirn Value" );
            return eosl_false;
        }

        if(_tmper)
        {
            columns[colCnt].columnId = THT1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;

            if (sscanf(_tmper, "%d-%s", &tmpVal, tmpArray) != 2)
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }

            if ((eosl_strcasecmp(tmpArray, "HR") == 0) && (tmpVal == 24))
            {
                columns[colCnt].value.value.longVal = THT1_TMPER_24_HR;
            }
            else if ((eosl_strcasecmp(tmpArray, "MIN") == 0) && (tmpVal == 15))
            {
                columns[colCnt].value.value.longVal = THT1_TMPER_15_MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Invalid TmPer Value" );
                return eosl_false;
            }
            colCnt++;
        }

        colArray.numCols  = colCnt;
        colArray.colArray = columns;
        retVal = emfPkSmiSetReq(cmd,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
        }
        else
        {
                return tc_compld_comment( handle, ctag, "SET-TH-T1" );
        }
    }
    else if(eosl_strcasecmp(modifier, "E1") == 0)
    {
        tableId = THE1_TAB_ID;

        TL1LOGP (PLOG_DEBUG, "TABLE ID:%d(0x%x)\n", tableId, tableId);

        memset(&rowKey, 0, sizeof(rowKey));
        memset(&colArray, 0, sizeof(colArray));
        colArray.colArray = columns;

        if(ParseAidMap(&aidInfo, _pm_id, AID_AMCSS7PORT, NULL))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        TL1LOGP (PLOG_DEBUG, "%s shelf:%d, atcaSlot:%d, amcSlot:%d, port:%d\n",
                             (aidInfo.devicemap == T1)?"T1":"E1",
                             aidInfo.lvl1, aidInfo.lvl2,
                             aidInfo.lvl3, aidInfo.lvl4);
        if (aidInfo.devicemap == E1)
        {
            rowKey.numIndices = 4;
            rowKey.rowIndex[0].colType          = TSSMI_LONG;
            rowKey.rowIndex[0].value.longVal    = aidInfo.lvl1;
            rowKey.rowIndex[1].colType          = TSSMI_LONG;
            rowKey.rowIndex[1].value.longVal    = aidInfo.lvl2;
            rowKey.rowIndex[2].colType          = TSSMI_LONG;
            rowKey.rowIndex[2].value.longVal    = aidInfo.lvl3;
            rowKey.rowIndex[3].colType          = TSSMI_LONG;
            rowKey.rowIndex[3].value.longVal    = aidInfo.lvl4;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        if(_montype)
        {
            columns[colCnt].columnId      = THE1_MONTYPE;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(enum_lookup_no_case(&E1MonType_ENUM_type, _montype))
            {
            	case E1MonType_AISS:
            		  columns[colCnt].value.value.longVal = THE1_AISS;
            		  break;
            	case E1MonType_ALL:
            		  columns[colCnt].value.value.longVal = THE1_ALL;
            		  break;
            	case E1MonType_BBEC:
            		  columns[colCnt].value.value.longVal = THE1_BBEC;
            		  break;            	
            	case E1MonType_BBEC_FE:
            		  columns[colCnt].value.value.longVal = THE1_BBEC_FE;
            		  break;
            	case E1MonType_BBER1:
            		  columns[colCnt].value.value.longVal = THE1_BBER1;
            		  break;
            	case E1MonType_BBER1_FE:
            		  columns[colCnt].value.value.longVal = THE1_BBER1_FE;
            		  break;
            	case E1MonType_CV_L:
            		  columns[colCnt].value.value.longVal = THE1_CV_L;
            		  break;
            	case E1MonType_CV_P:
            		  columns[colCnt].value.value.longVal = THE1_CV_P;
            		  break;
            	case E1MonType_ESC:
            		  columns[colCnt].value.value.longVal = THE1_ESC;
            		  break;
            	case E1MonType_ESC_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESC_FE;
            		  break;
            	case E1MonType_ESR1:
            		  columns[colCnt].value.value.longVal = THE1_ESR1;
            		  break;
            	case E1MonType_ESR1_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR1_FE;
            		  break;
            	case E1MonType_ESR2:
            		  columns[colCnt].value.value.longVal = THE1_ESR2;
            		  break;
            	case E1MonType_ESR2_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR2_FE;
            		  break;
            	case E1MonType_ESR3:
            		  columns[colCnt].value.value.longVal = THE1_ESR3;
            		  break;
            	case E1MonType_ESR3_FE:
            		  columns[colCnt].value.value.longVal = THE1_ESR3_FE;
            		  break;
            	case E1MonType_LOSS:
            		  columns[colCnt].value.value.longVal = THE1_LOSS;
            		  break;
            	case E1MonType_OOFS:
            		  columns[colCnt].value.value.longVal = THE1_OOFS;
            		  break;
            	case E1MonType_RAI:
            		  columns[colCnt].value.value.longVal = THE1_RAI;
            		  break;
            	case E1MonType_RAI_FE:
            		  columns[colCnt].value.value.longVal = THE1_RAI_FE;
            		  break;
            	case E1MonType_SESC:
            		  columns[colCnt].value.value.longVal = THE1_SESC;
            		  break;
            	case E1MonType_SESC_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESC_FE;
            		  break;
            	case E1MonType_SESR1:
            		  columns[colCnt].value.value.longVal = THE1_SESR1;
            		  break;
            	case E1MonType_SESR1_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR1_FE;
            		  break;
            	case E1MonType_SESR2:
            		  columns[colCnt].value.value.longVal = THE1_SESR2;
            		  break;
            	case E1MonType_SESR2_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR2_FE;
            		  break;
            	case E1MonType_SESR3:
            		  columns[colCnt].value.value.longVal = THE1_SESR3;
            		  break;
            	case E1MonType_SESR3_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR3_FE;
            		  break;
            	case E1MonType_SESR4:
            		  columns[colCnt].value.value.longVal = THE1_SESR4;
            		  break;
            	case E1MonType_SESR4_FE:
            		  columns[colCnt].value.value.longVal = THE1_SESR4_FE;
            		  break;
            	case E1MonType_UASC:
            		  columns[colCnt].value.value.longVal = THE1_UASC;
            		  break;
            	case E1MonType_UASC_FE:
            		  columns[colCnt].value.value.longVal = THE1_UASC_FE;
            		  break;
            	case E1MonType_CSS:
            		  columns[colCnt].value.value.longVal = THE1_CSS;
            		  break;
              default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, monType Invalid" );
                  return eosl_false;
            }
            colCnt++;
        }

        printf("kavon line %d for _thlev is %d\n", __LINE__, _thlev);
        if (_thlev >= 0)
        {
            columns[colCnt].columnId             = THE1_THLEV;
            columns[colCnt].value.colType        = TSSMI_LONG;
            columns[colCnt].value.value.longVal  = _thlev;
            colCnt++;     	
        }

        if(_locn)
        {
            columns[colCnt].columnId      = THE1_LOCN;
            columns[colCnt].value.colType = TSSMI_LONG;
            switch(*_locn)
            {
            case Location_FEND:
                columns[colCnt].value.value.longVal = THE1_LOCN_FEND;
                break;

            case Location_NEND:
                columns[colCnt].value.value.longVal = THE1_LOCN_NEND;
                break;
            default:
                  tc_error_response( handle, ctag, TE_IIDT, "Input, locn Invalid" );
                  return eosl_false;
            }
            colCnt++;
        }
 
        if(_dirn)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> dirn" );
            return eosl_false;
        }
 
        if(_tmper)
        {
            columns[colCnt].columnId      = THE1_TMPER;
            columns[colCnt].value.colType = TSSMI_LONG;

            if (eosl_strcasecmp(_tmper, "24-HR") == 0)
            {
                columns[colCnt].value.value.longVal = THE1_TMPER_24HR;
            }
            else if (eosl_strcasecmp(_tmper, "15-MIN") == 0)
            {
                columns[colCnt].value.value.longVal = THE1_TMPER_15MIN;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid" );
                return eosl_false;
            }
            colCnt++;
        }

        colArray.numCols  = colCnt;
        colArray.colArray = columns;
        
        retVal = emfPkSmiSetReq(cmd,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
                TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
                return eosl_false;
        }
        else
        {
                return tc_compld_comment( handle, ctag, "SET-TH-E1" );
        }
        
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - Threshold type is not supported at this time.");
        return eosl_false;        	
    }

#else
    DSX_CMD_BUF_t   buffer;

    char            *cmdClass;
    unsigned int    cmd;
    char            tmpArray[16];
    char            RespComment[16];
    char            mod[64];
    int             tmpVal;
    int             tmpEnum;
    int             i;

    /*
    ** prepare t1 data structure
    */
    
    memset(&buffer, 0, SIZEOF_DSXCMD_SET_TH);
    memset(RespComment, 0, sizeof(RespComment));

    if (eosl_strcasecmp(modifier, "T1") == 0)
    {
        if (ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                  (AID_IOM | AID_T3 | AID_PORT |
                                   AID_OC3_STS1 | AID_OC12_STS1 |
                                   AID_OC3_STS1_T1 | AID_OC12_STS1_T1 |
                                   AID_STS1|AID_AU3TUG3_T1),
                                  &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SET_TH_T1;

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
            /* I don't believe we allow wild cards here - BRIAN L */
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_T1;
            break;
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_T1;
            break;
        case DEVICE_MAP_IOM_T3:
            buffer.DeviceMap = DEVICE_MAP_IOM_T3_T1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_T1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_T1;
            break;
    	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_T1;
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
           buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_T1;
           break;
        case DEVICE_MAP_IOM_STM4_AU3:
           buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_T1;
           break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "T3") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SET_TH_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_T3),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All T3s on DS3 board */
            buffer.DeviceMap = DEVICE_MAP_IOM_T3;
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "E1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SET_TH_E1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_E1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:    /* All E1s on E1 board */
            buffer.DeviceMap = DEVICE_MAP_IOM_E1;
            break;
        default:
	    break;
        }
    }
    else if ((!eosl_strcasecmp(modifier, "OC3")) ||
             (!eosl_strcasecmp(modifier, "OC12")))
    {
        cmdClass = OC_CMD_CLASS; /* DS3_CMD_CLASS; */
        cmd = DS3CMD_SET_TH_OC;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id, (AID_IOM | AID_OC),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_OC3:
            if (!eosl_strcasecmp(modifier, "OC12"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM_OC12:
            if (!eosl_strcasecmp(modifier, "OC3"))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
                return eosl_false;
            }
            break;
        case DEVICE_MAP_IOM:
            if (!eosl_strcasecmp(modifier, "OC3"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC3;
            else if (!eosl_strcasecmp(modifier, "OC12"))
                buffer.DeviceMap = DEVICE_MAP_IOM_OC12;
            break;
        default:
            break;
        }
    }
    else if (!eosl_strcasecmp(modifier, "STS1"))
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SET_TH_IF;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_IOM | AID_STS1 | AID_OC |
                                  AID_OC3_STS1 | AID_OC12_STS1),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1;
            break;
        case DEVICE_MAP_IOM_STS1:
            break;
        case DEVICE_MAP_IOM_OC3:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            break;
        case DEVICE_MAP_IOM_OC12:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            break;
        default:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "VT1") == 0)
    {
        cmdClass = DS3_CMD_CLASS;
        cmd = DS3CMD_SET_TH_VT1;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId, _pm_id,
                                 (AID_OC3_STS1 | AID_OC3_STS1_VT |
                                  AID_OC12_STS1 | AID_OC12_STS1_VT |
                                  AID_STS1 | AID_STS1_VT),
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC3_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC3_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
            break;
        case DEVICE_MAP_IOM_OC12_STS1:
            buffer.DeviceMap = DEVICE_MAP_IOM_OC12_STS1_VT1;
            break;
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            break;
        }
    }
    else if (eosl_strcasecmp(modifier, "TUG3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_SET_TH_TUG3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TUG3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "AU3") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_SET_TH_AU3;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_AU3|AID_STM, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3;
            break;
	case DEVICE_MAP_IOM_STM4:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU12") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_SET_TH_TU12;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU12|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU12;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU12;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU12;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU12;
            break;
        }

    }
    else if (eosl_strcasecmp(modifier, "TU11") == 0)
    {
        cmdClass = OC_CMD_CLASS;
        cmd = DS3CMD_SET_TH_TU11;
        if(ParseAidToDeviceIdMap(&buffer.DeviceId,
			         _pm_id,
                                 AID_TU11|AID_AU3|AID_TUG3, 
                                 &buffer.DeviceMap))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }

        /* Handle wildcard DeviceMap ambiguities here */
        switch(buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_STM1_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_AU3_TU11;
            break;
        case DEVICE_MAP_IOM_STM4_AU3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_AU3_TU11;
            break;
	case DEVICE_MAP_IOM_STM1_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM1_TUG3_TU11;
            break;
	case DEVICE_MAP_IOM_STM4_TUG3:
            buffer.DeviceMap = DEVICE_MAP_IOM_STM4_TUG3_TU11;
            break;
        }
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC,
                           "Invalid Access Identifier - pm_id type is not supported at this time.");
        return eosl_false;
    }

    if(_montype)
    {
        switch (buffer.DeviceMap)
        {
        case DEVICE_MAP_IOM_T1:
        case DEVICE_MAP_IOM_T3_T1:
        case DEVICE_MAP_IOM_STS1_T1:
        case DEVICE_MAP_IOM_OC3_STS1_T1:
        case DEVICE_MAP_IOM_OC12_STS1_T1:
        case DEVICE_MAP_IOM_STM1_TUG3_T1:
        case DEVICE_MAP_IOM_STM4_TUG3_T1:
        case DEVICE_MAP_IOM_STM1_AU3_T1:
        case DEVICE_MAP_IOM_STM4_AU3_T1:
            tmpEnum = enum_lookup_no_case(&T3T1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case T3T1MonType_AISS_P:
                tmpEnum = DS3T1MonType_AISS_P;
                break;
            case T3T1MonType_ALL:
                tmpEnum = DS3T1MonType_ALL;
                break;
            case T3T1MonType_CSS_P:
                tmpEnum = DS3T1MonType_CSS_P;
                break;
            case T3T1MonType_CSS_PFE:
                tmpEnum = DS3T1MonType_CSS_PFE;
                break;
            case T3T1MonType_CV_L:
                tmpEnum = DS3T1MonType_CV_L;
                break;
            case T3T1MonType_CV_P:
                tmpEnum = DS3T1MonType_CV_P;
                break;
            case T3T1MonType_CV_PFE:
                tmpEnum = DS3T1MonType_CV_PFE;
                break;
            case T3T1MonType_ES_L:
                tmpEnum = DS3T1MonType_ES_L;
                break;
            case T3T1MonType_ES_LFE:
                tmpEnum = DS3T1MonType_ES_LFE;
                break;
            case T3T1MonType_ES_P:
                tmpEnum = DS3T1MonType_ES_P;
                break;
            case T3T1MonType_ES_PFE:
                tmpEnum = DS3T1MonType_ES_PFE;
                break;
            case T3T1MonType_ESA_P:
                tmpEnum = DS3T1MonType_ESA_P;
                break;
            case T3T1MonType_ESA_PFE:
                tmpEnum = DS3T1MonType_ESA_PFE;
                break;
            case T3T1MonType_ESB_P:
                tmpEnum = DS3T1MonType_ESB_P;
                break;
            case T3T1MonType_ESB_PFE:
                tmpEnum = DS3T1MonType_ESB_PFE;
                break;
            case T3T1MonType_FC:
                tmpEnum = DS3T1MonType_FC;
                break;
            case T3T1MonType_FC_FE:
                tmpEnum = DS3T1MonType_FC_FE;
                break;
            case T3T1MonType_LOSS_L:
                tmpEnum = DS3T1MonType_LOSS_L;
                break;
            case T3T1MonType_SAS_P:
                tmpEnum = DS3T1MonType_SAS_P;
                break;
            case T3T1MonType_SEFS_PFE:
                tmpEnum = DS3T1MonType_SEFS_PFE;
                break;
            case T3T1MonType_SES_L:
                tmpEnum = DS3T1MonType_SES_L;
                break;
            case T3T1MonType_SES_P:
                tmpEnum = DS3T1MonType_SES_P;
                break;
            case T3T1MonType_SES_PFE:
                tmpEnum = DS3T1MonType_SES_PFE;
                break;
            case T3T1MonType_UAS_P:
                tmpEnum = DS3T1MonType_UAS_P;
                break;
            case T3T1MonType_UAS_PFE:
                tmpEnum = DS3T1MonType_UAS_PFE;
                break;
            default:
                tmpEnum = -1;
            }
            break;

        case DEVICE_MAP_IOM_T3:
            tmpEnum = enum_lookup_no_case(&T3MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_OC3:
        case DEVICE_MAP_IOM_OC12:
            tmpEnum = enum_lookup_no_case(&OCnMonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1:
        case DEVICE_MAP_IOM_OC3_STS1:
        case DEVICE_MAP_IOM_OC12_STS1:
            tmpEnum = enum_lookup_no_case(&Sts1MonType_ENUM_type, _montype);
            break;

        case DEVICE_MAP_IOM_STS1_VT1:
        case DEVICE_MAP_IOM_OC3_STS1_VT1:
        case DEVICE_MAP_IOM_OC12_STS1_VT1:
            tmpEnum = enum_lookup_no_case(&VtMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_E1:
        case DEVICE_MAP_IOM_STM1_TUG3_E1:
        case DEVICE_MAP_IOM_STM4_TUG3_E1:
        case DEVICE_MAP_IOM_STM1_AU3_E1:
        case DEVICE_MAP_IOM_STM4_AU3_E1:
            tmpEnum = enum_lookup_no_case(&E1MonType_ENUM_type, _montype);
            switch(tmpEnum)
            {
            case E1MonType_AISS:
                tmpEnum = DS3E1MonType_AISS;
                break;
            case E1MonType_ALL:
                tmpEnum = DS3E1MonType_ALL;
                break;
            case E1MonType_BBEC:
                tmpEnum = DS3E1MonType_BBEC;
                break;
            case E1MonType_BBEC_FE:
                tmpEnum = DS3E1MonType_BBEC_FE;
                break;
            case E1MonType_BBER1:
                tmpEnum = DS3E1MonType_BBER1;
                break;
            case E1MonType_BBER1_FE:
                tmpEnum = DS3E1MonType_BBER1_FE;
                break;
            case E1MonType_CV:
                tmpEnum = DS3E1MonType_CV;
                break;
            case E1MonType_ESC:
                tmpEnum = DS3E1MonType_ESC;
                break;
            case E1MonType_ESC_FE:
                tmpEnum = DS3E1MonType_ESC_FE;
                break;
            case E1MonType_ESR1:
                tmpEnum = DS3E1MonType_ESR1;
                break;
            case E1MonType_ESR1_FE:
                tmpEnum = DS3E1MonType_ESR1_FE;
                break;
            case E1MonType_ESR2:
                tmpEnum = DS3E1MonType_ESR2;
                break;
            case E1MonType_ESR2_FE:
                tmpEnum = DS3E1MonType_ESR2_FE;
                break;
            case E1MonType_ESR3:
                tmpEnum = DS3E1MonType_ESR3;
                break;
            case E1MonType_ESR3_FE:
                tmpEnum = DS3E1MonType_ESR3_FE;
                break;
            case E1MonType_LOSS:
                tmpEnum = DS3E1MonType_LOSS;
                break;
            case E1MonType_OOFS:
                tmpEnum = DS3E1MonType_OOFS;
                break;
            case E1MonType_RAI:
                tmpEnum = DS3E1MonType_RAI;
                break;
            case E1MonType_RAI_FE:
                tmpEnum = DS3E1MonType_RAI_FE;
                break;
            case E1MonType_SESC:
                tmpEnum = DS3E1MonType_SESC;
                break;
            case E1MonType_SESC_FE:
                tmpEnum = DS3E1MonType_SESC_FE;
                break;
            case E1MonType_SESR1:
                tmpEnum = DS3E1MonType_SESR1;
                break;
            case E1MonType_SESR1_FE:
                tmpEnum = DS3E1MonType_SESR1_FE;
                break;
            case E1MonType_SESR2:
                tmpEnum = DS3E1MonType_SESR2;
                break;
            case E1MonType_SESR2_FE:
                tmpEnum = DS3E1MonType_SESR2_FE;
                break;
            case E1MonType_SESR3:
                tmpEnum = DS3E1MonType_SESR3;
                break;
            case E1MonType_SESR3_FE:
                tmpEnum = DS3E1MonType_SESR3_FE;
                break;
            case E1MonType_SESR4:
                tmpEnum = DS3E1MonType_SESR4;
                break;
            case E1MonType_SESR4_FE:
                tmpEnum = DS3E1MonType_SESR4_FE;
                break;
            case E1MonType_UASC:
                tmpEnum = DS3E1MonType_UASC;
                break;
            case E1MonType_UASC_FE:
                tmpEnum = DS3E1MonType_UASC_FE;
                break;
            case E1MonType_CSS:
                tmpEnum = DS3E1MonType_CSS;
                break;
            case E1MonType_LOFS:
            default:
                tmpEnum = -1;
            }
            break;
        case DEVICE_MAP_IOM_STM1_TUG3:
        case DEVICE_MAP_IOM_STM4_TUG3:
            tmpEnum = enum_lookup_no_case(&TugnMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_STM1_AU3:
        case DEVICE_MAP_IOM_STM4_AU3:
            tmpEnum = enum_lookup_no_case(&Au3nMonType_ENUM_type, _montype);
            break;
        case DEVICE_MAP_IOM_STM1_TUG3_TU12:
        case DEVICE_MAP_IOM_STM4_TUG3_TU12:
        case DEVICE_MAP_IOM_STM1_AU3_TU12:
        case DEVICE_MAP_IOM_STM4_AU3_TU12:
        case DEVICE_MAP_IOM_STM1_TUG3_TU11:
        case DEVICE_MAP_IOM_STM4_TUG3_TU11:
        case DEVICE_MAP_IOM_STM1_AU3_TU11:
        case DEVICE_MAP_IOM_STM4_AU3_TU11:
             tmpEnum = enum_lookup_no_case(&TUnMontype_ENUM_type, _montype);
            break;
          default:
              tmpEnum = -1;
              break;
        }

        if (tmpEnum == -1)
        {
            tc_error_response( handle, ctag, TE_IPNV,
                               "Input, Parameter Not Valid -> montype" );
            return eosl_false;
        }
        buffer.Data.SetTh.MonitoredType.valid = VALID_VALUE;
        buffer.Data.SetTh.MonitoredType.value = tmpEnum;
    }

    if(_locn)
    {
        buffer.Data.SetTh.Location.valid = VALID_VALUE;
        buffer.Data.SetTh.Location.value = *_locn;
    }

    if(_dirn)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> dirn" );
        return eosl_false;
    }

    if(_tmper)
    {
        i = sscanf(_tmper, "%d-%s", &tmpVal, tmpArray);
        if (i != 2)
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        if (eosl_strcasecmp(tmpArray, "HR") == 0)
        {
            tmpEnum = TIME_PERIOD_HR;
        } else if (eosl_strcasecmp(tmpArray, "MIN") == 0)
        {
            tmpEnum = TIME_PERIOD_MIN;
        }
        else if (eosl_strcasecmp(tmpArray, "DAY") == 0)
        {
            tmpEnum = TIME_PERIOD_DAY;
        }
        else
        {
            tc_error_response( handle, ctag, TE_IPNV, "Input, Parameter Not Valid -> TmPer" );
            return eosl_false;
        }
        buffer.Data.SetTh.TimePeriod.valid = VALID_VALUE;
        buffer.Data.SetTh.TimePeriod.value = PACK_TIME_PERIOD(tmpVal, tmpEnum);
    }

    if(_thlev >= 0)
    {
        buffer.Data.SetTh.ThresholdLevel.valid = VALID_VALUE;
        buffer.Data.SetTh.ThresholdLevel.value = _thlev;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  cmdClass, CMD, cmd,
                  (TL1_CMD_BUF_t *)&buffer, SIZEOF_DSXCMD_SET_TH,
                  (TL1_CMD_BUF_t *)&buffer, sizeof(buffer),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        procLogMsg (PLOG_ERROR, "agc_EM_NE_SET_TH_DSnFacility_req", "We have a bad response \n");
        TL1ErrorResp( handle, ctag, CMD_T1, buffer.Tl1Cmd.Error );
        return eosl_false;
    }


    for(i=0;i<=strlen(modifier);i++)
    {
       mod[i] = toupper(modifier[i]);
    }

    sprintf(RespComment, "SET-TH-%s", mod);
    return tc_compld_comment(handle, ctag, RespComment);
#endif
}


/**
 */
eosl_bool agc_EM_NE_ED_TRAFFICSTATS_req( const char * modifier,\
                                         eosl_handle handle,\
                                         TL1_TAG ctag ,\
                                         TL1_AID _src,\
                                         PrimaryStateIn_ENUM * _pst)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    int            colCnt = 0;
    SMCMD_t        smCmd;


    tableId = TELICA_TABLE_STST;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 0;

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if (_pst)
    {
        switch (*_pst)
        {
          case PrimaryStateIn_IS:
              columns[colCnt].value.value.longVal =  TRAFFIC_ON;
              break;
          case PrimaryStateIn_OOS:
              columns[colCnt].value.value.longVal = TRAFFIC_OFF;
              break;
          default:
              break;
        }
        columns[colCnt].columnId      = TS_COL_STAT_STATE;
        columns[colCnt].value.colType = TSSMI_LONG;
        colCnt++;
    }
    
    colArray.numCols  = colCnt;
    colArray.colArray = columns;
    
    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_ED_STATE_IVR_req",
                   "ED_STATE_IVR - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                            handle,
                            transId,
                            tableId,
                            &rowKey,
                            &colArray,
                            &smCmd,
                            TL1_MSG_TIMEOUT);
    
    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "ED-TRAFFICSTATS" ); /* success */
    }
}
    

/**
 */
eosl_bool agc_EM_NE_RTRV_TRAFFICSTATS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    short          length;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;

    length = sizeof(SMCMD_t);
    tableId = TELICA_TABLE_STST;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    rowKey.numIndices = 0;
    colArray.numCols = 0;
    colArray.colArray = columns;

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);


    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    retVal=emfUnpkSmiGetMultiResp(rtrvTrafficStatsMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}
    

/**
 */
eosl_bool agc_EM_NE_RTRV_STATE_IVR_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    short          retVal;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;

    length = sizeof(SMCMD_t);

    tableId = TELICA_TABLE_IVRSTATE;
    transId = ctag;

    rowKey.numIndices = 0;
    colArray.numCols = 0;
    colArray.colArray = columns;

    if ((_src != NULL) && (eosl_strcasecmp(_src, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    retVal = emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

   if (retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   retVal=emfUnpkSmiGetMultiResp(rtrvStateIvrMultiTsmResp, &smCmdPtr, &length, handle);
   if (retVal == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}

/**
 * Set Threshold IPATK
 */
eosl_bool agc_EM_NE_SET_TH_IPATK_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _pmId,\
									pmIpAtkMonType_ENUM * _montype,\
									int * _thlev,\
									pmNotApplicable_ENUM * _locn,\
									pmNotApplicable_ENUM * _dirn,\
									pmNotApplicable_ENUM * _tmper)
{
    TL1_EMF_IPATK_DATA_t buffer;
    SMCMD_t smCmd;

    /* Prepare data structure */
    memset(&buffer, 0, sizeof(TL1_EMF_IPATK_DATA_t));
    memset(&smCmd, 0, sizeof(SMCMD_t));    
    
    if ((_pmId != NULL) && (eosl_strcasecmp(_pmId, "COM") !=0 ))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    if(_montype)
    {
	    buffer.Data.SetTres.MonType = mapTL1TsmcIpAtkMonType(*_montype);
    }
    else
    {
	    buffer.Data.SetTres.MonType = IPATK_ALL_MONTYPES;
    }

    if(_thlev)
    {
	    if (*_thlev < 0 ||* _thlev > 500)
            {
	            tc_error_response( handle, ctag, TE_IDRG, "Invalid Data Range -> thlev" );
	            return eosl_false;
            }
            buffer.Data.SetTres.AlarmThreshold = *_thlev;
    }
    else
    {
	    buffer.Data.SetTres.AlarmThreshold = 200;
    }
    /*
    ** Send Event
    */
    if (TL1SendMsg(handle, ctag,
	           TL1_EMF_IPATK_PM_CLASS, TL1_EMF_IPATK_PM_EVENT,
		   CMD_SET_IPATK_TH,
		   (TL1_CMD_BUF_t *)&buffer,SIZEOF_CMD_SET_TH_IPATK,
		   (TL1_CMD_BUF_t *)&smCmd, sizeof(SMCMD_t),
		   TL1_MSG_TIMEOUT) == FAIL)
    {
	    procLogMsg(PLOG_ERROR,
			    "agc_EM_NE_SET_TH_IPATK_req",
			    "agc_EM_NE_SET_TH_IPATK_req: bad response \n");
            TL1ErrorResp(handle, ctag, CMD_EQM, smCmd.Tl1Cmd.Error);
	    return eosl_false;
    }
    
    return tc_compld_comment( handle, ctag, "SET-TH-IPATK" );
}

/**
 * Retrieve  STATE M3UAROUTECTXT
 */
eosl_bool agc_EM_NE_RTRV_STATE_M3UAROUTECTXT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									TL1_AID _routingKeyAid)
{
#ifdef ATCA
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length = 0;
    char	   tmpAid[66] 		= {0};
    char	   *pAid 		= NULL;
    char	   *shelfIdToken  	= NULL;
    char	   *atcaSlotToken	= NULL;
    char	   *netIdToken          = NULL;
    char	   *pLeftAid		= NULL;
    char	   *pPcIdAid		= NULL;
    char	   *siToken		= NULL;
    char 	   sgShelf[]		= "SG-SHELF-";
    char 	   mgcShelf[]		= "MGC-SHELF-";
    char 	   strAcm[]  		= "ACM-";
    char 	   strSi[]  		= "SI-";
    char 	   strNetId[]  		= "NETID-";
    int            netId;
    int		   ret			= FAIL;
    eosl_bool	   success;
    OPCDPCPAIR_t   opcDpc;
    char	   errStr[50];


    length = sizeof(SMCMD_t);
    tableId = STATE_M3UAROUTECTXT_TAB_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(smCmd));


    rowKey.numIndices = 0;

    if (_routingKeyAid)
    {
	/* If first or last char is a dash character */
	if ((_routingKeyAid[0] == '-') || (_routingKeyAid[strlen(_routingKeyAid) -1] == '-'))
	{
	    tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
	    return eosl_false;
	}

        /* AID ->
         * MGC: MGC-SHELF-<shelfId>-ACM-<atcaSlot>-NETID-<netId>-OPC-<opc>-DPC-<dpc>-SI-<si>
         * VSG: SG-SHELF-<shelfId>-ACM-<atcaSlot>-NETID-<netId>-OPC-<opc>-DPC-<dpc>[-SI-<si>]
         */
	strncpy(tmpAid, _routingKeyAid, strlen(_routingKeyAid));	
	toUpperStr(tmpAid);

	if (strncmp(tmpAid, sgShelf, strlen(sgShelf)) == 0)
	{
	    /* Split SG-SHELF-<shelfId> out */
	    ret = splitToken(tmpAid, &shelfIdToken, &pAid, 3, SPLIT_L2R);
	    if (ret != SUCCESS || !shelfIdToken || !pAid ||
	        (strlen(shelfIdToken) < strlen(sgShelf) + 1) ||
                (strncmp(shelfIdToken, sgShelf, strlen(sgShelf)) != 0) ||
	        (IsInputStrInRange(shelfIdToken + strlen(sgShelf), "0123456789") == 0))
	    {
		tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
		return eosl_false;
	    }
	    rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].colType = TSSMI_LONG;
	    rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].value.longVal = STATE_M3UA_SG;
	    rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].colType = TSSMI_LONG;
	    rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].value.longVal = atoi(shelfIdToken + strlen(sgShelf));
	}
	else if (strncmp(tmpAid, mgcShelf, strlen(mgcShelf)) == 0)
	{
	    /* Split MGC-SHELF-<shelfId> out */
	    ret = splitToken(tmpAid, &shelfIdToken, &pAid, 3, SPLIT_L2R);
	    if (ret != SUCCESS || !shelfIdToken || !pAid ||
                (strlen(shelfIdToken) < strlen(mgcShelf) + 1) ||
                (strncmp(shelfIdToken, mgcShelf, strlen(mgcShelf)) != 0) ||
                (IsInputStrInRange(shelfIdToken + strlen(mgcShelf), "0123456789") == 0))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
                return eosl_false;
            }
            rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].colType = TSSMI_LONG;
            rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].value.longVal = STATE_M3UA_MGC;
            rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].colType = TSSMI_LONG;
            rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].value.longVal = atoi(shelfIdToken + strlen(mgcShelf));
	}
	else
	{
	    tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
	    return eosl_false;
	}

	/* Split ACM-<atcaSlot> out */ 
	ret = splitToken(pAid, &atcaSlotToken, &pLeftAid, 2, SPLIT_L2R);
	if (ret != SUCCESS || !pLeftAid ||
            (strlen(atcaSlotToken) < strlen(strAcm) + 1) ||
            (strncmp(atcaSlotToken, strAcm, strlen(strAcm)) != 0) ||
            (IsInputStrInRange(atcaSlotToken + strlen(strAcm),"0123456789") == 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
            return eosl_false;
        }
	rowKey.rowIndex[STATE_M3UAROUTECTXT_ATCASLOT].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_ATCASLOT].value.longVal = atoi(atcaSlotToken + strlen(strAcm));

	if (!IS_VALID_SHELF_ID(rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].value.longVal) ||
	    !IS_VALID_PSLOT(rowKey.rowIndex[STATE_M3UAROUTECTXT_SHELFID].value.longVal, 
			    rowKey.rowIndex[STATE_M3UAROUTECTXT_ATCASLOT].value.longVal))
	{
	    tc_error_response( handle, ctag, TE_IIAC, 
				"Input, Invalid routingKeyAid - shelfId, atcaSlot");
	    return eosl_false;
	}

        /* rest of AID : NETID-<netId>-OPC-<opc>-DPC-<dpc>[-SI-<si>] */
	/* Split NETID-<netId> out */ 
	ret = splitToken(pLeftAid, &netIdToken, &pPcIdAid, 2, SPLIT_L2R);
	if (ret != SUCCESS || !pPcIdAid ||
            (strlen(netIdToken) < strlen(strNetId) + 1) ||
            (strncmp(netIdToken, strNetId, strlen(strNetId)) != 0) ||
            (IsInputStrInRange(netIdToken + strlen(strNetId),"0123456789") == 0))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
            return eosl_false;
        }

        netId = atoi(netIdToken + strlen(strNetId));

        if (netId < MGCNWK_MIN_NETID || netId > MGCNWK_MAX_NETID)
	{
	    tc_error_response( handle, ctag, TE_IIAC, 
				"Input, Invalid routingKeyAid - netId");
	    return eosl_false;
	}

	rowKey.rowIndex[STATE_M3UAROUTECTXT_NETID].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_NETID].value.longVal = netId;


	/* rest of AID : OPC-<opc>-DPC-<dpc>[-SI-<si>] */
	siToken = strstr(pPcIdAid, strSi);

	if ((rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].value.longVal == STATE_M3UA_SG) 
	 && (siToken != NULL))
	{
	    if ((*(siToken - 1) != '-') || (strlen(siToken) <= strlen(strSi)))
	    {
	        tc_error_response( handle, ctag, TE_IIAC,
		    "Input, Invalid routingKeyAid");
	        return eosl_false;
	    }
	    else
	    {
	        *(siToken - 1) = '\0';
	        siToken += strlen(strSi);
	    }
	}
	
	if (rowKey.rowIndex[STATE_M3UAROUTECTXT_SGMGC].value.longVal == STATE_M3UA_MGC)
	{
	    if ((siToken == NULL) || (strlen(siToken) <= strlen(strSi)))
	    {
		tc_error_response( handle, ctag, TE_IIAC,
			"Input, Invalid routingKeyAid - SI");
		return eosl_false;
	    }
	    *(siToken - 1) = '\0';
	    siToken += strlen(strSi);
	}

	/* pPcIdAid points to OPC-DPC block */
	success = opcDpc_atoi(pPcIdAid, &opcDpc, errStr);
        if(success == eosl_false)
        {	
	    tc_error_response( handle, ctag, TE_IIAC, errStr);
	    return eosl_false;
	}
	rowKey.rowIndex[STATE_M3UAROUTECTXT_OPC].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_OPC].value.longVal = opcDpc.opc;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_OPCFORMAT].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_OPCFORMAT].value.longVal = opcDpc.opcFormat;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_DPC].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_DPC].value.longVal = opcDpc.dpc;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_DPCFORMAT].colType = TSSMI_LONG;
	rowKey.rowIndex[STATE_M3UAROUTECTXT_DPCFORMAT].value.longVal = opcDpc.dpcFormat;
	rowKey.numIndices = 8;

	if (siToken != NULL)
	{
	    if (strcmp(siToken, "ISUP") == 0) 
	    {
	        rowKey.rowIndex[rowKey.numIndices].value.longVal = M3UA_MSG_SI_ISUP;
	    }
	    else if (strcmp(siToken, "SCCP") == 0)
            {
                rowKey.rowIndex[rowKey.numIndices].value.longVal = M3UA_MSG_SI_SCCP;
	    }
	    else if (strcmp(siToken, "BICC") == 0)
            {
                rowKey.rowIndex[rowKey.numIndices].value.longVal = M3UA_MSG_SI_BICC;
	    }
	    else
	    {
		tc_error_response( handle, ctag, TE_IIAC,
			"Input, Invalid routingKeyAid - SI");
		return eosl_false;
	    }
	    rowKey.rowIndex[rowKey.numIndices].colType = TSSMI_LONG;
	    rowKey.numIndices++;
	}
    }
    else
    {
	tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid routingKeyAid");
	return eosl_false;
    }	

    TL1LOGP(PLOG_INFO, "numIndices is %d\n", rowKey.numIndices);


    colArray.numCols = 0;
    colArray.colArray = columns;


    if ((emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                        handle,
                        transId,
                        tableId,
                        &rowKey,
                        &colArray,
                        &smCmd,
                        TL1_MSG_TIMEOUT)) == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error);
        return eosl_false;
    }

    if ((emfUnpkSmiGetMultiResp(rtrvStateM3uaRouteCtxtMultiTsmResp,
                                &smCmdPtr,
                                &length,
                                handle)) == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }

#endif

    return eosl_true;
}

/**
 * Retrieve  STATE SGP
 */
eosl_bool agc_EM_NE_RTRV_STATE_SGP_req( const char * modifier,\
                                                                      eosl_handle handle,\
                                                                       TL1_TAG ctag ,\
                                                                      TL1_AID _sgAssocId)
{
    
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[0];
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    short          length;
#ifndef ATCA
    int		   sgAssocId;
#endif
    TL1LOGP(PLOG_INFO, "agc_EM_NE_RTRV_STATE_SGP_req() entered\n");
    length = sizeof(SMCMD_t);
    tableId = MGC_STATESGP_TAB_ID;
    transId = ctag;
#ifdef ATCA
    int assocId = -1;
    int asId = -1;
    int shelfId = -1;
    int atcaSlot = -1;
#endif
    memset(&smCmd,0x0,sizeof(smCmd));
#ifndef ATCA
    if (_sgAssocId)
    {
        if (IsInputStrInRange(_sgAssocId, "0123456789"))
        {
	    sgAssocId = atoi(_sgAssocId);
            TL1LOGP(PLOG_INFO, "RTRV_STATE_SGP, sgAssocId = %d\n", sgAssocId);
	    if ((sgAssocId >= 1) && (sgAssocId <= 64))
	    {
                rowKey.rowIndex[0].colType = TSSMI_LONG;
                rowKey.rowIndex[0].value.longVal = sgAssocId;
                rowKey.numIndices = 1;
	    }
	    else
	    {
                tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid sgAssocId");
	        return eosl_false;
	    }
	}
	else
	{
            tc_error_response(handle,ctag,TE_IIAC,"Input, Invalid sgAssocId");
	    return eosl_false;
	}
    }
    else
    {
        rowKey.numIndices = 0;
    }
#else
      if(_sgAssocId)
      {
         if(parseStateSgpATCAAid( _sgAssocId, &assocId, &asId, &shelfId, &atcaSlot) != SUCCESS)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Input, Invalid Aid" );
            return eosl_false;
        }
        if( assocId != -1)
        {
             rowKey.rowIndex[0].colType = TSSMI_LONG;
             rowKey.rowIndex[0].value.longVal = assocId;
             rowKey.numIndices = 1;

        }
       if (asId != -1)
        {  
             rowKey.rowIndex[1].colType = TSSMI_LONG;
             rowKey.rowIndex[1].value.longVal = asId;
             rowKey.numIndices = 2;
        }
        if (shelfId != -1)
        {
             rowKey.rowIndex[2].colType = TSSMI_LONG;
             rowKey.rowIndex[2].value.longVal = shelfId;
             rowKey.rowIndex[3].colType = TSSMI_LONG;
             rowKey.rowIndex[3].value.longVal = atcaSlot;

             rowKey.numIndices = 4;
 
        }
 
      }
      else
      {
         rowKey.numIndices = 0;
      }
#endif
    colArray.numCols = 0;
    colArray.colArray = columns;

    if ((emfPkSmiGetReq(SM_GETMULTI_REQUEST,
                        handle,
                        transId,
                        tableId,
                        &rowKey,
                        &colArray,
                        &smCmd,
                        TL1_MSG_TIMEOUT)) == FALSE)

   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }

   if ((emfUnpkSmiGetMultiResp(rtrvStateSgpMultiTsmResp, 
   				 &smCmdPtr, 
				 &length, 
				 handle)) == FALSE)
   {
     tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
     return eosl_false;
   }
   else
   {
     return eosl_true;
   }
}

#define SIG_DBG_MAX  256        /* copied from signaling/sigcom/envopt.h in case include too many useless macros */
/**
 */
eosl_bool agc_EM_NE_SIGDBG_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _dbgcmd)
{
    SMCMD_STRING_CMD_t    buf;
    SMCMD_t               respBuff;
    unsigned int          lengthInclNull;
    int                   mesgLen;
    char                  cmd1[SIG_DBG_MAX] = "";
    char                  cmd2[SIG_DBG_MAX] = "";
    char                  cmd3[SIG_DBG_MAX] = "";
    TELICA_SESSION_DATA_t *pTelicaSessionData;

    if( procInfo.CPUState==CPU_BOOTING_ACT )
    {
        tc_error_response( handle, 
                           ctag,
                           TE_PICC,
                           "Host is in Booting Active Mode");
        return eosl_false;
    }

    procLogMsg(PLOG_ERROR,
               "agc_EM_NE_SIGDBG_req",
               "agc_EM_NE_SIGDBG_req: dbgcmd = %s\n", _dbgcmd);
    
    if (_dbgcmd == NULL)  /* Shouldn't happen -- mandatory parameter */
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    lengthInclNull = strlen(_dbgcmd) + 1;  /* Allow for null terminator */

    if (lengthInclNull > sizeof(buf.String.Data))
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    sscanf(_dbgcmd,"%s %s %s", cmd1, cmd2, cmd3);
#if 0                           /* temporary allow old sigdbg format, will forbid it later */
#ifdef ATCA    
    if (strstr(cmd1, "dest-") == NULL)
    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_SIGDBG_req",
                   "agc_EM_NE_SIGDBG_req: dest-a/s/b for sigdbg is mandatory since 8.0\n");
        tc_error_response(handle, ctag, TE_IIDT, "dest-a/s/b for sigdbg is mandatory since 8.0");
        return eosl_false;
    }
#endif    
#endif    

    pTelicaSessionData = getTelicaSessionData(handle);
    if (pTelicaSessionData == NULL)
    {
        procLogMsg(PLOG_ERROR,
                   "agc_EM_NE_SIGDBG_req",
                   "agc_EM_NE_SIGDBG_req couldn't get session data from handle = %d\n",
                   handle);
        return eosl_false ;
    }
    
    if (pTelicaSessionData->etsiLiFlag == 1)
    {
        if (eosl_strcasecmp(cmd2, "slamdbg") != 0 || eosl_strcasecmp(cmd3, "etsilog") != 0)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_SIGDBG_req",
                       "agc_EM_NE_SIGDBG_req permission denied\n");
            tc_error_response(handle,ctag,TE_EANS,"Incorrect Access Permission");
            return eosl_false;
        }
    }
    
    if (strstr(cmd1, "tl1") != NULL)
    {
        if (strstr(cmd1, "dest-a") == NULL)
        {
            procLogMsg(PLOG_ERROR,
                       "agc_EM_NE_SIGDBG_req",
                       "agc_EM_NE_SIGDBG_req: Only dest-a for tl1 sigdbg is valid");
            tc_error_response( handle, ctag, TE_IIDT, "Only dest-a for tl1 sigdbg is valid" );
            return eosl_false;
        }
        else
        {
            return agc_EM_NE_TL1DBG_req(modifier, handle, ctag, _dbgcmd + strlen(cmd1) + 1);
        }
    }
    
    memset(&buf, 0, sizeof(SMCMD_STRING_CMD_t));  
    memset(&respBuff, 0, sizeof(SMCMD_t));  

    buf.String.length = lengthInclNull;

    strcpy((char *)buf.String.Data, _dbgcmd);

    mesgLen = sizeof(buf) - sizeof(buf.String.Data) + lengthInclNull;

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  SM_CMD_CLASS, CMD, SIG_DEBUG_CMD,
                  (TL1_CMD_BUF_t *)&buf, mesgLen,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(respBuff),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_SIG, respBuff.Tl1Cmd.Error ); 
        return eosl_false;
    }


    return tc_compld_comment( handle, ctag, "SIGDBG" );
}


/**
 * Instructs an NE to perform a protection switch. Two command modes for switching
 * are provided: normal and forced. Not to be used for SONET line protection switching.
 */
eosl_bool agc_EM_NE_SW_TOPROTN_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp, char * _mode, char * _protid, Direction_ENUM * _dirn)
{
    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;
    char                            *option = NULL;
    char                            *tmp    = NULL;
    eosl_bool                       normal  = eosl_false;
  
    bzero( &cmdMsg, sizeof(cmdMsg) );
 
#ifdef ATCA
    if(ParseAidMap(&aidInfo, _iomOrSp, AID_ACM, NULL))
#else
    if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
#endif
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );  
        return eosl_false;
    }   
      
    if(_mode)
    {
        /* For each option specified for mode */
        for (option = strtok_r(_mode, "&", &tmp);
             option;
             option = strtok_r(NULL, "&", &tmp))
        {
            if (eosl_strcasecmp(option, "NORM") == 0) 
            {
                /* If the FRCD option has also been specified */
                if (cmdMsg.CmdInfo.SwToProtnEqpt.SwMode & SWMODE_FRCD_BIT)
                {
                    tc_error_response( handle, ctag, TE_IIAC,
                                       "Input, Invalid option combination "
                                       "specified for mode" );  
                    return eosl_false;
                }
                normal = eosl_true;
                /* No bit to set for NORM - it's the default */
            }
            else if (eosl_strcasecmp(option, "FRCD") == 0) 
            {
                /* If the NORM option has also been specified */
                if (normal == eosl_true)
                {
                    tc_error_response( handle, ctag, TE_IIAC,
                                       "Input, Invalid option combination "
                                       "specified for mode" );  
                    return eosl_false;
                }
                cmdMsg.CmdInfo.SwToProtnEqpt.SwMode |= SWMODE_FRCD_BIT;
            }
            else if (eosl_strcasecmp(option, "NORST") == 0)
            {
                cmdMsg.CmdInfo.SwToProtnEqpt.SwMode |= SWMODE_NORST_BIT;
            }
            else
            {
                tc_error_response( handle, ctag, TE_IIAC,
                                   "Input, Invalid mode option specified" );  
                return eosl_false;       
            }
        }
    }

    if(_protid)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> protid" );  
        return eosl_false;
    }

    if(_dirn)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> dirn" );  
        return eosl_false;
    }
            

    /*
    ** we are switching io module
    */
#ifdef ATCA
    cmdMsg.CmdInfo.SwToProtnEqpt.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.SwToProtnEqpt.AtcaSlot.atcaSlot = aidInfo.lvl2;

    procLogMsg(PLOG_INFO, __FUNCTION__,
               "Switching over Shelf: %d, Slot: %d, Mode:%d\n",
               cmdMsg.CmdInfo.SwToProtnEqpt.AtcaSlot.shelfId,
               cmdMsg.CmdInfo.SwToProtnEqpt.AtcaSlot.atcaSlot,
               cmdMsg.CmdInfo.SwToProtnEqpt.SwMode);
#else
    cmdMsg.CmdInfo.SwToProtnEqpt.SlotNum = aidInfo.lvl1;

    procLogMsg(PLOG_INFO, __FUNCTION__,
               "Switching over Slot:: %d, Mode:%d\n",
               cmdMsg.CmdInfo.SwToProtnEqpt.SlotNum,
               cmdMsg.CmdInfo.SwToProtnEqpt.SwMode);
#endif

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SWTOPROTN,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }   
    return tc_compld_comment( handle, ctag, "SW-TOPROTN-EQPT" );
}

eosl_bool agc_EM_NE_INIT_T0_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _t0Id)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    int            colCnt = 0;
    SMCMD_t        smCmd;



    tableId = INITT0_TAB_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));


    if(ParseAidToDeviceIdMap(NULL, _t0Id, (AID_T0 |AID_PORT), NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID) -> t0Id" );  
        return eosl_false;
    }

    rowKey.numIndices = 1;
    rowKey.rowIndex[0].colType = TSSMI_OCTET_STRING;
    rowKey.rowIndex[0].value.stringVal.ptr = _t0Id;
    rowKey.rowIndex[0].value.stringVal.len = strlen(_t0Id);
    
    colArray.numCols  = colCnt;
    colArray.colArray = columns;

    if (colArray.numCols > MAX_TSM_COLS)
    {
        procLogMsg(PLOG_ERROR, "agc_EM_NE_INIT_T0_req", "INIT-T0 - TOO MANY COLUMNS FOR ARRAY!\n");
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "INIT-T0");
    }
    return tc_compld_comment( handle, ctag, "INIT-T0");
}

/**
 * Instructs an NE to switch a protected working unit back to working.
 */
eosl_bool agc_EM_NE_SW_TOWKG_EQPT_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _sw_id, char * _mode, Direction_ENUM * _dirn)
{

    TL1_BUF_t                       cmdMsg;
    TL1_BUF_t                       respBuff;
    AID_INFO_TYPE_t                 aidInfo;
    bzero( &cmdMsg, sizeof(cmdMsg));

    if(ParseAidMap(&aidInfo, _sw_id, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    if(_mode)
    {
        if (eosl_strcasecmp(_mode, "NORM") == 0)
        {
             cmdMsg.CmdInfo.SwToWkgEqpt.SwMode = 0x0; 
        }
        else if (eosl_strcasecmp(_mode, "FRCD") == 0)
        {
             cmdMsg.CmdInfo.SwToWkgEqpt.SwMode |= SWMODE_FRCD_BIT;
        }
        else
        {
              tc_error_response( handle, ctag, TE_IIAC,
                    "Input, Invalid mode option specified" );
              return eosl_false;
        }
    }
    else
    {
       cmdMsg.CmdInfo.SwToWkgEqpt.SwMode = 0x0;
    }

    if(_dirn)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input Is Not Supported -> dirn" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_SWTOWKG,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_SWTOWK,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {

        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "SW-TOWKG-EQPT" );

}
eosl_bool agc_EM_NE_ENT_EQPT_ALL_req( const char * modifier,\
                                      eosl_handle handle,\
                                      TL1_TAG ctag ,\
                                      TL1_AID _ioModule,\
                                      char * _ioModuleType,\
                                      Redundancy_ENUM _rn,\
                                      int _spMemThreshold,\
                                      int * _spNVMemThreshold,\
                                      int * _diskMajorThreshold,\
                                      int * _diskCriticalThreshold,\
                                      int _spBusyThreshold,\
                                      char * _swVersion,\
                                      char * _rearModuleType,\
                                      char * _appSwVersion,\
                                      PrimaryStateIn_ENUM _pst)
{

    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask = 0;
    char                         * primaryState;
    int             i, len;
    eosl_bool       ret = eosl_false;

    memset(&cmdMsg, 0x0, sizeof(TL1_BUF_t)); /* set all valid flags=0 */


    /*
    **  Fill slot data structure
    */
    if(ParseAidMap(&aidInfo, _ioModule, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;

    strncpy(cmdMsg.CmdInfo.EntParams.Redundancy.strValue, enum_lookup_name(&Redundancy_ENUM_type, _rn),
            sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue));
    cmdMsg.CmdInfo.EntParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue) - 1] = '\0';
    cmdMsg.CmdInfo.EntParams.Redundancy.valid = VALID_VALUE;

    primaryState=enum_lookup_name( &PrimaryStateIn_ENUM_type, _pst);
    SetStateMask( primaryState, primaryState , NULL, &stateMask, NULL);
    cmdMsg.CmdInfo.EntParams.State.value=stateMask;
    cmdMsg.CmdInfo.EntParams.State.valid= (OPTIONAL_PARM_VALID) stateMask;

    if (_ioModuleType == NULL)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );
        return eosl_false;
    }

    len = strlen(_ioModuleType);
    if (len >= (int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue))
    {
        len = (unsigned int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue) - 1;
    }
    for (i = 0; i < len; i++)
    {
        cmdMsg.CmdInfo.EntParams.Type.strValue[i] = (char) toupper((int) _ioModuleType[i]);
    }
    cmdMsg.CmdInfo.EntParams.Type.strValue[len] = '\0';
    cmdMsg.CmdInfo.EntParams.Type.valid = VALID_VALUE;

    strncpy(cmdMsg.CmdInfo.EntParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EntParams.SWVersion.strValue));

    cmdMsg.CmdInfo.EntParams.SWVersion.valid = VALID_VALUE;

    cmdMsg.CmdInfo.EntParams.MemUtilThresh.value = _spMemThreshold;
    cmdMsg.CmdInfo.EntParams.MemUtilThresh.valid = VALID_VALUE;

    ret = assignDiskThreshold(handle, ctag, 1, _spNVMemThreshold, _diskMajorThreshold, _diskCriticalThreshold, &cmdMsg);
    if (eosl_false == ret) /* error response is set in function */
    {
        return eosl_false;
    }

    cmdMsg.CmdInfo.EntParams.CpuUtilThresh.value = _spBusyThreshold;
    cmdMsg.CmdInfo.EntParams.CpuUtilThresh.valid = VALID_VALUE;

    if(_rearModuleType)
    {
       len = strlen(_rearModuleType);
       if (len >= (int)sizeof(cmdMsg.CmdInfo.EntParams.RearType.strValue))
       {
        len = (unsigned int)sizeof(cmdMsg.CmdInfo.EntParams.RearType.strValue) - 1;
       }
       for (i = 0; i < len; i++)
       {
        cmdMsg.CmdInfo.EntParams.RearType.strValue[i] = (char) toupper((int) _rearModuleType[i]);
       }
       cmdMsg.CmdInfo.EntParams.RearType.strValue[len] = '\0';
       cmdMsg.CmdInfo.EntParams.RearType.valid = VALID_VALUE;
    }
    else
    {
       cmdMsg.CmdInfo.EntParams.RearType.valid = INVALID_VALUE;
    }
 
    if(_appSwVersion)
    {
        strncpy(cmdMsg.CmdInfo.EntParams.AppSWVersion.strValue,
                _appSwVersion,
                sizeof(cmdMsg.CmdInfo.EntParams.AppSWVersion.strValue));
        cmdMsg.CmdInfo.EntParams.AppSWVersion.strValue[
            sizeof(cmdMsg.CmdInfo.EntParams.AppSWVersion.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EntParams.AppSWVersion.valid = VALID_VALUE;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ENT-EQPT-ALL" );

}

/**
 */
eosl_bool agc_EM_NE_ED_EQPT_ALL_req( const char * modifier,\
                                     eosl_handle handle,\
                                     TL1_TAG ctag ,\
                                     TL1_AID _iomOrSp,\
                                     char * _ioModuleType,\
                                     Redundancy_ENUM * _rn,\
                                     int * _spMemThreshold,\
                                     int * _spNVMemThreshold,\
                                     int * _diskMajorThreshold,\
                                     int * _diskCriticalThreshold,\
                                     int * _spBusyThreshold,\
                                     char * _swVersion,\
                                     char * _rearModuleType,\
                                     char * _appSwVersion,\
                                     PrimaryStateIn_ENUM * _pst)
{
    /*SLOT_RTRV_INFO_t      * s_data; */
    char * temp;
    AID_INFO_TYPE_t aidInfo;

    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask=0;
    int                 len;
    int                 i;
    eosl_bool           ret = eosl_false;

    memset(&cmdMsg,0x0,sizeof(TL1_BUF_t)); /* set all valid flags=0 */


    /*
    ** let's do the slot stuff first
    */

    if(ParseAidMap(&aidInfo, _iomOrSp, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;

    if(_ioModuleType)
    {
        len = strlen(_ioModuleType);
        if (len > (int)sizeof(cmdMsg.CmdInfo.EdtParams.Type.strValue))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );  
            return eosl_false;
        }

        /* EMF needs upper case. */
        for (i = 0; i < len; i++)
        {
            cmdMsg.CmdInfo.EdtParams.Type.strValue[i] = (char) toupper((int) _ioModuleType[i]);
        }
        cmdMsg.CmdInfo.EdtParams.Type.strValue[len] = '\0';
        cmdMsg.CmdInfo.EdtParams.Type.valid = VALID_VALUE;
    }

    if(_rn)
    {
        temp = enum_lookup_name( &Redundancy_ENUM_type , *_rn);
        strncpy(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue, temp, sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue));
        cmdMsg.CmdInfo.EdtParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue - 1)] = '\0';
        cmdMsg.CmdInfo.EdtParams.Redundancy.valid= VALID_VALUE;
    }

    if(_swVersion)
    {
        strncpy(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue));
        cmdMsg.CmdInfo.EdtParams.SWVersion.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.SWVersion.valid= VALID_VALUE;
    }

    if(_pst)
    {
        temp=enum_lookup_name( &PrimaryStateIn_ENUM_type, *_pst);
        SetStateMask( temp, temp, NULL, &stateMask, NULL);
        cmdMsg.CmdInfo.EdtParams.State.value=stateMask;
        cmdMsg.CmdInfo.EdtParams.State.valid= (OPTIONAL_PARM_VALID) stateMask;
    }

    if(_spMemThreshold)
    {
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.value = *_spMemThreshold;
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.valid=VALID_VALUE;
    }

    ret = assignDiskThreshold(handle, ctag, 0, _spNVMemThreshold, _diskMajorThreshold, _diskCriticalThreshold, &cmdMsg);
    if (eosl_false == ret) /* error response is set in function */
    {
        return eosl_false;
    }

    if(_spBusyThreshold)
    {
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.value = *_spBusyThreshold;
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.valid=VALID_VALUE;
    }
    if(_rearModuleType)
    {
       len = strlen(_rearModuleType);
       if (len >= (int)sizeof(cmdMsg.CmdInfo.EntParams.RearType.strValue))
       {
        len = (unsigned int)sizeof(cmdMsg.CmdInfo.EntParams.RearType.strValue) - 1;
       }
       for (i = 0; i < len; i++)
       {
        cmdMsg.CmdInfo.EntParams.RearType.strValue[i] = (char) toupper((int) _rearModuleType[i]);
       }
       cmdMsg.CmdInfo.EntParams.RearType.strValue[len] = '\0';
       cmdMsg.CmdInfo.EntParams.RearType.valid = VALID_VALUE;
    }
    else
    {
       cmdMsg.CmdInfo.EntParams.RearType.valid = INVALID_VALUE;
    }
    if(_appSwVersion)
    {
        strncpy(cmdMsg.CmdInfo.EdtParams.AppSWVersion.strValue,
                _appSwVersion,
                sizeof(cmdMsg.CmdInfo.EdtParams.AppSWVersion.strValue));
        cmdMsg.CmdInfo.EdtParams.AppSWVersion.strValue[
            sizeof(cmdMsg.CmdInfo.EdtParams.AppSWVersion.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.AppSWVersion.valid = VALID_VALUE;
    }

    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "ED-EQPT-ALL" );

}

eosl_bool agc_EM_NE_DLT_EQPT_ALL_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{

    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    TL1_BUF_t                     respBuff;

    if(ParseAidMap(&aidInfo, _iomOrSp, AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.SlotNum = aidInfo.lvl1;


    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "DLT-EQPT-ALL" );

}

eosl_bool agc_EM_NE_RTRV_EQPT_ALL_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _iomOrSp)
{
/* cpuData                  *c_data; */
    RTRV_EQPT_ALL_resp_row        result[MAX_RTRV_EQPT_ALL_TL1_ENTRIES];
    AID_INFO_TYPE_t aidInfo;
    int                           slotCount;
    char                          slotNum[MAX_RTRV_EQPT_ALL_TL1_ENTRIES][8];
    CMD_BUF_t                     respBuff;
    TL1_BUF_t                     cmdMsg;
    char                          pstStr[PST_SIZE];
    char                          psqStr[PSQ_SIZE];
    int                           slot;
    char                          primaryState[MAX_RTRV_EQPT_ALL_TL1_ENTRIES][12];
    char                          secondaryState[MAX_RTRV_EQPT_ALL_TL1_ENTRIES][24];
    Redundancy_ENUM               rnArray[MAX_RTRV_INFO_EQPT_TL1_ENTRIES];
    int                           tsmcRowIndex=0;
    int                           lumosRowIndex=0;
    int                           retVal;

    memset(result, 0, sizeof(result));
    memset(slotNum,0, sizeof(slotNum));
    memset(primaryState,0, sizeof(primaryState));
    memset(secondaryState,0, sizeof(secondaryState));
    memset(rnArray,0, sizeof(rnArray));

    if (_iomOrSp)
    {
        if(ParseAidMap(&aidInfo, _iomOrSp, (AID_CPU | AID_IOM | AID_SF), NULL))
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        slotCount=1;
        slot=aidInfo.lvl1;
    }
    else
        /* No AID given -- default to ALL. */
    {
        slotCount = MAX_IOMS + NUM_SCS + NUM_SF;
        slot=ALL_SLOTS;
    }
    /*
  ** Prepare event
  */

    cmdMsg.CmdInfo.SlotNum=slot;

    /*
  ** Send event
  */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }


    /*
  ** get cpu information
  */
  /* c_data = (cpuData*)&data;
     GoAheadGetThreshold(c_data);*/

    for ( tsmcRowIndex=0;  tsmcRowIndex < slotCount; tsmcRowIndex++)
    {

        SlotToAid(respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].SlotNum, slotNum[lumosRowIndex]);
        result[lumosRowIndex]._iomOrSp = slotNum[lumosRowIndex];

        result[lumosRowIndex]._moduleType     = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].Type;
        result[lumosRowIndex]._rearModuleType = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].RearType;

        rnArray[lumosRowIndex] = (Redundancy_ENUM) enum_lookup_no_case(&Redundancy_ENUM_type,
                                                           respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].Redundancy);
        result[lumosRowIndex]._rn = &rnArray[lumosRowIndex];

        result[lumosRowIndex]._swVersion = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].SWVersion;

        if(strlen(respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].AppSWVersion) > 0)
        {
            result[lumosRowIndex]._appSwVersion = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].AppSWVersion;
        }
        else
        {
            result[lumosRowIndex]._appSwVersion = "NULL";
        }

        SetStateNames(respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].State,
                      respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].State2,
                      pstStr, psqStr, &(secondaryState[lumosRowIndex][0]));

        if (strlen(psqStr) > 0)
            sprintf(&(primaryState[lumosRowIndex][0]),"%s-%s", pstStr, psqStr);
        else
            sprintf(&(primaryState[lumosRowIndex][0]),"%s", pstStr);
        result[lumosRowIndex]._primaryState = &(primaryState[lumosRowIndex][0]);
        if (strlen(secondaryState[lumosRowIndex]) > 0)
        {
            result[lumosRowIndex]._secondaryState = &(secondaryState[lumosRowIndex][0]);
        }
        else
        {
            result[lumosRowIndex]._secondaryState = NULL;
        }


        /*
        ** fill cpu response information
        */
        result[lumosRowIndex]._memThreshold = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].MemUtilThresh;
        result[lumosRowIndex]._NVMemThreshold = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].DiskUtilLowThresh;
        result[lumosRowIndex]._diskMajorThreshold = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].DiskUtilMedThresh;
        result[lumosRowIndex]._diskCriticalThreshold = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].DiskUtilHighThresh;
        result[lumosRowIndex]._busyThreshold = respBuff.CmdInfo.RtrvEqpt[tsmcRowIndex].CpuUtilThresh;

        lumosRowIndex++;
        if ((lumosRowIndex >= MAX_RTRV_EQPT_ALL_TL1_ENTRIES) && ((tsmcRowIndex + 1) < slotCount))
        {
            retVal =  agc_EM_NE_RTRV_EQPT_ALL_resp ( modifier,
                                                    handle,
                                                    ctag,
                                                    TCC_RTRV,
                                                    result,
                                                    lumosRowIndex,
                                                    "RTRV-EQPT-ALL",
                                                    NULL );
            if (retVal == eosl_false)
            {
                return eosl_false;
            }

            lumosRowIndex = 0;
            memset(result, 0, sizeof(result));
            memset(slotNum,0, sizeof(slotNum));
            memset(primaryState,0, sizeof(primaryState));
            memset(secondaryState,0, sizeof(secondaryState));
            memset(rnArray,0, sizeof(rnArray));
        }
    }

    /*
  ** send tl1 response
  */
    return agc_EM_NE_RTRV_EQPT_ALL_resp( modifier,
                                     handle,
                                     ctag,
                                     TCC_COMPLD,
                                     result,
                                     lumosRowIndex,
                                     "RTRV-EQPT-ALL",
                                     NULL );
}

/**
 */
#define TL1_LOG_KEY "LOG"
#define TL1_LOG_LEN (strlen(TL1_LOG_KEY))
eosl_bool agc_EM_NE_TL1DBG_req( const char * modifier,\
                                eosl_handle handle,\
                                TL1_TAG ctag ,\
                                char * _dbgcmd)
{
    int  chassisType;
    int  mgType;
    int  sgType;
    char formatString[64];
    char platformDesc[32];
    char *stringPtr;
    char *usernamePtr;
    USER_DATA_t *userDataPtr;
    time_t todaysDate;
    ip_addr_t ip;
    int     errCode;
    char    errMsg[TL1_IPMSG_MAX_MSG_LEN];

    /* Design Note: Moved here from SIGDBG */    

    /* If TL1 debug command was not specified */
    if (_dbgcmd == NULL)  /* Shouldn't happen -- mandatory parameter */
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
        return eosl_false;
    }

    /* If TL1 logger debug command was specified */
    if (eosl_strncasecmp(_dbgcmd, TL1_LOG_KEY, TL1_LOG_LEN) == 0)
    {
	char *logname = NULL;
	char alllogname[80] = "SIGDBG LOG Enabled  "; 
        int i;
        
	if (strlen(_dbgcmd) == TL1_LOG_LEN)
	{
	  tl1logactive = 0x1;    	
          return tc_compld_comment( handle, ctag, "SIGDBG LOG All Disabled" );
	}

        logname = &_dbgcmd[TL1_LOG_LEN+1];

	if (eosl_strcasecmp(logname,"ERROR") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_ERROR;    	
        }
		
	if (eosl_strcasecmp(logname,"WARN") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_WARNING;    	
        }
		
	if (eosl_strcasecmp(logname,"INFO") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_INFO;    	
        }
		
	if (eosl_strcasecmp(logname,"ENTRY") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_ENTRY;    	
        }
		
	if (eosl_strcasecmp(logname,"DETAIL") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_DETAIL;    	
        }
		
	if (eosl_strcasecmp(logname,"DEBUG") == 0) 
        {
	  tl1logactive = tl1logactive | PLOG_DEBUG;    	
        }
    
	for (i = 0; i < 8; i++)
	{
	    if (tl1logactive & (1<<i))
	    strcat(alllogname,LOGNAME[i]);	    
        }		
	
        if (tl1logactive) 
        return tc_compld_comment( handle, ctag, alllogname);
    }

    /* If the master command set is to be enabled */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-MASTER") == 0)
    {
        enableMasterCommandSet();
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Master command set enabled");
    }
		
    /* If the native command set for this chassis is to be restored */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-NATIVE") == 0)
    {
        enableNativeCommandSet();
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Native command set restored");
    }
		
		
    /* If the command set for this chassis is to be explicitly set */
    if (eosl_strncasecmp(_dbgcmd,"CMDSET-CHASSIS", strlen("CMDSET-CHASSIS")) == 0)
    {
        if (sscanf(&_dbgcmd[strlen("CMDSET-CHASSIS")+1],
                   "%d-%d-%d",
                   &chassisType, &mgType, &sgType) == 3)
        {
            /* Initialize the TL1 command set for the specified chassis type */
            initCommandSet(chassisType, mgType, sgType);

            sprintf(platformDesc,
                    "SIGDBG - Command set for "
                    "ChassisType[%d] MgType[%d] SgType[%d]\n",
                    chassisType, mgType, sgType);

            return tc_compld_comment( handle,
                                      ctag,
                                      platformDesc);
        }
    }
		
#if 1 /* bug 86485 */
    /* If the boot command set for this chassis is to be restored */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-BOOT-ENABLE") == 0)
    {
        BootEnabled =  eosl_true;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Boot command set enabled");
    }

    /* If the boot command set for this chassis is to be disabled */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-BOOT-DISABLE") == 0)
    {
        BootEnabled =  eosl_false;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Boot command set disabled");
    }

    /* If the hug command set for this chassis is to be restored */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-HUG-ENABLE") == 0)
    {
        HUGEnabled =  eosl_true;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - HUG command set enabled");
    }

    /* If the hug command set for this chassis is to be disabled */
    if (eosl_strcasecmp(_dbgcmd,"CMDSET-HUG-DISABLE") == 0)
    {
        HUGEnabled =  eosl_false;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - HUG command set disabled");
    }
#endif
		
    /* If the EXEC command resource checks are to be enabled */
    if (eosl_strcasecmp(_dbgcmd,"CHKRSC-ENABLE") == 0)
    {
        resourceChecksEnabled = 1;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Resource checks enabled");
    }
		
    /* If the EXEC command resource checks are to be disabled */
    if (eosl_strcasecmp(_dbgcmd,"CHKRSC-DISABLE") == 0)
    {
        resourceChecksEnabled = 0;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Resource checks disabled");
    }
		
    /* If the EXEC debug mode is to be enabled */
    if (eosl_strcasecmp(_dbgcmd,"EXECDBG-ENABLE") == 0)
    {
        execDebugEnabled = 1;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Exec debug enabled");
    }
		
    /* If the EXEC debug mode is to be disabled */
    if (eosl_strcasecmp(_dbgcmd,"EXECDBG-DISABLE") == 0)
    {
        execDebugEnabled = 0;
        return tc_compld_comment( handle,
                                  ctag,
                                  "SIGDBG - Exec debug disabled");
    }
		
    /* If the account should be frozen */
    if (eosl_strncasecmp(_dbgcmd,"USR-FRZ-SET",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            userDataPtr->state |= USR_FRZ_BIT;
            saveUserState(userDataPtr);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - Account freeze set");
        }
    }
		
    /* If the account should be unfrozen */
    if (eosl_strncasecmp(_dbgcmd,"USR-FRZ-CLR",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            userDataPtr->state &= ~USR_FRZ_BIT;
            saveUserState(userDataPtr);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - Account freeze cleared");
        }
    }
		
    /* If the account should be expired */
    if (eosl_strncasecmp(_dbgcmd,"USR-EXP-SET",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            userDataPtr->passwdExp = 100;  /* 1970 */
            ModifyUserDb(usernamePtr, NULL, NULL, NULL,
                         NULL, NULL, &userDataPtr->passwdExp,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - User expiration set");
        }
    }
		
    /* If the account should be unexpired */
    if (eosl_strncasecmp(_dbgcmd,"USR-EXP-CLR",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            todaysDate = normalizeDate(time(NULL));
            userDataPtr->passwdExp = (todaysDate + (userDataPtr->pcnd * 24 * 60 * 60)+100000);
            ModifyUserDb(usernamePtr, NULL, NULL, NULL,
                         NULL, NULL, &userDataPtr->passwdExp,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - User expiration cleared");
        }
    }
		
    /* If the account should be in the warning period */
    if (eosl_strncasecmp(_dbgcmd,"USR-WRN-SET",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            todaysDate = normalizeDate(time(NULL));
            userDataPtr->passwdExp = (todaysDate + (3 * 24 * 60 * 60));  /* 3 days in the future */
            ModifyUserDb(usernamePtr, NULL, NULL, NULL,
                         NULL, NULL, &userDataPtr->passwdExp,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - User warning period set");
        }
    }
		
    /* If the account should be out of the warning period */
    if (eosl_strncasecmp(_dbgcmd,"USR-WRN-CLR",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            todaysDate = normalizeDate(time(NULL));
            userDataPtr->passwdExp = (todaysDate + (userDataPtr->pcnd * 24 * 60 * 60)+100000);
            ModifyUserDb(usernamePtr, NULL, NULL, NULL,
                         NULL, NULL, &userDataPtr->passwdExp,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - User warning period cleared");
        }
    }
		
    /* If the account should be in grace period */
    if (eosl_strncasecmp(_dbgcmd,"USR-GRC-SET",11) == 0)
    {
        usernamePtr = &_dbgcmd[12];
        if ((userDataPtr = GetUserDataFromDb(usernamePtr)) != NULL)
        {
            todaysDate = normalizeDate(time(NULL));
            userDataPtr->passwdExp = (todaysDate - ((userDataPtr->pcnd-3) * 24 * 60 * 60)); /* 3 days before end of grace period */
            ModifyUserDb(usernamePtr, NULL, NULL, NULL,
                         NULL, NULL, &userDataPtr->passwdExp,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            return tc_compld_comment( handle, ctag,
                                      "SIGDBG - User grace period set");
        }
    }

    /* If testing a regular expression */
    if (eosl_strncasecmp(_dbgcmd,"REGEX",5) == 0)
    {
        int         i;
        int         groupNum = 10;
        char        results[10][MAX_RESULT_LEN];
/*        const char* pattern = "^NULL$|(^[A-Z0-9_]{1,10})-([A-Z_][A-Z0-9_]*)($|-([0-9]{1,3}))$"; */
        const char* pattern  = "^_Version_=([[:digit:]]+),_KeyType_=([[:alpha:]]+),_SysID_=([[:alnum:]]+),_ValidStarting_=([[:digit:]]+),_Expires_=([[:digit:]]+),_Generated_=([[:digit:]]+),_EntitleType_=([[:alpha:]]+),_PrefixEnd_,(.+$)";

        memset(results, 0, sizeof(results));
        stringPtr = &_dbgcmd[6];

        /* Execute the regular expression */
        if (ParseRegExpStr(pattern, stringPtr, &groupNum, results, 0) != SUCCESS)
        {
            return tc_error_response( handle,
                                      ctag,
                                      TE_IIDT,
                                      "ParseRegExpStr failed" );
        }

        for (i=0; i < groupNum; i++)
        {
            sprintf(formatString, "Match [%d]: [%s]\n", i, results[i]);
            TL1LOGP(PLOG_ERROR, "%s", formatString);
            tc_compld_comment( handle, ctag, formatString);
        }

        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - REGEX processed");
    }

    /* If testing IP validation */
    if (eosl_strncasecmp(_dbgcmd,"IPBAS",3) == 0)
    {
        stringPtr = &_dbgcmd[6];
        if ((errCode = tl1ValidateIP(stringPtr,
                                     formatString,
                                     TL1_IPFMT_IPV4 | TL1_IPFMT_IPV6 | TL1_IPFMT_PRTL,
                                     0,
                                     NULL,
                                     &ip)) == TL1_IPCDE_SUCCESS)
        {
            TL1LOGP(PLOG_ERROR, "Formatted IP [%s]", formatString);
        }
        else
        {
            TL1LOGP (PLOG_ERROR,
                     "Invalid IP [%s] Error[%s]\n",
                     stringPtr,
                     tl1FormatIPErrorMessage(errCode, "AID", errMsg));
        }
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - IPBAS processed");
    }

    /* If testing extended IP validation */
    if (eosl_strncasecmp(_dbgcmd,"IPEXT",5) == 0)
    {
        stringPtr = &_dbgcmd[6];
        if ((errCode = tl1ValidateIP(stringPtr,
                                     formatString,
                                     TL1_IPFMT_IPV4 | TL1_IPFMT_IPV6,
                                     TL1_IPVAL_UNSPECIFIED | TL1_IPVAL_LOOPBACK | TL1_IPVAL_MULTICAST | TL1_IPVAL_LINKLOCAL | TL1_IPVAL_IPV6_STD,
                                     NULL,
                                     &ip)) == TL1_IPCDE_SUCCESS)
        {
            TL1LOGP(PLOG_ERROR, "Formatted IP [%s]", formatString);
        }
        else
        {
            TL1LOGP (PLOG_ERROR,
                     "Invalid IP [%s] Error[%s]\n",
                     stringPtr,
                     tl1FormatIPErrorMessage(errCode, "AID", errMsg));
        }
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - IPEXT processed");
    }

#ifdef ATCA
    /* If testing the license manager */
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-GOOD",16) == 0)
    {
        swLicMgrInformDebug(1);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-GOOD");
    }

    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-BAD",15) == 0)
    {
        swLicMgrInformDebug(2);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-BAD");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-AUDIT",17) == 0)
    {
        swLicMgrInformDebug(3);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-AUDIT");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-SYNCH",17) == 0)
    {
        swLicMgrInformDebug(4);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-SYNCH");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-STANDALONE",22) == 0)
    {
        swLicMgrInformDebug(5);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-STANDALONE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-NOAUTH",18) == 0)
    {
        swLicMgrInformDebug(6);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-NOAUTH");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-AUTH",16) == 0)
    {
        swLicMgrInformDebug(7);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-AUTH");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-ALM-24HR",20) == 0)
    {
        swLicMgrInformDebug(8);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-ALM-24HR");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-ALM-48HR",20) == 0)
    {
        swLicMgrInformDebug(9);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-ALM-48HR");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-ALM-72HR",20) == 0)
    {
        swLicMgrInformDebug(10);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-ALM-72HR");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-ALM-CLEAR",21) == 0)
    {
        swLicMgrInformDebug(11);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-ALM-CLEAR");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-ALM-NOW",19) == 0)
    {
        swLicMgrInformDebug(12);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-ALM-NOW");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-PMRC-IBCF",21) == 0)
    {
        swLicMgrInformDebug(13);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-PMRC-IBCF");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-PMRC-MGCF",21) == 0)
    {
        swLicMgrInformDebug(14);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-PMRC-MGCF");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-EVENT-IBCF",22) == 0)
    {
        swLicMgrInformDebug(15);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-EVENT-IBCF");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-AUDIT-ENABLE",24) == 0)
    {
        swLicMgrInformDebug(16);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-AUDIT-ENABLE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-AUDIT-DISABLE",25) == 0)
    {
        swLicMgrInformDebug(17);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-AUDIT-DISABLE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-PMRC-INC-IBCF",25) == 0)
    {
        swLicMgrInformDebug(18);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-PMRC-INC-IBCF");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-PMRC-INC-MGCF",25) == 0)
    {
        swLicMgrInformDebug(19);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-PMRC-INC-MGCF");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-TESTMODE-ENABLE",27) == 0)
    {
        swLicMgrInformDebug(20);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-TESTMODE-ENABLE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-TESTMODE-DISABLE",28) == 0)
    {
        swLicMgrInformDebug(21);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-TESTMODE-DISABLE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-GENCHECK-ENABLE",27) == 0)
    {
        swLicMgrInformDebug(22);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-GENCHECK-ENABLE");
    }
    if (eosl_strncasecmp(_dbgcmd,"SWLIC-DEBUG-GENCHECK-DISABLE",28) == 0)
    {
        swLicMgrInformDebug(23);
        return tc_compld_comment( handle, ctag,
                                  "SIGDBG - SWLIC-DEBUG-GENCHECK-DISABLE");
    }
#endif

    /* Design Note: As described in bug 87086, there are certain cases where an
     *     IP address is embedded within an AID, the literal format of the IP is
     *     used to determine uniqueness.  The correct behavior is for the IP to
     *     be "normalized".  This would allow the following IPs to be considered 
     *     identical instead of unique:
     *
     *         2605:0:60:101A:0:0:100
     *         2605:0000:60:101A:0:0:100
     *
     *            or
     *
     *         128.64.16.8
     *         128.064.016.008
     *
     *     As per release 8-3, all IPs are normalized by TL1.  In the event that
     *     provisioning prior to 8-3 contained non-normalized IPs, there needs
     *     to be an override to allow for deletion.  This debug flag will allow
     *     the IP to be passed through to the layer exactly as it is specified
     *     in the TL1 command to allow for cleanup of non-normalized IPs.
     *
     *     Note that it is not feasible to automatically normalize IPs via 8-3
     *     HUG since it's currently possible for multiple instances of the same
     *     IP to exist in different formats.
     */ 

    /* If the IP pass thru debug mode is to be enabled */
    if (eosl_strcasecmp(_dbgcmd,"NORMALIZEIP-ENABLE") == 0)
    {
        normalizeIP = 1;
        return tc_compld_comment( handle,
                                  ctag,
                                  "NORMALIZEIP enabled");
    }
		
    /* If the EXEC debug mode is to be disabled */
    if (eosl_strcasecmp(_dbgcmd,"NORMALIZEIP-DISABLE") == 0)
    {
        normalizeIP = 0;
        return tc_compld_comment( handle,
                                  ctag,
                                  "NORMALIZEIP disabled");
    }

    /* Bug 88420 - if check on backup is to be disabled/enabled */
    if (eosl_strcasecmp(_dbgcmd,"CHECKBACKUP-DISABLE") == 0)
    {
        CheckBackup = 0;
        return tc_compld_comment( handle,
                                  ctag,
                                  "CHECK-BACKUP disabled");
    }

    if (eosl_strcasecmp(_dbgcmd,"CHECKBACKUP-ENABLE") == 0)
    {
        CheckBackup = 1;
        return tc_compld_comment( handle,
                                  ctag,
                                  "CHECK-BACKUP enabled");
    }

		
    return tc_error_response( handle,
                              ctag,
                              TE_IIDT,
                              "Input, dbgcmd Invalid" );
}

/**
 */
eosl_bool agc_EM_NE_WRT_MEM_ADRS_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , TL1_AID _src, char * _hex_adrs, char * _hex1, char * _hex2, char * _hex3, char * _hex4, char * _hex5, char * _hex6, char * _hex7, char * _hex8)
{
/******************
                   MP_CMD_BUF_t                  mpRequest;
                   AID_INFO_TYPE_t               aidInfo;
                   int                           wordCnt;
                   int                           msgLen;

                   ??? NOT IMPLEMENTED IN MAINTENANCE LINK YET.
*************/
    tc_error_response( handle, ctag, TE_IICM, "Command Not Supported" );
    return eosl_false;

#if 0
    
    /*
    ** prepare t1 data structure
    */
    msgLen = sizeof(TL1_CMD_BUF_t) + sizeof(WRT_MEM_t);
    memset(&mpRequest, 0, msgLen);

    if(ParseAidMap(&aidInfo, _src, AID_CPU | AID_IOM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }
    mpRequest.Data.WrtMem.SlotNum = aidInfo.lvl1;

    if ((sscanf(_hex_adrs, "%x", &(mpRequest.Data.WrtMem.Addr))) != 1)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
        return eosl_false;
    }

    if ((sscanf(_hex1, "%x", &(mpRequest.Data.WrtMem.Data1))) != 1)
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
        return eosl_false;
    }
    wordCnt = 1;

    if (_hex2)
    {
        if ((sscanf(_hex2, "%x", &(mpRequest.Data.WrtMem.Data2))) != 1)
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
            return eosl_false;
        }
        wordCnt++;

        if (_hex3)
        {
            if ((sscanf(_hex3, "%x", &(mpRequest.Data.WrtMem.Data3))) != 1)
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                return eosl_false;
            }
            wordCnt++;

            if (_hex4)
            {
                if ((sscanf(_hex4, "%x", &(mpRequest.Data.WrtMem.Data4))) != 1)
                {
                    tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                    return eosl_false;
                }
                wordCnt++;

                if (_hex5)
                {
                    if ((sscanf(_hex5, "%x", &(mpRequest.Data.WrtMem.Data5))) != 1)
                    {
                        tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                        return eosl_false;
                    }
                    wordCnt++;

                    if (_hex6)
                    {
                        if ((sscanf(_hex6, "%x", &(mpRequest.Data.WrtMem.Data6))) != 1)
                        {
                            tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                            return eosl_false;
                        }
                        wordCnt++;

                        if (_hex7)
                        {
                            if ((sscanf(_hex7, "%x", &(mpRequest.Data.WrtMem.Data7))) != 1)
                            {
                                tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                                return eosl_false;
                            }
                            wordCnt++;

                            if (_hex8)
                            {
                                if ((sscanf(_hex8, "%x", &(mpRequest.Data.WrtMem.Data8))) != 1)
                                {
                                    tc_error_response( handle, ctag, TE_IIAC, "Invalid Hexadecimal Value" );
                                    return eosl_false;
                                }
                                wordCnt++;
                            }
                        }
                    }
                }
            }
        }
    }

    mpRequest.Data.WrtMem.WordCount = wordCnt;

  /* Set up CMD_BUF header data. */
    mpRequest.Tl1Cmd.Cmd = MPCMD_MEM_WRITE;
    mpRequest.Tl1Cmd.SessionHandle = handle;
    mpRequest.Tl1Cmd.CTag = ctag;


    if(TL1SendMsg(MP_CMD_CLASS, &buffer, msgLen) == FAIL)
    {
    ??? REPORT ERROR
            tc_error_response( handle, ctag, TE_SROF, "WRT-MEM-ADRS Failed" );
    return eosl_false;
    }

    return tc_compld_comment( handle, ctag, "WRT-MEM-ADRS" );
#endif
}

/**
 */
eosl_bool agc_EM_NE_NIDBG_req( const char * modifier, eosl_handle handle, TL1_TAG ctag , char * _dbgcmd)
{

    TL1_NI_BUF_t  tl1_evt_data = { {0} };
    TL1_NI_BUF_t  respBuff;

    /*NIDBG_PARAMS_t tl1_evt_data = {{ 0 }};
      NIDBG_PARAMS_t respBuff;*/

   procLogMsg (PLOG_INFO,
               "agc_EM_NE_NIDBG_req",
               "agc_EM_NE_NIDBG_req: handle:%d, ctag: %d\n", handle, (int)ctag);

   memset(&respBuff, 0, sizeof(TL1_NI_BUF_t));

   if (_dbgcmd == NULL)  /* Shouldn't happen -- mandatory parameter */
   {
       tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
       return eosl_false;
   }
   
   if (strlen(_dbgcmd) > NIDBG_COMMAND_STR_LEN)
   {
       tc_error_response( handle, ctag, TE_IIDT, "Input, dbgcmd Invalid" );
       return eosl_false;
   }
   
   /*
   ** Prepare response buffer
   */
   
   /* 
   ** Send event
   */
   /*tl1_evt_data.EventType = NICMD_NIDBG;*/
   tl1_evt_data.Tl1Cmd.Cmd = NICMD_NIDBG;
   tl1_evt_data.Tl1Cmd.CTag = ctag;
   tl1_evt_data.Tl1Cmd.SessionHandle = handle;
   
   strncpy(tl1_evt_data.Data.NiDbg.CmdBuffer, _dbgcmd, NIDBG_COMMAND_STR_LEN);
	tl1_evt_data.Data.NiDbg.CmdBuffer[NIDBG_COMMAND_STR_LEN] = '\0';
   
   if (TL1SendNiEvent(&tl1_evt_data) == SUCCESS)
   {	   	
       procLogMsg (PLOG_INFO,
                   "agc_EM_NE_NIDBG_req",
                   "agc_EM_NE_NIDBG_req: Event type %d is sent\n", NICMD_NIDBG);
   }
   else
   {
       procLogMsg (PLOG_ERROR,
                   "agc_EM_NE_NIDBG_req",
                   "agc_EM_NE_NIDBG_req: ERROR - Failed TL1SendNiEvent\n");
   }
   
   
   return tc_compld_comment( handle, ctag, "NIDBG" );
}

#ifdef ATCA
eosl_bool validate_ATCA_AMC_ENT( char * _swVersion,                     \
                                 AtcaCardType_ENUM *_cardType,          \
                                AtcaRedundancy_ENUM * _redundancy,      \
                                 char * _poolId,                        \
                                 int * _memThreshold,                   \
                                 int * _nvMemThreshold,                 \
                                 int * _busyThreshold,                  \
                                 char * _emIPv4Fixed,                   \
                                 char * _emIPv4Floating,                \
                                 int * _emIPv4NtwkMask,                 \
                                 int * _emFailoverTmr,                  \
                                 char * _sigAIPv4Fixed,                 \
                                 char * _sigAIPv4Floating,              \
                                 int * _sigAIPv4NtwkMask,               \
                                 int * _sigAFailoverTmr,                \
                                 char * _sigBIPv4Fixed,                 \
                                 char * _sigBIPv4Floating,              \
                                 int * _sigBIPv4NtwkMask,               \
                                 int * _sigBFailoverTmr,                \
                                 char * _sigCIPv4Fixed,                 \
                                char * _sigCIPv4Floating,               \
                                int * _sigCIPv4NtwkMask,                \
                                int * _sigCFailoverTmr,                 \
                                char * _sigDIPv4Fixed,                  \
                                char * _sigDIPv4Floating,               \
                                int * _sigDIPv4NtwkMask,                \
                                int * _sigDFailoverTmr,                 \
                                PrimaryStateIn_ENUM * _pst,             \
                                char** errmsg)
{
    *errmsg = NULL;

    /* cardtype should be AMCSS7 */
    if((!_cardType)||(_cardType&&(*_cardType != AtcaCardType_AMCSS7)))
    {
        *errmsg = "Input, CardType Invalid";
        goto ENT_VALID_FAILED;
    }

    /* rn must be SX, as to AMCSS7 */
    if(!_redundancy)
    {
        *errmsg = "Input, Redundancy is Invalid";
        goto ENT_VALID_FAILED;
    }

    if(eosl_false == validate_ATCA_AMC_ED(
            _swVersion,
            _redundancy, 
            _poolId,                    
            _memThreshold,               
            _nvMemThreshold,             
            _busyThreshold,              
            _emIPv4Fixed,               
            _emIPv4Floating,            
            _emIPv4NtwkMask,             
            _emFailoverTmr,              
            _sigAIPv4Fixed,             
            _sigAIPv4Floating,          
            _sigAIPv4NtwkMask,           
            _sigAFailoverTmr,            
            _sigBIPv4Fixed,             
            _sigBIPv4Floating,          
            _sigBIPv4NtwkMask,           
            _sigBFailoverTmr,            
            _sigCIPv4Fixed,             
            _sigCIPv4Floating,          
            _sigCIPv4NtwkMask,           
            _sigCFailoverTmr,            
            _sigDIPv4Fixed,             
            _sigDIPv4Floating,          
            _sigDIPv4NtwkMask,           
            _sigDFailoverTmr,            
            _pst,        
            errmsg))
    {
        goto ENT_VALID_FAILED;
    }


    return eosl_true;
 ENT_VALID_FAILED:
    return eosl_false;
}

eosl_bool validate_ATCA_AMC_ED(char * _swVersion,                     \
                               AtcaRedundancy_ENUM * _redundancy,     \
                               char * _poolId,                        \
                               int * _memThreshold,                   \
                               int * _nvMemThreshold,                 \
                               int * _busyThreshold,                  \
                               char * _emIPv4Fixed,                   \
                               char * _emIPv4Floating,                \
                               int * _emIPv4NtwkMask,                 \
                               int * _emFailoverTmr,                  \
                               char * _sigAIPv4Fixed,                 \
                               char * _sigAIPv4Floating,              \
                               int * _sigAIPv4NtwkMask,               \
                               int * _sigAFailoverTmr,                \
                               char * _sigBIPv4Fixed,                 \
                               char * _sigBIPv4Floating,              \
                               int * _sigBIPv4NtwkMask,               \
                               int * _sigBFailoverTmr,                \
                               char * _sigCIPv4Fixed,                 \
                               char * _sigCIPv4Floating,              \
                               int * _sigCIPv4NtwkMask,               \
                               int * _sigCFailoverTmr,                \
                               char * _sigDIPv4Fixed,                 \
                               char * _sigDIPv4Floating,              \
                               int * _sigDIPv4NtwkMask,               \
                               int * _sigDFailoverTmr,                \
                               PrimaryStateIn_ENUM * _pst,             \
                               char** errmsg)
{
    *errmsg = NULL;

    if ((_swVersion)&&(eosl_strcasecmp(_swVersion, "NULL") != 0))
    {
            *errmsg = "Input, SwVersion is Invalid";
            goto ED_VALID_FAILED;
    }

        /* if rn present, must be SX */
    if(_redundancy&&(*_redundancy != AtcaRedundancy_SIMPLEX))
    {
        *errmsg = "Input, Redundancy is Invalid";
        goto ED_VALID_FAILED;
    }

    if((_poolId) && ( eosl_strcasecmp(_poolId, "NULL") != 0) )
    {
        *errmsg = "Input, PoolId is Invalid";
        goto ED_VALID_FAILED;
    }
    if(_nvMemThreshold && (*_nvMemThreshold != 70))
    {
        *errmsg = "Input, NvMemThreshold is Invalid";
        goto ED_VALID_FAILED;
    }

    /* all IP should be NULL for AMC */
    if( (_emIPv4Fixed) && (eosl_strcasecmp(_emIPv4Fixed, "NULL") != 0) )
    {
        *errmsg = "Input, EmIPv4Fixed is Invalid";
        goto ED_VALID_FAILED;
    }

    if(( _emIPv4Floating) && (eosl_strcasecmp(_emIPv4Floating, "NULL") != 0) )    
    {
        *errmsg = "Input, EmIPv4Floating is Invalid";
        goto ED_VALID_FAILED;
    }
    
    if( (_emIPv4NtwkMask) && (*_emIPv4NtwkMask!= 0) )
    {
        *errmsg = "Input, EmIPv4NtwkMask is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_emFailoverTmr) && (*_emFailoverTmr != 180))
    {
        *errmsg = "Input, EmFailoverTmr is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigAIPv4Fixed) && (eosl_strcasecmp(_sigAIPv4Fixed, "NULL") != 0) )
    {
        *errmsg = "Input, SigAIPv4Fixed is Invalid";
        goto ED_VALID_FAILED;
    }

    if( _sigAIPv4Floating && (eosl_strcasecmp(_sigAIPv4Floating, "NULL") != 0) )
    {
        *errmsg = "Input, SigAIPv4Floating is Invalid";
        goto ED_VALID_FAILED;
    }
    
    if((_sigAIPv4NtwkMask) && (*_sigAIPv4NtwkMask != 0))
    {
        *errmsg = "Input, SigAIPv4NtwkMask is Invalid";
        goto ED_VALID_FAILED;
    }

    if((_sigAFailoverTmr) && (*_sigAFailoverTmr != 180))
    {
        *errmsg = "Input, SigAFailoverTmr is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigBIPv4Fixed) && (eosl_strcasecmp(_sigBIPv4Fixed, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Fixed is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigBIPv4Floating) && (eosl_strcasecmp(_sigBIPv4Floating, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Floating is Invalid";
        goto ED_VALID_FAILED;
    }
    
    if((_sigBIPv4NtwkMask) && (*_sigBIPv4NtwkMask != 0) )
    {
        *errmsg = "Input, SigBIPv4NtwkMask is Invalid";
        goto ED_VALID_FAILED;
    }

    if((_sigBFailoverTmr) && (*_sigBFailoverTmr != 180))
    {
        *errmsg = "Input, SigBFailoverTmr is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigCIPv4Fixed) && (eosl_strcasecmp(_sigCIPv4Fixed, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Fixed is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigCIPv4Floating) && (eosl_strcasecmp(_sigCIPv4Floating, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Floating is Invalid";
        goto ED_VALID_FAILED;
    }
    
    if((_sigCIPv4NtwkMask) && (*_sigCIPv4NtwkMask != 0) )
    {
        *errmsg = "Input, SigBIPv4NtwkMask is Invalid";
        goto ED_VALID_FAILED;
    }

    if((_sigCFailoverTmr) && (*_sigCFailoverTmr != 180))
    {
        *errmsg = "Input, SigBFailoverTmr is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigDIPv4Fixed) && (eosl_strcasecmp(_sigDIPv4Fixed, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Fixed is Invalid";
        goto ED_VALID_FAILED;
    }

    if( (_sigDIPv4Floating) && (eosl_strcasecmp(_sigDIPv4Floating, "NULL") != 0) )
    {
        *errmsg = "Input, SigBIPv4Floating is Invalid";
        goto ED_VALID_FAILED;
    }
    
    if((_sigDIPv4NtwkMask) && (*_sigDIPv4NtwkMask != 0) )
    {
        *errmsg = "Input, SigBIPv4NtwkMask is Invalid";
        goto ED_VALID_FAILED;
    }

    if((_sigDFailoverTmr) && (*_sigDFailoverTmr != 180))
    {
        *errmsg = "Input, SigBFailoverTmr is Invalid";
        goto ED_VALID_FAILED;
    }
    return eosl_true;

 ED_VALID_FAILED:
    return eosl_false;
}
#endif

/**
 * Delete ATCA Equipment
 */

eosl_bool agc_EM_NE_DLT_ATCA_EQPT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ioModule)
{
#ifdef ATCA
    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    TL1_BUF_t                     respBuff;
    int isAmc = 0;
    if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.AtcaSlot.atcaSlot = aidInfo.lvl2;
    cmdMsg.CmdInfo.AtcaSlot.amcSlot = aidInfo.lvl3;
    isAmc = (aidInfo.lvl3 == -1)? 0:1;

    /* EDWARD */
    if (isAmc)
    {
        TsSmiRowKey     rowKey;
        TsSmiColArray   colArray;
        TsSmiColObj     columns[MAX_TSM_COLS];
        TsTransId       transId = ctag;
        TsTableId       tableId = STGAMC_TAB_ID;
        int             colCnt = 0;
        int             retVal;
        SMCMD_t        smCmd;

        if(IS_CHASSIS_TYPE_ATCA_MGC(procInfo.ChassisType))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
            return eosl_false;
        }

        memset(&smCmd,0x0,sizeof(SMCMD_t));

        rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = aidInfo.lvl3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;

        rowKey.numIndices = 3;

        columns[colCnt].columnId = STGAMC_COL_CMD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_CMD_DLT;
        colCnt++;

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(SM_DLT_REQUEST,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        return tc_compld_comment( handle, ctag, "DLT-ATCA-EQPT" );
    }
    /* EDWARD */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_DELETE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)

    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif
    return tc_compld_comment( handle, ctag, "DLT-ATCA-EQPT" );
}

/**
 * Edit  ATCA Equipment
 */
eosl_bool agc_EM_NE_ED_ATCA_EQPT_req( const char * modifier,\
                                      eosl_handle handle,\
                                      TL1_TAG ctag ,\
                                      char * _ioModule,\
                                      char * _moduleType,\
                                      char * _swVersion,\
                                      char * _poolId,\
                                      int * _memThreshold,\
                                      int * _nvMemThreshold,\
                                      int * _diskMajorThreshold,\
                                      int * _diskCriticalThreshold,\
                                      int * _busyThreshold,\
                                      char * _emIPv4Fixed,\
                                      char * _emIPv4Floating,\
                                      int * _emIPv4NtwkMask,\
                                      int * _emFailoverTmr,\
                                      char * _sigAIPv4Fixed,\
                                      char * _sigAIPv4Floating,\
                                      int * _sigAIPv4NtwkMask,\
                                      int * _sigAFailoverTmr,\
                                      char * _sigBIPv4Fixed,\
                                      char * _sigBIPv4Floating,\
                                      int * _sigBIPv4NtwkMask,\
                                      int * _sigBFailoverTmr,\
                                      char * _sigCIPv4Fixed,\
									  char * _sigCIPv4Floating,\
									  int * _sigCIPv4NtwkMask,\
									  int * _sigCFailoverTmr,\
									  char * _sigDIPv4Fixed,\
									  char * _sigDIPv4Floating,\
									  int * _sigDIPv4NtwkMask,\
									  int * _sigDFailoverTmr,\
                                      char * _sigAIPv6Fixed,\
                                      char * _sigAIPv6Floating,\
                                      int * _sigAIPv6NtwkPrefix,\
                                      char * _sigBIPv6Fixed,\
                                      char * _sigBIPv6Floating,\
                                      int * _sigBIPv6NtwkPrefix,\
                                      PrimaryStateIn_ENUM * _pst)
{
#ifdef ATCA
    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask = 0;
    char                         * primaryState;
    int             i, len;
    eosl_bool       ret = eosl_false;
    unsigned int      tmpIp;
    int isAmc = 0;
    char *errmsg=NULL;
    int errCode;
    char errMsg[TL1_IPMSG_MAX_MSG_LEN];
    char formattedIp[INET6_ADDRSTRLEN];
    ip_addr_t genIP;

    memset(&cmdMsg, 0x0, sizeof(TL1_BUF_t)); /* set all valid flags=0 */

    /*
    **  Fill slot data structure
    */
    if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    isAmc = (aidInfo.lvl3 == -1)? 0:1;
    if(isAmc == 1)
    {
        if(IS_CHASSIS_TYPE_ATCA_MGC(procInfo.ChassisType))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Invalid Access Identifier (AID)");
            return eosl_false;
        }
        if(eosl_false == validate_ATCA_AMC_ED(
               _swVersion,
               NULL, 
               _poolId,                    
               _memThreshold,               
               _nvMemThreshold,             
               _busyThreshold,              
               _emIPv4Fixed,               
               _emIPv4Floating,            
               _emIPv4NtwkMask,             
               _emFailoverTmr,              
               _sigAIPv4Fixed,             
               _sigAIPv4Floating,          
               _sigAIPv4NtwkMask,           
               _sigAFailoverTmr,            
               _sigBIPv4Fixed,             
               _sigBIPv4Floating,          
               _sigBIPv4NtwkMask,           
               _sigBFailoverTmr, 
               _sigCIPv4Fixed,             
               _sigCIPv4Floating,          
               _sigCIPv4NtwkMask,           
               _sigCFailoverTmr,            
               _sigDIPv4Fixed,             
               _sigDIPv4Floating,          
               _sigDIPv4NtwkMask,           
               _sigDFailoverTmr,
               _pst,        
               &errmsg))
        {
            if(errmsg != NULL)
              tc_error_response( handle, ctag, TE_IIDT, errmsg );
            else
              tc_error_response( handle, ctag, TE_IIDT, "Input, Parameter Not Valid");
            return eosl_false;
        }
        /* BUG 81644 */
        if(_diskMajorThreshold && (*_diskMajorThreshold != 85))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, diskMajorThreshold Invalid" );
            return eosl_false;
        }

        if(_diskCriticalThreshold && (*_diskCriticalThreshold != 95))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, diskCriticalThreshold Invalid" );
            return eosl_false;
        }
    }

    cmdMsg.CmdInfo.EdtParams.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.EdtParams.AtcaSlot.atcaSlot = aidInfo.lvl2;
    cmdMsg.CmdInfo.EdtParams.AtcaSlot.amcSlot = aidInfo.lvl3;
    /* set up moduleType */
    if (_moduleType != NULL)
    {
        len = strlen(_moduleType);
        if(len > 10)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );
            return eosl_false;
        }
        if (len >= (int)sizeof(cmdMsg.CmdInfo.EdtParams.Type.strValue))
        {
            len = (unsigned int)sizeof(cmdMsg.CmdInfo.EdtParams.Type.strValue) - 1;
        }
        for (i = 0; i < len; i++)
        {
            cmdMsg.CmdInfo.EdtParams.Type.strValue[i] = (char) toupper((int) _moduleType[i]);
        }
        cmdMsg.CmdInfo.EdtParams.Type.strValue[len] = '\0';
        cmdMsg.CmdInfo.EdtParams.Type.valid = VALID_VALUE;
    }
    else
    {
        cmdMsg.CmdInfo.EdtParams.Type.valid = INVALID_VALUE;
    }
    /* set up swVersion */
    if(_swVersion == NULL)
    {
        cmdMsg.CmdInfo.EdtParams.SWVersion.valid = INVALID_VALUE;
    }
    else
    {
        len = strlen(_swVersion);
        if(len > 30)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, SwVersion Invalid" );
            return eosl_false;
        }
        strncpy(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EdtParams.SWVersion.strValue));
        cmdMsg.CmdInfo.EdtParams.SWVersion.valid = VALID_VALUE;
    }
#if 0
    /* set up redundancy  */
    if(_redundancy)
    {
        strncpy(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue, enum_lookup_name(&AtcaRedundancy_ENUM_type, *_redundancy),
                sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue));
        cmdMsg.CmdInfo.EdtParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EdtParams.Redundancy.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EdtParams.Redundancy.valid = VALID_VALUE;
    }
    else
    {
#endif
        cmdMsg.CmdInfo.EdtParams.Redundancy.valid = INVALID_VALUE;
    /* set up poolId */
    if(_poolId)
    {
        if (eosl_strcasecmp(_poolId, "NULL") == 0)
        {
            cmdMsg.CmdInfo.EdtParams.PoolId.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.PoolId.value = 0;
        }
        else
        {
            /* 75576*/
            if(!IsInputStrInRange(_poolId, "0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, "Input, PoolId Invalid");
                return eosl_false;
            }
            /* 75576*/

            int tmpId = 0;
            tmpId = atoi(_poolId);
            if(tmpId < 1 || tmpId > 21)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, PoolId Invalid" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.PoolId.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.PoolId.value = tmpId;
        }
    }
    else
    {
        cmdMsg.CmdInfo.EdtParams.PoolId.valid = INVALID_VALUE;
    }

    /* set up memThreshold */
    if(_memThreshold)
    {
        if(*_memThreshold < 0 || *_memThreshold > 100)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, MemThreshold Invalid" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.value = *_memThreshold;
        cmdMsg.CmdInfo.EdtParams.MemUtilThresh.valid = VALID_VALUE;
    }
    else
    {
            cmdMsg.CmdInfo.EdtParams.MemUtilThresh.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.MemUtilThresh.value = 90;*/
    }

    /* set up busyThreshold */
    if(_busyThreshold)
    {
        if(*_busyThreshold < 0 || *_busyThreshold > 100)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, BusyThreshold Invalid" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.valid = VALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.value = *_busyThreshold;
    }
    else
    {
            cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.CpuUtilThresh.value = 85;*/
    }

    /* following are not for AMC card */
    if(isAmc == 0)
    {
#if 0   /* FID14382.15, replaced by assignDiskThreshold(...) */
        /* set up nvMemThreshold */
        if(_nvMemThreshold)
        {
            if(*_nvMemThreshold < 0 || *_nvMemThreshold > 100)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, NvMemThreshold Invalid" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.DiskUtilThresh.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.DiskUtilThresh.value = *_nvMemThreshold;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.DiskUtilThresh.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.DiskUtilThresh.value = 90;*/
        }
#endif
        ret = assignDiskThreshold(handle, ctag, 0, _nvMemThreshold, _diskMajorThreshold, _diskCriticalThreshold, &cmdMsg);
        if (eosl_false == ret) /* error response is set in function */
        {
            return eosl_false;
        }

        /* set up EM  */
        if(_emIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_emIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_emIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.EmIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.EmIPv4Fixed.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.EmIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_emIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_emIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_emIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.EmIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.EmIPv4Floating.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.EmIPv4Floating.valid = INVALID_VALUE;
        }

        if(_emIPv4NtwkMask)
        {
            if(*_emIPv4NtwkMask < 0 || *_emIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.EmIPv4NtwkMask.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.EmIPv4NtwkMask.value = *_emIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.EmIPv4NtwkMask.valid = INVALID_VALUE;
            /*cmdMsg.CmdInfo.EdtParams.EmIPv4NtwkMask.value = 0;*/
        }

        if(_emFailoverTmr)
        {
            if(*_emFailoverTmr < 1 || *_emFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.EmFailoverTmr.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.EmFailoverTmr.value = *_emFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.EmFailoverTmr.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.EmFailoverTmr.value = 180;*/
        }

        /* set up SIGA */
        if(_sigAIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigAIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigAIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Fixed.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigAIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigAIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigAIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Floating.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigAIPv4Floating.valid = INVALID_VALUE;
        }

        if(_sigAIPv4NtwkMask)
        {
            if(*_sigAIPv4NtwkMask < 0 || *_sigAIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigAIPv4NtwkMask.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigAIPv4NtwkMask.value = *_sigAIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigAIPv4NtwkMask.valid = INVALID_VALUE;
            /*cmdMsg.CmdInfo.EdtParams.SigAIPv4NtwkMask.value = 0;*/
        }

        if(_sigAFailoverTmr)
        {
            if(*_sigAFailoverTmr < 1 || *_sigAFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigAFailoverTmr.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigAFailoverTmr.value = *_sigAFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigAFailoverTmr.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.SigAFailoverTmr.value = 180; */
        }

        /* set up SIGB */
        if(_sigBIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigBIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigBIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Fixed.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigBIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigBIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigBIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Floating.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigBIPv4Floating.valid = INVALID_VALUE;
        }

        if(_sigBIPv4NtwkMask)
        {
            if(*_sigBIPv4NtwkMask < 0 || *_sigBIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigBIPv4NtwkMask.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigBIPv4NtwkMask.value = *_sigBIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigBIPv4NtwkMask.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.SigBIPv4NtwkMask.value = 0;*/
        }

        if(_sigBFailoverTmr)
        {
            if(*_sigBFailoverTmr < 1 || *_sigBFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigBFailoverTmr.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigBFailoverTmr.value = *_sigBFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigBFailoverTmr.valid = INVALID_VALUE;
            /*cmdMsg.CmdInfo.EdtParams.SigBFailoverTmr.value = 180;*/
        }
		
		/* set up SIGC */
        if(_sigCIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigCIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigCIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Fixed.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigCIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigCIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigCIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Floating.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigCIPv4Floating.valid = INVALID_VALUE;
        }

        if(_sigCIPv4NtwkMask)
        {
            if(*_sigCIPv4NtwkMask < 0 || *_sigCIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigCIPv4NtwkMask.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigCIPv4NtwkMask.value = *_sigCIPv4NtwkMask;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigCIPv4NtwkMask.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.SigCIPv4NtwkMask.value = 0;*/
        }

        if(_sigCFailoverTmr)
        {
            if(*_sigCFailoverTmr < 1 || *_sigCFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigCFailoverTmr.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigCFailoverTmr.value = *_sigCFailoverTmr;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigCFailoverTmr.valid = INVALID_VALUE;
            /*cmdMsg.CmdInfo.EdtParams.SigCFailoverTmr.value = 180;*/
        }
        /* set up SIGD */
        if(_sigDIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigDIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigDIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Fixed.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigDIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigDIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigDIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Floating.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigDIPv4Floating.valid = INVALID_VALUE;
        }

        if(_sigDIPv4NtwkMask)
        {
            if(*_sigDIPv4NtwkMask < 0 || *_sigDIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigDIPv4NtwkMask.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigDIPv4NtwkMask.value = *_sigDIPv4NtwkMask;
            BLOCK_SIGC_D_ON_IBC4; 
       }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigDIPv4NtwkMask.valid = INVALID_VALUE;
            /* cmdMsg.CmdInfo.EdtParams.SigDIPv4NtwkMask.value = 0;*/
        }

        if(_sigDFailoverTmr)
        {
            if(*_sigDFailoverTmr < 1 || *_sigDFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigDFailoverTmr.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EdtParams.SigDFailoverTmr.value = *_sigDFailoverTmr;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EdtParams.SigDFailoverTmr.valid = INVALID_VALUE;
            /*cmdMsg.CmdInfo.EdtParams.SigDFailoverTmr.value = 180;*/
        }

        /* set up SIGA IPv6 */

        if(_sigAIPv6Fixed)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigAIPv6Fixed,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigAIPv6Fixed", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EdtParams.SigAIPv6Fixed.value = genIP.ip;
                cmdMsg.CmdInfo.EdtParams.SigAIPv6Fixed.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EdtParams.SigAIPv6Fixed.value, "sigAIPv6Fixed = ");
            }
        }

        if(_sigAIPv6Floating)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigAIPv6Floating,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigAIPv6Floating", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EdtParams.SigAIPv6Floating.value = genIP.ip;
                cmdMsg.CmdInfo.EdtParams.SigAIPv6Floating.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EdtParams.SigAIPv6Floating.value, "sigAIPv6Floating = ");
            }
        }

        if(_sigAIPv6NtwkPrefix)
        {
            if(*_sigAIPv6NtwkPrefix < 0 || *_sigAIPv6NtwkPrefix > 128)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, sigAIPv6NtwkPrefix Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigAIPv6NtwkPrefix.value = *_sigAIPv6NtwkPrefix;
            cmdMsg.CmdInfo.EdtParams.SigAIPv6NtwkPrefix.valid = VALID_VALUE;
        }

        /* set up SIGB IPv6 */

        if(_sigBIPv6Fixed)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigBIPv6Fixed,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigBIPv6Fixed", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EdtParams.SigBIPv6Fixed.value = genIP.ip;
                cmdMsg.CmdInfo.EdtParams.SigBIPv6Fixed.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EdtParams.SigBIPv6Fixed.value, "sigBIPv6Fixed = ");
            }
        }

        if(_sigBIPv6Floating)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigBIPv6Floating,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigBIPv6Floating", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EdtParams.SigBIPv6Floating.value = genIP.ip;
                cmdMsg.CmdInfo.EdtParams.SigBIPv6Floating.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EdtParams.SigBIPv6Floating.value, "sigBIPv6Floating = ");
            }
        }

        if(_sigBIPv6NtwkPrefix)
        {
            if(*_sigBIPv6NtwkPrefix < 0 || *_sigBIPv6NtwkPrefix > 128)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, sigBIPv6NtwkPrefix Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EdtParams.SigBIPv6NtwkPrefix.value = *_sigBIPv6NtwkPrefix;
            cmdMsg.CmdInfo.EdtParams.SigBIPv6NtwkPrefix.valid = VALID_VALUE;
        }
    }
    else
    {
        cmdMsg.CmdInfo.EdtParams.DiskUtilLowThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.DiskUtilMedThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.DiskUtilHighThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.EmIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.EmIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.EmIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.EmFailoverTmr.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAFailoverTmr.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBFailoverTmr.valid = INVALID_VALUE;
		cmdMsg.CmdInfo.EdtParams.SigCIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigCIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigCIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigCFailoverTmr.valid = INVALID_VALUE;
		cmdMsg.CmdInfo.EdtParams.SigDIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigDIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigDIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigDFailoverTmr.valid = INVALID_VALUE;
		
        cmdMsg.CmdInfo.EdtParams.SigAIPv6Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAIPv6Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigAIPv6NtwkPrefix.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv6Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv6Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EdtParams.SigBIPv6NtwkPrefix.valid = INVALID_VALUE;
    }
    /* set up pst */
    if(_pst)
    {
        primaryState=enum_lookup_name( &PrimaryStateIn_ENUM_type, *_pst);
        SetStateMask( primaryState, primaryState , NULL, &stateMask, NULL);
        switch(*_pst)
        {
          case PrimaryStateIn_IS:
            cmdMsg.CmdInfo.EdtParams.State.value = stateMask;
            break;

          case PrimaryStateIn_OOS:
            cmdMsg.CmdInfo.EdtParams.State.value = stateMask;
            break;
            
          default:
            break;
        }
        cmdMsg.CmdInfo.EdtParams.State.valid= VALID_VALUE;
    }
    else
    {
        cmdMsg.CmdInfo.EdtParams.State.valid= INVALID_VALUE;
    }

    /* EDWARD */
    if (isAmc)
    {
        TsSmiRowKey     rowKey;
        TsSmiColArray   colArray;
        TsSmiColObj     columns[MAX_TSM_COLS];
        TsTransId       transId = ctag;
        TsTableId       tableId = STGAMC_TAB_ID;
        int             colCnt = 0;
        int             retVal;
        SMCMD_t        smCmd;

        memset(&smCmd,0x0,sizeof(SMCMD_t));

        rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = aidInfo.lvl3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;

        rowKey.numIndices = 3;

        if(_ioModule)
        {
            columns[colCnt].columnId = STGAMC_COL_IOMODULE;
            columns[colCnt].value.colType = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.ptr = _ioModule;
            columns[colCnt].value.value.stringVal.len = strlen(_ioModule);
            colCnt++;
        }

        if(_moduleType)
        {
            columns[colCnt].columnId = STGAMC_COL_IOMODULETYPE;
            columns[colCnt].value.colType = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.ptr = _moduleType;
            columns[colCnt].value.value.stringVal.len = strlen(_moduleType);
            colCnt++;
        }

        if(_busyThreshold)
        {
            columns[colCnt].columnId = STGAMC_COL_CPUTHRESHOLD;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = *_busyThreshold;
            colCnt++;
        }

        if(_memThreshold)
        {
            columns[colCnt].columnId = STGAMC_COL_MEMTHRESHOLD;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = *_memThreshold;
            colCnt++;
        }

        if(_pst)
        {
            columns[colCnt].columnId = STGAMC_COL_PST;
            columns[colCnt].value.colType = TSSMI_LONG;
            if (*_pst == PrimaryStateIn_IS)
                columns[colCnt].value.value.longVal = STGAMC_PST_IS;
            else
                columns[colCnt].value.value.longVal = STGAMC_PST_OOS;
            colCnt++;
        }

        columns[colCnt].columnId = STGAMC_COL_CMD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_CMD_ED;
        colCnt++;

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(SM_ED_REQUEST,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        return tc_compld_comment( handle, ctag, "ED-ATCA-EQPT" );
    }
    /* EDWARD */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ED_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif    
    return tc_compld_comment( handle, ctag, "ED-ATCA-EQPT" );
}

/**
 * Retrieve  ATCA Equipment
 */
eosl_bool agc_EM_NE_RTRV_ATCA_EQPT_req( const char * modifier,\
                                        eosl_handle handle,\
                                        TL1_TAG ctag ,\
                                        char * _ioModule)
{
#ifdef ATCA
    AID_INFO_TYPE_t     aidInfo;
    CMD_BUF_t           respBuff;
    TL1_BUF_t           cmdMsg;
    int   retVal;
    int isAmc = 0;

    memset(&cmdMsg, 0, sizeof(TL1_BUF_t));
    
    cmdMsg.Buf.Cmd = EQMCMD_RTRV_EQPT;
    cmdMsg.Buf.SessionHandle = handle;
    cmdMsg.Buf.CTag =ctag;

    if (_ioModule)
    {
        if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot=aidInfo.lvl2;
        cmdMsg.CmdInfo.AtcaSlot.amcSlot= aidInfo.lvl3;

        isAmc = (aidInfo.lvl3 == -1)? 0:1;
        if(isAmc == 1)
        {
            if(IS_CHASSIS_TYPE_ATCA_MGC(procInfo.ChassisType))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
                return eosl_false;
            }
        }
    }
    else/* No AID given -- default to ALL. */
    {
        cmdMsg.CmdInfo.AtcaSlot.shelfId = ALL_SHELFS;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = ALL_SLOTS;
    }
    /*
    ** Prepare event
    */

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    /*
    ** send tl1 response
    */
    retVal = RtrvAtcaEqptResp(&respBuff);
    if (retVal == eosl_false)
    {
        tc_error_response(handle, ctag, TE_SDNR,"RTRV-ATCA-EQPT" );
    } 
    
    return retVal;
#else
    return tc_compld_comment( handle, ctag, "RTRV-ATCA-EQPT" );
#endif
}

/**
 * Enter ATCA Equipment
 */
eosl_bool agc_EM_NE_ENT_ATCA_EQPT_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _ioModule,\
									char * _moduleType,\
									char * _swVersion,\
									AtcaCardType_ENUM * _cardType,\
									AtcaRedundancy_ENUM * _redundancy,\
									char * _poolId,\
									int * _memThreshold,\
									int * _nvMemThreshold,\
                                    int * _diskMajorThreshold,\
                                    int * _diskCriticalThreshold,\
									int * _busyThreshold,\
									char * _emIPv4Fixed,\
									char * _emIPv4Floating,\
									int * _emIPv4NtwkMask,\
									int * _emFailoverTmr,\
									char * _sigAIPv4Fixed,\
									char * _sigAIPv4Floating,\
									int * _sigAIPv4NtwkMask,\
									int * _sigAFailoverTmr,\
									char * _sigBIPv4Fixed,\
									char * _sigBIPv4Floating,\
									int * _sigBIPv4NtwkMask,\
									int * _sigBFailoverTmr,\
									char * _sigCIPv4Fixed,\
									char * _sigCIPv4Floating,\
									int * _sigCIPv4NtwkMask,\
									int * _sigCFailoverTmr,\
									char * _sigDIPv4Fixed,\
									char * _sigDIPv4Floating,\
									int * _sigDIPv4NtwkMask,\
									int * _sigDFailoverTmr,\
									char * _sigAIPv6Fixed,\
									char * _sigAIPv6Floating,\
									int * _sigAIPv6NtwkPrefix,\
									char * _sigBIPv6Fixed,\
									char * _sigBIPv6Floating,\
									int * _sigBIPv6NtwkPrefix,\
									PrimaryStateIn_ENUM * _pst)
{
#ifdef ATCA
    AID_INFO_TYPE_t               aidInfo;
    TL1_BUF_t                     cmdMsg;
    CMD_BUF_t                     respBuff;
    int                           stateMask = 0;
    char                         * primaryState;
    int             i, len;
    eosl_bool       ret = eosl_false;
    unsigned int      tmpIp;
    int isAmc = 0;
    char *errmsg = NULL;
    int errCode;
    char errMsg[TL1_IPMSG_MAX_MSG_LEN];
    char formattedIp[INET6_ADDRSTRLEN];
    ip_addr_t genIP;
    int split_lab = 0;

    memset(&cmdMsg, 0x0, sizeof(TL1_BUF_t)); /* set all valid flags=0 */
    /*
    **  Fill slot data structure
    */
    if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    cmdMsg.CmdInfo.EntParams.AtcaSlot.shelfId = aidInfo.lvl1;
    cmdMsg.CmdInfo.EntParams.AtcaSlot.atcaSlot = aidInfo.lvl2;
    cmdMsg.CmdInfo.EntParams.AtcaSlot.amcSlot = aidInfo.lvl3;
    isAmc = (aidInfo.lvl3 == -1)? 0:1;
    if(isAmc == 1)
    {
        if(IS_CHASSIS_TYPE_ATCA_MGC(procInfo.ChassisType))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
            return eosl_false;
        }

        if(eosl_false == validate_ATCA_AMC_ENT(
               _swVersion,
               _cardType,
               _redundancy, 
               _poolId,                    
               _memThreshold,               
               _nvMemThreshold,             
               _busyThreshold,              
               _emIPv4Fixed,               
               _emIPv4Floating,            
               _emIPv4NtwkMask,             
               _emFailoverTmr,              
               _sigAIPv4Fixed,             
               _sigAIPv4Floating,          
               _sigAIPv4NtwkMask,           
               _sigAFailoverTmr,            
               _sigBIPv4Fixed,             
               _sigBIPv4Floating,          
               _sigBIPv4NtwkMask,           
               _sigBFailoverTmr,
               _sigCIPv4Fixed,             
               _sigCIPv4Floating,          
               _sigCIPv4NtwkMask,           
               _sigCFailoverTmr,            
               _sigDIPv4Fixed,             
               _sigDIPv4Floating,          
               _sigDIPv4NtwkMask,           
               _sigDFailoverTmr,
               _pst,        
               &errmsg))
        {
            if(errmsg != NULL)
              tc_error_response( handle, ctag, TE_IIDT, errmsg );
            else
              tc_error_response( handle, ctag, TE_IIDT, "Input, Parameter Not Valid");
            return eosl_false;
        }
         /* BUG 81644 */
        if(_diskMajorThreshold && (*_diskMajorThreshold != 85))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, diskMajorThreshold Invalid" );
            return eosl_false;
        }

        if(_diskCriticalThreshold && (*_diskCriticalThreshold != 95))
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, diskCriticalThreshold Invalid" );
            return eosl_false;
        }
    }
    /* set up moduleType */
    if (_moduleType == NULL)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );
        return eosl_false;
    }
    len = strlen(_moduleType);
    if(len > 10)
    {
        tc_error_response( handle, ctag, TE_IIDT, "Input, ModuleType Invalid" );
        return eosl_false;
    }
    if (len >= (int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue))
    {
        len = (unsigned int)sizeof(cmdMsg.CmdInfo.EntParams.Type.strValue) - 1;
    }
    for (i = 0; i < len; i++)
    {
        cmdMsg.CmdInfo.EntParams.Type.strValue[i] = (char) toupper((int) _moduleType[i]);
    }
    cmdMsg.CmdInfo.EntParams.Type.strValue[len] = '\0';
    cmdMsg.CmdInfo.EntParams.Type.valid = VALID_VALUE;

    /* set up cardType */

    if (_cardType == NULL)
    {
        cmdMsg.CmdInfo.EntParams.CardType = EQPT_CARDTYPE_ACCM;
    }
    else
    {
        switch(*_cardType)
        {
          case AtcaCardType_ACCM:
            cmdMsg.CmdInfo.EntParams.CardType = EQPT_CARDTYPE_ACCM;
            break;

          case AtcaCardType_ADCM:
            cmdMsg.CmdInfo.EntParams.CardType = EQPT_CARDTYPE_ADCM;
            break;

          case AtcaCardType_AMCSS7:
            cmdMsg.CmdInfo.EntParams.CardType = EQPT_CARDTYPE_AMCSS7;
            if(isAmc == 0)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, CardType Invalid" );
                return eosl_false;
            }
            break;
          
          default:
            tc_error_response( handle, ctag, TE_IIDT, "Input, CardType Invalid" );
            return eosl_false;
        }
    }

    /* set up redundancy  */
    if(_redundancy)
    {
        strncpy(cmdMsg.CmdInfo.EntParams.Redundancy.strValue, enum_lookup_name(&AtcaRedundancy_ENUM_type,*_redundancy),
                sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue));
        cmdMsg.CmdInfo.EntParams.Redundancy.strValue[sizeof(cmdMsg.CmdInfo.EntParams.Redundancy.strValue) - 1] = '\0';
        cmdMsg.CmdInfo.EntParams.Redundancy.valid = VALID_VALUE;
    }
    else
    {
        cmdMsg.CmdInfo.EntParams.Redundancy.valid = INVALID_VALUE;
    }
    /* set up poolId */
    if(_poolId)
    {

        if (eosl_strcasecmp(_poolId, "NULL") == 0)
        {
            cmdMsg.CmdInfo.EntParams.PoolId.valid = INVALID_VALUE;
        }
        else
        {
            /* 75576*/
            if(!IsInputStrInRange(_poolId, "0123456789"))
            {
                tc_error_response(handle, ctag, TE_IIDT, "Input, PoolId Invalid");
                return eosl_false;
            }
            /* 75576*/

            int tmpId = 0;
            tmpId = atoi(_poolId);
            if(tmpId < 1 || tmpId > 21)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, PoolId Invalid" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.PoolId.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.PoolId.value = tmpId;

            {   /* BUG 74509 BEGIN */

                /* LAB ONLY CODE */
                if ( IsSplitChassisEnabled() )
                {
                    if ( aidInfo.lvl2 == 11 ||
                         aidInfo.lvl2 == 12 ||
                         aidInfo.lvl2 == 13 ||
                         aidInfo.lvl2 == 14 )
                    {
                        /* This is MGC-2 of a split lab */
                        split_lab = 1;
                    }
                }
                if (split_lab)
                /* Design Note: The following is a stop-gap solution to work around
                 *     the issue defined in bug 74509.  The final solution will be
                 *     implemented as a feature (FID TBD).
                 */
                {
                static int slotPoolAssignment[MAX_PHYSICAL_SLOT_ID] = {0,0,0,2,2,3,3,0,0,4,4,2,2,3,3};
                char errorMsg[80];
                
                /* If card type was explicitly specified as ADCM and
                 *     redundancy was explicitly specified as DUPLEX and
                 *     an invalid poolId assignment was attempted.
                 */
                if (((_cardType)   && (*_cardType   == AtcaCardType_ADCM))    &&
                    ((_redundancy) && (*_redundancy == AtcaRedundancy_DUPLEX)) &&
                    (slotPoolAssignment[aidInfo.lvl2] != tmpId))
                {
                    sprintf(errorMsg, "Input, poolId Invalid. %s must be assigned poolId %d",
                            _ioModule, slotPoolAssignment[aidInfo.lvl2]);
                    tc_error_response(handle, ctag, TE_IIDT, errorMsg);
                    return eosl_false;
                }
                }
                else
                {
                static int slotPoolAssignment[MAX_PHYSICAL_SLOT_ID] = {0,0,0,2,2,3,3,0,0,4,4,5,5,6,6};
                char errorMsg[80];
                
                /* If card type was explicitly specified as ADCM and
                 *     redundancy was explicitly specified as DUPLEX and
                 *     an invalid poolId assignment was attempted.
                 */
                if (((_cardType)   && (*_cardType   == AtcaCardType_ADCM))    &&
                    ((_redundancy) && (*_redundancy == AtcaRedundancy_DUPLEX)) &&
                    (slotPoolAssignment[aidInfo.lvl2] != tmpId))
                {
                    sprintf(errorMsg, "Input, poolId Invalid. %s must be assigned poolId %d",
                            _ioModule, slotPoolAssignment[aidInfo.lvl2]);
                    tc_error_response(handle, ctag, TE_IIDT, errorMsg);
                    return eosl_false;
                }

                }
            }   /* BUG 74509 END */
        }
    }
    else
    {
        cmdMsg.CmdInfo.EntParams.PoolId.valid = INVALID_VALUE;
    }

    /* set up memThreshold */
    cmdMsg.CmdInfo.EntParams.MemUtilThresh.valid = VALID_VALUE;
    if(_memThreshold)
    {
        if(*_memThreshold < 0 || *_memThreshold > 100)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, MemThreshold Invalid" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.EntParams.MemUtilThresh.value = *_memThreshold;
    }
    else
    {
        cmdMsg.CmdInfo.EntParams.MemUtilThresh.value = 90;
    }

    /* set up busyThreshold */
    cmdMsg.CmdInfo.EntParams.CpuUtilThresh.valid = VALID_VALUE;
    if(_busyThreshold)
    {
        if(*_busyThreshold < 0 || *_busyThreshold > 100)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, BusyThreshold Invalid" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.EntParams.CpuUtilThresh.value = *_busyThreshold;
    }
    else
    {
        cmdMsg.CmdInfo.EntParams.CpuUtilThresh.value = 85;
    }

    /* following are not for AMC card */
    if(isAmc == 0)
    {
        /* set up swVersion */
        if(_swVersion == NULL)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, SwVersion Invalid" );
            return eosl_false;
        }
        len = strlen(_swVersion);
        if(len > 30)
        {
            tc_error_response( handle, ctag, TE_IIDT, "Input, SwVersion Invalid" );
            return eosl_false;
        }
        strncpy(cmdMsg.CmdInfo.EntParams.SWVersion.strValue, _swVersion, sizeof(cmdMsg.CmdInfo.EntParams.SWVersion.strValue));
        cmdMsg.CmdInfo.EntParams.SWVersion.valid = VALID_VALUE;

#if 0   /* FID14382.15, replaced by assignDiskThreshold(...) */
        /* set up nvMemThreshold */
        cmdMsg.CmdInfo.EntParams.DiskUtilThresh.valid = VALID_VALUE;
        if(_nvMemThreshold)
        {
            if(*_nvMemThreshold < 0 || *_nvMemThreshold > 100)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, NvMemThreshold Invalid" );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.DiskUtilThresh.value = *_nvMemThreshold;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.DiskUtilThresh.value = 90;
        }
#endif
        ret = assignDiskThreshold(handle, ctag, 1, _nvMemThreshold, _diskMajorThreshold, _diskCriticalThreshold, &cmdMsg);
        if (eosl_false == ret) /* error response is set in function */
        {
            return eosl_false;
        }

        /* set up EM  */
        if(_emIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_emIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_emIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.EmIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.EmIPv4Fixed.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.EmIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_emIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_emIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_emIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.EmIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.EmIPv4Floating.value = tmpIp;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.EmIPv4Floating.valid = INVALID_VALUE;
        }

        cmdMsg.CmdInfo.EntParams.EmIPv4NtwkMask.valid = VALID_VALUE;
        if(_emIPv4NtwkMask)
        {
            if(*_emIPv4NtwkMask < 0 || *_emIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.EmIPv4NtwkMask.value = *_emIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.EmIPv4NtwkMask.value = 0;
        }

        cmdMsg.CmdInfo.EntParams.EmFailoverTmr.valid = VALID_VALUE;
        if(_emFailoverTmr)
        {
            if(*_emFailoverTmr < 1 || *_emFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, EmFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.EmFailoverTmr.value = *_emFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.EmFailoverTmr.value = 180;
        }

        /* set up SIGA */
        if(_sigAIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigAIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigAIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.value = tmpIp;
            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigAIPv4Fixed [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.value,
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.valid);
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigAIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigAIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigAIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.value = tmpIp;
            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigAIPv4Floating [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.value,
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.valid);
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.valid = INVALID_VALUE;
        }

        cmdMsg.CmdInfo.EntParams.SigAIPv4NtwkMask.valid = VALID_VALUE;
        if(_sigAIPv4NtwkMask)
        {
            if(*_sigAIPv4NtwkMask < 0 || *_sigAIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigAIPv4NtwkMask.value = *_sigAIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigAIPv4NtwkMask.value = 0;
        }

        cmdMsg.CmdInfo.EntParams.SigAFailoverTmr.valid = VALID_VALUE;
        if(_sigAFailoverTmr)
        {
            if(*_sigAFailoverTmr < 1 || *_sigAFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigAFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigAFailoverTmr.value = *_sigAFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigAFailoverTmr.value = 180;
        }

        /* set up SIGB */
        if(_sigBIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigBIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigBIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.value = tmpIp;
            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigBIPv4Fixed [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.value,
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.valid);
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigBIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigBIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigBIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.value = tmpIp;
            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigBIPv4Floating [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.value,
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.valid);
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.valid = INVALID_VALUE;
        }

        cmdMsg.CmdInfo.EntParams.SigBIPv4NtwkMask.valid = VALID_VALUE;
        if(_sigBIPv4NtwkMask)
        {
            if(*_sigBIPv4NtwkMask < 0 || *_sigBIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigBIPv4NtwkMask.value = *_sigBIPv4NtwkMask;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigBIPv4NtwkMask.value = 0;
        }

        cmdMsg.CmdInfo.EntParams.SigBFailoverTmr.valid = VALID_VALUE;
        if(_sigBFailoverTmr)
        {
            if(*_sigBFailoverTmr < 1 || *_sigBFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigBFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigBFailoverTmr.value = *_sigBFailoverTmr;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigBFailoverTmr.value = 180;
        }
		        /* set up SIGC */
        if(_sigCIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigCIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigCIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigCIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigCIPv4Fixed.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;

        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigCIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigCIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigCIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigCIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigCIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigCIPv4Floating.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigCIPv4Floating.valid = INVALID_VALUE;
        }

        cmdMsg.CmdInfo.EntParams.SigCIPv4NtwkMask.valid = VALID_VALUE;
        if(_sigCIPv4NtwkMask)
        {
            if(*_sigCIPv4NtwkMask < 0 || *_sigCIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigCIPv4NtwkMask.value = *_sigCIPv4NtwkMask;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigCIPv4NtwkMask.value = 0;
        }

        cmdMsg.CmdInfo.EntParams.SigCFailoverTmr.valid = VALID_VALUE;
        if(_sigCFailoverTmr)
        {
            if(*_sigCFailoverTmr < 1 || *_sigCFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigCFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigCFailoverTmr.value = *_sigCFailoverTmr;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigCFailoverTmr.value = 180;
        }
		        /* set up SIGD */
        if(_sigDIPv4Fixed)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigDIPv4Fixed, "NULL") != 0) && 
                (ip_a2i(_sigDIPv4Fixed, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPV4Fixed Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigDIPv4Fixed.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigDIPv4Fixed.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigDIPv4Fixed.valid = INVALID_VALUE;
        }

        if(_sigDIPv4Floating)
        {
            tmpIp = 0;
            if ((eosl_strcasecmp(_sigDIPv4Floating, "NULL") != 0) && 
                (ip_a2i(_sigDIPv4Floating, &tmpIp) == 0))
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPV4Floating Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigDIPv4Floating.valid = VALID_VALUE;
            cmdMsg.CmdInfo.EntParams.SigDIPv4Floating.value = tmpIp;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigDIPv4Floating.valid = INVALID_VALUE;
        }

        cmdMsg.CmdInfo.EntParams.SigDIPv4NtwkMask.valid = VALID_VALUE;
        if(_sigDIPv4NtwkMask)
        {
            if(*_sigDIPv4NtwkMask < 0 || *_sigDIPv4NtwkMask > 32)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDIPv4NtwkMask Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigDIPv4NtwkMask.value = *_sigDIPv4NtwkMask;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigDIPv4NtwkMask.value = 0;
        }

        cmdMsg.CmdInfo.EntParams.SigDFailoverTmr.valid = VALID_VALUE;
        if(_sigDFailoverTmr)
        {
            if(*_sigDFailoverTmr < 1 || *_sigDFailoverTmr > 3600)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, SigDFailoverTmr Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigDFailoverTmr.value = *_sigDFailoverTmr;
            BLOCK_SIGC_D_ON_IBC4;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigDFailoverTmr.value = 180;
        }

        /* set up SIGA IPv6 */

        if(_sigAIPv6Fixed)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigAIPv6Fixed,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigAIPv6Fixed", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EntParams.SigAIPv6Fixed.value = genIP.ip;
                cmdMsg.CmdInfo.EntParams.SigAIPv6Fixed.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EntParams.SigAIPv6Fixed.value, "sigAIPv6Fixed = ");
            }
        }

        if(_sigAIPv6Floating)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigAIPv6Floating,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigAIPv6Floating", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EntParams.SigAIPv6Floating.value = genIP.ip;
                cmdMsg.CmdInfo.EntParams.SigAIPv6Floating.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EntParams.SigAIPv6Floating.value, "sigAIPv6Floating = ");
            }
        }

        cmdMsg.CmdInfo.EntParams.SigAIPv6NtwkPrefix.valid = VALID_VALUE;
        if(_sigAIPv6NtwkPrefix)
        {
            if(*_sigAIPv6NtwkPrefix < 0 || *_sigAIPv6NtwkPrefix > 128)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, sigAIPv6NtwkPrefix Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigAIPv6NtwkPrefix.value = *_sigAIPv6NtwkPrefix;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigAIPv6NtwkPrefix.value = 0;
        }

        /* set up SIGB IPv6 */

        if(_sigBIPv6Fixed)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigBIPv6Fixed,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigBIPv6Fixed", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EntParams.SigBIPv6Fixed.value = genIP.ip;
                cmdMsg.CmdInfo.EntParams.SigBIPv6Fixed.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EntParams.SigBIPv6Fixed.value, "sigBIPv6Fixed = ");
            }
        }

        if(_sigBIPv6Floating)
        {
            /* If specified parameter is invalid */
            if ((errCode = tl1ValidateIP(_sigBIPv6Floating,
                                         formattedIp,
                                         TL1_IPFMT_NULL | TL1_IPFMT_IPV6,
                                         TL1_IPVAL_IPV6_STD,
                                         NULL,
                                         &genIP)) != TL1_IPCDE_SUCCESS)
            {
                tc_error_response( handle, ctag, TE_IIDT,
                                   tl1FormatIPErrorMessage(errCode, "sigBIPv6Floating", errMsg));
                return eosl_false;
            }
            else
            {
                cmdMsg.CmdInfo.EntParams.SigBIPv6Floating.value = genIP.ip;
                cmdMsg.CmdInfo.EntParams.SigBIPv6Floating.valid = VALID_VALUE;
                IPV6_LOGBINARYADDRESS(DFLT_LOG, PLOG_ERROR,
                                      cmdMsg.CmdInfo.EntParams.SigBIPv6Floating.value, "sigBIPv6Floating = ");
            }
        }

        cmdMsg.CmdInfo.EntParams.SigBIPv6NtwkPrefix.valid = VALID_VALUE;
        if(_sigBIPv6NtwkPrefix)
        {
            if(*_sigBIPv6NtwkPrefix < 0 || *_sigBIPv6NtwkPrefix > 128)
            {
                tc_error_response( handle, ctag, TE_IIDT, "Input, sigBIPv6NtwkPrefix Invalid." );
                return eosl_false;
            }
            cmdMsg.CmdInfo.EntParams.SigBIPv6NtwkPrefix.value = *_sigBIPv6NtwkPrefix;
        }
        else
        {
            cmdMsg.CmdInfo.EntParams.SigBIPv6NtwkPrefix.value = 0;
        }
    }
    else
    {
        cmdMsg.CmdInfo.EntParams.DiskUtilLowThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.DiskUtilMedThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.DiskUtilHighThresh.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.EmIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.EmIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.EmIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.EmFailoverTmr.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAFailoverTmr.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBFailoverTmr.valid = INVALID_VALUE;
		cmdMsg.CmdInfo.EntParams.SigCIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigCIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigCIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigCFailoverTmr.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigDIPv4Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigDIPv4Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigDIPv4NtwkMask.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigDFailoverTmr.valid = INVALID_VALUE;
		
        cmdMsg.CmdInfo.EntParams.SigAIPv6Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAIPv6Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigAIPv6NtwkPrefix.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv6Fixed.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv6Floating.valid = INVALID_VALUE;
        cmdMsg.CmdInfo.EntParams.SigBIPv6NtwkPrefix.valid = INVALID_VALUE;
    }

    /* set up pst */
    cmdMsg.CmdInfo.EntParams.State.valid= VALID_VALUE;
    if(_pst)
    {
        primaryState=enum_lookup_name( &PrimaryStateIn_ENUM_type, *_pst);
        SetStateMask( primaryState, primaryState , NULL, &stateMask, NULL);
        switch(*_pst)
        {
          case PrimaryStateIn_IS:
            cmdMsg.CmdInfo.EntParams.State.value = stateMask;
            break;

          case PrimaryStateIn_OOS:
            cmdMsg.CmdInfo.EntParams.State.value = stateMask;
            break;
            
          default:
            break;
        }
    }
    else
    {
        primaryState=enum_lookup_name( &PrimaryStateIn_ENUM_type, PrimaryStateIn_IS);
        SetStateMask( primaryState, primaryState , NULL, &stateMask, NULL);
        cmdMsg.CmdInfo.EntParams.State.value = stateMask;
    }
    /* EDWARD */
    if (isAmc)
    {
        TsSmiRowKey     rowKey;
        TsSmiColArray   colArray;
        TsSmiColObj     columns[MAX_TSM_COLS];
        TsTransId       transId = ctag;
        TsTableId       tableId = STGAMC_TAB_ID;
        int             colCnt = 0;
        int             retVal;
        SMCMD_t        smCmd;

        memset(&smCmd,0x0,sizeof(SMCMD_t));

        rowKey.rowIndex[0].value.longVal = aidInfo.lvl1;
        rowKey.rowIndex[0].colType = TSSMI_LONG;
        rowKey.rowIndex[1].value.longVal = aidInfo.lvl2;
        rowKey.rowIndex[1].colType = TSSMI_LONG;
        rowKey.rowIndex[2].value.longVal = aidInfo.lvl3;
        rowKey.rowIndex[2].colType = TSSMI_LONG;

        rowKey.numIndices = 3;

        if(_ioModule)
        {
            columns[colCnt].columnId = STGAMC_COL_IOMODULE;
            columns[colCnt].value.colType = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.ptr = _ioModule;
            columns[colCnt].value.value.stringVal.len = strlen(_ioModule);
            colCnt++;
        }

        if(_moduleType)
        {
            columns[colCnt].columnId = STGAMC_COL_IOMODULETYPE;
            columns[colCnt].value.colType = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.ptr = _moduleType;
            columns[colCnt].value.value.stringVal.len = strlen(_moduleType);
            colCnt++;
        }

        if(_busyThreshold)
        {
            columns[colCnt].columnId = STGAMC_COL_CPUTHRESHOLD;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = *_busyThreshold;
            colCnt++;
        }

        if(_memThreshold)
        {
            columns[colCnt].columnId = STGAMC_COL_MEMTHRESHOLD;
            columns[colCnt].value.colType = TSSMI_LONG;
            columns[colCnt].value.value.longVal = *_memThreshold;
            colCnt++;
        }

        if(_pst)
        {
            columns[colCnt].columnId = STGAMC_COL_PST;
            columns[colCnt].value.colType = TSSMI_LONG;
            if (*_pst == PrimaryStateIn_IS)
                columns[colCnt].value.value.longVal = STGAMC_PST_IS;
            else
                columns[colCnt].value.value.longVal = STGAMC_PST_OOS;
            colCnt++;
        }

        columns[colCnt].columnId = STGAMC_COL_CMD;
        columns[colCnt].value.colType = TSSMI_LONG;
        columns[colCnt].value.value.longVal = STGAMC_CMD_ENT;
        colCnt++;

        colArray.numCols  = colCnt;
        colArray.colArray = columns;

        retVal = emfPkSmiSetReq(SM_ENT_REQUEST,
                                handle,
                                transId,
                                tableId,
                                &rowKey,
                                &colArray,
                                &smCmd,
                                TL1_MSG_TIMEOUT);
        if(retVal == FALSE)
        {
            TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
            return eosl_false;
        }
        return tc_compld_comment( handle, ctag, "ENT-ATCA-EQPT" );
    }
    /* EDWARD */

    /* RTC DEBUG */

            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigAIPv4Fixed 2 [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.value,
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Fixed.valid);

            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigAIPv4Floating 2 [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.value,
                        cmdMsg.CmdInfo.EntParams.SigAIPv4Floating.valid);

            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigBIPv4Fixed 2 [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.value,
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Fixed.valid);

            procLogMsg (PLOG_INFO, "agc_EM_NE_ENT_ATCA_EQPT_req",
		        "SigBIPv4Floating 2 [%d:%d]\n",
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.value,
                        cmdMsg.CmdInfo.EntParams.SigBIPv4Floating.valid);


    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_ENT_EQPT,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(TL1_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }
#endif    
    return tc_compld_comment( handle, ctag, "ENT-ATCA-EQPT" );
}

/* FID14382.15, add new alarm on disk usage threshold: major & critical.
 * TL1: ENT/ED-EQPT, ENT/ED-EQPT-ALL, ENT/ED-ATCA-EQPT
 * The function validate the 3 disk usage threshold, and assign them to emf struct,
 * 1. minor(low, NVMemThreshold) < major(medium, diskMajorThreshold) < critical(high, diskCriticalThreshold)
 * 2. for ENT-, if a threshold is absent, use default value instead for validation: 70, 85, 95.
 * 3. for ED-, current value is stored in emf XML DB, if a threshold is absent, we just ignore it and let EMF do the validation.
 * parameters:
 * action: 1: ENT-, 0: ED-.
 * inDiskLow(minor alarm): NVMemThreshold, default 70.
 * inDiskMed(major alarm): diskMajorThreshold, default 85.
 * inDiskHigh(critical alarm): diskCriticalThreshold, default 95.
 * return code:
 * eosl_false(0): failed.
 * eosl_true(1): succeed.
 * */
eosl_bool assignDiskThreshold(eosl_handle handle, TL1_TAG ctag, int action,
        int *inDiskLow, int *inDiskMed, int *inDiskHigh, TL1_BUF_t *outCmdMsg)
{
    int tmpLow = DISABLE_DISK_THRESHOLD;
    int tmpMed = DISABLE_DISK_THRESHOLD;
    int tmpHigh = DISABLE_DISK_THRESHOLD;
    int defaultLow=0, defaultMed=0, defaultHigh=0; /* flag, whether uses default value in ENT- */

    if (NULL == outCmdMsg)
    {
        tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
        return eosl_false;
    }

    if (inDiskLow) /* minor alarm */
    {
        if (*inDiskLow > MAX_DISK_THRESHOLD
        || *inDiskLow < MIN_DISK_THRESHOLD)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid NVMemThreshold(0-100)");
            return eosl_false;
        }
        outCmdMsg->CmdInfo.EntParams.DiskUtilLowThresh.value = *inDiskLow;
        outCmdMsg->CmdInfo.EntParams.DiskUtilLowThresh.valid = VALID_VALUE;
        tmpLow = *inDiskLow;
    }
    else if (action == 1) /* default param, only for ENT- */
    {
        outCmdMsg->CmdInfo.EntParams.DiskUtilLowThresh.value = DEFAULT_DISK_THRESHOLD_MINOR;
        outCmdMsg->CmdInfo.EntParams.DiskUtilLowThresh.valid = VALID_VALUE;
        tmpLow = DEFAULT_DISK_THRESHOLD_MINOR;
        defaultLow = 1;
    }

    if (inDiskMed) /* major alarm */
    {
        if (*inDiskMed > MAX_DISK_THRESHOLD
        || *inDiskMed < MIN_DISK_THRESHOLD)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid diskMajorThreshold(0-100)");
            return eosl_false;
        }
        outCmdMsg->CmdInfo.EntParams.DiskUtilMedThresh.value = *inDiskMed;
        outCmdMsg->CmdInfo.EntParams.DiskUtilMedThresh.valid = VALID_VALUE;
        tmpMed = *inDiskMed;
    }
    else if (action == 1) /* default param, only for ENT- */
    {
        outCmdMsg->CmdInfo.EntParams.DiskUtilMedThresh.value = DEFAULT_DISK_THRESHOLD_MAJOR;
        outCmdMsg->CmdInfo.EntParams.DiskUtilMedThresh.valid = VALID_VALUE;
        tmpMed = DEFAULT_DISK_THRESHOLD_MAJOR;
        defaultMed = 1;
    }

    if (inDiskHigh) /* critical alarm */
    {
        if (*inDiskHigh > MAX_DISK_THRESHOLD
        || *inDiskHigh < MIN_DISK_THRESHOLD)
        {
            tc_error_response(handle, ctag, TE_IIDT, "Input, Invalid diskCriticalThreshold(0-100)");
            return eosl_false;
        }
        outCmdMsg->CmdInfo.EntParams.DiskUtilHighThresh.value = *inDiskHigh;
        outCmdMsg->CmdInfo.EntParams.DiskUtilHighThresh.valid = VALID_VALUE;
        tmpHigh = *inDiskHigh;
    }
    else if (action == 1) /* default param, only for ENT- */
    {
        outCmdMsg->CmdInfo.EntParams.DiskUtilHighThresh.value = DEFAULT_DISK_THRESHOLD_CRITICAL;
        outCmdMsg->CmdInfo.EntParams.DiskUtilHighThresh.valid = VALID_VALUE;
        tmpHigh = DEFAULT_DISK_THRESHOLD_CRITICAL;
        defaultHigh = 1;
    }

    /* check value: NVMemThreshold < diskMajorThreshold < diskCriticalThreshold */
    /* if any threshold is disabled(=0), it doesn't need to follow the rule */
    /* med vs. high */
    if (tmpMed != DISABLE_DISK_THRESHOLD)
    {
        if (tmpHigh != DISABLE_DISK_THRESHOLD)
        {
            if (tmpMed >= tmpHigh)
            {
                if (defaultMed)         /* default major > input Critical */
                { tc_error_response(handle, ctag, TE_IIDT, "Input, default diskMajorThreshold(85) >= diskCriticalThreshold"); }
                else if (defaultHigh)   /* input major >= default critical */
                { tc_error_response(handle, ctag, TE_IIDT, "Input, diskMajorThreshold >= default diskCriticalThreshold(95)"); }
                else                    /* input major >= input critical */
                { tc_error_response(handle, ctag, TE_IIDT, "Input, diskMajorThreshold >= diskCriticalThreshold"); }
                return eosl_false;
            }
        }
    }
    /* low vs. med, low vs. high */
    if (tmpLow != DISABLE_DISK_THRESHOLD)
    {
        if (tmpMed != DISABLE_DISK_THRESHOLD)
        {
            if (tmpLow >= tmpMed)
            {
                if ((outCmdMsg->Buf.Cmd == EQMCMD_ENT_EQPT)||(outCmdMsg->Buf.Cmd == EQMCMD_ED_EQPT))
                {                        
                    if (defaultLow)         /* default minor > input major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, default spNVMemThreshold(70) >= diskMajorThreshold"); }
                    else if (defaultMed)    /* input minor >= default major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, spNVMemThreshold >= default diskMajorThreshold(85)"); }
                    else                    /* input minor >= input major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, spNVMemThreshold >= diskMajorThreshold"); }
                }
                else
                {
                    if (defaultLow)         /* default minor > input major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, default NVMemThreshold(70) >= diskMajorThreshold"); }
                    else if (defaultMed)    /* input minor >= default major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, NVMemThreshold >= default diskMajorThreshold(85)"); }
                    else                    /* input minor >= input major */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, NVMemThreshold >= diskMajorThreshold"); }
                }
                return eosl_false;
            }
        }
        if (tmpHigh != DISABLE_DISK_THRESHOLD) /* med may absent, check low vs. high */
        {
            if (tmpLow >= tmpHigh)
            {
                if ((outCmdMsg->Buf.Cmd == EQMCMD_ENT_EQPT)||(outCmdMsg->Buf.Cmd == EQMCMD_ED_EQPT))
                {    
                    if (defaultLow)         /* default minor > input critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, default spNVMemThreshold(70) >= diskCriticalThreshold"); }
                    else if (defaultHigh)   /* input minor >= default critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, spNVMemThreshold >= default diskCriticalThreshold(95)"); }
                    else                    /* input minor >= input critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, spNVMemThreshold >= diskCriticalThreshold"); }
                }
                else
                {
                    if (defaultLow)         /* default minor > input critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, default NVMemThreshold(70) >= diskCriticalThreshold"); }
                    else if (defaultHigh)   /* input minor >= default critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, NVMemThreshold >= default diskCriticalThreshold(95)"); }
                    else                    /* input minor >= input critical */
                    { tc_error_response(handle, ctag, TE_IIDT, "Input, NVMemThreshold >= diskCriticalThreshold"); }
                }
                return eosl_false;
            }
        }
    }

    return eosl_true;
}

/**
 * Retrieve  ATCA EQPTSTATE
 */
eosl_bool agc_EM_NE_RTRV_ATCA_EQPTSTATE_req( const char * modifier,\
                                             eosl_handle handle,\
                                             TL1_TAG ctag ,\
                                             char * _ioModule)
{
#ifdef ATCA
    AID_INFO_TYPE_t     aidInfo;
    CMD_BUF_t           respBuff;
    TL1_BUF_t           cmdMsg;
    int   retVal;
    int isAmc = 0;

    memset(&cmdMsg, 0, sizeof(TL1_BUF_t));
    
    cmdMsg.Buf.Cmd = EQMCMD_RTRV_EQPTSTATE;
    cmdMsg.Buf.SessionHandle = handle;
    cmdMsg.Buf.CTag =ctag;

    if (_ioModule)
    {
        if(ParseAidMap(&aidInfo, _ioModule, AID_AMCSS7|AID_ACM, NULL))
        {
            tc_error_response( handle,
                               ctag,
                               TE_IIAC,
                               "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        cmdMsg.CmdInfo.AtcaSlot.shelfId = aidInfo.lvl1;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot=aidInfo.lvl2;
        cmdMsg.CmdInfo.AtcaSlot.amcSlot= aidInfo.lvl3;

        isAmc = (aidInfo.lvl3 == -1)? 0:1;
        if(isAmc == 1)
        {
            if(IS_CHASSIS_TYPE_ATCA_MGC(procInfo.ChassisType))
            {
                tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)");
                return eosl_false;
            }
        }
    }
    else/* No AID given -- default to ALL. */
    {
        cmdMsg.CmdInfo.AtcaSlot.shelfId = ALL_SHELFS;
        cmdMsg.CmdInfo.AtcaSlot.atcaSlot = ALL_SLOTS;
    }

    /*
    ** Send event
    */
    if(TL1SendMsg(handle, ctag,
                  EQM_CMD_CLASS, CMD, EQMCMD_RTRV_EQPTSTATE,
                  (TL1_CMD_BUF_t *)&cmdMsg, SIZEOF_EQMCMD_RTRV_EQPTSTATE,
                  (TL1_CMD_BUF_t *)&respBuff, sizeof(CMD_BUF_t),
                  TL1_MSG_TIMEOUT) == FAIL)
    {
        TL1ErrorResp( handle, ctag, CMD_EQM, respBuff.Buf.Error );
        return eosl_false;
    }

    /*
    ** send tl1 response
    */
    retVal = RtrvAtcaEqptStateResp(&respBuff);
    if (retVal == eosl_false)
    {
        tc_error_response(handle, ctag, TE_SDNR,"RTRV-ATCA-EQPTSTATE" );
    } 
    
    return retVal;
#else
    return tc_compld_comment( handle, ctag, "RTRV-ATCA-EQPTSTATE" );
#endif
}

/**
 * Delete SUUSER SECU
 */
eosl_bool agc_EM_NE_DLT_SUUSER_SECU_req( const char * modifier,\
                           eosl_handle handle,\
                            TL1_TAG ctag ,\
                           char * _uid)
{
   int retVal;

   retVal =  agc_EM_NE_DLT_USER_SECU_req(modifier, handle, ctag, "suadmin0");
   if ( retVal == eosl_false)
   {
      return eosl_false;
   }
   else
   {
      return tc_compld_comment( handle, ctag, "DLT-SUUSER-SECU" );
   }
}

/**
 * Enter SUUSER SECU
 */
eosl_bool agc_EM_NE_ENT_SUUSER_SECU_req( const char * modifier,\
                           eosl_handle handle,\
                            TL1_TAG ctag ,\
                           char * _uid)
{
    int page = 0;
    int tmout = 0;
    int retVal,j;
    /*save password into the tmp file*/
     /* FILE *fp = NULL; */
     char * filename = "/tmp/sutmp";

     /*generate password, the password's length is 16, the first and last can't number*/
     static unsigned char PADDING[62] = {
  '0', '1','2', '3', '4','5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e','f','g', 'h','i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v','w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U','V', 'W', 'X', 'Y', 'Z'};

     int i,x;
     char password[MAX_PASSWORD_SIZE+1];
     char *uid = "suadmin0";
     char     errorMsg[256];
     char   * script   = ENCRYPT_PASSWORD; 
     char     parameters[MAX_PASSWORD_SIZE + 4] = "\'";
     int  actTmout = 0;
     UserAuthType_ENUM authType = UserAuthType_LOCAL;

     srand((unsigned) time(NULL));
     for (j = 0; j != 10; ++j)
     {
         memset(password, 0x00, sizeof(password));        
         for(i = 0; i< MAX_PASSWORD_SIZE; i++)
         {
             x =rand()%62;
             password[i] = PADDING[x];
         }

         password[0] = 'z';
         password[MAX_PASSWORD_SIZE-2] = '7';
         password[MAX_PASSWORD_SIZE-1] = 'A';
         
         /* If the password is invalid based on the password complexity level */
         if ( IsPasswordValid(getMemPasswdComplx(),
                              uid,
                              password,
                              NULL,
                              NULL,
                              getMemPasswdMaxReuse(),
                              errorMsg)  == eosl_true)
         {
             break;
         }
     }
     if (j == 10)
     {
         tc_error_response( handle, ctag, TE_IIDT, "failed to generate password");
         return eosl_false;
     }

#if 0
    for ( j=0; j< 10; j++)
    {
         if ( password[MAX_PASSWORD_SIZE-1] == PADDING[j])
          {
               password[MAX_PASSWORD_SIZE-1] = 'A';
          }
          else if (password[0] == PADDING[j])
          {
              password[0] = 'z';
          }
          else
          {
              break;
          }
    }
#endif

    strcat(parameters, password);
    strcat(parameters, "\'");
    
    /* call a script to encrypt the password and write it to tmpfile */
    if (runOSCommand(script, parameters, filename) != 0) 
    {
        tc_error_response( handle, ctag, TE_SROF, "Failed to encrypt password" );
        unlink(filename);
        return eosl_false;
    }

#if 0
    /*write the password into tmpfile*/
     fd = open (filename, O_CREAT| O_TRUNC| O_WRONLY, S_IRUSR | S_IWUSR);
     if (fd == -1) {
         TL1LOGP(PLOG_ERROR, "can not open sutmp file\n");
         tc_error_response( handle, ctag, TE_IIDT, "can not open file");
     }
     write (fd, password, strlen (password));
     close (fd);
     /*
      * fp = fopen(filename,"w+");
      * if ( fp == NULL )
      * {
      *    TL1LOGP(PLOG_ERROR, "can not open this file\n");
      *    tc_error_response( handle, ctag, TE_IIDT, "can not open file");
      * }
      * fputs(password, fp);
      * fclose(fp);
      */
#endif

    /* add new user to tl1user db*/
     int maxSes = 1;
     retVal = agc_EM_NE_ENT_USER_SECU_req(modifier, handle, ctag,
                                uid,
                                password,
                                NULL,
                                UserPrivilege_ADMIN,
                                &page,
                                NULL,
                                &tmout,
                                NULL,
                                NULL,
                                &maxSes,
                                &actTmout,
                                &authType,
                                PrimaryStateIn_IS);
    if (retVal == eosl_false)
    {
       return eosl_false;
    }
    else
    {
      return tc_compld_comment( handle, ctag, "ENT-SUUSER-SECU" );
    }
}
/**
 * Delete CALL Trace
 */
eosl_bool agc_EM_NE_DLT_TRC_CALL_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _trcCallId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    TsSmiColObj    columns[MAX_TSM_COLS];
    short          retVal;
    SMCMD_t        smCmd;
    int            colnCnt=0;
    int            cmd=SM_DLT_REQUEST;

    tableId = CALLTRACE_TAB_ID;
    transId = ctag;
    memset(&smCmd,0x0,sizeof(SMCMD_t));

    if(eosl_strcasecmp(_trcCallId, "ALL") == 0)
    {
        rowKey.numIndices =0;
    }
    /*validate AID to permit only numbers within*/
    else if(IsInputStrInRange(_trcCallId,"0123456789"))
    {
        rowKey.numIndices =1;
        rowKey.rowIndex[0].colType =TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal =atoi(_trcCallId);
    }
    else
    {
        tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
        return eosl_false;
    }

    colArray.numCols  = colnCnt;
    colArray.colArray = columns;

    retVal = emfPkSmiSetReq(cmd,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);

    if(retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }
    else
    {
        return tc_compld_comment( handle, ctag, "DLT-TRC-CALL" );
    }

}



/**
 * Enter CALL Trace
 */
eosl_bool agc_EM_NE_ENT_TRC_CALL_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _trcCallId,\
									char * _sipUri,\
									char * _telNum,\
									FileFormat_ENUM * _fileFormat,\
									int * _duration)
{
   TsTransId      transId;
   TsTableId      tableId;
   TsSmiRowKey    rowKey;
   TsSmiColArray  colArray;
   TsSmiColObj    columns[MAX_TSM_COLS];
   short          retVal;
   SMCMD_t        smCmd;
   int            colCnt=0;
   int            cmd=SM_ENT_REQUEST;
   char           sipUri[64];
   int            sipUriCheck = 0;
   int            i = 0;

   tableId = CALLTRACE_TAB_ID;
   transId = ctag;
   memset(&smCmd,0x0,sizeof(SMCMD_t));

   /*validate AID to permit only numbers within*/
   if(!(IsInputStrInRange(_trcCallId,"0123456789")))
   {
       tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
       return eosl_false;
   }
   rowKey.numIndices =1;
   rowKey.rowIndex[0].colType =TSSMI_LONG;
   rowKey.rowIndex[0].value.longVal =atoi(_trcCallId);

   if(_sipUri)
   {
       if (eosl_strcasecmp(_sipUri, "NULL") == 0)
       {
           columns[colCnt].columnId      = CALLTRACE_COL_SIPURI;
           columns[colCnt].value.colType = TSSMI_RESET;
       }
       else
       {
           if((strlen(_sipUri) > CALLTRACE_SIPURI_MAXLEN) ||
              (strlen(_sipUri) < (3+2)))
           {
               tc_error_response(handle, ctag, TE_IPNV,"Input, Value Invalid");
               return eosl_false;
           }
           else
         {
            if((_sipUri[0] != '"') ||
                  (_sipUri[strlen(_sipUri)-1] != '"') || 
                  (_sipUri[1] == '@') ||
                  (_sipUri[strlen(_sipUri)-2] == '@'))
            {
               tc_error_response(handle, ctag, TE_IPNV,"Input, Value Invalid");
               return eosl_false;
            }
            else
            {
               strcpy(sipUri, &_sipUri[1]);
               sipUri[strlen(_sipUri)-2] = '\0';
               for(i = 0; i < (strlen(_sipUri)-2); i++)
               {
                  if(sipUri[i] == '@')
                     sipUriCheck++;
               }
               if(sipUriCheck != 1)
               {
                  tc_error_response(handle, ctag, TE_IPNV,"Input, ValueInvalid");
                  return eosl_false;
               }
               toUpperStr(sipUri);
               columns[colCnt].columnId = CALLTRACE_COL_SIPURI;
               columns[colCnt].value.colType = TSSMI_OCTET_STRING;
               columns[colCnt].value.value.stringVal.len = strlen(sipUri);
               columns[colCnt].value.value.stringVal.ptr = sipUri;
            }
         }
      }
      colCnt++;
   }

   if(_telNum)
   {
      TkString token;

      memset(&token,0,sizeof(token));
      if (eosl_strcasecmp(_telNum, "NULL") == 0)
      {
         columns[colCnt].columnId      = CALLTRACE_COL_TELNUMDGTS;
         columns[colCnt].value.colType = TSSMI_RESET;
         colCnt++;
      }
      else
      {
         if (*(char*)_telNum != '"')
         {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
            return eosl_false;
         }

         /* Extract all the parameters from Raw Input */
         if (getTokenQT('-',_telNum,&token,2) == eosl_false)
         {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
            return eosl_false;
         }

         if (token.numTks < 1)
         {
            tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
            return eosl_false;
         }
         /* Add  First */
         if (token.numTks > 0)
         {
            if ((token.tkLst[0][0] == 0) || (strlen(token.tkLst[0]) < 3) ||
                  (strlen(token.tkLst[0]) > CALLTRACE_TELNUMDGTS_MAXLEN ))
            {
               tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
               return eosl_false;
            }
            if(!(IsInputStrInRange(token.tkLst[0],"0123456789abcdefABCDEF")))
            {
               tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
               return eosl_false;
            }
            toUpperStr(token.tkLst[0]);
            columns[colCnt].columnId = CALLTRACE_COL_TELNUMDGTS;
            columns[colCnt].value.colType = TSSMI_OCTET_STRING;
            columns[colCnt].value.value.stringVal.len = strlen(token.tkLst[0]);
            columns[colCnt].value.value.stringVal.ptr = token.tkLst[0];
            colCnt++;

         }/* token.numTks > 0 */
         /* Add  Second */
         if (token.numTks > 1)
         {
            if (token.tkLst[1][0] == 0)
            {
               tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
               return eosl_false;
            }
            /* Translate the termSlot to previous ENUM value */
            retVal = str2enumV1(token.tkLst[1],&MatchDirn_ENUM_type);
            if(retVal >= 0)
            {
               columns[colCnt].columnId = CALLTRACE_COL_MATCHDIRN;
               columns[colCnt].value.colType = TSSMI_LONG;
               switch(retVal)
               {

                  case MatchDirn_LEFT:
                     columns[colCnt].value.value.longVal = CALLTRACE_MATCHDIRN_LEFT;
                     break;
                  case MatchDirn_RIGHT:
                     columns[colCnt].value.value.longVal = CALLTRACE_MATCHDIRN_RIGHT;
                     break;
                  default:
                     tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
                     return eosl_false;
               }
            }
            else
            {
               tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
               return eosl_false;
            }
            colCnt++;
         }
      }
   }
   
   if(_fileFormat)
   {
      columns[colCnt].columnId = CALLTRACE_COL_FILEFORMAT;
      columns[colCnt].value.colType = TSSMI_LONG;
      switch(*_fileFormat)
      {
         case FileFormat_PCAP:
            columns[colCnt].value.value.longVal = CALLTRACE_FILEFORMAT_PCAP;
            break;

         default:
            tc_error_response( handle, ctag, TE_IIDT, "Input, Value Invalid" );
            return eosl_false;
      }
      colCnt++;
   }

   if(_duration)
   {
      columns[colCnt].columnId = CALLTRACE_COL_DURATION;
      columns[colCnt].value.colType = TSSMI_LONG;
      columns[colCnt].value.value.longVal = *_duration;
      colCnt++;
   }

   if((((_sipUri == NULL) || (eosl_strcasecmp(_sipUri, "NULL") == 0)) &&
       ((_telNum == NULL) || (eosl_strcasecmp(_telNum, "NULL") == 0))) || 
      (((eosl_strcasecmp(_sipUri, "NULL") != 0) && (_sipUri != NULL))&& 
       ((eosl_strcasecmp(_telNum, "NULL") != 0) && (_telNum != NULL)))) 
   {
      tc_error_response( handle, ctag, TE_IIAC, "Input Invalid, Either sipUri or telNum can exist" );  
         return eosl_false;    
   }
   colArray.numCols  = colCnt;
   colArray.colArray = columns;

   if (colArray.numCols > MAX_TSM_COLS)
   {
      procLogMsg(PLOG_ERROR, "agc_EM_NE_ENT_TRC_CALL_req",
            "ENT_TRC_CALL - TOO MANY COLUMNS FOR ARRAY!\n");
      tc_error_response(handle, ctag, TE_SROF, "Requested Operation Failed");
      return eosl_false;
   }

   retVal = emfPkSmiSetReq(cmd,
         handle,
         transId,
         tableId,
         &rowKey,
         &colArray,
         &smCmd,
         TL1_MSG_TIMEOUT);


   if(retVal == FALSE)
   {
      TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
      return eosl_false;
   }
   else
   {
      return tc_compld_comment( handle, ctag, "ENT-TRC-CALL" );
   }
}

/**
 * Retrieve  CALL Trace
 */
eosl_bool agc_EM_NE_RTRV_TRC_CALL_req( const char * modifier,\
									eosl_handle handle,\
									 TL1_TAG ctag ,\
									char * _trcCallId)
{
    TsTransId      transId;
    TsTableId      tableId;
    TsSmiRowKey    rowKey;
    TsSmiColArray  colArray;
    SMCMD_t        smCmd;
    u8             *smCmdPtr = (u8 *)&smCmd;
    s16            retVal;
    short          length;

    length = sizeof(SMCMD_t);

    tableId = CALLTRACE_TAB_ID;
    transId = ctag;
    colArray.numCols  = 0;

    if(_trcCallId)
    {
        /*validate AID to permit only numbers within*/
        if(!(IsInputStrInRange(_trcCallId,"0123456789")))
        {
            tc_error_response( handle, ctag, TE_IIAC, "Invalid Access Identifier (AID)" );
            return eosl_false;
        }
        rowKey.numIndices =1;
        rowKey.rowIndex[0].colType =TSSMI_LONG;
        rowKey.rowIndex[0].value.longVal =atoi(_trcCallId);
    }
    else
    {
        rowKey.numIndices =0;
    }

    retVal = emfPkSmiGetReq(SM_GETNEXTMULTI_REQUEST,
                                 handle,
                                 transId,
                                 tableId,
                                 &rowKey,
                                 &colArray,
                                 &smCmd,
                                 TL1_MSG_TIMEOUT);



    if (retVal == FALSE)
    {
        TL1ErrorResp( handle, ctag, CMD_SIG, smCmd.Tl1Cmd.Error );
        return eosl_false;
    }

    retVal=emfUnpkSmiGetMultiResp(rtrvCallTraceMultiTsmResp, &smCmdPtr, &length, handle);
    if (retVal == FALSE)
    {
        tc_error_response(handle, ctag, TE_SROF, "Error unpacking signaling response data");
        return eosl_false;
    }
    else
    {
        return eosl_true;
    }
    
}
